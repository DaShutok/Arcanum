diff -r b4c056460923 -r da13f4f7a26c README
--- a/README	Thu Apr 05 13:10:49 2012 +0300
+++ b/README	Mon Apr 16 14:29:17 2012 +0300
@@ -42,11 +42,11 @@
 
 Платежи за ядро:
 
-1.varvarr1 - 06.03.2012
-2.Dlink_lip - 20.03.201
-3.syrex - 20.03.2012
-4.Artager - 21.03.2012
-5.salarik - 31.03.2012
-6.Akvilon - 01.04.2012
+1.Dlink_lip - 20.03.201
+2.syrex - 20.03.2012
+3.Artager - 21.03.2012
+4.salarik - 31.03.2012
+5.Akvilon - 01.04.2012
+6.Noisecontrol - 09.04.2012
 
 Дмитрий Dimitro Мележик
diff -r b4c056460923 -r da13f4f7a26c cmake/compiler/gcc/settings.cmake
--- a/cmake/compiler/gcc/settings.cmake	Thu Apr 05 13:10:49 2012 +0300
+++ b/cmake/compiler/gcc/settings.cmake	Mon Apr 16 14:29:17 2012 +0300
@@ -3,14 +3,12 @@
 
 add_definitions(-fno-delete-null-pointer-checks)
 
-if( USE_SFMT)
-  if(PLATFORM EQUAL 32)
-    # Required on 32-bit systems to enable SSE2 (standard on x64)
-    add_definitions(-msse2 -mfpmath=sse)
-  endif()
-  add_definitions(-DHAVE_SSE2 -D__SSE2__)
-  message(STATUS "GCC: SFMT enabled, SSE2 flags forced")
+if(PLATFORM EQUAL 32)
+  # Required on 32-bit systems to enable SSE2 (standard on x64)
+  add_definitions(-msse2 -mfpmath=sse)
 endif()
+add_definitions(-DHAVE_SSE2 -D__SSE2__)
+message(STATUS "GCC: SSE2 flags forced")
 
 if( WITH_WARNINGS )
   add_definitions(-Wall -Wfatal-errors -Wextra)
diff -r b4c056460923 -r da13f4f7a26c cmake/compiler/icc/settings.cmake
--- a/cmake/compiler/icc/settings.cmake	Thu Apr 05 13:10:49 2012 +0300
+++ b/cmake/compiler/icc/settings.cmake	Mon Apr 16 14:29:17 2012 +0300
@@ -1,13 +1,10 @@
 # Set build-directive (used in core to tell which buildtype we used)
 add_definitions(-D_BUILD_DIRECTIVE="${CMAKE_BUILD_TYPE}")
 
-if( USE_SFMT)
-  if(PLATFORM EQUAL 32)
-    add_definitions(-axSSE2)
-  else()
-    add_definitions(-xSSE2)
-  endif()
-  message(STATUS "ICC: SFMT enabled, SSE2 flags forced")
+if(PLATFORM EQUAL 32)
+  add_definitions(-axSSE2)
+else()
+  add_definitions(-xSSE2)
 endif()
 
 if( WITH_WARNINGS )
diff -r b4c056460923 -r da13f4f7a26c cmake/compiler/msvc/settings.cmake
--- a/cmake/compiler/msvc/settings.cmake	Thu Apr 05 13:10:49 2012 +0300
+++ b/cmake/compiler/msvc/settings.cmake	Mon Apr 16 14:29:17 2012 +0300
@@ -20,11 +20,8 @@
   set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} /LARGEADDRESSAWARE")
   message(STATUS "MSVC: Enabled large address awareness")
 
-  # Test if we need SSE2-support
-  if(USE_SFMT)
-    add_definitions(/arch:SSE2)
-    message(STATUS "MSVC: Enabled SSE2 support")
-  endif()
+  add_definitions(/arch:SSE2)
+  message(STATUS "MSVC: Enabled SSE2 support")
 endif()
 
 # Set build-directive (used in core to tell which buildtype we used)
diff -r b4c056460923 -r da13f4f7a26c cmake/options.cmake
--- a/cmake/options.cmake	Thu Apr 05 13:10:49 2012 +0300
+++ b/cmake/options.cmake	Mon Apr 16 14:29:17 2012 +0300
@@ -13,6 +13,5 @@
 option(TOOLS            "Build map/vmap extraction/assembler tools"                   0)
 option(USE_SCRIPTPCH    "Use precompiled headers when compiling scripts"              1)
 option(USE_COREPCH      "Use precompiled headers when compiling servers"              1)
-option(USE_SFMT         "Use SFMT as random numbergenerator"                          1)
 option(WITH_WARNINGS    "Show all warnings during compile"                            0)
 option(WITH_COREDEBUG   "Include additional debug-code in core"                       0)
diff -r b4c056460923 -r da13f4f7a26c cmake/platform/unix/settings.cmake
--- a/cmake/platform/unix/settings.cmake	Thu Apr 05 13:10:49 2012 +0300
+++ b/cmake/platform/unix/settings.cmake	Mon Apr 16 14:29:17 2012 +0300
@@ -1,6 +1,8 @@
 # Package overloads - Linux
 if(CMAKE_SYSTEM_NAME MATCHES "Linux")
-  set(JEMALLOC_LIBRARY "jemalloc")
+  if (NOT NOJEM)
+    set(JEMALLOC_LIBRARY "jemalloc")
+  endif()
 endif()
 
 # set default configuration directory
diff -r b4c056460923 -r da13f4f7a26c cmake/showoptions.cmake
--- a/cmake/showoptions.cmake	Thu Apr 05 13:10:49 2012 +0300
+++ b/cmake/showoptions.cmake	Mon Apr 16 14:29:17 2012 +0300
@@ -50,13 +50,6 @@
   message("* Build scripts w/PCH    : No")
 endif()
 
-if( USE_SFMT )
-  message("* Use SFMT for RNG       : Yes")
-  add_definitions(-DUSE_SFMT_FOR_RNG)
-else()
-  message("* Use SFMT for RNG       : No  (default)")
-endif()
-
 if( WITH_WARNINGS )
   message("* Show all warnings      : Yes")
 else()
@@ -78,4 +71,10 @@
   endif()
 endif( WIN32 )
 
+if ( NOJEM )
+  message("")
+  message("*** WARNING: jemalloc linking has been disabled!")
+  message("*** Please note that this is for DEBUGGING WITH VALGRIND only!")
+  message("*** DO NOT DISABLE IT UNLESS YOU KNOW WHAT YOU'RE DOING!")
+endif()
 message("")
diff -r b4c056460923 -r da13f4f7a26c dep/CMakeLists.txt
--- a/dep/CMakeLists.txt	Thu Apr 05 13:10:49 2012 +0300
+++ b/dep/CMakeLists.txt	Mon Apr 16 14:29:17 2012 +0300
@@ -15,8 +15,8 @@
 endif()
 
 if(CMAKE_SYSTEM_NAME MATCHES "Linux")
-  if(SERVERS)
-    add_subdirectory(jemalloc)
+  if(SERVERS AND NOT NOJEM)
+    add_subdirectory(jemalloc)  
   endif()
 endif()
 
diff -r b4c056460923 -r da13f4f7a26c dep/PackageList.txt
--- a/dep/PackageList.txt	Thu Apr 05 13:10:49 2012 +0300
+++ b/dep/PackageList.txt	Mon Apr 16 14:29:17 2012 +0300
@@ -20,10 +20,6 @@
   https://libmpq.org/
   Version: 1.0.4
 
-MersenneTwister (a very fast random number generator)
-  http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
-  Version: 0.4.2
-
 MySQL (the world's most popular open source database software)
   http://www.mysql.com/
   Version: 5.5.9 (GA)
diff -r b4c056460923 -r da13f4f7a26c dep/mersennetwister/MersenneTwister.h
--- a/dep/mersennetwister/MersenneTwister.h	Thu Apr 05 13:10:49 2012 +0300
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,405 +0,0 @@
-// MersenneTwister.h
-// Mersenne Twister random number generator -- a C++ class MTRand
-// Based on code by Makoto Matsumoto, Takuji Nishimura, and Shawn Cokus
-// Richard J. Wagner  v1.0  15 May 2003  rjwagner@writeme.com
-
-// The Mersenne Twister is an algorithm for generating random numbers.  It
-// was designed with consideration of the flaws in various other generators.
-// The period, 2^19937-1, and the order of equidistribution, 623 dimensions,
-// are far greater.  The generator is also fast; it avoids multiplication and
-// division, and it benefits from caches and pipelines.  For more information
-// see the inventors' web page at http://www.math.keio.ac.jp/~matumoto/emt.html
-
-// Reference
-// M. Matsumoto and T. Nishimura, "Mersenne Twister: A 623-Dimensionally
-// Equidistributed Uniform Pseudo-Random Number Generator", ACM Transactions on
-// Modeling and Computer Simulation, Vol. 8, No. 1, January 1998, pp 3-30.
-
-// Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
-// Copyright (C) 2000 - 2003, Richard J. Wagner
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-//
-//   1. Redistributions of source code must retain the above copyright
-//      notice, this list of conditions and the following disclaimer.
-//
-//   2. Redistributions in binary form must reproduce the above copyright
-//      notice, this list of conditions and the following disclaimer in the
-//      documentation and/or other materials provided with the distribution.
-//
-//   3. The names of its contributors may not be used to endorse or promote
-//      products derived from this software without specific prior written
-//      permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
-// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// The original code included the following notice:
-//
-//     When you use this, send an email to: matumoto@math.keio.ac.jp
-//     with an appropriate reference to your work.
-//
-// It would be nice to CC: rjwagner@writeme.com and Cokus@math.washington.edu
-// when you write.
-
-#ifndef MERSENNETWISTER_H
-#define MERSENNETWISTER_H
-
-// Not thread safe (unless auto-initialization is avoided and each thread has
-// its own MTRand object)
-
-#include"Define.h"
-
-#include <limits.h>
-#include <time.h>
-#include <math.h>
-
-class MTRand {
-// Data
-public:
-    typedef ::uint32 uint32;
-    enum { N = 624 };       // length of state vector
-    enum { SAVE = N + 1 };  // length of array for save()
-
-protected:
-    enum { M = 397 };  // period parameter
-
-    uint32 state[N];   // internal state
-    uint32 *pNext;     // next value to get from state
-    int left;          // number of values left before reload needed
-
-//Methods
-public:
-    MTRand( const uint32& oneSeed );  // initialize with a simple uint32
-    MTRand( uint32 *const bigSeed, uint32 const seedLength = N );  // or an array
-    MTRand();                         // auto-initialize with /dev/urandom or time() and clock()
-    MTRand(const MTRand&);            // prevent copy constructor
-    MTRand& operator=(const MTRand&); // no-op operator=
-
-    // Do NOT use for CRYPTOGRAPHY without securely hashing several returned
-    // values together, otherwise the generator state can be learned after
-    // reading 624 consecutive values.
-
-    // Access to 32-bit random numbers
-    double rand();                          // real number in [0,1]
-    double rand( const double& n );         // real number in [0,n]
-    double randExc();                       // real number in [0,1)
-    double randExc( const double& n );      // real number in [0,n)
-    double randDblExc();                    // real number in (0,1)
-    double randDblExc( const double& n );   // real number in (0,n)
-    uint32 randInt();                       // integer in [0,2^32-1]
-    uint32 randInt( const uint32& n );      // integer in [0,n] for n < 2^32
-    double operator()() { return rand(); }  // same as rand()
-
-    // Access to 53-bit random numbers (capacity of IEEE double precision)
-    double rand53();  // real number in [0,1)
-
-    // Access to nonuniform random number distributions
-    double randNorm( const double& mean = 0.0, const double& variance = 0.0 );
-
-    // Re-seeding functions with same behavior as initializers
-    void seed( const uint32 oneSeed );
-    void seed( uint32 *const bigSeed, const uint32 seedLength = N );
-    void seed();
-
-    // Saving and loading generator state
-    void save( uint32* saveArray ) const;  // to array of size SAVE
-    void load( uint32 *const loadArray );  // from such array
-    /* Trinity not use streams for random values output
-    friend std::ostream& operator<<( std::ostream& os, const MTRand& mtrand );
-    friend std::istream& operator>>( std::istream& is, MTRand& mtrand );
-    */
-protected:
-    void initialize( const uint32 oneSeed );
-    void reload();
-    uint32 hiBit( const uint32& u ) const { return u & 0x80000000UL; }
-    uint32 loBit( const uint32& u ) const { return u & 0x00000001UL; }
-    uint32 loBits( const uint32& u ) const { return u & 0x7fffffffUL; }
-    uint32 mixBits( const uint32& u, const uint32& v ) const
-        { return hiBit(u) | loBits(v); }
-    uint32 twist( const uint32& m, const uint32& s0, const uint32& s1 ) const
-        { return m ^ (mixBits(s0,s1)>>1) ^ uint32(-(int32)(loBit(s1) & 0x9908b0dfUL)); }
-    static uint32 hash( time_t t, clock_t c );
-};
-
-inline MTRand::MTRand(const MTRand&)
-    { seed(); }
-
-inline MTRand& MTRand::operator=(const MTRand&)
-    { return *this; }
-
-inline MTRand::MTRand( const uint32& oneSeed )
-    { seed(oneSeed); }
-
-inline MTRand::MTRand( uint32 *const bigSeed, const uint32 seedLength )
-    { seed(bigSeed,seedLength); }
-
-inline MTRand::MTRand()
-    { seed(); }
-
-inline double MTRand::rand()
-    { return double(randInt()) * (1.0/4294967295.0); }
-
-inline double MTRand::rand( const double& n )
-    { return rand() * n; }
-
-inline double MTRand::randExc()
-    { return double(randInt()) * (1.0/4294967296.0); }
-
-inline double MTRand::randExc( const double& n )
-    { return randExc() * n; }
-
-inline double MTRand::randDblExc()
-    { return ( double(randInt()) + 0.5 ) * (1.0/4294967296.0); }
-
-inline double MTRand::randDblExc( const double& n )
-    { return randDblExc() * n; }
-
-inline double MTRand::rand53()
-{
-    uint32 a = randInt() >> 5, b = randInt() >> 6;
-    return ( a * 67108864.0 + b ) * (1.0/9007199254740992.0);  // by Isaku Wada
-}
-
-inline double MTRand::randNorm( const double& mean, const double& variance )
-{
-    // Return a real number from a normal (Gaussian) distribution with given
-    // mean and variance by Box-Muller method
-    double r = sqrt( -2.0 * log( 1.0-randDblExc()) ) * variance;
-    double phi = 2.0 * 3.14159265358979323846264338328 * randExc();
-    return mean + r * cos(phi);
-}
-
-inline MTRand::uint32 MTRand::randInt()
-{
-    // Pull a 32-bit integer from the generator state
-    // Every other access function simply transforms the numbers extracted here
-
-    if( left == 0 ) reload();
-    --left;
-
-    register uint32 s1;
-    s1 = *pNext++;
-    s1 ^= (s1 >> 11);
-    s1 ^= (s1 <<  7) & 0x9d2c5680UL;
-    s1 ^= (s1 << 15) & 0xefc60000UL;
-    return ( s1 ^ (s1 >> 18) );
-}
-
-inline MTRand::uint32 MTRand::randInt( const uint32& n )
-{
-    // Find which bits are used in n
-    // Optimized by Magnus Jonsson (magnus@smartelectronix.com)
-    uint32 used = n;
-    used |= used >> 1;
-    used |= used >> 2;
-    used |= used >> 4;
-    used |= used >> 8;
-    used |= used >> 16;
-
-    // Draw numbers until one is found in [0,n]
-    uint32 i;
-    do
-        i = randInt() & used;  // toss unused bits to shorten search
-    while( i > n );
-    return i;
-}
-
-inline void MTRand::seed( const uint32 oneSeed )
-{
-    // Seed the generator with a simple uint32
-    initialize(oneSeed);
-    reload();
-}
-
-inline void MTRand::seed( uint32 *const bigSeed, const uint32 seedLength )
-{
-    // Seed the generator with an array of uint32's
-    // There are 2^19937-1 possible initial states.  This function allows
-    // all of those to be accessed by providing at least 19937 bits (with a
-    // default seed length of N = 624 uint32's).  Any bits above the lower 32
-    // in each element are discarded.
-    // Just call seed() if you want to get array from /dev/urandom
-    initialize(19650218UL);
-    register int i = 1;
-    register uint32 j = 0;
-    register int k = ( N > int(seedLength) ? N : int(seedLength) );
-    for (; k; --k )
-    {
-        state[i] =
-            state[i] ^ ( (state[i-1] ^ (state[i-1] >> 30)) * 1664525UL );
-        state[i] += ( bigSeed[j] & 0xffffffffUL ) + j;
-        state[i] &= 0xffffffffUL;
-        ++i;  ++j;
-        if( i >= N ) { state[0] = state[N-1];  i = 1; }
-        if( j >= seedLength ) j = 0;
-    }
-    for (k = N - 1; k; --k )
-    {
-        state[i] =
-            state[i] ^ ( (state[i-1] ^ (state[i-1] >> 30)) * 1566083941UL );
-        state[i] -= i;
-        state[i] &= 0xffffffffUL;
-        ++i;
-        if( i >= N ) { state[0] = state[N-1];  i = 1; }
-    }
-    state[0] = 0x80000000UL;  // MSB is 1, assuring non-zero initial array
-    reload();
-}
-
-inline void MTRand::seed()
-{
-    // Seed the generator with hash of time() and clock() values
-    seed( hash( time(NULL), clock() ) );
-}
-
-inline void MTRand::initialize( const uint32 seed )
-{
-    // Initialize generator state with seed
-    // See Knuth TAOCP Vol 2, 3rd Ed, p.106 for multiplier.
-    // In previous versions, most significant bits (MSBs) of the seed affect
-    // only MSBs of the state array.  Modified 9 Jan 2002 by Makoto Matsumoto.
-    register uint32 *s = state;
-    register uint32 *r = state;
-    register int i = 1;
-    *s++ = seed & 0xffffffffUL;
-    for (; i < N; ++i )
-    {
-        *s++ = ( 1812433253UL * ( *r ^ (*r >> 30) ) + i ) & 0xffffffffUL;
-        r++;
-    }
-}
-
-inline void MTRand::reload()
-{
-    // Generate N new values in state
-    // Made clearer and faster by Matthew Bellew (matthew.bellew@home.com)
-    register uint32 *p = state;
-    register int i;
-    for (i = N - M; i--; ++p )
-        *p = twist( p[M], p[0], p[1] );
-    for (i = M; --i; ++p )
-        *p = twist( p[M-N], p[0], p[1] );
-    *p = twist( p[M-N], p[0], state[0] );
-
-    left = N, pNext = state;
-}
-
-inline MTRand::uint32 MTRand::hash( time_t t, clock_t c )
-{
-    // Get a uint32 from t and c
-    // Better than uint32(x) in case x is floating point in [0,1]
-    // Based on code by Lawrence Kirby (fred@genesis.demon.co.uk)
-
-    static uint32 differ = 0;  // guarantee time-based seeds will change
-
-    uint32 h1 = 0;
-    unsigned char *p = (unsigned char *) &t;
-    for (size_t i = 0; i < sizeof(t); ++i )
-    {
-        h1 *= UCHAR_MAX + 2U;
-        h1 += p[i];
-    }
-    uint32 h2 = 0;
-    p = (unsigned char *) &c;
-    for (size_t j = 0; j < sizeof(c); ++j )
-    {
-        h2 *= UCHAR_MAX + 2U;
-        h2 += p[j];
-    }
-    return ( h1 + differ++ ) ^ h2;
-}
-
-inline void MTRand::save( uint32* saveArray ) const
-{
-    register uint32 *sa = saveArray;
-    register const uint32 *s = state;
-    register int i = N;
-    for (; i--; *sa++ = *s++ ) {}
-    *sa = left;
-}
-
-inline void MTRand::load( uint32 *const loadArray )
-{
-    register uint32 *s = state;
-    register uint32 *la = loadArray;
-    register int i = N;
-    for (; i--; *s++ = *la++ ) {}
-    left = *la;
-    pNext = &state[N-left];
-}
-
-/* Trinity not use streams for random values output
-inline std::ostream& operator<<( std::ostream& os, const MTRand& mtrand )
-{
-    register const MTRand::uint32 *s = mtrand.state;
-    register int i = mtrand.N;
-    for (; i--; os << *s++ << "\t" ) {}
-    return os << mtrand.left;
-}
-
-inline std::istream& operator>>( std::istream& is, MTRand& mtrand )
-{
-    register MTRand::uint32 *s = mtrand.state;
-    register int i = mtrand.N;
-    for (; i--; is >> *s++ ) {}
-    is >> mtrand.left;
-    mtrand.pNext = &mtrand.state[mtrand.N-mtrand.left];
-    return is;
-}
-*/
-
-#endif  // MERSENNETWISTER_H
-
-// Change log:
-//
-// v0.1 - First release on 15 May 2000
-//      - Based on code by Makoto Matsumoto, Takuji Nishimura, and Shawn Cokus
-//      - Translated from C to C++
-//      - Made completely ANSI compliant
-//      - Designed convenient interface for initialization, seeding, and
-//        obtaining numbers in default or user-defined ranges
-//      - Added automatic seeding from /dev/urandom or time() and clock()
-//      - Provided functions for saving and loading generator state
-//
-// v0.2 - Fixed bug which reloaded generator one step too late
-//
-// v0.3 - Switched to clearer, faster reload() code from Matthew Bellew
-//
-// v0.4 - Removed trailing newline in saved generator format to be consistent
-//        with output format of built-in types
-//
-// v0.5 - Improved portability by replacing static const int's with enum's and
-//        clarifying return values in seed(); suggested by Eric Heimburg
-//      - Removed MAXINT constant; use 0xffffffffUL instead
-//
-// v0.6 - Eliminated seed overflow when uint32 is larger than 32 bits
-//      - Changed integer [0,n] generator to give better uniformity
-//
-// v0.7 - Fixed operator precedence ambiguity in reload()
-//      - Added access for real numbers in (0,1) and (0,n)
-//
-// v0.8 - Included time.h header to properly support time_t and clock_t
-//
-// v1.0 - Revised seeding to match 26 Jan 2002 update of Nishimura and Matsumoto
-//      - Allowed for seeding with arrays of any length
-//      - Added access for real numbers in [0,1) with 53-bit resolution
-//      - Added access for real numbers from normal (Gaussian) distributions
-//      - Increased overall speed by optimizing twist()
-//      - Doubled speed of integer [0,n] generation
-//      - Fixed out-of-range number generation on 64-bit machines
-//      - Improved portability by substituting literal constants for long enum's
-//      - Changed license from GNU LGPL to BSD
-
diff -r b4c056460923 -r da13f4f7a26c sql/Arcanum/[INDEV] Gunship_Battle.sql
--- a/sql/Arcanum/[INDEV] Gunship_Battle.sql	Thu Apr 05 13:10:49 2012 +0300
+++ b/sql/Arcanum/[INDEV] Gunship_Battle.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -78,7 +78,7 @@
 (13, 1, 70374, 0, 0, 31, 0, 3, 37540, 0, 0, 0, '', NULL),
 (13, 1, 70383, 0, 0, 31, 0, 3, 37215, 0, 0, 0, '', NULL),
 (13, 3, 70173, 0, 0, 31, 0, 3, 37215, 0, 0, 0, '', NULL),
-(13, 1, 72959, 0, 0, 31, 0, 3, 0, 0, 0, 0, '', NULL);
+(13, 1, 72959, 0, 0, 31, 0, 4, 0, 0, 0, 0, '', NULL);
 
 DELETE FROM transports WHERE entry IN (201580, 201581, 201811, 201812);
 DELETE FROM creature WHERE id IN (37230, 36838, 36839, 36948, 36939);
diff -r b4c056460923 -r da13f4f7a26c sql/Arcanum/update_400+.sql
--- a/sql/Arcanum/update_400+.sql	Thu Apr 05 13:10:49 2012 +0300
+++ b/sql/Arcanum/update_400+.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -126,15 +126,6 @@
 INSERT INTO `smart_scripts` (`entryorguid`,`source_type`,`id`,`link`,`event_type`,`event_flags`,`action_type`,`action_param1`,`target_type`,`target_param1`,`comment`) VALUES
 (26237, 0, 0, 0, 54, 1, 33, 26237, 18, 20,'Quest: 11969');
 
--- Sylvana scripting
-UPDATE `creature_template` SET `unit_flags`=`unit_flags`&~2,`AIName`='',`dmg_multiplier`=70,`ScriptName`='boss_lady_sylvanas_windrunner' WHERE `entry`=10181;
-UPDATE `creature_template` SET `unit_flags`=`unit_flags`|2,`dmg_multiplier`=70 WHERE `entry`=6412;
-DELETE FROM `creature_text` WHERE `entry`=10181;
-INSERT INTO `creature_text` (`entry`,`groupid`,`id`,`text`,`type`,`language`,`probability`,`emote`,`duration`,`sound`,`comment`) VALUES
-(10181,1,0,'Let none survive!',14,0,0,5,0,5886,'Sylvanas Windrunner - Aggro'),
-(10181,1,1,'May my aim be true.',14,0,0,5,0,5886,'Sylvanas Windrunner - Aggro'),
-(10181,2,0,'Ah...ah...',14,0,0,5,0,16320,'Sylvanas Windrunner - Death');
-
 -- Cairne Bloodhoof scripting
 UPDATE `creature_template` SET `unit_flags`=`unit_flags`&~2,`AIName`='',`ScriptName`='boss_cairne_bloodhoof' WHERE `entry`=3057;
 DELETE FROM `creature_text` WHERE `entry`=3057;
@@ -199,8 +190,9 @@
 UPDATE `creature_template` SET `ScriptName` = 'npc_roanauk' WHERE `entry` = '26810';
 
 -- ViP vendor
+DELETE FROM creature_template WHERE entry = 100003;
 INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction_A`, `faction_H`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `equipment_id`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `WDBVerified`) VALUES
-('100002','0','0','0','0','0','28769','0','0','0','ViP торговец','','','0','80','80','0','35','35','129','1','1.14286','1','0','0','0','0','0','1','0','0','1','0','0','0','0','0','0','0','0','0','0','7','4718662','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','2','2','1','0','0','0','0','0','0','0','0','1','0','0','0','npc_vip_vendor','1');
+('100003','0','0','0','0','0','28769','0','0','0','ViP торговец','','','0','80','80','0','35','35','129','1','1.14286','1','0','0','0','0','0','1','0','0','1','0','0','0','0','0','0','0','0','0','0','7','4718662','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','2','2','1','0','0','0','0','0','0','0','0','1','0','0','0','npc_vip_vendor','1');
 
 -- Nagrand
 -- Quest: Not On My Watch!, http://old.wowhead.com/quest=9918
@@ -346,3 +338,1587 @@
 DELETE FROM `conditions` WHERE ConditionTypeOrReference = 24 AND Sourceentry = 39651;
 DELETE FROM `script_waypoint` WHERE entry = 33370;
 DELETE FROM `db_script_string` WHERE entry IN (2000000599,2000000600,2000000601,2000000602);
+
+-- The Storm Peaks
+-- Quests: Discipline, http://old.wowhead.com/quest=12906
+--         Maintaining Discipline, http://old.wowhead.com/quest=13422
+UPDATE `quest_template` SET `RequiredNpcOrGo1`='30146', `RequiredSpellCast1`='56033' WHERE `Id` IN (12906, 13422);
+
+-- Loot corrections
+-- 39152
+DELETE FROM gameobject_loot_template WHERE item = 39152;
+DELETE FROM reference_loot_template WHERE item = 39152;
+DELETE FROM creature_loot_template WHERE item = 39152;
+INSERT INTO `gameobject_loot_template` (`entry`, `item`, `ChanceOrQuestChance`, `lootmode`, `groupid`, `mincountOrRef`, `maxcount`) VALUES
+('24589','39152','25','1','0','1','1'),
+('24556','39152','25','1','0','1','1');
+INSERT INTO `reference_loot_template` (`entry`, `item`, `ChanceOrQuestChance`, `lootmode`, `groupid`, `mincountOrRef`, `maxcount`) VALUES
+('35034','39152','25','1','0','1','1'),
+('35040','39152','25','1','0','1','1'),
+('35049','39152','25','1','0','1','1');
+INSERT INTO `creature_loot_template` (`entry`, `item`, `ChanceOrQuestChance`, `lootmode`, `groupid`, `mincountOrRef`, `maxcount`) VALUES
+('30748','39152','25','1','0','1','1'),
+('26550','39152','1','1','0','1','1'),
+('26553','39152','1.6','1','0','1','1'),
+('26554','39152','1.3','1','0','1','1'),
+('26555','39152','1.4','1','0','1','1'),
+('26668','39152','25','1','0','1','1'),
+('26669','39152','1.4','1','0','1','1'),
+('26687','39152','25','1','0','1','1'),
+('26693','39152','25','1','0','1','1'),
+('26861','39152','25','1','0','1','1'),
+('27633','39152','2.2','1','0','1','1'),
+('27635','39152','1.7','1','0','1','1'),
+('27871','39152','29','1','0','1','1'),
+('27960','39152','1.1','1','0','1','1'),
+('27969','39152','1.1','1','0','1','1'),
+('28022','39152','0.4','1','0','1','1'),
+('28023','39152','0.4','1','0','1','1'),
+('28026','39152','0.5','1','0','1','1'),
+('28035','39152','0.1','1','0','1','1'),
+('28036','39152','0.2','1','0','1','1'),
+('28080','39152','0.05','1','0','1','1'),
+('28081','39152','0.1','1','0','1','1'),
+('28101','39152','0.2','1','0','1','1'),
+('28108','39152','0.2','1','0','1','1'),
+('28123','39152','0.3','1','0','1','1'),
+('28124','39152','0.9','1','0','1','1'),
+('28158','39152','0.1','1','0','1','1'),
+('28188','39152','0.1','1','0','1','1'),
+('28255','39152','0.4','1','0','1','1'),
+('28257','39152','0.1','1','0','1','1'),
+('28268','39152','0.1','1','0','1','1'),
+('28373','39152','0.05','1','0','1','1'),
+('28388','39152','0.1','1','0','1','1'),
+('28402','39152','0.05','1','0','1','1'),
+('28403','39152','0.05','1','0','1','1'),
+('28412','39152','0.1','1','0','1','1'),
+('28414','39152','0.05','1','0','1','1'),
+('28417','39152','0.05','1','0','1','1'),
+('28418','39152','0.1','1','0','1','1'),
+('28465','39152','0.1','1','0','1','1'),
+('28495','39152','0.3','1','0','1','1'),
+('28504','39152','0.05','1','0','1','1'),
+('28538','39152','0.05','1','0','1','1'),
+('28565','39152','0.6','1','0','1','1'),
+('28575','39152','0.1','1','0','1','1'),
+('28578','39152','1.4','1','0','1','1'),
+('28579','39152','1','1','0','1','1'),
+('28586','39152','25','1','0','1','1'),
+('28587','39152','25','1','0','1','1'),
+('28600','39152','0.1','1','0','1','1'),
+('28602','39152','0.2','1','0','1','1'),
+('28641','39152','0.2','1','0','1','1'),
+('28802','39152','0.3','1','0','1','1'),
+('28861','39152','0.1','1','0','1','1'),
+('28916','39152','0.1','1','0','1','1'),
+('28923','39152','25','1','0','1','1'),
+('28988','39152','0.1','1','0','1','1'),
+('29123','39152','0.2','1','0','1','1'),
+('29129','39152','0.4','1','0','1','1'),
+('29133','39152','0.2','1','0','1','1'),
+('29211','39152','0.5','1','0','1','1'),
+('29235','39152','0.2','1','0','1','1'),
+('29236','39152','0.6','1','0','1','1'),
+('29237','39152','0.3','1','0','1','1'),
+('29266','39152','25','1','0','1','1'),
+('29304','39152','25','1','0','1','1'),
+('29305','39152','25','1','0','1','1'),
+('29306','39152','25','1','0','1','1'),
+('29312','39152','25','1','0','1','1'),
+('29314','39152','25','1','0','1','1'),
+('29315','39152','25','1','0','1','1'),
+('29316','39152','25','1','0','1','1'),
+('29323','39152','0.05','1','0','1','1'),
+('29329','39152','0.05','1','0','1','1'),
+('29331','39152','0.1','1','0','1','1'),
+('29338','39152','0.05','1','0','1','1'),
+('29370','39152','0.1','1','0','1','1'),
+('29404','39152','0.2','1','0','1','1'),
+('29407','39152','0.2','1','0','1','1'),
+('29409','39152','0.8','1','0','1','1'),
+('29413','39152','0.1','1','0','1','1'),
+('29449','39152','0.7','1','0','1','1'),
+('29450','39152','0.4','1','0','1','1'),
+('29451','39152','0.3','1','0','1','1'),
+('29586','39152','0.1','1','0','1','1'),
+('29622','39152','0.1','1','0','1','1'),
+('29623','39152','0.1','1','0','1','1'),
+('29646','39152','0.1','1','0','1','1'),
+('29652','39152','0.2','1','0','1','1'),
+('29654','39152','2.1','1','0','1','1'),
+('29656','39152','2.1','1','0','1','1'),
+('29697','39152','1.6','1','0','1','1'),
+('29699','39152','4','1','0','1','1'),
+('29717','39152','0.1','1','0','1','1'),
+('29719','39152','0.05','1','0','1','1'),
+('29720','39152','0.1','1','0','1','1'),
+('29792','39152','0.2','1','0','1','1'),
+('29793','39152','0.2','1','0','1','1'),
+('29819','39152','1.5','1','0','1','1'),
+('29820','39152','1.6','1','0','1','1'),
+('29822','39152','1.8','1','0','1','1'),
+('29826','39152','1.8','1','0','1','1'),
+('29832','39152','3.3','1','0','1','1'),
+('29834','39152','1.4','1','0','1','1'),
+('29843','39152','0.1','1','0','1','1'),
+('29880','39152','0.05','1','0','1','1'),
+('30037','39152','0.05','1','0','1','1'),
+('30202','39152','0.05','1','0','1','1'),
+('30204','39152','0.5','1','0','1','1'),
+('30205','39152','0.2','1','0','1','1'),
+('30250','39152','0.05','1','0','1','1'),
+('30333','39152','0.1','1','0','1','1'),
+('30453','39152','3.4','1','0','1','1'),
+('30660','39152','5','1','0','1','1'),
+('30666','39152','4.8','1','0','1','1'),
+('30667','39152','4.4','1','0','1','1'),
+('30668','39152','4.2','1','0','1','1'),
+('30680','39152','9.3','1','0','1','1'),
+('30681','39152','7.3','1','0','1','1'),
+('30682','39152','4.2','1','0','1','1'),
+('30687','39152','0.05','1','0','1','1'),
+('30689','39152','0.2','1','0','1','1'),
+('30695','39152','5.2','1','0','1','1'),
+('30701','39152','0.1','1','0','1','1'),
+('30856','39152','0.4','1','0','1','1'),
+('30860','39152','0.1','1','0','1','1'),
+('30863','39152','0.1','1','0','1','1'),
+('30865','39152','0.1','1','0','1','1'),
+('30892','39152','4.4','1','0','1','1'),
+('30893','39152','5.5','1','0','1','1'),
+('30894','39152','2.6','1','0','1','1'),
+('30920','39152','0.3','1','0','1','1'),
+('30921','39152','0.05','1','0','1','1'),
+('30951','39152','0.3','1','0','1','1'),
+('31134','39152','25','1','0','1','1'),
+('31140','39152','0.05','1','0','1','1'),
+('31150','39152','0.3','1','0','1','1'),
+('31152','39152','0.2','1','0','1','1'),
+('31231','39152','0.5','1','0','1','1'),
+('31258','39152','0.05','1','0','1','1'),
+('31402','39152','0.7','1','0','1','1'),
+('31403','39152','0.8','1','0','1','1'),
+('31718','39152','0.05','1','0','1','1'),
+('31738','39152','0.2','1','0','1','1'),
+('31746','39152','0.05','1','0','1','1'),
+('31754','39152','1','1','0','1','1'),
+('31847','39152','0.05','1','0','1','1'),
+('32191','39152','2.8','1','0','1','1'),
+('32255','39152','0.2','1','0','1','1'),
+('32259','39152','0.1','1','0','1','1'),
+('32276','39152','0.1','1','0','1','1'),
+('32278','39152','1.7','1','0','1','1'),
+('32289','39152','0.1','1','0','1','1'),
+('32353','39152','5','1','0','1','1'),
+('32507','39152','0.3','1','0','1','1'),
+('31362','39152','25','1','0','1','1'),
+('31350','39152','25','1','0','1','1'),
+('31349','39152','25','1','0','1','1'),
+('31360','39152','25','1','0','1','1'),
+('30532','39152','25','1','0','1','1'),
+('30529','39152','25','1','0','1','1'),
+('30510','39152','25','1','0','1','1'),
+('30540','39152','25','1','0','1','1'),
+('31612','39152','25','1','0','1','1'),
+('31611','39152','25','1','0','1','1'),
+('31610','39152','25','1','0','1','1'),
+('31456','39152','25','1','0','1','1'),
+('31469','39152','25','1','0','1','1'),
+('31465','39152','25','1','0','1','1'),
+('31464','39152','25','1','0','1','1'),
+('31463','39152','25','1','0','1','1'),
+('31370','39152','25','1','0','1','1'),
+('30530','39152','25','1','0','1','1'),
+('31368','39152','25','1','0','1','1'),
+('29932','39152','25','1','0','1','1'),
+('29313','39152','25','1','0','1','1'),
+('31507','39152','25','1','0','1','1'),
+('31510','39152','25','1','0','1','1'),
+('31508','39152','25','1','0','1','1'),
+('31511','39152','25','1','0','1','1'),
+('31509','39152','25','1','0','1','1'),
+('31512','39152','25','1','0','1','1'),
+('31506','39152','25','1','0','1','1'),
+('31533','39152','25','1','0','1','1'),
+('31536','39152','25','1','0','1','1'),
+('31537','39152','25','1','0','1','1'),
+('31538','39152','25','1','0','1','1'),
+('31674','39152','25','1','0','1','1'),
+('30810','39152','25','1','0','1','1'),
+('30774','39152','25','1','0','1','1'),
+('30807','39152','25','1','0','1','1'),
+('30788','39152','25','1','0','1','1'),
+('30998','39152','5','1','0','1','1');
+
+-- 45912
+DELETE FROM gameobject_loot_template WHERE item = 45912;
+DELETE FROM reference_loot_template WHERE item = 39152;
+DELETE FROM creature_loot_template WHERE item = 45912;
+INSERT INTO `reference_loot_template` (`entry`, `item`, `ChanceOrQuestChance`, `lootmode`, `groupid`, `mincountOrRef`, `maxcount`) VALUES
+('10009','45912','0','1','1','1','1');
+INSERT INTO `creature_loot_template` (`entry`, `item`, `ChanceOrQuestChance`, `lootmode`, `groupid`, `mincountOrRef`, `maxcount`) VALUES
+('15928','45912','0.1','1','0','1','1'),
+('15931','45912','0.1','1','0','1','1'),
+('15932','45912','0.1','1','0','1','1'),
+('15936','45912','0.1','1','0','1','1'),
+('15952','45912','0.1','1','0','1','1'),
+('15953','45912','0.1','1','0','1','1'),
+('15954','45912','0.1','1','0','1','1'),
+('15956','45912','0.1','1','0','1','1'),
+('15989','45912','0.1','1','0','1','1'),
+('15990','45912','0.1','1','0','1','1'),
+('16011','45912','0.1','1','0','1','1'),
+('16028','45912','0.1','1','0','1','1'),
+('16060','45912','0.1','1','0','1','1'),
+('16061','45912','0.1','1','0','1','1'),
+('16243','45912','0.1','1','0','1','1'),
+('21223','45912','0.1','1','0','1','1'),
+('26482','45912','0.1','1','0','1','1'),
+('27483','45912','0.1','1','0','1','1'),
+('29452','45912','0.1','1','0','1','1'),
+('26643','45912','0.1','1','0','1','1'),
+('26358','45912','0.1','1','0','1','1'),
+('26369','45912','0.1','1','0','1','1'),
+('28297','45912','0.1','1','0','1','1'),
+('24637','45912','0.1','1','0','1','1'),
+('25800','45912','0.1','1','0','1','1'),
+('25605','45912','0.1','1','0','1','1'),
+('25582','45912','0.1','1','0','1','1'),
+('25301','45912','0.1','1','0','1','1'),
+('29327','45912','0.1','1','0','1','1'),
+('28404','45912','0.1','1','0','1','1'),
+('25489','45912','0.1','1','0','1','1'),
+('28002','45912','0.1','1','0','1','1'),
+('25675','45912','0.1','1','0','1','1'),
+('25791','45912','0.1','1','0','1','1'),
+('23644','45912','0.1','1','0','1','1'),
+('23645','45912','0.1','1','0','1','1'),
+('23651','45912','0.1','1','0','1','1'),
+('23652','45912','0.1','1','0','1','1'),
+('23654','45912','0.1','1','0','1','1'),
+('23656','45912','0.1','1','0','1','1'),
+('23658','45912','0.1','1','0','1','1'),
+('23660','45912','0.1','1','0','1','1'),
+('23677','45912','0.1','1','0','1','1'),
+('23678','45912','0.1','1','0','1','1'),
+('23680','45912','0.1','1','0','1','1'),
+('23688','45912','0.1','1','0','1','1'),
+('23689','45912','0.1','1','0','1','1'),
+('23690','45912','0.1','1','0','1','1'),
+('23691','45912','0.1','1','0','1','1'),
+('23693','45912','0.1','1','0','1','1'),
+('23725','45912','0.1','1','0','1','1'),
+('23740','45912','0.1','1','0','1','1'),
+('23744','45912','0.1','1','0','1','1'),
+('23750','45912','0.1','1','0','1','1'),
+('23760','45912','0.1','1','0','1','1'),
+('23772','45912','0.1','1','0','1','1'),
+('23776','45912','0.1','1','0','1','1'),
+('23785','45912','0.1','1','0','1','1'),
+('23871','45912','0.1','1','0','1','1'),
+('23874','45912','0.1','1','0','1','1'),
+('23875','45912','0.1','1','0','1','1'),
+('23883','45912','0.1','1','0','1','1'),
+('23886','45912','0.1','1','0','1','1'),
+('23887','45912','0.1','1','0','1','1'),
+('23919','45912','0.1','1','0','1','1'),
+('23929','45912','0.1','1','0','1','1'),
+('23945','45912','0.1','1','0','1','1'),
+('23953','45912','0.1','1','0','1','1'),
+('23980','45912','0.1','1','0','1','1'),
+('23956','45912','0.1','1','0','1','1'),
+('23958','45912','0.1','1','0','1','1'),
+('23959','45912','0.1','1','0','1','1'),
+('23960','45912','0.1','1','0','1','1'),
+('23961','45912','0.1','1','0','1','1'),
+('23962','45912','0.1','1','0','1','1'),
+('23967','45912','0.1','1','0','1','1'),
+('23982','45912','0.1','1','0','1','1'),
+('23989','45912','0.1','1','0','1','1'),
+('23990','45912','0.1','1','0','1','1'),
+('23991','45912','0.1','1','0','1','1'),
+('23992','45912','0.1','1','0','1','1'),
+('23993','45912','0.1','1','0','1','1'),
+('23994','45912','0.1','1','0','1','1'),
+('23998','45912','0.1','1','0','1','1'),
+('24013','45912','0.1','1','0','1','1'),
+('24026','45912','0.1','1','0','1','1'),
+('24063','45912','0.1','1','0','1','1'),
+('24069','45912','0.1','1','0','1','1'),
+('24071','45912','0.1','1','0','1','1'),
+('24073','45912','0.1','1','0','1','1'),
+('24076','45912','0.1','1','0','1','1'),
+('24078','45912','0.1','1','0','1','1'),
+('24079','45912','0.1','1','0','1','1'),
+('24080','45912','0.1','1','0','1','1'),
+('24082','45912','0.1','1','0','1','1'),
+('24083','45912','0.1','1','0','1','1'),
+('24085','45912','0.1','1','0','1','1'),
+('24104','45912','0.1','1','0','1','1'),
+('24128','45912','0.1','1','0','1','1'),
+('24160','45912','0.1','1','0','1','1'),
+('24162','45912','0.1','1','0','1','1'),
+('24169','45912','0.1','1','0','1','1'),
+('24173','45912','0.1','1','0','1','1'),
+('24196','45912','0.1','1','0','1','1'),
+('24200','45912','0.1','1','0','1','1'),
+('24201','45912','0.1','1','0','1','1'),
+('24206','45912','0.1','1','0','1','1'),
+('24213','45912','0.1','1','0','1','1'),
+('24216','45912','0.1','1','0','1','1'),
+('24228','45912','0.1','1','0','1','1'),
+('24229','45912','0.1','1','0','1','1'),
+('24238','45912','0.1','1','0','1','1'),
+('24249','45912','0.1','1','0','1','1'),
+('24250','45912','0.1','1','0','1','1'),
+('24271','45912','0.1','1','0','1','1'),
+('24277','45912','0.1','1','0','1','1'),
+('24285','45912','0.1','1','0','1','1'),
+('24286','45912','0.1','1','0','1','1'),
+('24287','45912','0.1','1','0','1','1'),
+('24291','45912','0.1','1','0','1','1'),
+('24316','45912','0.1','1','0','1','1'),
+('24334','45912','0.1','1','0','1','1'),
+('24340','45912','0.1','1','0','1','1'),
+('24371','45912','0.1','1','0','1','1'),
+('24440','45912','0.1','1','0','1','1'),
+('24458','45912','0.1','1','0','1','1'),
+('24459','45912','0.1','1','0','1','1'),
+('24460','45912','0.1','1','0','1','1'),
+('24461','45912','0.1','1','0','1','1'),
+('24469','45912','0.1','1','0','1','1'),
+('24475','45912','0.1','1','0','1','1'),
+('24478','45912','0.1','1','0','1','1'),
+('24485','45912','0.1','1','0','1','1'),
+('24514','45912','0.1','1','0','1','1'),
+('24516','45912','0.1','1','0','1','1'),
+('24517','45912','0.1','1','0','1','1'),
+('24518','45912','0.1','1','0','1','1'),
+('24546','45912','0.1','1','0','1','1'),
+('24547','45912','0.1','1','0','1','1'),
+('24562','45912','0.1','1','0','1','1'),
+('24563','45912','0.1','1','0','1','1'),
+('24566','45912','0.1','1','0','1','1'),
+('24567','45912','0.1','1','0','1','1'),
+('24601','45912','0.1','1','0','1','1'),
+('24613','45912','0.1','1','0','1','1'),
+('24614','45912','0.1','1','0','1','1'),
+('24633','45912','0.1','1','0','1','1'),
+('24635','45912','0.1','1','0','1','1'),
+('24642','45912','0.1','1','0','1','1'),
+('24644','45912','0.1','1','0','1','1'),
+('24673','45912','0.1','1','0','1','1'),
+('24676','45912','0.1','1','0','1','1'),
+('24677','45912','0.1','1','0','1','1'),
+('24681','45912','0.1','1','0','1','1'),
+('24713','45912','0.1','1','0','1','1'),
+('24747','45912','0.1','1','0','1','1'),
+('24765','45912','0.1','1','0','1','1'),
+('24779','45912','0.1','1','0','1','1'),
+('24785','45912','0.1','1','0','1','1'),
+('24786','45912','0.1','1','0','1','1'),
+('24787','45912','0.1','1','0','1','1'),
+('24789','45912','0.1','1','0','1','1'),
+('24790','45912','0.1','1','0','1','1'),
+('24791','45912','0.1','1','0','1','1'),
+('24797','45912','0.1','1','0','1','1'),
+('24812','45912','0.1','1','0','1','1'),
+('24849','45912','0.1','1','0','1','1'),
+('24863','45912','0.1','1','0','1','1'),
+('24871','45912','0.1','1','0','1','1'),
+('24872','45912','0.1','1','0','1','1'),
+('24899','45912','0.1','1','0','1','1'),
+('24900','45912','0.1','1','0','1','1'),
+('24901','45912','0.1','1','0','1','1'),
+('24914','45912','0.1','1','0','1','1'),
+('24954','45912','0.1','1','0','1','1'),
+('24957','45912','0.1','1','0','1','1'),
+('25203','45912','0.1','1','0','1','1'),
+('25204','45912','0.1','1','0','1','1'),
+('25209','45912','0.1','1','0','1','1'),
+('25226','45912','0.1','1','0','1','1'),
+('25227','45912','0.1','1','0','1','1'),
+('25228','45912','0.1','1','0','1','1'),
+('25284','45912','0.1','1','0','1','1'),
+('25294','45912','0.1','1','0','1','1'),
+('25316','45912','0.1','1','0','1','1'),
+('25350','45912','0.1','1','0','1','1'),
+('25351','45912','0.1','1','0','1','1'),
+('25353','45912','0.1','1','0','1','1'),
+('25355','45912','0.1','1','0','1','1'),
+('25378','45912','0.1','1','0','1','1'),
+('25383','45912','0.1','1','0','1','1'),
+('25386','45912','0.1','1','0','1','1'),
+('25387','45912','0.1','1','0','1','1'),
+('25392','45912','0.1','1','0','1','1'),
+('25393','45912','0.1','1','0','1','1'),
+('25396','45912','0.1','1','0','1','1'),
+('25415','45912','0.1','1','0','1','1'),
+('25417','45912','0.1','1','0','1','1'),
+('25419','45912','0.1','1','0','1','1'),
+('25445','45912','0.1','1','0','1','1'),
+('25448','45912','0.1','1','0','1','1'),
+('25449','45912','0.1','1','0','1','1'),
+('25452','45912','0.1','1','0','1','1'),
+('25454','45912','0.1','1','0','1','1'),
+('25464','45912','0.1','1','0','1','1'),
+('25467','45912','0.1','1','0','1','1'),
+('25468','45912','0.1','1','0','1','1'),
+('25470','45912','0.1','1','0','1','1'),
+('25481','45912','0.1','1','0','1','1'),
+('25482','45912','0.1','1','0','1','1'),
+('25487','45912','0.1','1','0','1','1'),
+('25488','45912','0.1','1','0','1','1'),
+('25498','45912','0.1','1','0','1','1'),
+('25501','45912','0.1','1','0','1','1'),
+('25514','45912','0.1','1','0','1','1'),
+('25585','45912','0.1','1','0','1','1'),
+('25596','45912','0.1','1','0','1','1'),
+('25601','45912','0.1','1','0','1','1'),
+('25609','45912','0.1','1','0','1','1'),
+('25618','45912','0.1','1','0','1','1'),
+('25619','45912','0.1','1','0','1','1'),
+('25622','45912','0.1','1','0','1','1'),
+('25623','45912','0.1','1','0','1','1'),
+('25650','45912','0.1','1','0','1','1'),
+('25651','45912','0.1','1','0','1','1'),
+('25655','45912','0.1','1','0','1','1'),
+('25660','45912','0.1','1','0','1','1'),
+('25678','45912','0.1','1','0','1','1'),
+('25680','45912','0.1','1','0','1','1'),
+('25682','45912','0.1','1','0','1','1'),
+('25685','45912','0.1','1','0','1','1'),
+('25686','45912','0.1','1','0','1','1'),
+('25687','45912','0.1','1','0','1','1'),
+('25699','45912','0.1','1','0','1','1'),
+('25700','45912','0.1','1','0','1','1'),
+('25701','45912','0.1','1','0','1','1'),
+('25707','45912','0.1','1','0','1','1'),
+('25709','45912','0.1','1','0','1','1'),
+('25711','45912','0.1','1','0','1','1'),
+('25712','45912','0.1','1','0','1','1'),
+('25713','45912','0.1','1','0','1','1'),
+('25715','45912','0.1','1','0','1','1'),
+('25716','45912','0.1','1','0','1','1'),
+('25717','45912','0.1','1','0','1','1'),
+('25718','45912','0.1','1','0','1','1'),
+('25719','45912','0.1','1','0','1','1'),
+('25720','45912','0.1','1','0','1','1'),
+('25721','45912','0.1','1','0','1','1'),
+('25722','45912','0.1','1','0','1','1'),
+('25725','45912','0.1','1','0','1','1'),
+('25726','45912','0.1','1','0','1','1'),
+('25728','45912','0.1','1','0','1','1'),
+('25743','45912','0.1','1','0','1','1'),
+('25748','45912','0.1','1','0','1','1'),
+('25750','45912','0.1','1','0','1','1'),
+('25752','45912','0.1','1','0','1','1'),
+('25753','45912','0.1','1','0','1','1'),
+('25758','45912','0.1','1','0','1','1'),
+('25766','45912','0.1','1','0','1','1'),
+('25768','45912','0.1','1','0','1','1'),
+('25774','45912','0.1','1','0','1','1'),
+('25789','45912','0.1','1','0','1','1'),
+('25792','45912','0.1','1','0','1','1'),
+('25793','45912','0.1','1','0','1','1'),
+('25801','45912','0.1','1','0','1','1'),
+('25802','45912','0.1','1','0','1','1'),
+('25804','45912','0.1','1','0','1','1'),
+('25808','45912','0.1','1','0','1','1'),
+('25809','45912','0.1','1','0','1','1'),
+('25814','45912','0.1','1','0','1','1'),
+('25817','45912','0.1','1','0','1','1'),
+('25819','45912','0.1','1','0','1','1'),
+('25834','45912','0.1','1','0','1','1'),
+('25881','45912','0.1','1','0','1','1'),
+('25968','45912','0.1','1','0','1','1'),
+('25981','45912','0.1','1','0','1','1'),
+('26073','45912','0.1','1','0','1','1'),
+('26076','45912','0.1','1','0','1','1'),
+('26103','45912','0.1','1','0','1','1'),
+('26115','45912','0.1','1','0','1','1'),
+('26126','45912','0.1','1','0','1','1'),
+('26165','45912','0.1','1','0','1','1'),
+('26174','45912','0.1','1','0','1','1'),
+('26225','45912','0.1','1','0','1','1'),
+('26231','45912','0.1','1','0','1','1'),
+('26232','45912','0.1','1','0','1','1'),
+('26252','45912','0.1','1','0','1','1'),
+('26266','45912','0.1','1','0','1','1'),
+('26271','45912','0.1','1','0','1','1'),
+('26272','45912','0.1','1','0','1','1'),
+('26273','45912','0.1','1','0','1','1'),
+('26276','45912','0.1','1','0','1','1'),
+('26280','45912','0.1','1','0','1','1'),
+('26281','45912','0.1','1','0','1','1'),
+('26283','45912','0.1','1','0','1','1'),
+('26284','45912','0.1','1','0','1','1'),
+('26287','45912','0.1','1','0','1','1'),
+('26290','45912','0.1','1','0','1','1'),
+('26291','45912','0.1','1','0','1','1'),
+('26293','45912','0.1','1','0','1','1'),
+('26316','45912','0.1','1','0','1','1'),
+('26319','45912','0.1','1','0','1','1'),
+('26322','45912','0.1','1','0','1','1'),
+('26333','45912','0.1','1','0','1','1'),
+('26334','45912','0.1','1','0','1','1'),
+('26336','45912','0.1','1','0','1','1'),
+('26343','45912','0.1','1','0','1','1'),
+('26344','45912','0.1','1','0','1','1'),
+('26347','45912','0.1','1','0','1','1'),
+('26349','45912','0.1','1','0','1','1'),
+('26357','45912','0.1','1','0','1','1'),
+('26359','45912','0.1','1','0','1','1'),
+('26360','45912','0.1','1','0','1','1'),
+('26363','45912','0.1','1','0','1','1'),
+('26366','45912','0.1','1','0','1','1'),
+('26370','45912','0.1','1','0','1','1'),
+('26402','45912','0.1','1','0','1','1'),
+('26406','45912','0.1','1','0','1','1'),
+('26407','45912','0.1','1','0','1','1'),
+('26411','45912','0.1','1','0','1','1'),
+('26413','45912','0.1','1','0','1','1'),
+('26417','45912','0.1','1','0','1','1'),
+('26418','45912','0.1','1','0','1','1'),
+('26421','45912','0.1','1','0','1','1'),
+('26425','45912','0.1','1','0','1','1'),
+('26426','45912','0.1','1','0','1','1'),
+('26428','45912','0.1','1','0','1','1'),
+('26434','45912','0.1','1','0','1','1'),
+('26446','45912','0.1','1','0','1','1'),
+('26447','45912','0.1','1','0','1','1'),
+('26449','45912','0.1','1','0','1','1'),
+('26455','45912','0.1','1','0','1','1'),
+('26457','45912','0.1','1','0','1','1'),
+('26461','45912','0.1','1','0','1','1'),
+('26467','45912','0.1','1','0','1','1'),
+('26472','45912','0.1','1','0','1','1'),
+('26483','45912','0.1','1','0','1','1'),
+('26511','45912','0.1','1','0','1','1'),
+('26521','45912','0.1','1','0','1','1'),
+('26522','45912','0.1','1','0','1','1'),
+('26536','45912','0.1','1','0','1','1'),
+('26550','45912','0.1','1','0','1','1'),
+('26553','45912','0.1','1','0','1','1'),
+('26554','45912','0.1','1','0','1','1'),
+('26555','45912','0.1','1','0','1','1'),
+('26575','45912','0.1','1','0','1','1'),
+('26577','45912','0.1','1','0','1','1'),
+('26578','45912','0.1','1','0','1','1'),
+('26586','45912','0.1','1','0','1','1'),
+('26592','45912','0.1','1','0','1','1'),
+('26605','45912','0.1','1','0','1','1'),
+('26606','45912','0.1','1','0','1','1'),
+('26613','45912','0.1','1','0','1','1'),
+('26615','45912','0.1','1','0','1','1'),
+('26616','45912','0.1','1','0','1','1'),
+('26620','45912','0.1','1','0','1','1'),
+('26621','45912','0.1','1','0','1','1'),
+('26622','45912','0.1','1','0','1','1'),
+('26623','45912','0.1','1','0','1','1'),
+('26624','45912','0.1','1','0','1','1'),
+('26625','45912','0.1','1','0','1','1'),
+('26626','45912','0.1','1','0','1','1'),
+('26627','45912','0.1','1','0','1','1'),
+('26628','45912','0.1','1','0','1','1'),
+('26630','45912','0.1','1','0','1','1'),
+('26631','45912','0.1','1','0','1','1'),
+('26632','45912','0.1','1','0','1','1'),
+('26633','45912','0.1','1','0','1','1'),
+('26635','45912','0.1','1','0','1','1'),
+('26636','45912','0.1','1','0','1','1'),
+('26637','45912','0.1','1','0','1','1'),
+('26638','45912','0.1','1','0','1','1'),
+('26639','45912','0.1','1','0','1','1'),
+('26641','45912','0.1','1','0','1','1'),
+('26644','45912','0.1','1','0','1','1'),
+('26646','45912','0.1','1','0','1','1'),
+('26655','45912','0.1','1','0','1','1'),
+('26658','45912','0.1','1','0','1','1'),
+('26667','45912','0.1','1','0','1','1'),
+('26668','45912','0.1','1','0','1','1'),
+('26669','45912','0.1','1','0','1','1'),
+('26670','45912','0.1','1','0','1','1'),
+('26672','45912','0.1','1','0','1','1'),
+('26681','45912','0.1','1','0','1','1'),
+('26687','45912','0.1','1','0','1','1'),
+('26693','45912','0.1','1','0','1','1'),
+('26694','45912','0.1','1','0','1','1'),
+('26696','45912','0.1','1','0','1','1'),
+('26704','45912','0.1','1','0','1','1'),
+('26706','45912','0.1','1','0','1','1'),
+('26716','45912','0.1','1','0','1','1'),
+('26722','45912','0.1','1','0','1','1'),
+('26723','45912','0.1','1','0','1','1'),
+('26727','45912','0.1','1','0','1','1'),
+('26728','45912','0.1','1','0','1','1'),
+('26729','45912','0.1','1','0','1','1'),
+('26730','45912','0.1','1','0','1','1'),
+('26731','45912','0.1','1','0','1','1'),
+('26734','45912','0.1','1','0','1','1'),
+('26735','45912','0.1','1','0','1','1'),
+('26737','45912','0.1','1','0','1','1'),
+('26762','45912','0.1','1','0','1','1'),
+('26763','45912','0.1','1','0','1','1'),
+('26769','45912','0.1','1','0','1','1'),
+('26782','45912','0.1','1','0','1','1'),
+('26792','45912','0.1','1','0','1','1'),
+('26794','45912','0.1','1','0','1','1'),
+('26795','45912','0.1','1','0','1','1'),
+('26796','45912','0.1','1','0','1','1'),
+('26797','45912','0.1','1','0','1','1'),
+('26798','45912','0.1','1','0','1','1'),
+('26799','45912','0.1','1','0','1','1'),
+('26800','45912','0.1','1','0','1','1'),
+('26801','45912','0.1','1','0','1','1'),
+('26802','45912','0.1','1','0','1','1'),
+('26803','45912','0.1','1','0','1','1'),
+('26805','45912','0.1','1','0','1','1'),
+('26806','45912','0.1','1','0','1','1'),
+('26811','45912','0.1','1','0','1','1'),
+('26812','45912','0.1','1','0','1','1'),
+('26816','45912','0.1','1','0','1','1'),
+('26823','45912','0.1','1','0','1','1'),
+('26824','45912','0.1','1','0','1','1'),
+('26825','45912','0.1','1','0','1','1'),
+('26826','45912','0.1','1','0','1','1'),
+('26827','45912','0.1','1','0','1','1'),
+('26828','45912','0.1','1','0','1','1'),
+('26830','45912','0.1','1','0','1','1'),
+('26836','45912','0.1','1','0','1','1'),
+('26838','45912','0.1','1','0','1','1'),
+('26841','45912','0.1','1','0','1','1'),
+('26858','45912','0.1','1','0','1','1'),
+('26861','45912','0.1','1','0','1','1'),
+('26862','45912','0.1','1','0','1','1'),
+('26863','45912','0.1','1','0','1','1'),
+('26919','45912','0.1','1','0','1','1'),
+('26926','45912','0.1','1','0','1','1'),
+('26942','45912','0.1','1','0','1','1'),
+('26943','45912','0.1','1','0','1','1'),
+('26946','45912','0.1','1','0','1','1'),
+('26948','45912','0.1','1','0','1','1'),
+('26966','45912','0.1','1','0','1','1'),
+('27002','45912','0.1','1','0','1','1'),
+('27004','45912','0.1','1','0','1','1'),
+('27005','45912','0.1','1','0','1','1'),
+('27006','45912','0.1','1','0','1','1'),
+('27007','45912','0.1','1','0','1','1'),
+('27008','45912','0.1','1','0','1','1'),
+('27009','45912','0.1','1','0','1','1'),
+('27018','45912','0.1','1','0','1','1'),
+('27020','45912','0.1','1','0','1','1'),
+('27024','45912','0.1','1','0','1','1'),
+('27105','45912','0.1','1','0','1','1'),
+('27117','45912','0.1','1','0','1','1'),
+('27118','45912','0.1','1','0','1','1'),
+('27122','45912','0.1','1','0','1','1'),
+('27131','45912','0.1','1','0','1','1'),
+('27210','45912','0.1','1','0','1','1'),
+('27213','45912','0.1','1','0','1','1'),
+('27220','45912','0.1','1','0','1','1'),
+('27224','45912','0.1','1','0','1','1'),
+('27225','45912','0.1','1','0','1','1'),
+('27226','45912','0.1','1','0','1','1'),
+('27229','45912','0.1','1','0','1','1'),
+('27230','45912','0.1','1','0','1','1'),
+('27232','45912','0.1','1','0','1','1'),
+('27234','45912','0.1','1','0','1','1'),
+('27237','45912','0.1','1','0','1','1'),
+('27238','45912','0.1','1','0','1','1'),
+('27244','45912','0.1','1','0','1','1'),
+('27246','45912','0.1','1','0','1','1'),
+('27247','45912','0.1','1','0','1','1'),
+('27249','45912','0.1','1','0','1','1'),
+('27254','45912','0.1','1','0','1','1'),
+('27259','45912','0.1','1','0','1','1'),
+('27260','45912','0.1','1','0','1','1'),
+('27270','45912','0.1','1','0','1','1'),
+('27272','45912','0.1','1','0','1','1'),
+('27283','45912','0.1','1','0','1','1'),
+('27284','45912','0.1','1','0','1','1'),
+('27285','45912','0.1','1','0','1','1'),
+('27286','45912','0.1','1','0','1','1'),
+('27287','45912','0.1','1','0','1','1'),
+('27288','45912','0.1','1','0','1','1'),
+('27294','45912','0.1','1','0','1','1'),
+('27329','45912','0.1','1','0','1','1'),
+('27334','45912','0.1','1','0','1','1'),
+('27340','45912','0.1','1','0','1','1'),
+('27342','45912','0.1','1','0','1','1'),
+('27343','45912','0.1','1','0','1','1'),
+('27356','45912','0.1','1','0','1','1'),
+('27358','45912','0.1','1','0','1','1'),
+('27382','45912','0.1','1','0','1','1'),
+('27383','45912','0.1','1','0','1','1'),
+('27401','45912','0.1','1','0','1','1'),
+('27408','45912','0.1','1','0','1','1'),
+('27410','45912','0.1','1','0','1','1'),
+('27414','45912','0.1','1','0','1','1'),
+('27421','45912','0.1','1','0','1','1'),
+('27424','45912','0.1','1','0','1','1'),
+('27431','45912','0.1','1','0','1','1'),
+('27447','45912','0.1','1','0','1','1'),
+('27470','45912','0.1','1','0','1','1'),
+('27500','45912','0.1','1','0','1','1'),
+('27513','45912','0.1','1','0','1','1'),
+('27523','45912','0.1','1','0','1','1'),
+('27533','45912','0.1','1','0','1','1'),
+('27534','45912','0.1','1','0','1','1'),
+('27539','45912','0.1','1','0','1','1'),
+('27551','45912','0.1','1','0','1','1'),
+('27552','45912','0.1','1','0','1','1'),
+('27554','45912','0.1','1','0','1','1'),
+('27555','45912','0.1','1','0','1','1'),
+('27578','45912','0.1','1','0','1','1'),
+('27579','45912','0.1','1','0','1','1'),
+('27580','45912','0.1','1','0','1','1'),
+('27617','45912','0.1','1','0','1','1'),
+('27633','45912','0.1','1','0','1','1'),
+('27635','45912','0.1','1','0','1','1'),
+('27636','45912','0.1','1','0','1','1'),
+('27639','45912','0.1','1','0','1','1'),
+('27640','45912','0.1','1','0','1','1'),
+('27641','45912','0.1','1','0','1','1'),
+('27642','45912','0.1','1','0','1','1'),
+('27644','45912','0.1','1','0','1','1'),
+('27645','45912','0.1','1','0','1','1'),
+('27647','45912','0.1','1','0','1','1'),
+('27648','45912','0.1','1','0','1','1'),
+('27649','45912','0.1','1','0','1','1'),
+('27650','45912','0.1','1','0','1','1'),
+('27651','45912','0.1','1','0','1','1'),
+('27653','45912','0.1','1','0','1','1'),
+('27654','45912','0.1','1','0','1','1'),
+('27655','45912','0.1','1','0','1','1'),
+('27656','45912','0.1','1','0','1','1'),
+('27680','45912','0.1','1','0','1','1'),
+('27699','45912','0.1','1','0','1','1'),
+('27701','45912','0.1','1','0','1','1'),
+('27753','45912','0.1','1','0','1','1'),
+('27799','45912','0.1','1','0','1','1'),
+('27800','45912','0.1','1','0','1','1'),
+('27808','45912','0.1','1','0','1','1'),
+('27823','45912','0.1','1','0','1','1'),
+('27824','45912','0.1','1','0','1','1'),
+('27835','45912','0.1','1','0','1','1'),
+('27859','45912','0.1','1','0','1','1'),
+('27860','45912','0.1','1','0','1','1'),
+('27871','45912','0.1','1','0','1','1'),
+('27927','45912','0.1','1','0','1','1'),
+('27941','45912','0.1','1','0','1','1'),
+('27947','45912','0.1','1','0','1','1'),
+('27949','45912','0.1','1','0','1','1'),
+('27960','45912','0.1','1','0','1','1'),
+('27961','45912','0.1','1','0','1','1'),
+('27962','45912','0.1','1','0','1','1'),
+('27963','45912','0.1','1','0','1','1'),
+('27964','45912','0.1','1','0','1','1'),
+('27965','45912','0.1','1','0','1','1'),
+('27966','45912','0.1','1','0','1','1'),
+('27969','45912','0.1','1','0','1','1'),
+('27970','45912','0.1','1','0','1','1'),
+('27971','45912','0.1','1','0','1','1'),
+('27972','45912','0.1','1','0','1','1'),
+('27975','45912','0.1','1','0','1','1'),
+('27977','45912','0.1','1','0','1','1'),
+('27978','45912','0.1','1','0','1','1'),
+('28001','45912','0.1','1','0','1','1'),
+('28003','45912','0.1','1','0','1','1'),
+('28004','45912','0.1','1','0','1','1'),
+('28006','45912','0.1','1','0','1','1'),
+('28009','45912','0.1','1','0','1','1'),
+('28010','45912','0.1','1','0','1','1'),
+('28011','45912','0.1','1','0','1','1'),
+('28018','45912','0.1','1','0','1','1'),
+('28022','45912','0.1','1','0','1','1'),
+('28023','45912','0.1','1','0','1','1'),
+('28024','45912','0.1','1','0','1','1'),
+('28025','45912','0.1','1','0','1','1'),
+('28026','45912','0.1','1','0','1','1'),
+('28034','45912','0.1','1','0','1','1'),
+('28036','45912','0.1','1','0','1','1'),
+('28068','45912','0.1','1','0','1','1'),
+('28069','45912','0.1','1','0','1','1'),
+('28076','45912','0.1','1','0','1','1'),
+('28077','45912','0.1','1','0','1','1'),
+('28078','45912','0.1','1','0','1','1'),
+('28079','45912','0.1','1','0','1','1'),
+('28080','45912','0.1','1','0','1','1'),
+('28081','45912','0.1','1','0','1','1'),
+('28082','45912','0.1','1','0','1','1'),
+('28083','45912','0.1','1','0','1','1'),
+('28085','45912','0.1','1','0','1','1'),
+('28086','45912','0.1','1','0','1','1'),
+('28087','45912','0.1','1','0','1','1'),
+('28094','45912','0.1','1','0','1','1'),
+('28095','45912','0.1','1','0','1','1'),
+('28096','45912','0.1','1','0','1','1'),
+('28097','45912','0.1','1','0','1','1'),
+('28098','45912','0.1','1','0','1','1'),
+('28101','45912','0.1','1','0','1','1'),
+('28108','45912','0.1','1','0','1','1'),
+('28118','45912','0.1','1','0','1','1'),
+('28129','45912','0.1','1','0','1','1'),
+('28145','45912','0.1','1','0','1','1'),
+('28186','45912','0.1','1','0','1','1'),
+('28203','45912','0.1','1','0','1','1'),
+('28213','45912','0.1','1','0','1','1'),
+('28220','45912','0.1','1','0','1','1'),
+('28221','45912','0.1','1','0','1','1'),
+('28231','45912','0.1','1','0','1','1'),
+('28233','45912','0.1','1','0','1','1'),
+('28243','45912','0.1','1','0','1','1'),
+('28255','45912','0.1','1','0','1','1'),
+('28257','45912','0.1','1','0','1','1'),
+('28258','45912','0.1','1','0','1','1'),
+('28268','45912','0.1','1','0','1','1'),
+('28288','45912','0.1','1','0','1','1'),
+('28303','45912','0.1','1','0','1','1'),
+('28312','45912','0.1','1','0','1','1'),
+('28317','45912','0.1','1','0','1','1'),
+('28323','45912','0.1','1','0','1','1'),
+('28325','45912','0.1','1','0','1','1'),
+('28342','45912','0.1','1','0','1','1'),
+('28345','45912','0.1','1','0','1','1'),
+('28358','45912','0.1','1','0','1','1'),
+('28368','45912','0.1','1','0','1','1'),
+('28373','45912','0.1','1','0','1','1'),
+('28378','45912','0.1','1','0','1','1'),
+('28379','45912','0.1','1','0','1','1'),
+('28380','45912','0.1','1','0','1','1'),
+('28381','45912','0.1','1','0','1','1'),
+('28389','45912','0.1','1','0','1','1'),
+('28399','45912','0.1','1','0','1','1'),
+('28402','45912','0.1','1','0','1','1'),
+('28403','45912','0.1','1','0','1','1'),
+('28410','45912','0.1','1','0','1','1'),
+('28411','45912','0.1','1','0','1','1'),
+('28412','45912','0.1','1','0','1','1'),
+('28414','45912','0.1','1','0','1','1'),
+('28418','45912','0.1','1','0','1','1'),
+('28419','45912','0.1','1','0','1','1'),
+('28443','45912','0.1','1','0','1','1'),
+('28465','45912','0.1','1','0','1','1'),
+('28467','45912','0.1','1','0','1','1'),
+('28477','45912','0.1','1','0','1','1'),
+('28495','45912','0.1','1','0','1','1'),
+('28496','45912','0.1','1','0','1','1'),
+('28538','45912','0.1','1','0','1','1'),
+('28546','45912','0.1','1','0','1','1'),
+('28547','45912','0.1','1','0','1','1'),
+('28564','45912','0.1','1','0','1','1'),
+('28565','45912','0.1','1','0','1','1'),
+('28578','45912','0.1','1','0','1','1'),
+('28579','45912','0.1','1','0','1','1'),
+('28580','45912','0.1','1','0','1','1'),
+('28581','45912','0.1','1','0','1','1'),
+('28582','45912','0.1','1','0','1','1'),
+('28583','45912','0.1','1','0','1','1'),
+('28584','45912','0.1','1','0','1','1'),
+('28586','45912','0.1','1','0','1','1'),
+('28587','45912','0.1','1','0','1','1'),
+('28597','45912','0.1','1','0','1','1'),
+('28600','45912','0.1','1','0','1','1'),
+('28603','45912','0.1','1','0','1','1'),
+('28641','45912','0.1','1','0','1','1'),
+('28659','45912','0.1','1','0','1','1'),
+('28684','45912','0.1','1','0','1','1'),
+('28729','45912','0.1','1','0','1','1'),
+('28730','45912','0.1','1','0','1','1'),
+('28731','45912','0.1','1','0','1','1'),
+('28732','45912','0.1','1','0','1','1'),
+('28733','45912','0.1','1','0','1','1'),
+('28734','45912','0.1','1','0','1','1'),
+('28747','45912','0.1','1','0','1','1'),
+('28748','45912','0.1','1','0','1','1'),
+('28750','45912','0.1','1','0','1','1'),
+('28752','45912','0.1','1','0','1','1'),
+('28759','45912','0.1','1','0','1','1'),
+('28779','45912','0.1','1','0','1','1'),
+('28784','45912','0.1','1','0','1','1'),
+('28793','45912','0.1','1','0','1','1'),
+('28802','45912','0.1','1','0','1','1'),
+('28803','45912','0.1','1','0','1','1'),
+('28826','45912','0.1','1','0','1','1'),
+('28835','45912','0.1','1','0','1','1'),
+('28836','45912','0.1','1','0','1','1'),
+('28837','45912','0.1','1','0','1','1'),
+('28838','45912','0.1','1','0','1','1'),
+('28840','45912','0.1','1','0','1','1'),
+('28843','45912','0.1','1','0','1','1'),
+('28847','45912','0.1','1','0','1','1'),
+('28851','45912','0.1','1','0','1','1'),
+('28858','45912','0.1','1','0','1','1'),
+('28862','45912','0.1','1','0','1','1'),
+('28875','45912','0.1','1','0','1','1'),
+('28877','45912','0.1','1','0','1','1'),
+('28879','45912','0.1','1','0','1','1'),
+('28882','45912','0.1','1','0','1','1'),
+('28902','45912','0.1','1','0','1','1'),
+('28918','45912','0.1','1','0','1','1'),
+('28920','45912','0.1','1','0','1','1'),
+('28921','45912','0.1','1','0','1','1'),
+('28922','45912','0.1','1','0','1','1'),
+('28923','45912','0.1','1','0','1','1'),
+('28931','45912','0.1','1','0','1','1'),
+('28961','45912','0.1','1','0','1','1'),
+('28965','45912','0.1','1','0','1','1'),
+('28988','45912','0.1','1','0','1','1'),
+('29013','45912','0.1','1','0','1','1'),
+('29018','45912','0.1','1','0','1','1'),
+('29026','45912','0.1','1','0','1','1'),
+('29036','45912','0.1','1','0','1','1'),
+('29044','45912','0.1','1','0','1','1'),
+('29117','45912','0.1','1','0','1','1'),
+('29120','45912','0.1','1','0','1','1'),
+('29123','45912','0.1','1','0','1','1'),
+('29124','45912','0.1','1','0','1','1'),
+('29128','45912','0.1','1','0','1','1'),
+('29129','45912','0.1','1','0','1','1'),
+('29133','45912','0.1','1','0','1','1'),
+('29211','45912','0.1','1','0','1','1'),
+('29216','45912','0.1','1','0','1','1'),
+('29217','45912','0.1','1','0','1','1'),
+('29235','45912','0.1','1','0','1','1'),
+('29236','45912','0.1','1','0','1','1'),
+('29237','45912','0.1','1','0','1','1'),
+('29249','45912','0.1','1','0','1','1'),
+('29266','45912','0.1','1','0','1','1'),
+('29268','45912','0.1','1','0','1','1'),
+('29278','45912','0.1','1','0','1','1'),
+('29304','45912','0.1','1','0','1','1'),
+('29305','45912','0.1','1','0','1','1'),
+('29306','45912','0.1','1','0','1','1'),
+('29307','45912','0.1','1','0','1','1'),
+('29308','45912','0.1','1','0','1','1'),
+('29309','45912','0.1','1','0','1','1'),
+('29310','45912','0.1','1','0','1','1'),
+('29311','45912','0.1','1','0','1','1'),
+('29312','45912','0.1','1','0','1','1'),
+('29313','45912','0.1','1','0','1','1'),
+('29314','45912','0.1','1','0','1','1'),
+('29315','45912','0.1','1','0','1','1'),
+('29316','45912','0.1','1','0','1','1'),
+('29319','45912','0.1','1','0','1','1'),
+('29324','45912','0.1','1','0','1','1'),
+('29332','45912','0.1','1','0','1','1'),
+('29335','45912','0.1','1','0','1','1'),
+('29350','45912','0.1','1','0','1','1'),
+('29358','45912','0.1','1','0','1','1'),
+('29373','45912','0.1','1','0','1','1'),
+('29375','45912','0.1','1','0','1','1'),
+('29380','45912','0.1','1','0','1','1'),
+('29382','45912','0.1','1','0','1','1'),
+('29389','45912','0.1','1','0','1','1'),
+('29390','45912','0.1','1','0','1','1'),
+('29392','45912','0.1','1','0','1','1'),
+('29402','45912','0.1','1','0','1','1'),
+('29409','45912','0.1','1','0','1','1'),
+('29411','45912','0.1','1','0','1','1'),
+('29412','45912','0.1','1','0','1','1'),
+('29417','45912','0.1','1','0','1','1'),
+('29426','45912','0.1','1','0','1','1'),
+('29427','45912','0.1','1','0','1','1'),
+('29436','45912','0.1','1','0','1','1'),
+('29448','45912','0.1','1','0','1','1'),
+('29461','45912','0.1','1','0','1','1'),
+('29469','45912','0.1','1','0','1','1'),
+('29479','45912','0.1','1','0','1','1'),
+('29486','45912','0.1','1','0','1','1'),
+('29487','45912','0.1','1','0','1','1'),
+('29489','45912','0.1','1','0','1','1'),
+('29490','45912','0.1','1','0','1','1'),
+('29498','45912','0.1','1','0','1','1'),
+('29503','45912','0.1','1','0','1','1'),
+('29504','45912','0.1','1','0','1','1'),
+('29553','45912','0.1','1','0','1','1'),
+('29559','45912','0.1','1','0','1','1'),
+('29562','45912','0.1','1','0','1','1'),
+('29570','45912','0.1','1','0','1','1'),
+('29573','45912','0.1','1','0','1','1'),
+('29575','45912','0.1','1','0','1','1'),
+('29590','45912','0.1','1','0','1','1'),
+('29592','45912','0.1','1','0','1','1'),
+('29605','45912','0.1','1','0','1','1'),
+('29614','45912','0.1','1','0','1','1'),
+('29615','45912','0.1','1','0','1','1'),
+('29624','45912','0.1','1','0','1','1'),
+('29646','45912','0.1','1','0','1','1'),
+('29654','45912','0.1','1','0','1','1'),
+('29656','45912','0.1','1','0','1','1'),
+('29664','45912','0.1','1','0','1','1'),
+('29693','45912','0.1','1','0','1','1'),
+('29697','45912','0.1','1','0','1','1'),
+('29698','45912','0.1','1','0','1','1'),
+('29699','45912','0.1','1','0','1','1'),
+('29701','45912','0.1','1','0','1','1'),
+('29710','45912','0.1','1','0','1','1'),
+('29718','45912','0.1','1','0','1','1'),
+('29719','45912','0.1','1','0','1','1'),
+('29722','45912','0.1','1','0','1','1'),
+('29724','45912','0.1','1','0','1','1'),
+('29735','45912','0.1','1','0','1','1'),
+('29738','45912','0.1','1','0','1','1'),
+('29753','45912','0.1','1','0','1','1'),
+('29755','45912','0.1','1','0','1','1'),
+('29768','45912','0.1','1','0','1','1'),
+('29774','45912','0.1','1','0','1','1'),
+('29775','45912','0.1','1','0','1','1'),
+('29792','45912','0.1','1','0','1','1'),
+('29793','45912','0.1','1','0','1','1'),
+('29794','45912','0.1','1','0','1','1'),
+('29808','45912','0.1','1','0','1','1'),
+('29809','45912','0.1','1','0','1','1'),
+('29819','45912','0.1','1','0','1','1'),
+('29820','45912','0.1','1','0','1','1'),
+('29822','45912','0.1','1','0','1','1'),
+('29826','45912','0.1','1','0','1','1'),
+('29829','45912','0.1','1','0','1','1'),
+('29830','45912','0.1','1','0','1','1'),
+('29832','45912','0.1','1','0','1','1'),
+('29834','45912','0.1','1','0','1','1'),
+('29836','45912','0.1','1','0','1','1'),
+('29838','45912','0.1','1','0','1','1'),
+('29844','45912','0.1','1','0','1','1'),
+('29854','45912','0.1','1','0','1','1'),
+('29861','45912','0.1','1','0','1','1'),
+('29874','45912','0.1','1','0','1','1'),
+('29875','45912','0.1','1','0','1','1'),
+('29885','45912','0.1','1','0','1','1'),
+('29915','45912','0.1','1','0','1','1'),
+('29920','45912','0.1','1','0','1','1'),
+('29931','45912','0.1','1','0','1','1'),
+('29932','45912','0.1','1','0','1','1'),
+('29940','45912','0.1','1','0','1','1'),
+('29955','45912','0.1','1','0','1','1'),
+('29958','45912','0.1','1','0','1','1'),
+('29974','45912','0.1','1','0','1','1'),
+('29991','45912','0.1','1','0','1','1'),
+('29994','45912','0.1','1','0','1','1'),
+('30003','45912','0.1','1','0','1','1'),
+('30040','45912','0.1','1','0','1','1'),
+('30053','45912','0.1','1','0','1','1'),
+('30061','45912','0.1','1','0','1','1'),
+('30083','45912','0.1','1','0','1','1'),
+('30105','45912','0.1','1','0','1','1'),
+('30111','45912','0.1','1','0','1','1'),
+('30135','45912','0.1','1','0','1','1'),
+('30144','45912','0.1','1','0','1','1'),
+('30146','45912','0.1','1','0','1','1'),
+('30147','45912','0.1','1','0','1','1'),
+('30148','45912','0.1','1','0','1','1'),
+('30154','45912','0.1','1','0','1','1'),
+('30160','45912','0.1','1','0','1','1'),
+('30164','45912','0.1','1','0','1','1'),
+('30167','45912','0.1','1','0','1','1'),
+('30179','45912','0.1','1','0','1','1'),
+('30184','45912','0.1','1','0','1','1'),
+('30202','45912','0.1','1','0','1','1'),
+('30204','45912','0.1','1','0','1','1'),
+('30205','45912','0.1','1','0','1','1'),
+('30206','45912','0.1','1','0','1','1'),
+('30247','45912','0.1','1','0','1','1'),
+('30258','45912','0.1','1','0','1','1'),
+('30260','45912','0.1','1','0','1','1'),
+('30276','45912','0.1','1','0','1','1'),
+('30277','45912','0.1','1','0','1','1'),
+('30278','45912','0.1','1','0','1','1'),
+('30279','45912','0.1','1','0','1','1'),
+('30283','45912','0.1','1','0','1','1'),
+('30284','45912','0.1','1','0','1','1'),
+('30285','45912','0.1','1','0','1','1'),
+('30286','45912','0.1','1','0','1','1'),
+('30287','45912','0.1','1','0','1','1'),
+('30291','45912','0.1','1','0','1','1'),
+('30294','45912','0.1','1','0','1','1'),
+('30319','45912','0.1','1','0','1','1'),
+('30325','45912','0.1','1','0','1','1'),
+('30329','45912','0.1','1','0','1','1'),
+('30333','45912','0.1','1','0','1','1'),
+('30340','45912','0.1','1','0','1','1'),
+('30341','45912','0.1','1','0','1','1'),
+('30353','45912','0.1','1','0','1','1'),
+('30387','45912','0.1','1','0','1','1'),
+('30397','45912','0.1','1','0','1','1'),
+('30398','45912','0.1','1','0','1','1'),
+('30409','45912','0.1','1','0','1','1'),
+('30414','45912','0.1','1','0','1','1'),
+('30422','45912','0.1','1','0','1','1'),
+('30424','45912','0.1','1','0','1','1'),
+('30430','45912','0.1','1','0','1','1'),
+('30432','45912','0.1','1','0','1','1'),
+('30445','45912','0.1','1','0','1','1'),
+('30447','45912','0.1','1','0','1','1'),
+('30448','45912','0.1','1','0','1','1'),
+('30449','45912','0.1','1','0','1','1'),
+('30450','45912','0.1','1','0','1','1'),
+('30451','45912','0.1','1','0','1','1'),
+('30452','45912','0.1','1','0','1','1'),
+('30453','45912','0.1','1','0','1','1'),
+('30455','45912','0.1','1','0','1','1'),
+('30456','45912','0.1','1','0','1','1'),
+('30457','45912','0.1','1','0','1','1'),
+('30459','45912','0.1','1','0','1','1'),
+('30460','45912','0.1','1','0','1','1'),
+('30473','45912','0.1','1','0','1','1'),
+('30478','45912','0.1','1','0','1','1'),
+('30485','45912','0.1','1','0','1','1'),
+('30495','45912','0.1','1','0','1','1'),
+('30496','45912','0.1','1','0','1','1'),
+('30497','45912','0.1','1','0','1','1'),
+('30498','45912','0.1','1','0','1','1'),
+('30508','45912','0.1','1','0','1','1'),
+('30509','45912','0.1','1','0','1','1'),
+('30510','45912','0.1','1','0','1','1'),
+('30516','45912','0.1','1','0','1','1'),
+('30517','45912','0.1','1','0','1','1'),
+('30519','45912','0.1','1','0','1','1'),
+('30524','45912','0.1','1','0','1','1'),
+('30525','45912','0.1','1','0','1','1'),
+('30526','45912','0.1','1','0','1','1'),
+('30529','45912','0.1','1','0','1','1'),
+('30530','45912','0.1','1','0','1','1'),
+('30532','45912','0.1','1','0','1','1'),
+('30540','45912','0.1','1','0','1','1'),
+('30541','45912','0.1','1','0','1','1'),
+('30543','45912','0.1','1','0','1','1'),
+('30633','45912','0.1','1','0','1','1'),
+('30660','45912','0.1','1','0','1','1'),
+('30666','45912','0.1','1','0','1','1'),
+('30667','45912','0.1','1','0','1','1'),
+('30668','45912','0.1','1','0','1','1'),
+('30680','45912','0.1','1','0','1','1'),
+('30681','45912','0.1','1','0','1','1'),
+('30682','45912','0.1','1','0','1','1'),
+('30689','45912','0.1','1','0','1','1'),
+('30695','45912','0.1','1','0','1','1'),
+('30696','45912','0.1','1','0','1','1'),
+('30697','45912','0.1','1','0','1','1'),
+('30698','45912','0.1','1','0','1','1'),
+('30746','45912','0.1','1','0','1','1'),
+('30747','45912','0.1','1','0','1','1'),
+('30748','45912','0.1','1','0','1','1'),
+('30762','45912','0.1','1','0','1','1'),
+('30764','45912','0.1','1','0','1','1'),
+('30765','45912','0.1','1','0','1','1'),
+('30766','45912','0.1','1','0','1','1'),
+('30767','45912','0.1','1','0','1','1'),
+('30774','45912','0.1','1','0','1','1'),
+('30788','45912','0.1','1','0','1','1'),
+('30791','45912','0.1','1','0','1','1'),
+('30806','45912','0.1','1','0','1','1'),
+('30807','45912','0.1','1','0','1','1'),
+('30810','45912','0.1','1','0','1','1'),
+('30816','45912','0.1','1','0','1','1'),
+('30817','45912','0.1','1','0','1','1'),
+('30818','45912','0.1','1','0','1','1'),
+('30820','45912','0.1','1','0','1','1'),
+('30821','45912','0.1','1','0','1','1'),
+('30829','45912','0.1','1','0','1','1'),
+('30830','45912','0.1','1','0','1','1'),
+('30831','45912','0.1','1','0','1','1'),
+('30842','45912','0.1','1','0','1','1'),
+('30845','45912','0.1','1','0','1','1'),
+('30846','45912','0.1','1','0','1','1'),
+('30847','45912','0.1','1','0','1','1'),
+('30848','45912','0.1','1','0','1','1'),
+('30849','45912','0.1','1','0','1','1'),
+('30861','45912','0.1','1','0','1','1'),
+('30862','45912','0.1','1','0','1','1'),
+('30863','45912','0.1','1','0','1','1'),
+('30864','45912','0.1','1','0','1','1'),
+('30872','45912','0.1','1','0','1','1'),
+('30873','45912','0.1','1','0','1','1'),
+('30875','45912','0.1','1','0','1','1'),
+('30876','45912','0.1','1','0','1','1'),
+('30877','45912','0.1','1','0','1','1'),
+('30892','45912','0.1','1','0','1','1'),
+('30893','45912','0.1','1','0','1','1'),
+('30894','45912','0.1','1','0','1','1'),
+('30901','45912','0.1','1','0','1','1'),
+('30902','45912','0.1','1','0','1','1'),
+('30904','45912','0.1','1','0','1','1'),
+('30905','45912','0.1','1','0','1','1'),
+('30906','45912','0.1','1','0','1','1'),
+('30907','45912','0.1','1','0','1','1'),
+('30908','45912','0.1','1','0','1','1'),
+('30909','45912','0.1','1','0','1','1'),
+('30910','45912','0.1','1','0','1','1'),
+('30911','45912','0.1','1','0','1','1'),
+('30912','45912','0.1','1','0','1','1'),
+('30913','45912','0.1','1','0','1','1'),
+('30914','45912','0.1','1','0','1','1'),
+('30915','45912','0.1','1','0','1','1'),
+('30916','45912','0.1','1','0','1','1'),
+('30920','45912','0.1','1','0','1','1'),
+('30925','45912','0.1','1','0','1','1'),
+('30926','45912','0.1','1','0','1','1'),
+('30927','45912','0.1','1','0','1','1'),
+('30928','45912','0.1','1','0','1','1'),
+('30929','45912','0.1','1','0','1','1'),
+('30930','45912','0.1','1','0','1','1'),
+('30931','45912','0.1','1','0','1','1'),
+('30932','45912','0.1','1','0','1','1'),
+('30933','45912','0.1','1','0','1','1'),
+('30935','45912','0.1','1','0','1','1'),
+('30936','45912','0.1','1','0','1','1'),
+('30938','45912','0.1','1','0','1','1'),
+('30939','45912','0.1','1','0','1','1'),
+('30941','45912','0.1','1','0','1','1'),
+('30942','45912','0.1','1','0','1','1'),
+('30949','45912','0.1','1','0','1','1'),
+('30951','45912','0.1','1','0','1','1'),
+('30952','45912','0.1','1','0','1','1'),
+('30953','45912','0.1','1','0','1','1'),
+('30956','45912','0.1','1','0','1','1'),
+('30958','45912','0.1','1','0','1','1'),
+('30960','45912','0.1','1','0','1','1'),
+('30964','45912','0.1','1','0','1','1'),
+('30966','45912','0.1','1','0','1','1'),
+('30967','45912','0.1','1','0','1','1'),
+('30968','45912','0.1','1','0','1','1'),
+('30971','45912','0.1','1','0','1','1'),
+('30972','45912','0.1','1','0','1','1'),
+('30974','45912','0.1','1','0','1','1'),
+('30975','45912','0.1','1','0','1','1'),
+('30976','45912','0.1','1','0','1','1'),
+('30977','45912','0.1','1','0','1','1'),
+('30978','45912','0.1','1','0','1','1'),
+('30979','45912','0.1','1','0','1','1'),
+('30980','45912','0.1','1','0','1','1'),
+('30981','45912','0.1','1','0','1','1'),
+('30982','45912','0.1','1','0','1','1'),
+('30983','45912','0.1','1','0','1','1'),
+('30988','45912','0.1','1','0','1','1'),
+('30998','45912','0.1','1','0','1','1'),
+('31015','45912','0.1','1','0','1','1'),
+('31037','45912','0.1','1','0','1','1'),
+('31039','45912','0.1','1','0','1','1'),
+('31041','45912','0.1','1','0','1','1'),
+('31042','45912','0.1','1','0','1','1'),
+('31043','45912','0.1','1','0','1','1'),
+('31104','45912','0.1','1','0','1','1'),
+('31134','45912','0.1','1','0','1','1'),
+('31137','45912','0.1','1','0','1','1'),
+('31139','45912','0.1','1','0','1','1'),
+('31140','45912','0.1','1','0','1','1'),
+('31142','45912','0.1','1','0','1','1'),
+('31150','45912','0.1','1','0','1','1'),
+('31155','45912','0.1','1','0','1','1'),
+('31159','45912','0.1','1','0','1','1'),
+('31160','45912','0.1','1','0','1','1'),
+('31161','45912','0.1','1','0','1','1'),
+('31163','45912','0.1','1','0','1','1'),
+('31198','45912','0.1','1','0','1','1'),
+('31205','45912','0.1','1','0','1','1'),
+('31220','45912','0.1','1','0','1','1'),
+('31221','45912','0.1','1','0','1','1'),
+('31223','45912','0.1','1','0','1','1'),
+('31224','45912','0.1','1','0','1','1'),
+('31225','45912','0.1','1','0','1','1'),
+('31226','45912','0.1','1','0','1','1'),
+('31228','45912','0.1','1','0','1','1'),
+('31229','45912','0.1','1','0','1','1'),
+('31231','45912','0.1','1','0','1','1'),
+('31233','45912','0.1','1','0','1','1'),
+('31236','45912','0.1','1','0','1','1'),
+('31255','45912','0.1','1','0','1','1'),
+('31260','45912','0.1','1','0','1','1'),
+('31262','45912','0.1','1','0','1','1'),
+('31263','45912','0.1','1','0','1','1'),
+('31265','45912','0.1','1','0','1','1'),
+('31283','45912','0.1','1','0','1','1'),
+('31311','45912','0.1','1','0','1','1'),
+('31322','45912','0.1','1','0','1','1'),
+('31323','45912','0.1','1','0','1','1'),
+('31325','45912','0.1','1','0','1','1'),
+('31326','45912','0.1','1','0','1','1'),
+('31327','45912','0.1','1','0','1','1'),
+('31336','45912','0.1','1','0','1','1'),
+('31337','45912','0.1','1','0','1','1'),
+('31338','45912','0.1','1','0','1','1'),
+('31339','45912','0.1','1','0','1','1'),
+('31340','45912','0.1','1','0','1','1'),
+('31341','45912','0.1','1','0','1','1'),
+('31342','45912','0.1','1','0','1','1'),
+('31343','45912','0.1','1','0','1','1'),
+('31344','45912','0.1','1','0','1','1'),
+('31345','45912','0.1','1','0','1','1'),
+('31346','45912','0.1','1','0','1','1'),
+('31347','45912','0.1','1','0','1','1'),
+('31349','45912','0.1','1','0','1','1'),
+('31350','45912','0.1','1','0','1','1'),
+('31351','45912','0.1','1','0','1','1'),
+('31352','45912','0.1','1','0','1','1'),
+('31354','45912','0.1','1','0','1','1'),
+('31355','45912','0.1','1','0','1','1'),
+('31357','45912','0.1','1','0','1','1'),
+('31359','45912','0.1','1','0','1','1'),
+('31360','45912','0.1','1','0','1','1'),
+('31362','45912','0.1','1','0','1','1'),
+('31363','45912','0.1','1','0','1','1'),
+('31365','45912','0.1','1','0','1','1'),
+('31367','45912','0.1','1','0','1','1'),
+('31368','45912','0.1','1','0','1','1'),
+('31370','45912','0.1','1','0','1','1'),
+('31371','45912','0.1','1','0','1','1'),
+('31372','45912','0.1','1','0','1','1'),
+('31373','45912','0.1','1','0','1','1'),
+('31374','45912','0.1','1','0','1','1'),
+('31375','45912','0.1','1','0','1','1'),
+('31376','45912','0.1','1','0','1','1'),
+('31377','45912','0.1','1','0','1','1'),
+('31378','45912','0.1','1','0','1','1'),
+('31381','45912','0.1','1','0','1','1'),
+('31383','45912','0.1','1','0','1','1'),
+('31384','45912','0.1','1','0','1','1'),
+('31385','45912','0.1','1','0','1','1'),
+('31386','45912','0.1','1','0','1','1'),
+('31387','45912','0.1','1','0','1','1'),
+('31393','45912','0.1','1','0','1','1'),
+('31399','45912','0.1','1','0','1','1'),
+('31401','45912','0.1','1','0','1','1'),
+('31402','45912','0.1','1','0','1','1'),
+('31403','45912','0.1','1','0','1','1'),
+('31404','45912','0.1','1','0','1','1'),
+('31411','45912','0.1','1','0','1','1'),
+('31413','45912','0.1','1','0','1','1'),
+('31442','45912','0.1','1','0','1','1'),
+('31443','45912','0.1','1','0','1','1'),
+('31449','45912','0.1','1','0','1','1'),
+('31450','45912','0.1','1','0','1','1'),
+('31451','45912','0.1','1','0','1','1'),
+('31455','45912','0.1','1','0','1','1'),
+('31456','45912','0.1','1','0','1','1'),
+('31457','45912','0.1','1','0','1','1'),
+('31459','45912','0.1','1','0','1','1'),
+('31460','45912','0.1','1','0','1','1'),
+('31463','45912','0.1','1','0','1','1'),
+('31464','45912','0.1','1','0','1','1'),
+('31465','45912','0.1','1','0','1','1'),
+('31466','45912','0.1','1','0','1','1'),
+('31468','45912','0.1','1','0','1','1'),
+('31469','45912','0.1','1','0','1','1'),
+('31470','45912','0.1','1','0','1','1'),
+('31471','45912','0.1','1','0','1','1'),
+('31472','45912','0.1','1','0','1','1'),
+('31475','45912','0.1','1','0','1','1'),
+('31486','45912','0.1','1','0','1','1'),
+('31490','45912','0.1','1','0','1','1'),
+('31493','45912','0.1','1','0','1','1'),
+('31501','45912','0.1','1','0','1','1'),
+('31502','45912','0.1','1','0','1','1'),
+('31503','45912','0.1','1','0','1','1'),
+('31504','45912','0.1','1','0','1','1'),
+('31506','45912','0.1','1','0','1','1'),
+('31507','45912','0.1','1','0','1','1'),
+('31508','45912','0.1','1','0','1','1'),
+('31509','45912','0.1','1','0','1','1'),
+('31510','45912','0.1','1','0','1','1'),
+('31511','45912','0.1','1','0','1','1'),
+('31512','45912','0.1','1','0','1','1'),
+('31535','45912','0.1','1','0','1','1'),
+('31533','45912','0.1','1','0','1','1'),
+('31536','45912','0.1','1','0','1','1'),
+('31537','45912','0.1','1','0','1','1'),
+('31538','45912','0.1','1','0','1','1'),
+('31554','45912','0.1','1','0','1','1'),
+('31555','45912','0.1','1','0','1','1'),
+('31558','45912','0.1','1','0','1','1'),
+('31559','45912','0.1','1','0','1','1'),
+('31560','45912','0.1','1','0','1','1'),
+('31561','45912','0.1','1','0','1','1'),
+('31591','45912','0.1','1','0','1','1'),
+('31592','45912','0.1','1','0','1','1'),
+('31599','45912','0.1','1','0','1','1'),
+('31604','45912','0.1','1','0','1','1'),
+('31605','45912','0.1','1','0','1','1'),
+('31606','45912','0.1','1','0','1','1'),
+('31607','45912','0.1','1','0','1','1'),
+('31608','45912','0.1','1','0','1','1'),
+('31609','45912','0.1','1','0','1','1'),
+('31610','45912','0.1','1','0','1','1'),
+('31611','45912','0.1','1','0','1','1'),
+('31612','45912','0.1','1','0','1','1'),
+('31615','45912','0.1','1','0','1','1'),
+('31616','45912','0.1','1','0','1','1'),
+('31617','45912','0.1','1','0','1','1'),
+('31656','45912','0.1','1','0','1','1'),
+('31658','45912','0.1','1','0','1','1'),
+('31659','45912','0.1','1','0','1','1'),
+('31660','45912','0.1','1','0','1','1'),
+('31661','45912','0.1','1','0','1','1'),
+('31662','45912','0.1','1','0','1','1'),
+('31663','45912','0.1','1','0','1','1'),
+('31665','45912','0.1','1','0','1','1'),
+('31666','45912','0.1','1','0','1','1'),
+('31667','45912','0.1','1','0','1','1'),
+('31669','45912','0.1','1','0','1','1'),
+('31671','45912','0.1','1','0','1','1'),
+('31674','45912','0.1','1','0','1','1'),
+('31675','45912','0.1','1','0','1','1'),
+('31676','45912','0.1','1','0','1','1'),
+('31678','45912','0.1','1','0','1','1'),
+('31679','45912','0.1','1','0','1','1'),
+('31691','45912','0.1','1','0','1','1'),
+('31702','45912','0.1','1','0','1','1'),
+('31718','45912','0.1','1','0','1','1'),
+('31738','45912','0.1','1','0','1','1'),
+('31747','45912','0.1','1','0','1','1'),
+('31754','45912','0.1','1','0','1','1'),
+('31775','45912','0.1','1','0','1','1'),
+('31780','45912','0.1','1','0','1','1'),
+('31787','45912','0.1','1','0','1','1'),
+('31798','45912','0.1','1','0','1','1'),
+('31812','45912','0.1','1','0','1','1'),
+('31813','45912','0.1','1','0','1','1'),
+('31843','45912','0.1','1','0','1','1'),
+('31847','45912','0.1','1','0','1','1'),
+('31853','45912','0.1','1','0','1','1'),
+('31900','45912','0.1','1','0','1','1'),
+('32149','45912','0.1','1','0','1','1'),
+('32161','45912','0.1','1','0','1','1'),
+('32162','45912','0.1','1','0','1','1'),
+('32175','45912','0.1','1','0','1','1'),
+('32181','45912','0.1','1','0','1','1'),
+('32191','45912','0.1','1','0','1','1'),
+('32192','45912','0.1','1','0','1','1'),
+('32236','45912','0.1','1','0','1','1'),
+('32238','45912','0.1','1','0','1','1'),
+('32255','45912','0.1','1','0','1','1'),
+('32257','45912','0.1','1','0','1','1'),
+('32260','45912','0.1','1','0','1','1'),
+('32267','45912','0.1','1','0','1','1'),
+('32268','45912','0.1','1','0','1','1'),
+('32276','45912','0.1','1','0','1','1'),
+('32278','45912','0.1','1','0','1','1'),
+('32280','45912','0.1','1','0','1','1'),
+('32284','45912','0.1','1','0','1','1'),
+('32289','45912','0.1','1','0','1','1'),
+('32290','45912','0.1','1','0','1','1'),
+('32297','45912','0.1','1','0','1','1'),
+('32300','45912','0.1','1','0','1','1'),
+('32323','45912','0.1','1','0','1','1'),
+('32349','45912','0.1','1','0','1','1'),
+('32353','45912','0.1','1','0','1','1'),
+('32368','45912','0.1','1','0','1','1'),
+('32467','45912','0.1','1','0','1','1'),
+('32482','45912','0.1','1','0','1','1'),
+('32490','45912','0.1','1','0','1','1'),
+('32492','45912','0.1','1','0','1','1'),
+('32502','45912','0.1','1','0','1','1'),
+('32507','45912','0.1','1','0','1','1'),
+('32572','45912','0.1','1','0','1','1'),
+('32664','45912','0.1','1','0','1','1'),
+('32767','45912','0.1','1','0','1','1'),
+('32769','45912','0.1','1','0','1','1'),
+('32770','45912','0.1','1','0','1','1'),
+('32771','45912','0.1','1','0','1','1'),
+('32772','45912','0.1','1','0','1','1'),
+('32857','45912','0.1','1','0','1','1'),
+('32867','45912','0.1','1','0','1','1'),
+('32915','45912','0.1','1','0','1','1'),
+('32927','45912','0.1','1','0','1','1'),
+('32956','45912','0.1','1','0','1','1'),
+('33113','45912','0.1','1','0','1','1'),
+('33118','45912','0.1','1','0','1','1'),
+('33186','45912','0.1','1','0','1','1'),
+('33190','45912','0.1','1','0','1','1'),
+('33271','45912','0.1','1','0','1','1'),
+('33288','45912','0.1','1','0','1','1'),
+('33289','45912','0.1','1','0','1','1'),
+('33293','45912','0.1','1','0','1','1'),
+('33755','45912','0.1','1','0','1','1'),
+('33432','45912','0.1','1','0','1','1'),
+('33449','45912','0.1','1','0','1','1'),
+('33515','45912','0.1','1','0','1','1'),
+('33528','45912','0.1','1','0','1','1'),
+('33537','45912','0.1','1','0','1','1'),
+('33651','45912','0.1','1','0','1','1'),
+('33692','45912','0.1','1','0','1','1'),
+('33693','45912','0.1','1','0','1','1'),
+('33694','45912','0.1','1','0','1','1'),
+('34183','45912','0.1','1','0','1','1'),
+('33700','45912','0.1','1','0','1','1'),
+('33724','45912','0.1','1','0','1','1'),
+('33729','45912','0.1','1','0','1','1'),
+('33733','45912','0.1','1','0','1','1'),
+('33772','45912','0.1','1','0','1','1'),
+('33885','45912','0.1','1','0','1','1'),
+('33955','45912','0.1','1','0','1','1'),
+('34003','45912','0.1','1','0','1','1'),
+('34015','45912','0.1','1','0','1','1'),
+('34016','45912','0.1','1','0','1','1'),
+('34057','45912','0.1','1','0','1','1'),
+('34115','45912','0.1','1','0','1','1'),
+('34140','45912','0.1','1','0','1','1'),
+('34175','45912','0.1','1','0','1','1'),
+('35325','45912','0.1','1','0','1','1'),
+('35309','45912','0.1','1','0','1','1'),
+('35305','45912','0.1','1','0','1','1'),
+('35307','45912','0.1','1','0','1','1'),
+('35451','45912','0.1','1','0','1','1'),
+('35113','45912','0.1','1','0','1','1'),
+('34920','45912','0.1','1','0','1','1'),
+('35143','45912','0.1','1','0','1','1'),
+('35060','45912','0.1','1','0','1','1'),
+('36840','45912','0.1','1','0','1','1'),
+('36886','45912','0.1','1','0','1','1'),
+('36892','45912','0.1','1','0','1','1'),
+('36893','45912','0.1','1','0','1','1'),
+('36998','45912','0.1','1','0','1','1'),
+('37003','45912','0.1','1','0','1','1'),
+('37004','45912','0.1','1','0','1','1'),
+('37011','45912','0.1','1','0','1','1'),
+('37016','45912','0.1','1','0','1','1'),
+('37017','45912','0.1','1','0','1','1'),
+('37021','45912','0.1','1','0','1','1'),
+('37026','45912','0.1','1','0','1','1'),
+('37027','45912','0.1','1','0','1','1'),
+('37029','45912','0.1','1','0','1','1'),
+('37030','45912','0.1','1','0','1','1'),
+('37031','45912','0.1','1','0','1','1'),
+('37032','45912','0.1','1','0','1','1'),
+('37033','45912','0.1','1','0','1','1'),
+('37035','45912','0.1','1','0','1','1'),
+('37144','45912','0.1','1','0','1','1'),
+('37146','45912','0.1','1','0','1','1'),
+('37148','45912','0.1','1','0','1','1'),
+('37149','45912','0.1','1','0','1','1'),
+('37158','45912','0.1','1','0','1','1'),
+('37034','45912','0.1','1','0','1','1'),
+('38032','45912','0.1','1','0','1','1'),
+('35490','45912','0.1','1','0','1','1'),
+('37643','45912','0.1','1','0','1','1'),
+('37644','45912','0.1','1','0','1','1'),
+('37622','45912','0.1','1','0','1','1'),
+('37626','45912','0.1','1','0','1','1'),
+('37641','45912','0.1','1','0','1','1'),
+('37642','45912','0.1','1','0','1','1'),
+('38082','45912','0.1','1','0','1','1'),
+('38086','45912','0.1','1','0','1','1'),
+('38079','45912','0.1','1','0','1','1'),
+('38061','45912','0.1','1','0','1','1'),
+('38081','45912','0.1','1','0','1','1'),
+('38078','45912','0.1','1','0','1','1'),
+('38085','45912','0.1','1','0','1','1'),
+('38083','45912','0.1','1','0','1','1'),
+('38080','45912','0.1','1','0','1','1'),
+('38092','45912','0.1','1','0','1','1'),
+('38091','45912','0.1','1','0','1','1'),
+('38090','45912','0.1','1','0','1','1'),
+('38087','45912','0.1','1','0','1','1'),
+('38088','45912','0.1','1','0','1','1'),
+('38096','45912','0.1','1','0','1','1'),
+('38097','45912','0.1','1','0','1','1'),
+('38093','45912','0.1','1','0','1','1'),
+('38084','45912','0.1','1','0','1','1'),
+('38089','45912','0.1','1','0','1','1'),
+('38444','45912','0.1','1','0','1','1'),
+('38064','45912','0.1','1','0','1','1'),
+('38103','45912','0.1','1','0','1','1'),
+('38095','45912','0.1','1','0','1','1'),
+('34728','45912','0.1','1','0','1','1'),
+('34734','45912','0.1','1','0','1','1');
diff -r b4c056460923 -r da13f4f7a26c sql/Arcanum/world_FULL_400.sql
--- a/sql/Arcanum/world_FULL_400.sql	Thu Apr 05 13:10:49 2012 +0300
+++ b/sql/Arcanum/world_FULL_400.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -683,19 +683,6 @@
 UPDATE creature SET npcflag = 1 WHERE id = 37187 AND `modelid` = 30583; -- Флаг госсипа ТОЛЬКО для ВП Саурфанга, который заспаунен для битвы с Саурфангом Смертоносным
 UPDATE creature_template SET `npcflag` = 0 WHERE entry = 37187; -- При входе в инсту у ВП Саурфанга НЕ должно быть госсипов начали ивента с Саурфангом Смертоносным
 UPDATE `creature` SET `phaseMask`='1' WHERE `guid`='136293';
-
-DELETE FROM `creature_text` WHERE `entry`=37187 AND `groupid` IN (15,16,17,18);
-INSERT INTO `creature_text` (`entry`,`groupid`,`id`,`text`,`type`,`language`,`probability`,`emote`,`duration`,`sound`,`comment`) VALUES
-(37187,15,0, 'The paladin still lives? Is it possible, Highlord? Could he have survived?',0,0,0,6,0,17107, 'High Overlord Saurfang - SAY_SAURFANG_INTRO_1'),
-(37187,16,0, 'Then we must save him! If we rescue Bolvar Fordragon, we may quell the unrest between the Alliance and the Horde.',0,0,0,5,0,17108, 'High Overlord Saurfang - SAY_SAURFANG_INTRO_2'),
-(37187,17,0, 'Our mission is now clear: The Lich King will answer for his crimes and we will save Highlord Bolvar Fordragon!',0,0,0,15,0,17109, 'High Overlord Saurfang - SAY_SAURFANG_INTRO_3'),
-(37187,18,0, 'Kor''kron, prepare Orgrim''s Hammer for its final voyage! Champions, our gunship will find a point to dock on the upper reaches of the citadel. Meet us there!',1,0,0,22,0,17110, 'High Overlord Saurfang - SAY_SAURFANG_INTRO_4');
-
-DELETE FROM `creature_text` WHERE `entry`=37200 AND `groupid` IN (13,14,15);
-INSERT INTO `creature_text` (`entry`,`groupid`,`id`,`text`,`type`,`language`,`probability`,`emote`,`duration`,`sound`,`comment`) VALUES
-(37200,13,0, 'Could it be, Lord Fordring? If Bolvar lives, mayhap there is hope fer peace between the Alliance and the Horde. We must reach the top o'' this cursed place and free the paladin!',0,0,0,6,0,16980, 'Muradin Bronzebeard - SAY_SAURFANG_INTRO_2'),
-(37200,14,0, 'Prepare the Skybreaker fer an aerial assault on the citadel!',1,0,0,5,0,16981, 'Muradin Bronzebeard - SAY_SAURFANG_INTRO_3'),
-(37200,15,0, 'Heroes, ye must fight yer way to a clear extraction point within Icecrown. We''ll try an'' rendezvous on the ramparts!',1,0,0,22,0,16982, 'Muradin Bronzebeard - SAY_SAURFANG_INTRO_4');
 SET @GUID := 136293;
 SET @PATH_ID := @GUID*10;
 DELETE FROM `waypoint_data` WHERE `id`=@PATH_ID;
@@ -1171,6 +1158,10 @@
 (37187,12,0,'%s weeps over the corpse of his son.',2,17106,0,0,15,0,'High Overlord Saurfang - SAY_OUTRO_HORDE_2'),
 (37187,13,0,'You will have a proper ceremony in Nagrand next to the pyres of your mother and ancestors.',0,17101,0,0,0,0,'High Overlord Saurfang - SAY_OUTRO_HORDE_3'),
 (37187,14,0,'Honor, young heroes... no matter how dire the battle... Never forsake it!',0,17102,0,0,0,0,'High Overlord Saurfang - SAY_OUTRO_HORDE_4'),
+(37187,15,0, 'The paladin still lives? Is it possible, Highlord? Could he have survived?',0,0,0,6,0,17107, 'High Overlord Saurfang - SAY_SAURFANG_INTRO_1'),
+(37187,16,0, 'Then we must save him! If we rescue Bolvar Fordragon, we may quell the unrest between the Alliance and the Horde.',0,0,0,5,0,17108, 'High Overlord Saurfang - SAY_SAURFANG_INTRO_2'),
+(37187,17,0, 'Our mission is now clear: The Lich King will answer for his crimes and we will save Highlord Bolvar Fordragon!',0,0,0,15,0,17109, 'High Overlord Saurfang - SAY_SAURFANG_INTRO_3'),
+(37187,18,0, 'Kor''kron, prepare Orgrim''s Hammer for its final voyage! Champions, our gunship will find a point to dock on the upper reaches of the citadel. Meet us there!',1,0,0,22,0,17110, 'High Overlord Saurfang - SAY_SAURFANG_INTRO_4'),
 (37188,0,0,'%s cries.',2,16651,0,0,18,0,'Lady Jaina Proudmoore - SAY_OUTRO_ALLIANCE_17'),
 (37188,1,0,'It was nothing, your majesty. Just... I''m proud of my king.',0,16652,0,0,0,0,'Lady Jaina Proudmoore - SAY_OUTRO_ALLIANCE_19'),
 (37200,0,0,'Let''s get a move on then! Move ou...',1,16974,0,0,0,0,'Muradin Bronzebeard - SAY_INTRO_ALLIANCE_1'),
@@ -1186,6 +1177,9 @@
 (37200,10,0,'I... I can''t do it. Get back on yer ship and we''ll spare yer life.',0,16973,0,0,0,0,'Muradin Bronzebeard - SAY_OUTRO_ALLIANCE_9'),
 (37200,11,0,'A mage portal from Stormwind appears between the two and Varian Wrynn and Jaina Proudmoore emerge.',2,0,0,0,0,0,'Muradin Bronzebeard - SAY_OUTRO_ALLIANCE_10'),
 (37200,12,0,'Right away, yer majesty!',0,16979,0,0,0,0,'Muradin Bronzebeard - SAY_OUTRO_ALLIANCE_21'),
+(37200,13,0, 'Could it be, Lord Fordring? If Bolvar lives, mayhap there is hope fer peace between the Alliance and the Horde. We must reach the top o'' this cursed place and free the paladin!',0,0,0,6,0,16980, 'Muradin Bronzebeard - SAY_SAURFANG_INTRO_2'),
+(37200,14,0, 'Prepare the Skybreaker fer an aerial assault on the citadel!',1,0,0,5,0,16981, 'Muradin Bronzebeard - SAY_SAURFANG_INTRO_3'),
+(37200,15,0, 'Heroes, ye must fight yer way to a clear extraction point within Icecrown. We''ll try an'' rendezvous on the ramparts!',1,0,0,22,0,16982, 'Muradin Bronzebeard - SAY_SAURFANG_INTRO_4'),
 (37813,0,0,'For every Horde soldier that you killed -- for every Alliance dog that fell, the Lich King''s armies grew. Even now the val''kyr work to raise your fallen as Scourge.',1,16701,0,0,0,0,'Deathbringer Saurfang - SAY_INTRO_ALLIANCE_2'),
 (37813,1,0,'Things are about to get much worse. Come, taste the power that the Lich King has bestowed upon me!',1,16702,0,0,0,0,'Deathbringer Saurfang - SAY_INTRO_ALLIANCE_3'),
 (37813,2,0,'Dwarves...',1,16703,0,0,0,0,'Deathbringer Saurfang - SAY_INTRO_ALLIANCE_6'),
@@ -1345,7 +1339,7 @@
 INSERT INTO `creature_equip_template`(`entry`,`itemEntry1`,`itemEntry2`,`itemEntry3`) VALUES ('2475','39659','0','0');
 
 -- Offlike rusification
-DELETE FROM `locales_creature_text` WHERE `entry` IN (36855,36612,36948,36939,37030,37033,37032,37003,37026,36998,37813,37187);
+DELETE FROM `locales_creature_text` WHERE `entry` IN (36855,36612,36948,36939,37030,37033,37032,37003,37026,36998,37813,37187,37181,37183,37187,37200);
 INSERT INTO `locales_creature_text`(`entry`,`textGroup`,`id`,`text_loc1`,`text_loc2`,`text_loc3`,`text_loc4`,`text_loc5`,`text_loc6`,`text_loc7`,`text_loc8`) VALUES
 (36855,0,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Вы здесь потому, что наделены особым знанием: вы понимаете, что на мир пало проклятье слепоты!'),
 (36855,1,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Вам удалось сквозь пелену лжи разглядеть источник истиной силы!'),
@@ -1437,7 +1431,31 @@
 (37187,6,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,'У тебя за спиной лежит тело моего сына. Ничто не помешает мне его забрать.'),
 (37187,10,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Я не забуду вашей доброты… благодарю, Ваше Величество.'),
 (37187,13,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Мы похороним тебя как подобает, в Награнде, рядом с матерью и предками…'),
-(37187,14,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Помните о чести, герои… какой бы жестокой ни была битва… никогда не отрекайтесь от нее.');
+(37187,14,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Помните о чести, герои… какой бы жестокой ни была битва… никогда не отрекайтесь от нее.'),
+
+(37181,0,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Вы находитесь в самом сердце земель плети. Здесь вас не защитит свет. Ничто вас не защитит...'),
+(37181,1,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Ты бы мог стать величайшим из моих рыцарей, Фордринг: Той силой тьмы, которая прокатилась бы по этому миру и перевернула страницу истории.'),
+(37181,2,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Сломить его было очень трудно. И я подверг его душу ужасным мучениям. Он так долго сопротивлялся, но скоро он склонится перед своим королем.'),
+(37181,3,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,'В конце-концов все вы будете служить мне.'),
+(37181,4,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Но тебе уже не суждено им стать. Скоро у меня будет другой рыцарь.'),
+
+(37183,0,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Никогда... Я никогда... Не буду служить тебе...'),
+
+(37187,15,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Паладин еще жив? Верховный лорд, возможно ли это?'),
+(37187,16,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Мы должны спасти его! Если мы спасем Болвара Фордрагона, напряжение между Ордой и Альянсом спадет.'),
+(37187,17,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Теперь наша задача ясна: мы заставим Короля-лича ответить за все злодеяния и спасем паладина.'),
+(37187,18,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Кор\'крон, готовьте \"Молот Оргрима\" к последнему полету! Герои, мы попробуем подлететь к стене цитадели и будем ждать вас там!'),
+
+(37200,13,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Что же это? Если Болвар жив, то, может, есть еще надежда на мир между Альянсом и Ордой? Нам нужно попасть на верхушку этой проклятой башни и освободить паладина!'),
+(37200,14,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Подготовить \"Усмиритель небес\" к воздушной атаке на цитадель!'),
+(37200,15,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Герои, попытайтесь выбраться на бастион! Попробуем встретиться с вами там!'),
+
+(37119,0,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Вот мы и на месте. То, что произойдет здесь, войдет в легенды. Не важно, каким будет исход: для истории мы будем героями, сражавшимися за свободу и покой своего народа.'),
+(37119,1,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Помните, герои: страх – ваш самый опасный противник в этих проклятых залах. Скрепите свои сердца, и ваши души воссияют ярче тысячи солнц. Завидев вас, враг отступит. Враг падет, когда Свет праведности коснется его!'),
+(37119,2,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Наш поход на Цитадель Ледяной Короны начинается!'),
+(37119,3,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,'АРТАС! Я поклялся, что ты умрешь, а Плеть будет разбита! Я закончу то, что начал у Часовни Последней Надежды.'),
+(37119,4,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Сила Света не ведает преград, Саурфанг. Его душа безмерно страдает, и все же пока он жив.'),
+(37119,5,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Да будет так, во имя Света.');
 
 -- Ruby Sanctum
 -- Halion
diff -r b4c056460923 -r da13f4f7a26c sql/base/auth_database.sql
--- a/sql/base/auth_database.sql	Thu Apr 05 13:10:49 2012 +0300
+++ b/sql/base/auth_database.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -1,8 +1,8 @@
--- MySQL dump 10.13  Distrib 5.5.19, for Win64 (x86)
+-- MySQL dump 10.13  Distrib 5.5.22, for Win64 (x86)
 --
 -- Host: localhost    Database: auth
 -- ------------------------------------------------------
--- Server version	5.5.19
+-- Server version	5.5.22
 
 /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
 /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
@@ -23,27 +23,27 @@
 /*!40101 SET @saved_cs_client     = @@character_set_client */;
 /*!40101 SET character_set_client = utf8 */;
 CREATE TABLE `account` (
-  `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT 'Identifier',
+  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT 'Identifier',
   `username` varchar(32) NOT NULL DEFAULT '',
   `sha_pass_hash` varchar(40) NOT NULL DEFAULT '',
-  `sessionkey` longtext,
-  `v` longtext,
-  `s` longtext,
-  `email` text,
+  `sessionkey` varchar(80) NOT NULL DEFAULT '',
+  `v` varchar(64) NOT NULL DEFAULT '',
+  `s` varchar(64) NOT NULL DEFAULT '',
+  `email` varchar(254) NOT NULL DEFAULT '',
   `joindate` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
-  `last_ip` varchar(30) NOT NULL DEFAULT '127.0.0.1',
-  `failed_logins` int(11) unsigned NOT NULL DEFAULT '0',
+  `last_ip` varchar(15) NOT NULL DEFAULT '127.0.0.1',
+  `failed_logins` int(10) unsigned NOT NULL DEFAULT '0',
   `locked` tinyint(3) unsigned NOT NULL DEFAULT '0',
   `last_login` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',
-  `online` tinyint(4) NOT NULL DEFAULT '0',
+  `online` tinyint(3) unsigned NOT NULL DEFAULT '0',
   `expansion` tinyint(3) unsigned NOT NULL DEFAULT '2',
-  `mutetime` bigint(40) NOT NULL DEFAULT '0',
+  `mutetime` bigint(20) NOT NULL DEFAULT '0',
   `locale` tinyint(3) unsigned NOT NULL DEFAULT '0',
-  `os` varchar(4) NOT NULL DEFAULT '',
-  `recruiter` int(11) NOT NULL DEFAULT '0',
+  `os` varchar(3) NOT NULL DEFAULT '',
+  `recruiter` int(10) unsigned NOT NULL DEFAULT '0',
   PRIMARY KEY (`id`),
   UNIQUE KEY `idx_username` (`username`)
-) ENGINE=MyISAM AUTO_INCREMENT=5 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='Account System';
+) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='Account System';
 /*!40101 SET character_set_client = @saved_cs_client */;
 
 --
@@ -63,11 +63,11 @@
 /*!40101 SET @saved_cs_client     = @@character_set_client */;
 /*!40101 SET character_set_client = utf8 */;
 CREATE TABLE `account_access` (
-  `id` int(11) unsigned NOT NULL,
+  `id` int(10) unsigned NOT NULL,
   `gmlevel` tinyint(3) unsigned NOT NULL,
   `RealmID` int(11) NOT NULL DEFAULT '-1',
   PRIMARY KEY (`id`,`RealmID`)
-) ENGINE=MyISAM DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
 /*!40101 SET character_set_client = @saved_cs_client */;
 
 --
@@ -87,14 +87,14 @@
 /*!40101 SET @saved_cs_client     = @@character_set_client */;
 /*!40101 SET character_set_client = utf8 */;
 CREATE TABLE `account_banned` (
-  `id` int(11) NOT NULL DEFAULT '0' COMMENT 'Account id',
-  `bandate` bigint(40) NOT NULL DEFAULT '0',
-  `unbandate` bigint(40) NOT NULL DEFAULT '0',
+  `id` int(10) unsigned NOT NULL DEFAULT '0' COMMENT 'Account id',
+  `bandate` int(10) unsigned NOT NULL DEFAULT '0',
+  `unbandate` int(10) unsigned NOT NULL DEFAULT '0',
   `bannedby` varchar(50) NOT NULL,
   `banreason` varchar(255) NOT NULL,
-  `active` tinyint(4) NOT NULL DEFAULT '1',
+  `active` tinyint(3) unsigned NOT NULL DEFAULT '1',
   PRIMARY KEY (`id`,`bandate`)
-) ENGINE=MyISAM DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='Ban List';
+) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='Ban List';
 /*!40101 SET character_set_client = @saved_cs_client */;
 
 --
@@ -114,13 +114,13 @@
 /*!40101 SET @saved_cs_client     = @@character_set_client */;
 /*!40101 SET character_set_client = utf8 */;
 CREATE TABLE `ip_banned` (
-  `ip` varchar(32) NOT NULL DEFAULT '127.0.0.1',
-  `bandate` bigint(40) NOT NULL,
-  `unbandate` bigint(40) NOT NULL,
+  `ip` varchar(15) NOT NULL DEFAULT '127.0.0.1',
+  `bandate` int(10) unsigned NOT NULL,
+  `unbandate` int(10) unsigned NOT NULL,
   `bannedby` varchar(50) NOT NULL DEFAULT '[Console]',
   `banreason` varchar(255) NOT NULL DEFAULT 'no reason',
   PRIMARY KEY (`ip`,`bandate`)
-) ENGINE=MyISAM DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='Banned IPs';
+) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='Banned IPs';
 /*!40101 SET character_set_client = @saved_cs_client */;
 
 --
@@ -140,11 +140,11 @@
 /*!40101 SET @saved_cs_client     = @@character_set_client */;
 /*!40101 SET character_set_client = utf8 */;
 CREATE TABLE `logs` (
-  `time` int(14) NOT NULL,
-  `realm` int(4) NOT NULL,
-  `type` int(4) NOT NULL,
-  `string` text
-) ENGINE=MyISAM DEFAULT CHARSET=latin1;
+  `time` int(10) unsigned NOT NULL,
+  `realm` int(10) unsigned NOT NULL,
+  `type` tinyint(3) unsigned NOT NULL,
+  `string` text CHARACTER SET latin1
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
 /*!40101 SET character_set_client = @saved_cs_client */;
 
 --
@@ -164,12 +164,12 @@
 /*!40101 SET @saved_cs_client     = @@character_set_client */;
 /*!40101 SET character_set_client = utf8 */;
 CREATE TABLE `realmcharacters` (
-  `realmid` int(11) unsigned NOT NULL DEFAULT '0',
-  `acctid` bigint(20) unsigned NOT NULL,
+  `realmid` int(10) unsigned NOT NULL DEFAULT '0',
+  `acctid` int(10) unsigned NOT NULL,
   `numchars` tinyint(3) unsigned NOT NULL DEFAULT '0',
   PRIMARY KEY (`realmid`,`acctid`),
   KEY `acctid` (`acctid`)
-) ENGINE=MyISAM DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='Realm Character Tracker';
+) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='Realm Character Tracker';
 /*!40101 SET character_set_client = @saved_cs_client */;
 
 --
@@ -189,19 +189,19 @@
 /*!40101 SET @saved_cs_client     = @@character_set_client */;
 /*!40101 SET character_set_client = utf8 */;
 CREATE TABLE `realmlist` (
-  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
+  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
   `name` varchar(32) NOT NULL DEFAULT '',
-  `address` varchar(32) NOT NULL DEFAULT '127.0.0.1',
-  `port` int(11) NOT NULL DEFAULT '8085',
+  `address` varchar(255) NOT NULL DEFAULT '127.0.0.1',
+  `port` smallint(5) unsigned NOT NULL DEFAULT '8085',
   `icon` tinyint(3) unsigned NOT NULL DEFAULT '0',
-  `color` tinyint(3) unsigned NOT NULL DEFAULT '2',
+  `flag` tinyint(3) unsigned NOT NULL DEFAULT '2',
   `timezone` tinyint(3) unsigned NOT NULL DEFAULT '0',
   `allowedSecurityLevel` tinyint(3) unsigned NOT NULL DEFAULT '0',
   `population` float unsigned NOT NULL DEFAULT '0',
-  `gamebuild` int(11) unsigned NOT NULL DEFAULT '12340',
+  `gamebuild` int(10) unsigned NOT NULL DEFAULT '12340',
   PRIMARY KEY (`id`),
   UNIQUE KEY `idx_name` (`name`)
-) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='Realm System';
+) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COMMENT='Realm System';
 /*!40101 SET character_set_client = @saved_cs_client */;
 
 --
@@ -222,14 +222,13 @@
 /*!40101 SET @saved_cs_client     = @@character_set_client */;
 /*!40101 SET character_set_client = utf8 */;
 CREATE TABLE `uptime` (
-  `realmid` int(11) unsigned NOT NULL,
-  `starttime` bigint(20) unsigned NOT NULL DEFAULT '0',
-  `startstring` varchar(64) NOT NULL DEFAULT '',
-  `uptime` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `realmid` int(10) unsigned NOT NULL,
+  `starttime` int(10) unsigned NOT NULL DEFAULT '0',
+  `uptime` int(10) unsigned NOT NULL DEFAULT '0',
   `maxplayers` smallint(5) unsigned NOT NULL DEFAULT '0',
   `revision` varchar(255) NOT NULL DEFAULT 'Trinitycore',
   PRIMARY KEY (`realmid`,`starttime`)
-) ENGINE=MyISAM DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='Uptime system';
+) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='Uptime system';
 /*!40101 SET character_set_client = @saved_cs_client */;
 
 --
@@ -250,4 +249,4 @@
 /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
 /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
 
--- Dump completed on 2012-02-19 13:18:35
+-- Dump completed on 2012-03-28 18:26:06
diff -r b4c056460923 -r da13f4f7a26c sql/base/characters_database.sql
--- a/sql/base/characters_database.sql	Thu Apr 05 13:10:49 2012 +0300
+++ b/sql/base/characters_database.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -1,8 +1,8 @@
--- MySQL dump 10.13  Distrib 5.5.9, for Win64 (x86)
+-- MySQL dump 10.13  Distrib 5.5.21, for Win64 (x86)
 --
 -- Host: localhost    Database: characters
 -- ------------------------------------------------------
--- Server version    5.5.9
+-- Server version	5.5.21
 
 /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
 /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
@@ -1932,6 +1932,8 @@
   `posX` float NOT NULL DEFAULT '0',
   `posY` float NOT NULL DEFAULT '0',
   `posZ` float NOT NULL DEFAULT '0',
+  `latency` int(10) unsigned NOT NULL DEFAULT '0',
+  `createTime` int(10) unsigned NOT NULL DEFAULT '0',
   PRIMARY KEY (`reportId`)
 ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='Player System';
 /*!40101 SET character_set_client = @saved_cs_client */;
@@ -2270,3 +2272,5 @@
 /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
 /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
 /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
+
+-- Dump completed on 2012-03-25 21:14:19
diff -r b4c056460923 -r da13f4f7a26c sql/updates/auth/2012_03_25_00_auth_misc.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/auth/2012_03_25_00_auth_misc.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,8 @@
+ALTER TABLE `account_banned`
+    CHANGE `bandate` `bandate` INT(10) UNSIGNED DEFAULT 0 NOT NULL,
+    CHANGE `unbandate` `unbandate` INT(10) UNSIGNED DEFAULT 0 NOT NULL;
+
+ALTER TABLE `ip_banned`
+    CHANGE `ip` `ip` VARCHAR(15) CHARSET utf8 COLLATE utf8_general_ci DEFAULT '127.0.0.1' NOT NULL,
+    CHANGE `bandate` `bandate` INT(10) UNSIGNED NOT NULL,
+    CHANGE `unbandate` `unbandate` INT(10) UNSIGNED NOT NULL;
diff -r b4c056460923 -r da13f4f7a26c sql/updates/auth/2012_03_26_00_auth_realmlist.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/auth/2012_03_26_00_auth_realmlist.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,2 @@
+ALTER TABLE `realmlist`
+    CHANGE `color` `flag` tinyint(3) unsigned NOT NULL DEFAULT '2';
diff -r b4c056460923 -r da13f4f7a26c sql/updates/auth/2012_03_28_00_auth_account.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/auth/2012_03_28_00_auth_account.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,13 @@
+ALTER TABLE `account`
+ CHANGE `id` `id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'Identifier',
+ CHANGE `sessionkey` `sessionkey` VARCHAR(80) NOT NULL DEFAULT '',
+ CHANGE `v` `v` VARCHAR(64) NOT NULL DEFAULT '',
+ CHANGE `s` `s` VARCHAR(64) NOT NULL DEFAULT '',
+ CHANGE `email` `email` VARCHAR(254) NOT NULL DEFAULT '',
+ CHANGE `last_ip` `last_ip` VARCHAR(15) NOT NULL DEFAULT '127.0.0.1',
+ CHANGE `failed_logins` `failed_logins` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+ CHANGE `online` `online` TINYINT(3) UNSIGNED NOT NULL DEFAULT '0',
+ CHANGE `mutetime` `mutetime` BIGINT(20) NOT NULL DEFAULT '0',
+ CHANGE `os` `os` VARCHAR(3) NOT NULL DEFAULT '',
+ CHANGE `recruiter` `recruiter` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+ ROW_FORMAT=DEFAULT ENGINE=INNODB;
diff -r b4c056460923 -r da13f4f7a26c sql/updates/auth/2012_03_28_01_auth_account_access.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/auth/2012_03_28_01_auth_account_access.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,3 @@
+ALTER TABLE `account_access`
+ CHANGE `id` `id` INT(10) UNSIGNED NOT NULL,
+ ROW_FORMAT=DEFAULT ENGINE=INNODB;
diff -r b4c056460923 -r da13f4f7a26c sql/updates/auth/2012_03_28_02_auth_account_banned.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/auth/2012_03_28_02_auth_account_banned.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,4 @@
+ALTER TABLE `account_banned`
+ CHANGE `id` `id` INT(10) UNSIGNED DEFAULT '0' NOT NULL COMMENT 'Account id',
+ CHANGE `active` `active` TINYINT(3) UNSIGNED DEFAULT '1' NOT NULL,
+ ROW_FORMAT=DEFAULT ENGINE=INNODB;
diff -r b4c056460923 -r da13f4f7a26c sql/updates/auth/2012_03_28_03_auth_ip_banned.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/auth/2012_03_28_03_auth_ip_banned.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,2 @@
+ALTER TABLE `ip_banned`
+ ROW_FORMAT=DEFAULT ENGINE=INNODB;
diff -r b4c056460923 -r da13f4f7a26c sql/updates/auth/2012_03_28_04_auth_logs.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/auth/2012_03_28_04_auth_logs.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,5 @@
+ALTER TABLE `logs`
+ CHANGE `time` `time` INT(10) UNSIGNED NOT NULL,
+ CHANGE `realm` `realm` INT(10) UNSIGNED NOT NULL,
+ CHANGE `type` `type` TINYINT(3) UNSIGNED NOT NULL,
+ ROW_FORMAT=DEFAULT ENGINE=INNODB;
diff -r b4c056460923 -r da13f4f7a26c sql/updates/auth/2012_03_28_05_auth_realmcharacters.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/auth/2012_03_28_05_auth_realmcharacters.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,4 @@
+ALTER TABLE `realmcharacters`
+ CHANGE `realmid` `realmid` INT(10) UNSIGNED DEFAULT 0 NOT NULL,
+ CHANGE `acctid` `acctid` INT(10) UNSIGNED NOT NULL,
+ ROW_FORMAT=DEFAULT ENGINE=INNODB;
diff -r b4c056460923 -r da13f4f7a26c sql/updates/auth/2012_03_28_06_auth_realmlist.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/auth/2012_03_28_06_auth_realmlist.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,6 @@
+ALTER TABLE `realmlist`
+ CHANGE `id` `id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
+ CHANGE `address` `address` VARCHAR(15) DEFAULT '127.0.0.1' NOT NULL,
+ CHANGE `port` `port` SMALLINT(5) UNSIGNED DEFAULT '8085' NOT NULL,
+ CHANGE `gamebuild` `gamebuild` INT(10) UNSIGNED DEFAULT '12340' NOT NULL,
+ ROW_FORMAT=DEFAULT ENGINE=INNODB;
diff -r b4c056460923 -r da13f4f7a26c sql/updates/auth/2012_03_28_07_auth_uptime.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/auth/2012_03_28_07_auth_uptime.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,6 @@
+ALTER TABLE `uptime`
+ DROP COLUMN `startstring`,
+ CHANGE `realmid` `realmid` INT(10) UNSIGNED NOT NULL,
+ CHANGE `starttime` `starttime` INT(10) UNSIGNED DEFAULT 0 NOT NULL,
+ CHANGE `uptime` `uptime` INT(10) UNSIGNED DEFAULT 0 NOT NULL,
+ ROW_FORMAT=DEFAULT ENGINE=INNODB;
diff -r b4c056460923 -r da13f4f7a26c sql/updates/auth/2012_04_01_00_auth_realmlist.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/auth/2012_04_01_00_auth_realmlist.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,1 @@
+ALTER TABLE `realmlist` CHANGE `address` `address` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '127.0.0.1';
diff -r b4c056460923 -r da13f4f7a26c sql/updates/auth/2012_04_04_00_auth_realmlist.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/auth/2012_04_04_00_auth_realmlist.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,1 @@
+ALTER TABLE `realmlist` CHANGE `address` `address` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '127.0.0.1';
diff -r b4c056460923 -r da13f4f7a26c sql/updates/characters/2012_03_01_00_characters_character_queststatus.sql
--- a/sql/updates/characters/2012_03_01_00_characters_character_queststatus.sql	Thu Apr 05 13:10:49 2012 +0300
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1 +0,0 @@
-DELETE FROM `character_queststatus` WHERE `status`=0;
diff -r b4c056460923 -r da13f4f7a26c sql/updates/characters/2012_04_07_00_characters_lag_reports.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/characters/2012_04_07_00_characters_lag_reports.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,2 @@
+ALTER TABLE `lag_reports` ADD `latency` int(10) unsigned NOT NULL DEFAULT '0';
+ALTER TABLE `lag_reports` ADD `createTime` int(10) unsigned NOT NULL DEFAULT '0';
diff -r b4c056460923 -r da13f4f7a26c sql/updates/world/2012_03_19_00_world_smart_scripts.sql
--- a/sql/updates/world/2012_03_19_00_world_smart_scripts.sql	Thu Apr 05 13:10:49 2012 +0300
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,21 +0,0 @@
--- SAI for Unrestrained Dragonhawk
-UPDATE `creature_template` SET `AIName`='SmartAI',`ScriptName`='' WHERE `entry`=25236;
-DELETE FROM `smart_scripts` WHERE (`entryorguid`=25236 AND `source_type`=0);
-INSERT INTO `smart_scripts` (`entryorguid`,`source_type`,`id`,`link`,`event_type`,`event_phase_mask`,`event_chance`,`event_flags`,`event_param1`,`event_param2`,`event_param3`,`event_param4`,`action_type`,`action_param1`,`action_param2`,`action_param3`,`action_param4`,`action_param5`,`action_param6`,`target_type`,`target_param1`,`target_param2`,`target_param3`,`target_x`,`target_y`,`target_z`,`target_o`,`comment`) VALUES
-(25236,0,0,1,62,0,100,0,9143,0,0,0,11,45353,0,0,0,0,0,7,0,0,0,0,0,0,0,'Unrestrained Dragonhawk - On Gossip option select - cast "Quest - Sunwell Daily - Ship Bombing Run Return" on player'),
-(25236,0,1,0,61,0,100,0,0,0,0,0,72,0,0,0,0,0,0,7,0,0,0,0,0,0,0,'Unrestrained Dragonhawk - On Gossip option select - Close Gossip');
--- Unrestrained Dragonhawk Gossip
-UPDATE `creature_template` SET `gossip_menu_id`=9143 WHERE `entry`=25236;
--- Gossip_menu from UDB
-DELETE FROM `gossip_menu` WHERE `entry`=9143;
-INSERT INTO `gossip_menu` (`entry`,`text_id`) VALUES
-(9143,12371);
--- Gossip_menu_option Update from UDB
-DELETE FROM `gossip_menu_option` WHERE `menu_id`=9143;
-INSERT INTO `gossip_menu_option` (`menu_id`,`id`,`option_icon`,`option_text`,`option_id`,`npc_option_npcflag`,`action_menu_id`,`action_poi_id`,`box_coded`,`box_money`,`box_text`) VALUES
-(9143,0,0, '<Ride the dragonhawk to Sun''s Reach.>',1,1,0,0,0,0, '');
--- Gossip option Conditions
-DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=15 AND `SourceGroup`=9143;
-INSERT INTO `conditions` (`SourceTypeOrReferenceId`,`SourceGroup`,`SourceEntry`,`ElseGroup`,`ConditionTypeOrReference`,`ConditionValue1`,`ConditionValue2`,`ConditionValue3`,`ErrorTextId`,`ScriptName`,`Comment`) VALUES
-(15,9143,0,0,9,11542,0,0,0,'','Show gossip option if player has quest 11542 but not complete'),
-(15,9143,0,1,9,11543,0,0,0,'','Show gossip option if player has quest 11543 but not complete');
diff -r b4c056460923 -r da13f4f7a26c sql/updates/world/2012_03_20_00_world_gossip.sql
--- a/sql/updates/world/2012_03_20_00_world_gossip.sql	Thu Apr 05 13:10:49 2012 +0300
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,88 +0,0 @@
--- Creature Gossip_menu_id Update from sniff
-UPDATE `creature_template` SET `gossip_menu_id`=9052 WHERE `entry`=24965; -- Vindicator Xayann 
-UPDATE `creature_template` SET `gossip_menu_id`=9050 WHERE `entry`=24975; -- Mar'nah 
-UPDATE `creature_template` SET `gossip_menu_id`=9126 WHERE `entry`=25032; -- Eldara Dawnrunner 
-UPDATE `creature_template` SET `gossip_menu_id`=9087 WHERE `entry`=25046; -- Smith Hauthaa 
-UPDATE `creature_template` SET `gossip_menu_id`=9064 WHERE `entry`=25057; -- Battlemage Arynna 
-UPDATE `creature_template` SET `gossip_menu_id`=9062, `AIName`='SmartAI', `ScriptName`='' WHERE `entry`=25059; -- Ayren Cloudbreaker 
-UPDATE `creature_template` SET `gossip_menu_id`=9063 WHERE `entry`=25061; -- Harbinger Inuuro 
-UPDATE `creature_template` SET `gossip_menu_id`=9127 WHERE `entry`=25069; -- Magister Ilastar 
-UPDATE `creature_template` SET `gossip_menu_id`=9115 WHERE `entry`=25112; -- Anchorite Ayuri 
-UPDATE `creature_template` SET `gossip_menu_id`=9105 WHERE `entry`=25169; -- Archmage Ne'thul
-UPDATE `creature_template` SET `gossip_menu_id`=9286 WHERE `entry`=25632; -- Vindicator Moorba
-UPDATE `creature_template` SET `gossip_menu_id`=9285 WHERE `entry`=25638; -- Captain Selana
-UPDATE `creature_template` SET `gossip_menu_id`=9198 WHERE `entry`=25950; -- Shaani
-
--- Gossip Menu insert from sniff
-DELETE FROM `gossip_menu` WHERE `entry`=9050 AND `text_id`=12237;
-DELETE FROM `gossip_menu` WHERE `entry`=9052 AND `text_id`=12241;
-DELETE FROM `gossip_menu` WHERE `entry`=9062 AND `text_id`=12252;
-DELETE FROM `gossip_menu` WHERE `entry`=9063 AND `text_id`=12256;
-DELETE FROM `gossip_menu` WHERE `entry`=9064 AND `text_id`=12258;
-DELETE FROM `gossip_menu` WHERE `entry`=9087 AND `text_id`=12286;
-DELETE FROM `gossip_menu` WHERE `entry`=9115 AND `text_id`=12323;
-DELETE FROM `gossip_menu` WHERE `entry`=9126 AND `text_id`=12338;
-DELETE FROM `gossip_menu` WHERE `entry`=9127 AND `text_id`=12340;
-DELETE FROM `gossip_menu` WHERE `entry`=9198 AND `text_id`=12497;
-DELETE FROM `gossip_menu` WHERE `entry`=9285 AND `text_id`=12596;
-DELETE FROM `gossip_menu` WHERE `entry`=9286 AND `text_id`=12597;
-DELETE FROM `gossip_menu` WHERE `entry`=9287 AND `text_id`=12598;
-DELETE FROM `gossip_menu` WHERE `entry`=9288 AND `text_id`=12599;
-DELETE FROM `gossip_menu` WHERE `entry`=9289 AND `text_id`=12600;
-DELETE FROM `gossip_menu` WHERE `entry`=9290 AND `text_id`=12601;
-DELETE FROM `gossip_menu` WHERE `entry`=9293 AND `text_id`=12604;
-INSERT INTO `gossip_menu` (`entry`,`text_id`) VALUES
-(9050,12237),
-(9052,12241),
-(9062,12252),
-(9063,12256),
-(9064,12258),
-(9087,12286),
-(9115,12323),
-(9126,12338),
-(9127,12340),
-(9198,12497),
-(9285,12596),
-(9286,12597),
-(9287,12598),
-(9288,12599),
-(9289,12600),
-(9290,12601),
-(9293,12604);
-
--- Creature Gossip_menu_option insert from sniff
-DELETE FROM `gossip_menu_option` WHERE `menu_id` IN (9050,9087,9126,9198,9285,9287,9288,9289) AND `id`=0;
-DELETE FROM `gossip_menu_option` WHERE `menu_id`=9062 AND `id` IN (0,1);
-DELETE FROM `gossip_menu_option` WHERE `menu_id`=9286 AND `id`=2;
-INSERT INTO `gossip_menu_option` (`menu_id`, `id`, `option_icon`,`option_text`,`option_id`,`npc_option_npcflag`,`action_menu_id`,`action_poi_id`,`box_coded`,`box_money`,`box_text`)VALUES
-(9050,0,1,'Let me browse your goods.',3,128,0,0,0,0,''),
-(9062,0,0,'Speaking of action, I''ve been ordered to undertake an air strike.',1,1,0,0,0,0,''), 
-(9062,1,0,'I need to intercept the Dawnblade reinforcements.',1,1,0,0,0,0,''),
-(9087,0,1,'Let me browse your goods.',3,128,0,0,0,0,''),
-(9126,0,1,'Let me browse your goods.',3,128,0,0,0,0,''),
-(9198,0,1,'Let me browse your goods.',3,128,0,0,0,0,''),
-(9285,0,0,'Give me a situation report, Captain.',1,1,9287,0,0,0,''),
-(9286,2,0,'What is the current state of the Sunwell''s Gates?',1,1,9293,0,0,0,''), 
-(9287,0,0,'What went wrong?',1,1,9288,0,0,0,''),
-(9288,0,0,'Why did they stop?',1,1,9289,0,0,0,''),
-(9289,0,0,'Your insight is appreciated.',1,1,9290,0,0,0,'');
-
--- Conditions
-DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=15 AND `SourceGroup`=9062 AND `SourceEntry` IN (0,1);
-INSERT INTO `conditions` (`SourceTypeOrReferenceId`,`SourceGroup`,`SourceEntry`,`SourceId`,`ElseGroup`,`ConditionTypeOrReference`,`ConditionValue1`,`ConditionValue2`,`ConditionValue3`,`NegativeCondition`,`ErrorTextId`,`ScriptName`,`Comment`) VALUES
-(15,9062,0,0,0,9,11532,0,0,0,0,'','Show gossip option only if player has taken quest 11532'),
-(15,9062,0,0,1,9,11533,0,0,0,0,'','Show gossip option only if player has taken quest 11533'),
-(15,9062,1,0,0,9,11542,0,0,0,0,'','Show gossip option only if player has taken quest 11542'),
-(15,9062,1,0,1,9,11543,0,0,0,0,'','Show gossip option only if player has taken quest 11543');
-
--- SmartAI
-DELETE FROM `smart_scripts` WHERE `entryorguid`=25059 AND `source_type`=0;
-INSERT INTO `smart_scripts` (`entryorguid`,`source_type`,`id`,`link`,`event_type`,`event_phase_mask`,`event_chance`,`event_flags`,`event_param1`,`event_param2`,`event_param3`,`event_param4`,`action_type`,`action_param1`,`action_param2`,`action_param3`,`action_param4`,`action_param5`,`action_param6`,`target_type`,`target_param1`,`target_param2`,`target_param3`,`target_x`,`target_y`,`target_z`,`target_o`,`comment`) VALUES
-(25059,0,0,2,62,0,100,0,9062,0,0,0,11,45071,0,0,0,0,0,7,0,0,0,0,0,0,0,'Ayren Cloudbreaker - On Gossip option select - Cast "Quest - Sunwell Daily - Dead Scar Bombing Run" on player'),
-(25059,0,1,2,62,0,100,0,9062,1,0,0,11,45113,0,0,0,0,0,7,0,0,0,0,0,0,0,'Ayren Cloudbreaker - On Gossip option select - Cast "Quest - Sunwell Daily - Ship Bombing Run" on player'),
-(25059,0,2,0,61,0,100,0,0,0,0,0,72,0,0,0,0,0,0,7,0,0,0,0,0,0,0,'Ayren Cloudbreaker - On Gossip option select - Close Gossip');
-
--- Spell scripts from sniff
-DELETE FROM `spell_scripts` WHERE `id`=45071;
-INSERT INTO `spell_scripts` (`id`,`effIndex`,`delay`,`command`,`datalong`,`datalong2`,`dataint`,`x`,`y`,`z`,`o`) VALUES
-(45071,2,0,16,12318,1,0,0,0,0,0); -- Play sound
diff -r b4c056460923 -r da13f4f7a26c sql/updates/world/2012_04_12_02_world_spell_bonus_data.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/world/2012_04_12_02_world_spell_bonus_data.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,29 @@
+-- Druid
+UPDATE `spell_bonus_data` SET `direct_bonus`=0,`dot_bonus`=0 WHERE `entry` IN (779,1822,60089);
+DELETE FROM `spell_bonus_data` WHERE `entry` IN (1079,9007,22568);
+INSERT INTO `spell_bonus_data` (`entry`,`direct_bonus`,`dot_bonus`,`ap_bonus`,`ap_dot_bonus`,`comments`) VALUES
+(1079,0,0,-1,-1, 'Druid - Rip'),
+(9007,0,0,-1,-1, 'Druid - Pounce Bleed'),
+(22568,0,0,-1,-1, 'Druid - Ferocious Bite');
+
+-- Hunter
+UPDATE `spell_bonus_data` SET `direct_bonus`=0,`dot_bonus`=0 WHERE `entry` IN (3044,3674,53352,13812,13797,1978,42243);
+UPDATE `spell_bonus_data` SET `ap_dot_bonus`=0.1 WHERE `entry`=13812;
+DELETE FROM `spell_bonus_data` WHERE `entry` IN (24131,53353);
+INSERT INTO `spell_bonus_data` (`entry`,`direct_bonus`,`dot_bonus`,`ap_bonus`,`ap_dot_bonus`,`comments`) VALUES
+(24131,0,0,-1,-1, 'Hunter - Wyvern Sting (triggered)'),
+(53353,0,0,-1,-1, 'Hunter - Chimera Shot (Serpent)');
+DELETE FROM `spell_ranks` WHERE `first_spell_id`=24131;
+INSERT INTO `spell_ranks` VALUES
+(24131,24131,1),
+(24131,24134,2),
+(24131,24135,3),
+(24131,27069,4),
+(24131,49009,5),
+(24131,49010,6);
+
+-- Rogue
+UPDATE `spell_bonus_data` SET `direct_bonus`=0,`dot_bonus`=0 WHERE `entry` IN (2818,2819,11353,11354,25349,26968,27187,57969,57970);
+
+-- Howling blast
+UPDATE `spell_bonus_data` SET `ap_bonus`=0.2 WHERE `entry`=49184;
diff -r b4c056460923 -r da13f4f7a26c sql/updates/world/2012_04_12_03_world_spell_bonus_data.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/world/2012_04_12_03_world_spell_bonus_data.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,8 @@
+-- Fixes some spell power stacking exploits
+DELETE FROM `spell_bonus_data` WHERE `entry` IN (44525,18798,16614,7712,13897);
+INSERT INTO `spell_bonus_data` (`entry`,`direct_bonus`,`dot_bonus`,`ap_bonus`,`ap_dot_bonus`,`comments`) VALUES
+(44525,0,0,-1,-1, 'Enchant Weapon - Icebreaker'),
+(18798,0,0,-1,-1, 'Item - Freezing Band'),
+(16614,0,0,-1,-1, 'Item - Storm Gauntlets'),
+(7712,0,0,-1,-1, 'Item - Fiery Retributer | Blazefury Medallion'),
+(13897,0,0,-1,-1, 'Enchant Weapon - Fiery Weapon');
diff -r b4c056460923 -r da13f4f7a26c sql/updates/world/2012_04_12_04_world_creature_template.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/world/2012_04_12_04_world_creature_template.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,2 @@
+-- Update modelid for Invincible (with not bugged animation)
+UPDATE `creature_template` SET `modelid1`=31007,`modelid2`=0,`WDBVerified`=-12340 WHERE `entry`=38545;
diff -r b4c056460923 -r da13f4f7a26c sql/updates/world/2012_04_12_05_world_command.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/world/2012_04_12_05_world_command.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,2 @@
+DELETE FROM `trinity_string` WHERE `entry` IN(555,556);
+DELETE FROM `command` WHERE `name`='hover';
diff -r b4c056460923 -r da13f4f7a26c sql/updates/world/2012_04_13_00_world_sai.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/world/2012_04_13_00_world_sai.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,25 @@
+UPDATE `smart_scripts` SET `target_type`=`action_param6` WHERE
+(`entryorguid`=369200 AND `source_type`=9 AND `id`=3) OR
+(`entryorguid`=369201 AND `source_type`=9 AND `id`=3) OR
+(`entryorguid`=3692 AND `source_type`=0 AND `id`=2) OR
+(`entryorguid`=3692 AND `source_type`=0 AND `id`=3) OR
+(`entryorguid`=3584 AND `source_type`=0 AND `id`=3) OR
+(`entryorguid`=3584 AND `source_type`=0 AND `id`=4) OR
+(`entryorguid`=954600 AND `source_type`=9 AND `id`=2) OR
+(`entryorguid`=954600 AND `source_type`=9 AND `id`=3) OR
+(`entryorguid`=7207 AND `source_type`=0 AND `id`=1) OR
+(`entryorguid`=7207 AND `source_type`=0 AND `id`=2) OR
+(`entryorguid`=911700 AND `source_type`=9 AND `id`=3);
+
+UPDATE `smart_scripts` SET `action_param6`=0 WHERE
+(`entryorguid`=369200 AND `source_type`=9 AND `id`=3) OR
+(`entryorguid`=369201 AND `source_type`=9 AND `id`=3) OR
+(`entryorguid`=3692 AND `source_type`=0 AND `id`=2) OR
+(`entryorguid`=3692 AND `source_type`=0 AND `id`=3) OR
+(`entryorguid`=3584 AND `source_type`=0 AND `id`=3) OR
+(`entryorguid`=3584 AND `source_type`=0 AND `id`=4) OR
+(`entryorguid`=954600 AND `source_type`=9 AND `id`=2) OR
+(`entryorguid`=954600 AND `source_type`=9 AND `id`=3) OR
+(`entryorguid`=7207 AND `source_type`=0 AND `id`=1) OR
+(`entryorguid`=7207 AND `source_type`=0 AND `id`=2) OR
+(`entryorguid`=911700 AND `source_type`=9 AND `id`=3);
diff -r b4c056460923 -r da13f4f7a26c sql/updates/world/2012_04_13_01_world_misc.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/world/2012_04_13_01_world_misc.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,219 @@
+-- Gnomish Playback Device (item 52709) Targeting condition -- by norfik closes #2169
+DELETE FROM `conditions` WHERE `SourceEntry`=74222 AND `ConditionValue2` IN (1268, 7955, 6119);
+INSERT INTO `conditions` (`SourceTypeOrReferenceId`, `SourceGroup`, `SourceEntry`, `ElseGroup`, `ConditionTypeOrReference`, `ConditionValue1`, `ConditionValue2`, `ConditionValue3`, `ErrorTextId`, `ScriptName`, `Comment`) VALUES
+(17, 0, 74222, 1, 31, 3, 1268, 0, 63, '', 'Gnomish Playback Device on Ozzie Togglevolt'),
+(17, 0, 74222, 2, 31, 3, 7955, 0, 63, '', 'Gnomish Playback Device on Milli Featherwhistle'),
+(17, 0, 74222, 3, 31, 3, 6119, 0, 63, '', 'Gnomish Playback Device on Tog Rustsprocket');
+
+-- fix revenge ap coeff -- by ric101 closes #3344
+UPDATE `spell_bonus_data` SET `ap_bonus` = 0.310 WHERE `entry` = 6572; 
+
+-- fix life seed sp coeff -- by warpten closes #4162
+DELETE FROM `spell_bonus_data` WHERE `entry`=48503;
+INSERT INTO `spell_bonus_data` (`entry`, `direct_bonus`, `dot_bonus`, `ap_bonus`, `ap_dot_bonus`, `comments`) VALUES
+(48503,0,0,0,0, 'Druid - Living Seed Heal');
+
+-- fix glyph of shadowflame proc only allow on damage. by kandera closes #3530
+UPDATE `spell_proc_event` SET `procEx` = procEx|262144 WHERE`entry` = 63310; -- Glyph of shadowflame fix
+
+-- Disable deprecated quests /in 2.4/ from Midsummer Festival - The Festival of Fire {A/H} by trista closes #5982
+DELETE FROM `disables` WHERE `sourceType` = 1 AND `entry` in (9367,9368);
+INSERT INTO `disables` (`sourceType`,`entry`,`flags`,`params_0`,`params_1`,`comment`) VALUES
+(1,9367,0,0,0,'Disable quest The Festival of Fire {A}/Deprecated after 2.4 Midsummer Festival revamp/'),
+(1,9368,0,0,0,'Disable quest The Festival of Fire {H}/Deprecated after 2.4 Midsummer Festival revamp/');
+
+-- fix gameobject spawn for just maces sign -- by mrsmite closes #5849
+DELETE FROM `gameobject` WHERE `guid` = 10714;
+UPDATE `gameobject` SET `guid` = 10714 WHERE `guid` = 61895 AND `id` = 2157;
+
+-- update npc texts. by helias closes #6098
+DELETE FROM `npc_text` WHERE `ID` IN (10719,10782,10783,10787,10788,2838,9072,9110,10310,13293,13641,14089,15077,15155,15240,15412,15866,15873,15877,8663,8244,8254,8255,8282,8291,8296,8298,11093,3464,4776,4713,12130,13002,9984,12977,12978,10918,10999,10986,10991);
+INSERT INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`) VALUES 
+(10719, '<The chime of A"dal"s voice echoes reassuringly through your mind.>$B$BWorry not, child.  Look in your pack and you will find it once more.', NULL, 0, 1, 0, 0, 0, 0, 0, 0),
+(10782, 'Sayoc, da ugly orc here, teach you daggers. You want teaching in other places, you talk to Ileda in da Farstrider Square of Silvermoon or Archibald in the War Quarter of Undercity, hokay?', 'Sayoc, da ugly orc here, teach you daggers. You want teaching in other places, you talk to Ileda in da Farstrider Square of Silvermoon or Archibald in the War Quarter of Undercity, hokay?', 1, 1, 0, 0, 0, 0, 0, 0),
+(10783, 'You want to punch things, yah? Talk to Sayoc right here. He teach you.', 'You want to punch things, yah? Talk to Sayoc right here. He teach you.', 1, 1, 0, 0, 0, 0, 0, 0),
+(10787, 'Ileda of da blood elves, in Farstrider Square of Silvermoon, train her students in both one and two-handed swords. Archibald, da Undercity"s weapon master, also train you, mon. He in da War Quarter.', 'Ileda of da blood elves, in Farstrider Square of Silvermoon, train her students in both one and two-handed swords. Archibald, da Undercity"s weapon master, also train you, mon. He in da War Quarter.', 1, 1, 0, 0, 0, 0, 0, 0),
+(10788, 'Hanashi here knows staves. If you want a sturdier instructor, go to Thunder Bluff. Ansekhwa will teach you on the lower central rise there.', '', 1, 1, 0, 0, 0, 0, 0, 0),
+(2838, '', 'Sure thing, $N. Here"s another for you.', 0, 1, 0, 0, 0, 0, 0, 0),
+(9072, 'A search of the corpse"s clothing and equipment reveals the insignia you need, undamaged by the battle and foul environment.', '', 0, 1, 0, 0, 0, 0, 0, 0),
+(9110, 'Say, you happen to see that arch in the lake to the west?  I wonder where that goes?  I should go divin" over there.', '', 0, 1, 0, 1, 0, 0, 0, 0),
+(10310, 'You must be exalted with the blood elves before I will teach you a riding skill, $c.', '', 1, 1, 0, 1, 0, 0, 0, 0),
+(13293, 'Please hurry, $N. I am in a great deal of pain and time is running out.', '', 0, 1, 0, 0, 0, 0, 0, 0),
+(13641, '<Brann looks at you expectantly.>', '', 0, 1, 0, 0, 0, 0, 0, 0),
+(14089, 'I"ve got a lead on Norgannon"s keystone, which guards access to Ulduar"s archives, but the Titans divided it into two pieces and secreted them away.$B$BOne of the pieces, the keystone"s shell, is held within the Inventor"s Library on the northern coast, south of Ulduar itself. The first thing you"ll need to do is retrieve the fragments of an access disk from the library"s guardians.', '', 0, 1, 0, 0, 0, 0, 0, 0),
+(15077, 'There you are! I was beginning to think that the Sunreavers had intercepted you. Are you ready to deliver the tome to our representatives in Icecrown?', '', 0, 1, 0, 0, 0, 0, 0, 0),
+(15155, 'These appear to be the remains of Thalorien Dawnseeker, the last wielder of Quel"Delar.', '', 0, 1, 0, 0, 0, 0, 0, 0),
+(15240, 'I will escort you into the Sunwell when you"re ready.', 'I will escort you into the Sunwell when you"re ready.', 0, 1, 0, 0, 0, 0, 0, 0),
+(15412, 'We got the final barrier blockin" entry to Frostwing Halls down, $g lad:lass;. Only Sindragosa stands between the Lich King and divine retribution! What are ye waitin" for?!', '', 0, 1, 0, 5, 0, 0, 0, 0),
+(15866, 'De Darkspears have a home again! An" we couldn"t have done it wit"out ya helpin", $N. Now, we celebrate!', '', 0, 1, 0, 1, 0, 1, 0, 0),
+(15873, 'Vol"jin told me ta keep hittin" da drum till he gets back.  If ya be waitin" for him, he"d be back soon to take back da Isles.$B$BJust wait here and enjoy da music!', '', 0, 1, 0, 0, 0, 0, 0, 0),
+(15877, 'We require da help of allies on da islands.$B$BZen"tabra has been watching over da animals of de Islands for some time now.  We"d need her help and da help of da animal creatures.$B$BBwonsamdi is a powerful loa dat controls de spirits of de dead on da islands.  His blessing is crucial for our attack.$B$BOnce our allies have joined us, Zalazane and his army of mind-controlled trolls will have no chance!  Then, da Echo Isles will be de Darkspears!', '', 0, 1, 0, 0, 0, 0, 0, 0),
+(8663, 'Thank you for delivering that list!  My leg is almost recovered enough that I"ll be able to walk back to the crash site.', '', 0, 1, 0, 0, 0, 0, 0, 0),
+(8244, 'We"ve been so wrapped up in this war, some of us forgot to make time for love.', '', 0, 1, 0, 0, 0, 0, 0, 0),
+(8254, 'You work with machines for so long, sometimes you forget about real hearts.', '', 0, 1, 0, 0, 0, 0, 0, 0),
+(8255, '', 'When you have lived as long as I, it becomes easy to forget about love for years. It is always good to be reminded.', 0, 1, 0, 0, 0, 0, 0, 0),
+(8282, '', 'You look like you"ve had your heart broken. Come back when you"re not so sad.', 0, 1, 0, 25, 0, 153, 0, 0),
+(8291, 'What, you don"t have a token to give me? Don"t you love me?', '', 0, 1, 0, 18, 0, 0, 0, 0),
+(8296, 'It looks like you"ve already found love. You can give me a love token, but I"m not giving you anything nice. I"m waiting for someone special.', 'It looks like you"ve already found love. You can give me a love token, but I"m not giving you anything nice. I"m waiting for someone special.', 0, 1, 0, 1, 0, 0, 0, 0),
+(8298, 'I"d like you better if you would apply some perfume.', 'I"d like you better if you would apply some perfume.', 0, 1, 0, 24, 0, 0, 0, 0),
+(11093, 'Let"s get out of here!', '', 0, 1, 0, 5, 0, 0, 0, 0),
+(3464, '', 'You do fine work, but it"s a bit rough around the edges. Don"t worry about it, it will come with practice. Speaking of which, how about we see what you"ve been working on?', 7, 1, 0, 0, 0, 0, 0, 0),
+(4776, 'The battle is over, and the people of Darrowshire are saved.', '', 0, 1, 0, 0, 0, 0, 0, 0),
+(4713, 'The Nightmare is finally over!  Darrowshire, forgive me!', '', 0, 1, 0, 15, 0, 0, 0, 0),
+(12130, '<Old Icefin eyes you warily, his fishy eye blinking as he bobs his head up and down once in a curt dismissal.>', '', 0, 1, 0, 0, 0, 0, 0, 0),
+(13002, 'There ya go, mon. Try ta be more careful with this one, won"t ya?$b$bNow head down ta Drak"Zin Ruins and drink it near the pedestal!', NULL, 0, 1, 0, 0, 0, 0, 0, 0),
+(9984, 'What are ye doin" here?! Get yer chatty self ta Alterac Vallery, where ye"re needed!', '', 7, 1, 1, 5, 0, 0, 0, 0),
+(12977, 'Blight, Blight, Blight... that"s all I hear about around here. I miss the diversity!$b$bHere, here. You have pets, yes? Of course you do. Of course. Little pets. I have a mixture for them. It will make them ca-- ah, clever and strong creatures, yes. Yes. ', '', 1, 1, 396, 5, 0, 0, 0, 0),
+(12978, 'Careful with it. It"s unstable and loses its potency quickly. Use it soon! And... preferably within eyesight, yes...', '', 1, 1, 5, 0, 0, 0, 0, 0),
+(10918, 'The boy"s too stupid still to say it -- not enough crystal exposure yet -- but, he"s thankful for what you did in getting him those flasks.$B$BNow, only nine more sons to go.  Gah!$B$B<Both of Torkus"s heads sigh.>$B$BWant to take one of them off of our hands?  We"ll sell him to you cheap.', '', 0, 1, 0, 1, 0, 5, 0, 6),
+(10999, 'Friend! It"s been too long.  What can we get for you?', '', 0, 1, 1, 1, 0, 0, 0, 0),
+(10986, 'Our drinks should quench even the mightiest of thirsts.', '', 0, 1, 1, 396, 0, 0, 0, 0),
+(10991, 'What can I say, $N?  Yer the finest o" the Sha"tari Skyguard!$B$BJust don"t be lettin" that go ta yer head.  I can still teach ya a thing or two, $G lad : lass;!$B$B<Sky Commander Keller grins at you and winks.>', '', 0, 0, 0, 0, 0, 0, 0, 0);
+
+-- Fix Kor'kron War Rider flying by trista closes #5569
+UPDATE `creature_template` SET `inhabittype`=5,`speed_walk`=1, `speed_run`=1 WHERE `entry`=26813;
+
+-- Gretta the Arbiter (Storm Peaks, Brunhilldar) by mweinelt closes #5493
+-- Daily Quest Pooling
+-- Source: http://www.wowwiki.com/Gretta_the_Arbiter
+SET @pool_id := 354;
+
+DELETE FROM `pool_template` WHERE `entry` = @pool_id;
+INSERT INTO `pool_template` (`entry`, `max_limit`, `description`) VALUES
+(@pool_id, 1, 'Gretta the Arbiter - Daily Quests');
+
+DELETE FROM `pool_quest` WHERE `entry` IN (13424, 13423, 13422, 13425);
+INSERT INTO `pool_quest` (`entry`, `pool_entry`, `description`) VALUES
+(13424, @pool_id, 'Back to the Pit'),
+(13423, @pool_id, 'Defending Your Title'),
+(13422, @pool_id, 'Maintaining Discipline'),
+(13425, @pool_id, 'The Aberrations Must Die');
+
+-- Pathing for Arzeth the Merciless Entry: 19354 by kiperr closes #5510
+SET @NPC := 69051;
+SET @PATH := @NPC * 10;
+UPDATE `creature` SET `spawndist`=0,`MovementType`=2,`position_x`=-617.6182,`position_y`=4800.323,`position_z`=38.53064 WHERE `guid`=@NPC;
+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,1,0, '');
+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
+(@PATH,1,-546.5514,4799.893,33.83914,0,0,0,100,0),
+(@PATH,2,-512.5808,4799.929,32.09928,0,0,0,100,0),
+(@PATH,3,-480.9247,4799.97,28.25657,0,0,0,100,0),
+(@PATH,4,-512.6269,4799.873,32.09928,0,0,0,100,0),
+(@PATH,5,-542.1885,4799.724,33.71414,0,0,0,100,0),
+(@PATH,6,-570.3811,4800.449,34.60215,0,0,0,100,0),
+(@PATH,7,-592.3809,4800.299,35.85215,0,0,0,100,0),
+(@PATH,8,-617.6182,4800.323,38.53064,0,0,0,100,0),
+(@PATH,9,-659.4124,4799.819,49.09505,0,0,0,100,0),
+(@PATH,10,-582.4199,4800.242,34.97715,0,0,0,100,0),
+(@PATH,11,-546.5514,4799.893,33.83914,0,0,0,100,0),
+(@PATH,12,-542.1885,4799.724,33.71414,0,0,0,100,0),
+(@PATH,13,-570.3811,4800.449,34.60215,0,0,0,100,0),
+(@PATH,14,-592.3809,4800.299,35.85215,0,0,0,100,0),
+(@PATH,15,-617.6182,4800.323,38.53064,0,0,0,100,0),
+(@PATH,16,-659.4124,4799.819,49.09505,0,0,0,100,0),
+(@PATH,17,-512.5808,4799.929,32.09928,0,0,0,100,0),
+(@PATH,18,-480.9247,4799.97,28.25657,0,0,0,100,0),
+(@PATH,19,-512.6269,4799.873,32.09928,0,0,0,100,0),
+(@PATH,20,-542.1885,4799.724,33.71414,0,0,0,100,0),
+(@PATH,21,-570.3811,4800.449,34.60215,0,0,0,100,0),
+(@PATH,22,-592.3809,4800.299,35.85215,0,0,0,100,0),
+(@PATH,23,-617.6182,4800.323,38.53064,0,0,0,100,0),
+(@PATH,24,-659.4124,4799.819,49.09505,0,0,0,100,0),
+(@PATH,25,-582.4199,4800.242,34.97715,0,0,0,100,0),
+(@PATH,26,-512.6269,4799.873,32.09928,0,0,0,100,0),
+(@PATH,27,-542.1885,4799.724,33.71414,0,0,0,100,0),
+(@PATH,28,-570.3811,4800.449,34.60215,0,0,0,100,0),
+(@PATH,29,-592.3809,4800.299,35.85215,0,0,0,100,0),
+(@PATH,30,-617.6182,4800.323,38.53064,0,0,0,100,0);
+
+-- Dark Portal - corrects the entry position and orientation by cdawg closes #5470
+UPDATE `areatrigger_teleport` SET `target_position_x`=-248.149292, `target_position_y`=921.874953, `target_position_z`=84.388448, `target_orientation`=1.584155 WHERE `id`=4354;
+
+-- Add pamphlets to mail loot by gecko32 closes #5408
+DELETE FROM `mail_loot_template` WHERE `entry` BETWEEN 224 AND 233;
+INSERT INTO `mail_loot_template` (`entry`, `item`, `ChanceOrQuestChance`, `lootmode`, `groupid`, `mincountOrRef`, `maxcount`) VALUES 
+(224, 46875, 100, 1, 0, 1, 1), -- Riding Training Pamphlet Elwynn Forest
+(225, 46876, 100, 1, 0, 1, 1), -- Riding Training Pamphlet Darnassus
+(226, 46877, 100, 1, 0, 1, 1), -- Riding Training Pamphlet Dun Morogh drawf
+(227, 46879, 100, 1, 0, 1, 1), -- Riding Training Pamphlet Azuremyst Isle
+(228, 46878, 100, 1, 0, 1, 1), -- Riding Training Pamphlet Dun Morogh gnome
+(229, 46884, 100, 1, 0, 1, 1), -- Riding Training Pamphlet Mulgore
+(230, 46883, 100, 1, 0, 1, 1), -- Riding Training Pamphlet Durator
+(231, 46880, 100, 1, 0, 1, 1), -- Riding Training Pamphlet Orgrimmar
+(232, 46882, 100, 1, 0, 1, 1), -- Riding Training Pamphlet Eversong Woods
+(233, 46881, 100, 1, 0, 1, 1); -- Riding Training Pamphlet Tirisfal Glades
+
+-- fix coordinates for cannoneer whessan by mosoo closes #5406
+UPDATE `creature` SET `position_x`=-2093.53, `position_y`=-3496.47, `position_z`=130.084, `orientation`=3.008 WHERE `id`=3455 LIMIT 1;
+
+-- fix quest requirement for the last of her kind by shlomi 1515 closes #4875
+UPDATE `quest_template` SET `PrevQuestID` = 12900 WHERE `id` = 12983;
+
+-- Add rep reward to ICC25 Trash by gecko32 closes #5457
+DELETE FROM `creature_onkill_reputation` WHERE `creature_id` IN (37655,38031,38057,38058,38059,38061,38062,38063,38064,38072,38073,38074,38075,38076,38098,38099,38100,38101,38102,38103,38105,38108,38110,38126,38130,38131,38132,38133,38139,38151,38219,38220,38418,38445,38446,38479,38480,38481);
+INSERT INTO `creature_onkill_reputation` (`creature_id`, `RewOnKillRepFaction1`, `RewOnKillRepFaction2`, `MaxStanding1`, `IsTeamAward1`, `RewOnKillRepValue1`, `MaxStanding2`, `IsTeamAward2`, `RewOnKillRepValue2`, `TeamDependent`) VALUES
+(37655, 1156, 0, 7, 0, 45, 0, 0, 0, 0), -- Decaying colossus
+(38031, 1156, 0, 7, 0, 45, 0, 0, 0, 0), -- Deathbound Ward
+(38057, 1156, 0, 7, 0, 15, 0, 0, 0, 0), -- Servant of the throne
+(38058, 1156, 0, 7, 0, 15, 0, 0, 0, 0), -- Nerub'ar Broodkeeper
+(38059, 1156, 0, 7, 0, 15, 0, 0, 0, 0), -- Ancient Skeletal Soldier
+(38061, 1156, 0, 7, 0, 15, 0, 0, 0, 0), -- The Damned
+(38062, 1156, 0, 7, 0, 15, 0, 0, 0, 0), -- Plague Scientist
+(38063, 1156, 0, 7, 0, 15, 0, 0, 0, 0), -- Vengeful Fleshreaper
+(38064, 1156, 0, 7, 0, 150, 0, 0, 0, 0), -- Stinky
+(38072, 1156, 0, 7, 0, 15, 0, 0, 0, 0), -- Deathspeacker Attedent
+(38073, 1156, 0, 7, 0, 15, 0, 0, 0, 0), -- Deathspeacker Disciple
+(38074, 1156, 0, 7, 0, 45, 0, 0, 0, 0), -- Deathspeacker High Preist
+(38075, 1156, 0, 7, 0, 15, 0, 0, 0, 0), -- Deathspeacker Servant
+(38076, 1156, 0, 7, 0, 15, 0, 0, 0, 0), -- Deathspeacker Zealot
+(38098, 1156, 0, 7, 0, 15, 0, 0, 0, 0), -- Darkfallen Advisor
+(38099, 1156, 0, 7, 0, 15, 0, 0, 0, 0), -- Darkfallen Archmage
+(38100, 1156, 0, 7, 0, 15, 0, 0, 0, 0), -- Darkfallen Blood Knight
+(38101, 1156, 0, 7, 0, 15, 0, 0, 0, 0), -- Darkfallen Lieutenant
+(38102, 1156, 0, 7, 0, 15, 0, 0, 0, 0), -- Darkfallen Commander
+(38103, 1156, 0, 7, 0, 150, 0, 0, 0, 0), -- Precious
+(38105, 1156, 0, 7, 0, 2, 0, 0, 0, 0), -- Plagued Zombie
+(38108, 1156, 0, 7, 0, 15, 0, 0, 0, 0), -- Blighted Abomination
+(38110, 1156, 0, 7, 0, 30, 0, 0, 0, 0), -- Pustulating Horror
+(38126, 1156, 0, 7, 0, 15, 0, 0, 0, 0), -- Ymirjar Frostbinder
+(38130, 1156, 0, 7, 0, 15, 0, 0, 0, 0), -- Ymirjar Deathbringer
+(38131, 1156, 0, 7, 0, 15, 0, 0, 0, 0), -- Ymirjar Huntress
+(38132, 1156, 0, 7, 0, 15, 0, 0, 0, 0), -- Ymirjar Battle-Maiden
+(38133, 1156, 0, 7, 0, 15, 0, 0, 0, 0), -- Ymirjar Warlord
+(38139, 1156, 0, 7, 0, 15, 0, 0, 0, 0), -- Frostwarden Handler
+(38151, 1156, 0, 7, 0, 15, 0, 0, 0, 0), -- Frostwing Whelp
+(38219, 1156, 0, 7, 0, 150, 0, 0, 0, 0), -- Spinestalker
+(38220, 1156, 0, 7, 0, 150, 0, 0, 0, 0), -- Rimefang
+(38418, 1156, 0, 7, 0, 45, 0, 0, 0, 0), -- Val'kyr Herald
+(38445, 1156, 0, 7, 0, 15, 0, 0, 0, 0), -- Spire Minion
+(38446, 1156, 0, 7, 0, 15, 0, 0, 0, 0), -- Frenzied Abomination
+(38479, 1156, 0, 7, 0, 15, 0, 0, 0, 0), -- Darkfallen Tactician
+(38480, 1156, 0, 7, 0, 15, 0, 0, 0, 0), -- Darkfallen Noble
+(38481, 1156, 0, 7, 0, 15, 0, 0, 0, 0); -- Spire Gargoyle
+
+-- fix procs by warpten closes #4467 for 
+-- Needle-Encrusted Scorpion
+DELETE FROM `spell_proc_event` WHERE `entry`=71404;
+INSERT INTO `spell_proc_event` (`entry`,`SchoolMask`,`SpellFamilyName`,`SpellFamilyMask0`,`SpellFamilyMask1`,`SpellFamilyMask2`,`procFlags`,`procEx`,`ppmRate`,`CustomChance`,`Cooldown`) VALUES
+(71404,0,0,0,0,0,0,2,0,0,50);
+
+-- Black Magic
+DELETE FROM `spell_proc_event` WHERE `entry`=59630;
+INSERT INTO `spell_proc_event` (`entry`,`SchoolMask`,`SpellFamilyName`,`SpellFamilyMask0`,`SpellFamilyMask1`,`SpellFamilyMask2`,`procFlags`,`procEx`,`ppmRate`,`CustomChance`,`Cooldown`) VALUES
+(59630,0,0,0,0,0,0,0,0,0,35);
+
+-- Environment Creature Hight Update by shlomi1515 closes #4043
+UPDATE `creature` SET `position_z`=558.210022 WHERE `guid` IN (85141,85143,85154,85153,85142,85151,85152,85150);
+UPDATE `creature` SET `position_z`=586.302 WHERE `guid` IN (85145,85144,85146);
+UPDATE `creature` SET `position_z`=586.263 WHERE `guid` IN (85147,85148,85149);
+
+-- fix winterskorn raider not landing by nayd closes #3899
+UPDATE `creature_template` SET `InhabitType`=`InhabitType`|1 WHERE `entry`=23665;
+
+-- fix head of onyxia's loot closes by kandera #3851
+UPDATE `item_template` SET `flags` = flags|4096 WHERE `entry` IN (18422,18423,49644,49643);
+
+-- fix visual for plagued dragonsflayer tribesman by shlomi1515 closes #3518
+DELETE FROM `creature_addon` WHERE `guid` = 97540;
diff -r b4c056460923 -r da13f4f7a26c sql/updates/world/2012_04_13_02_world_misc.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/world/2012_04_13_02_world_misc.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,18 @@
+UPDATE `creature_template` SET `InhabitType`=4 WHERE `entry` IN (38308,38309,37824); -- Professor Putricide triggers
+UPDATE `creature_template` SET `ScriptName`='npc_gas_cloud' WHERE `entry`=37562; -- Gas Cloud
+DELETE FROM `spell_script_names` WHERE `ScriptName`='spell_putricide_ooze_summon';
+DELETE FROM `spell_target_position` WHERE `id` IN (71413,71414);
+INSERT INTO `spell_target_position` (`id`,`target_map`,`target_position_x`,`target_position_y`,`target_position_z`,`target_orientation`) VALUES
+(71414,631,4335.00,3206.75,389.399,0),
+(71413,631,4380.43,3206.55,389.398,0);
+
+DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=13 AND `SourceEntry` IN (71615,71618,71412,71415);
+INSERT INTO `conditions` (`SourceTypeOrReferenceId`,`SourceGroup`,`SourceEntry`,`ConditionTypeOrReference`,`ConditionValue1`,`ConditionValue2`,`Comment`) VALUES
+(13,4,71615,31,3,37690,'Putricide - Tear Gas on Slime Puddle'),
+(13,1,71618,31,3,37562,'Putricide - Tear Gas on Gas Cloud'),
+(13,2,71618,31,3,37697,'Putricide - Tear Gas on Volatile Ooze'),
+(13,4,71618,31,3,38159,'Putricide - Tear Gas on Choking Gas Bomb');
+
+UPDATE `spell_script_names` SET `ScriptName`='spell_putricide_clear_aura_effect_value' WHERE `ScriptName`='spell_putricide_clear_mutated_plague';
+INSERT INTO `spell_script_names` (`spell_id`,`ScriptName`) VALUES
+(71620,'spell_putricide_clear_aura_effect_value');
diff -r b4c056460923 -r da13f4f7a26c sql/updates/world/2012_04_13_03_world_bg_template.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/world/2012_04_13_03_world_bg_template.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,7 @@
+ALTER TABLE `battleground_template` ADD `StartMaxDist` float NOT NULL DEFAULT 0 AFTER `HordeStartO`;
+
+UPDATE `battleground_template` SET `StartMaxDist`=200 WHERE `id`=30; -- IC
+UPDATE `battleground_template` SET `StartMaxDist`=100 WHERE `id`=1; -- AV
+UPDATE `battleground_template` SET `StartMaxDist`=75 WHERE `id` IN (2,3,7); -- WSG, AB, EotS
+
+UPDATE `battleground_template` SET `MinLvl`=1 WHERE `id`=32;
diff -r b4c056460923 -r da13f4f7a26c sql/updates/world/2012_04_13_04_world_spell_proc_event.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/world/2012_04_13_04_world_spell_proc_event.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,4 @@
+-- Blackened Naaru Silver proc cooldown
+DELETE FROM `spell_proc_event` WHERE `entry`=45355;
+INSERT INTO `spell_proc_event`(`entry`,`schoolmask`,`spellfamilyname`,`spellfamilymask0`,`spellfamilymask1`,`spellfamilymask2`,`procflags`,`procex`,`ppmrate`,`customchance`,`cooldown`) VALUES
+(45355,0,0,0,0,0,0,0,0,0,45);
\ No newline at end of file
diff -r b4c056460923 -r da13f4f7a26c sql/updates/world/2012_04_14_00_world_gameobject_loot_template.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/world/2012_04_14_00_world_gameobject_loot_template.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,3 @@
+-- Add Bogblossom to this Bogblossom object for the druid quest (other one already contains it)
+DELETE FROM `gameobject_loot_template` WHERE (`entry`=10961) AND (`item`=31950);
+INSERT INTO `gameobject_loot_template` (`entry`,`item`,`ChanceOrQuestChance`,`lootmode`,`groupid`,`mincountOrRef`,`maxcount`) VALUES (10961,31950,-100,0,0,1,1);
diff -r b4c056460923 -r da13f4f7a26c sql/updates/world/2012_04_14_01_world_gameobject_loot_template.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/world/2012_04_14_01_world_gameobject_loot_template.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,11 @@
+-- Add missing gameobject_loot_templates to prevent startup errors
+DELETE FROM `gameobject_loot_template` WHERE `entry` IN (3458,3459,3460,3461,15920,16841,26878,27725);
+INSERT INTO `gameobject_loot_template` (`entry`,`item`,`ChanceOrQuestChance`,`lootmode`,`groupid`,`mincountOrRef`,`maxcount`) VALUES 
+(3458,4594,100,0,0,1,1), -- Rockscale Cod on Feast Fish
+(3459,3771,100,0,0,1,1), -- Wild Hog Shank On Feast Boar
+(3460,4538,100,0,0,1,1), -- Snapvine Watermelon on Feast Fruit
+(3461,1708,100,0,0,1,1), -- Sweet Nectar on Feast Goblet
+(15920,17822,-100,0,0,1,1), -- Weird Map on weird object
+(16841,18950,-100,0,0,1,1), -- Chambermaid Pillaclenchers Pillow on Pillaclencher's Ornate Pillow
+(26878,45062,100,0,0,1,1), -- Dusty Journal on Dusty Journal (different ID)
+(27725,49648,100,0,0,1,1); -- Borrowed Tabard on Clean Laundry (might need condition!)
diff -r b4c056460923 -r da13f4f7a26c sql/updates/world/2012_04_14_02_world_creature_template_addon.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/world/2012_04_14_02_world_creature_template_addon.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,3 @@
+UPDATE `creature_template_addon` SET `auras`='50453' WHERE `entry`=28017;
+DELETE FROM `creature_ai_scripts` WHERE `creature_id`=28017;
+UPDATE `creature_template` SET `ainame` = '' WHERE `entry`=28017;
\ No newline at end of file
diff -r b4c056460923 -r da13f4f7a26c sql/updates/world/2012_04_14_03_world_spell_bonus_data.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/world/2012_04_14_03_world_spell_bonus_data.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,1 @@
+UPDATE `spell_bonus_data` SET `direct_bonus`=0.8930 WHERE `entry`=51505;
diff -r b4c056460923 -r da13f4f7a26c sql/updates/world/2012_04_14_04_world_spell_proc_event.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/world/2012_04_14_04_world_spell_proc_event.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,3 @@
+DELETE FROM `spell_proc_event` WHERE `entry`=53601;
+INSERT INTO `spell_proc_event` (`entry`,`SchoolMask`,`SpellFamilyName`,`SpellFamilyMask0`,`SpellFamilyMask1`,`SpellFamilyMask2`,`procFlags`,`procEx`,`ppmRate`,`CustomChance`,`Cooldown`) VALUES
+(53601, 0, 0, 0x00000000, 0x00000000, 0x00000000, 0, 0, 0, 0, 6);
diff -r b4c056460923 -r da13f4f7a26c sql/updates/world/2012_04_14_05_world_spell_proc_event.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/world/2012_04_14_05_world_spell_proc_event.sql	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,1 @@
+DELETE FROM `spell_proc_event` WHERE `entry` IN (51486,51485,51483);
diff -r b4c056460923 -r da13f4f7a26c src/server/authserver/Realms/RealmList.cpp
--- a/src/server/authserver/Realms/RealmList.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/authserver/Realms/RealmList.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -31,7 +31,7 @@
     UpdateRealms(true);
 }
 
-void RealmList::UpdateRealm(uint32 ID, const std::string& name, const std::string& address, uint32 port, uint8 icon, uint8 color, uint8 timezone, AccountTypes allowedSecurityLevel, float popu, uint32 build)
+void RealmList::UpdateRealm(uint32 ID, const std::string& name, const std::string& address, uint16 port, uint8 icon, RealmFlags flag, uint8 timezone, AccountTypes allowedSecurityLevel, float popu, uint32 build)
 {
     // Create new if not exist or update existed
     Realm& realm = m_realms[name];
@@ -39,7 +39,7 @@
     realm.m_ID = ID;
     realm.name = name;
     realm.icon = icon;
-    realm.color = color;
+    realm.flag = flag;
     realm.timezone = timezone;
     realm.allowedSecurityLevel = allowedSecurityLevel;
     realm.populationLevel = popu;
@@ -70,7 +70,7 @@
 {
     sLog->outDetail("Updating Realm List...");
 
-    PreparedStatement *stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_REALMLIST);
+    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_REALMLIST);
     PreparedQueryResult result = LoginDatabase.Query(stmt);
 
     // Circle through results and add them to the realm map
@@ -79,18 +79,18 @@
         do
         {
             Field* fields = result->Fetch();
-            uint32 realmId = fields[0].GetUInt32();
-            const std::string& name = fields[1].GetString();
+            uint32 realmId             = fields[0].GetUInt32();
+            const std::string& name    = fields[1].GetString();
             const std::string& address = fields[2].GetString();
-            uint32 port = fields[3].GetUInt32();
-            uint8 icon = fields[4].GetUInt8();
-            uint8 color = fields[5].GetUInt8();
-            uint8 timezone = fields[6].GetUInt8();
+            uint16 port                = fields[3].GetUInt16();
+            uint8 icon                 = fields[4].GetUInt8();
+            RealmFlags flag            = RealmFlags(fields[5].GetUInt8());
+            uint8 timezone             = fields[6].GetUInt8();
             uint8 allowedSecurityLevel = fields[7].GetUInt8();
-            float pop = fields[8].GetFloat();
-            uint32 build = fields[9].GetUInt32();
+            float pop                  = fields[8].GetFloat();
+            uint32 build               = fields[9].GetUInt32();
 
-            UpdateRealm(realmId, name, address, port, icon, color, timezone, (allowedSecurityLevel <= SEC_ADMINISTRATOR ? AccountTypes(allowedSecurityLevel) : SEC_ADMINISTRATOR), pop, build);
+            UpdateRealm(realmId, name, address, port, icon, flag, timezone, (allowedSecurityLevel <= SEC_ADMINISTRATOR ? AccountTypes(allowedSecurityLevel) : SEC_ADMINISTRATOR), pop, build);
 
             if (init)
                 sLog->outString("Added realm \"%s\".", fields[1].GetCString());
diff -r b4c056460923 -r da13f4f7a26c src/server/authserver/Realms/RealmList.h
--- a/src/server/authserver/Realms/RealmList.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/authserver/Realms/RealmList.h	Mon Apr 16 14:29:17 2012 +0300
@@ -23,13 +23,26 @@
 #include <ace/Null_Mutex.h>
 #include "Common.h"
 
+enum RealmFlags
+{
+    REALM_FLAG_NONE                              = 0x00,
+    REALM_FLAG_INVALID                           = 0x01,
+    REALM_FLAG_OFFLINE                           = 0x02,
+    REALM_FLAG_SPECIFYBUILD                      = 0x04,
+    REALM_FLAG_UNK1                              = 0x08,
+    REALM_FLAG_UNK2                              = 0x10,
+    REALM_FLAG_RECOMMENDED                       = 0x20,
+    REALM_FLAG_NEW                               = 0x40,
+    REALM_FLAG_FULL                              = 0x80
+};
+
 // Storage object for a realm
 struct Realm
 {
     std::string address;
     std::string name;
     uint8 icon;
-    uint8 color;
+    RealmFlags flag;
     uint8 timezone;
     uint32 m_ID;
     AccountTypes allowedSecurityLevel;
@@ -58,7 +71,7 @@
 
 private:
     void UpdateRealms(bool init=false);
-    void UpdateRealm(uint32 ID, const std::string& name, const std::string& address, uint32 port, uint8 icon, uint8 color, uint8 timezone, AccountTypes allowedSecurityLevel, float popu, uint32 build);
+    void UpdateRealm(uint32 ID, const std::string& name, const std::string& address, uint16 port, uint8 icon, RealmFlags flag, uint8 timezone, AccountTypes allowedSecurityLevel, float popu, uint32 build);
 
     RealmMap m_realms;
     uint32   m_UpdateInterval;
diff -r b4c056460923 -r da13f4f7a26c src/server/authserver/Server/AuthSocket.cpp
--- a/src/server/authserver/Server/AuthSocket.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/authserver/Server/AuthSocket.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -881,7 +881,7 @@
         pkt << i->second.icon;                              // realm type
         if (_expversion & (POST_BC_EXP_FLAG | POST_WOTLK_EXP_FLAG))
             pkt << lock;                                    // if 1, then realm locked
-        pkt << i->second.color;                             // if 2, then realm is offline
+        pkt << uint8(i->second.flag);                       // RealmFlags
         pkt << i->first;
         pkt << i->second.address;
         pkt << i->second.populationLevel;
@@ -892,6 +892,15 @@
         else
             pkt << (uint8)0x0;                              // 1.12.1 and 1.12.2 clients
 
+        if (i->second.flag & REALM_FLAG_SPECIFYBUILD)
+        {
+            // TODO: Make this customizable
+            pkt << uint8(3);
+            pkt << uint8(3);
+            pkt << uint8(5);
+            pkt << uint16(12340);
+        }
+
         ++RealmListSize;
     }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/authserver/Server/AuthSocket.h
--- a/src/server/authserver/Server/AuthSocket.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/authserver/Server/AuthSocket.h	Mon Apr 16 14:29:17 2012 +0300
@@ -23,19 +23,6 @@
 #include "BigNumber.h"
 #include "RealmSocket.h"
 
-enum RealmFlags
-{
-    REALM_FLAG_NONE                              = 0x00,
-    REALM_FLAG_INVALID                           = 0x01,
-    REALM_FLAG_OFFLINE                           = 0x02,
-    REALM_FLAG_SPECIFYBUILD                      = 0x04,
-    REALM_FLAG_UNK1                              = 0x08,
-    REALM_FLAG_UNK2                              = 0x10,
-    REALM_FLAG_RECOMMENDED                       = 0x20,
-    REALM_FLAG_NEW                               = 0x40,
-    REALM_FLAG_FULL                              = 0x80
-};
-
 // Handle login commands
 class AuthSocket: public RealmSocket::Session
 {
diff -r b4c056460923 -r da13f4f7a26c src/server/authserver/authserver.conf.dist
--- a/src/server/authserver/authserver.conf.dist	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/authserver/authserver.conf.dist	Mon Apr 16 14:29:17 2012 +0300
@@ -111,6 +111,14 @@
 SQLDriverLogFile = ""
 
 #
+#    SQLDriverQueryLogging
+#        Description: Log SQL queries to the SQLDriverLogFile and console.
+#        Default:     0 - (Disabled, Query errors only)
+#                     1 - (Enabled, Full query logging - may have performance impact)
+
+SQLDriverQueryLogging = 0
+
+#
 #    LogTimestamp
 #        Description: Append timestamp to the server log file name.
 #                     Logname_YYYY-MM-DD_HH-MM-SS.Ext for Logname.Ext
diff -r b4c056460923 -r da13f4f7a26c src/server/game/AI/CoreAI/GameObjectAI.h
--- a/src/server/game/AI/CoreAI/GameObjectAI.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/AI/CoreAI/GameObjectAI.h	Mon Apr 16 14:29:17 2012 +0300
@@ -33,21 +33,24 @@
         explicit GameObjectAI(GameObject* g) : go(g) {}
         virtual ~GameObjectAI() {}
 
-        virtual void UpdateAI(const uint32 /*diff*/) {}
+        virtual void UpdateAI(uint32 /*diff*/) {}
 
         virtual void InitializeAI() { Reset(); }
 
         virtual void Reset() {};
 
-        static int Permissible(const GameObject* go);
+        static int Permissible(GameObject const* go);
 
-        virtual bool GossipHello(Player* /*player*/) {return false;}
-        virtual bool GossipSelect(Player* /*player*/, uint32 /*sender*/, uint32 /*action*/) {return false;}
-        virtual bool GossipSelectCode(Player* /*player*/, uint32 /*sender*/, uint32 /*action*/, const char* /*code*/) {return false;}
-        virtual bool QuestAccept(Player* /*player*/, Quest const* /*quest*/) {return false;}
-        virtual bool QuestReward(Player* /*player*/, Quest const* /*quest*/, uint32 /*opt*/) {return false;}
-        virtual uint32 GetDialogStatus(Player* /*player*/) {return 100;}
+        virtual bool GossipHello(Player* /*player*/) { return false; }
+        virtual bool GossipSelect(Player* /*player*/, uint32 /*sender*/, uint32 /*action*/) { return false; }
+        virtual bool GossipSelectCode(Player* /*player*/, uint32 /*sender*/, uint32 /*action*/, char const* /*code*/) { return false; }
+        virtual bool QuestAccept(Player* /*player*/, Quest const* /*quest*/) { return false; }
+        virtual bool QuestReward(Player* /*player*/, Quest const* /*quest*/, uint32 /*opt*/) { return false; }
+        virtual uint32 GetDialogStatus(Player* /*player*/) { return 100; }
         virtual void Destroyed(Player* /*player*/, uint32 /*eventId*/) {}
+        virtual uint32 GetData(uint32 /*id*/) { return 0; }
+        virtual void SetData64(uint32 /*id*/, uint64 /*value*/) {}
+        virtual uint64 GetData64(uint32 /*id*/) { return 0; }
         virtual void SetData(uint32 /*id*/, uint32 /*value*/) {}
         virtual void OnGameEvent(bool /*start*/, uint16 /*eventId*/) {}
         virtual void OnStateChanged(uint32 /*state*/, Unit* /*unit*/) { }
@@ -58,8 +61,8 @@
     public:
         explicit NullGameObjectAI(GameObject* g);
 
-        void UpdateAI(const uint32 /*diff*/) {}
+        void UpdateAI(uint32 /*diff*/) {}
 
-        static int Permissible(const GameObject* /*go*/) { return PERMIT_BASE_IDLE; }
+        static int Permissible(GameObject const* /*go*/) { return PERMIT_BASE_IDLE; }
 };
 #endif
diff -r b4c056460923 -r da13f4f7a26c src/server/game/AI/CoreAI/GuardAI.cpp
--- a/src/server/game/AI/CoreAI/GuardAI.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/AI/CoreAI/GuardAI.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -92,15 +92,15 @@
     {
         sLog->outStaticDebug("Creature stopped attacking because victim does not exist [guid=%u]", me->GetGUIDLow());
     }
-    else if (!victim ->isAlive())
+    else if (!victim->isAlive())
     {
         sLog->outStaticDebug("Creature stopped attacking because victim is dead [guid=%u]", me->GetGUIDLow());
     }
-    else if (victim ->HasStealthAura())
+    else if (victim->HasStealthAura())
     {
         sLog->outStaticDebug("Creature stopped attacking because victim is using stealth [guid=%u]", me->GetGUIDLow());
     }
-    else if (victim ->isInFlight())
+    else if (victim->isInFlight())
     {
         sLog->outStaticDebug("Creature stopped attacking because victim is flying away [guid=%u]", me->GetGUIDLow());
     }
diff -r b4c056460923 -r da13f4f7a26c src/server/game/AI/CoreAI/PetAI.cpp
--- a/src/server/game/AI/CoreAI/PetAI.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/AI/CoreAI/PetAI.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -109,17 +109,25 @@
     }
     else if (owner && me->GetCharmInfo()) //no victim
     {
-        Unit* nextTarget = SelectNextTarget();
+        // Only aggressive pets do target search every update.
+        // Defensive pets do target search only in these cases:
+        //  * Owner attacks something - handled by OwnerAttacked()
+        //  * Owner receives damage - handled by OwnerDamagedBy()
+        //  * Pet is in combat and current target dies - handled by KilledUnit()
+        if (me->HasReactState(REACT_AGGRESSIVE))
+        {
+            Unit* nextTarget = SelectNextTarget();
 
-        if (me->HasReactState(REACT_PASSIVE))
-            _stopAttack();
-        else if (nextTarget)
-            AttackStart(nextTarget);
+            if (nextTarget)
+                AttackStart(nextTarget);
+            else
+                HandleReturnMovement();
+        }
         else
             HandleReturnMovement();
     }
     else if (owner && !me->HasUnitState(UNIT_STATE_FOLLOW)) // no charm info and no victim
-        me->GetMotionMaster()->MoveFollow(owner, PET_FOLLOW_DIST, me->GetFollowAngle());
+        HandleReturnMovement();
 
     if (!me->GetCharmInfo())
         return;
@@ -302,6 +310,47 @@
     DoAttack(target, true);
 }
 
+void PetAI::OwnerDamagedBy(Unit* attacker)
+{
+    // Called when owner takes damage. Allows defensive pets to know
+    //  that their owner might need help
+
+    if (!attacker)
+        return;
+
+    // Passive pets don't do anything
+    if (me->HasReactState(REACT_PASSIVE))
+        return;
+
+    // Prevent pet from disengaging from current target
+    if (me->getVictim() && me->getVictim()->isAlive())
+        return;
+
+    // Continue to evaluate and attack if necessary
+    AttackStart(attacker);
+}
+
+void PetAI::OwnerAttacked(Unit* target)
+{
+    // Called when owner attacks something. Allows defensive pets to know
+    //  that they need to assist
+
+    // Target might be NULL if called from spell with invalid cast targets
+    if (!target)
+        return;
+
+    // Passive pets don't do anything
+    if (me->HasReactState(REACT_PASSIVE))
+        return;
+
+    // Prevent pet from disengaging from current target
+    if (me->getVictim() && me->getVictim()->isAlive())
+        return;
+
+    // Continue to evaluate and attack if necessary
+    AttackStart(target);
+}
+
 Unit* PetAI::SelectNextTarget()
 {
     // Provides next target selection after current target death
diff -r b4c056460923 -r da13f4f7a26c src/server/game/AI/CoreAI/PetAI.h
--- a/src/server/game/AI/CoreAI/PetAI.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/AI/CoreAI/PetAI.h	Mon Apr 16 14:29:17 2012 +0300
@@ -40,6 +40,8 @@
         void KilledUnit(Unit* /*victim*/);
         void AttackStart(Unit* target);
         void MovementInform(uint32 moveType, uint32 data);
+        void OwnerDamagedBy(Unit* attacker);
+        void OwnerAttacked(Unit* target);
 
     private:
         bool _isVisible(Unit*) const;
diff -r b4c056460923 -r da13f4f7a26c src/server/game/AI/CoreAI/TotemAI.cpp
--- a/src/server/game/AI/CoreAI/TotemAI.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/AI/CoreAI/TotemAI.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -27,8 +27,7 @@
 #include "GridNotifiersImpl.h"
 #include "CellImpl.h"
 
-int
-TotemAI::Permissible(const Creature* creature)
+int TotemAI::Permissible(Creature const* creature)
 {
     if (creature->isTotem())
         return PERMIT_BASE_PROACTIVE;
@@ -41,8 +40,7 @@
     ASSERT(c->isTotem());
 }
 
-void
-TotemAI::MoveInLineOfSight(Unit*)
+void TotemAI::MoveInLineOfSight(Unit* /*who*/)
 {
 }
 
@@ -51,10 +49,9 @@
     me->CombatStop(true);
 }
 
-void
-TotemAI::UpdateAI(const uint32 /*diff*/)
+void TotemAI::UpdateAI(uint32 const /*diff*/)
 {
-  if (me->ToTotem()->GetTotemType() != TOTEM_ACTIVE)
+    if (me->ToTotem()->GetTotemType() != TOTEM_ACTIVE)
         return;
 
     if (!me->isAlive() || me->IsNonMeleeSpellCasted(false))
@@ -98,8 +95,7 @@
         i_victimGuid = 0;
 }
 
-void
-TotemAI::AttackStart(Unit*)
+void TotemAI::AttackStart(Unit* /*victim*/)
 {
     // Sentry totem sends ping on attack
     if (me->GetEntry() == SENTRY_TOTEM_ENTRY && me->GetOwner()->GetTypeId() == TYPEID_PLAYER)
diff -r b4c056460923 -r da13f4f7a26c src/server/game/AI/CoreAI/TotemAI.h
--- a/src/server/game/AI/CoreAI/TotemAI.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/AI/CoreAI/TotemAI.h	Mon Apr 16 14:29:17 2012 +0300
@@ -31,12 +31,12 @@
 
         explicit TotemAI(Creature* c);
 
-        void MoveInLineOfSight(Unit*);
-        void AttackStart(Unit*);
+        void MoveInLineOfSight(Unit* who);
+        void AttackStart(Unit* victim);
         void EnterEvadeMode();
 
-        void UpdateAI(const uint32);
-        static int Permissible(const Creature*);
+        void UpdateAI(uint32 const diff);
+        static int Permissible(Creature const* creature);
 
     private:
         uint64 i_victimGuid;
diff -r b4c056460923 -r da13f4f7a26c src/server/game/AI/CoreAI/UnitAI.h
--- a/src/server/game/AI/CoreAI/UnitAI.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/AI/CoreAI/UnitAI.h	Mon Apr 16 14:29:17 2012 +0300
@@ -223,7 +223,7 @@
                 targetList.reverse();
 
             if (targetType == SELECT_TARGET_RANDOM)
-                Trinity::RandomResizeList(targetList, maxTargets);
+                Trinity::Containers::RandomResizeList(targetList, maxTargets);
             else
                 targetList.resize(maxTargets);
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/game/AI/CreatureAI.h
--- a/src/server/game/AI/CreatureAI.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/AI/CreatureAI.h	Mon Apr 16 14:29:17 2012 +0300
@@ -140,6 +140,12 @@
         // Called at text emote receive from player
         virtual void ReceiveEmote(Player* /*player*/, uint32 /*emoteId*/) {}
 
+        // Called when owner takes damage
+        virtual void OwnerDamagedBy(Unit* /*attacker*/) {}
+
+        // Called when owner attacks something
+        virtual void OwnerAttacked(Unit* /*target*/) {}
+
         /// == Triggered Actions Requested ==================
 
         // Called when creature attack expected (if creature can and no have current victim)
diff -r b4c056460923 -r da13f4f7a26c src/server/game/AI/CreatureAIImpl.h
--- a/src/server/game/AI/CreatureAIImpl.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/AI/CreatureAIImpl.h	Mon Apr 16 14:29:17 2012 +0300
@@ -604,6 +604,7 @@
 
 inline void UnitAI::DoCastVictim(uint32 spellId, bool triggered)
 {
+    // Why don't we check for casting unit_state and existing target as we do in DoCast(.. ?
     me->CastSpell(me->getVictim(), spellId, triggered);
 }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/AI/CreatureAISelector.cpp
--- a/src/server/game/AI/CreatureAISelector.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/AI/CreatureAISelector.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -82,7 +82,7 @@
             {
                 const CreatureAICreator* factory = iter->second;
                 const SelectableAI* p = dynamic_cast<const SelectableAI*>(factory);
-                ASSERT(p != NULL);
+                ASSERT(p);
                 int val = p->Permit(creature);
                 if (val > best_val)
                 {
@@ -102,7 +102,7 @@
     MovementGenerator* selectMovementGenerator(Creature* creature)
     {
         MovementGeneratorRegistry& mv_registry(*MovementGeneratorRepository::instance());
-        ASSERT(creature->GetCreatureTemplate() != NULL);
+        ASSERT(creature->GetCreatureTemplate());
         const MovementGeneratorCreator* mv_factory = mv_registry.GetRegistryItem(creature->GetDefaultMovementType());
 
         /* if (mv_factory == NULL)
@@ -133,6 +133,9 @@
         const GameObjectAICreator* ai_factory = NULL;
         GameObjectAIRegistry& ai_registry(*GameObjectAIRepository::instance());
 
+        if (GameObjectAI* scriptedAI = sScriptMgr->GetGameObjectAI(go))
+            return scriptedAI;
+
         ai_factory = ai_registry.GetRegistryItem(go->GetAIName());
 
         //future goAI types go here
diff -r b4c056460923 -r da13f4f7a26c src/server/game/AI/EventAI/CreatureEventAI.cpp
--- a/src/server/game/AI/EventAI/CreatureEventAI.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/AI/EventAI/CreatureEventAI.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -95,7 +95,7 @@
     m_AttackDistance = 0.0f;
     m_AttackAngle = 0.0f;
 
-    m_InvinceabilityHpLevel = 0;
+    m_InvincibilityHpLevel = 0;
 
     //Handle Spawned Events
     if (!m_bEmptyList)
@@ -816,9 +816,9 @@
         case ACTION_T_SET_INVINCIBILITY_HP_LEVEL:
         {
             if (action.invincibility_hp_level.is_percent)
-                m_InvinceabilityHpLevel = me->CountPctFromMaxHealth(action.invincibility_hp_level.hp_level);
+                m_InvincibilityHpLevel = me->CountPctFromMaxHealth(action.invincibility_hp_level.hp_level);
             else
-                m_InvinceabilityHpLevel = action.invincibility_hp_level.hp_level;
+                m_InvincibilityHpLevel = action.invincibility_hp_level.hp_level;
             break;
         }
         case ACTION_T_MOUNT_TO_ENTRY_OR_MODEL:
@@ -1350,12 +1350,12 @@
 
 void CreatureEventAI::DamageTaken(Unit* /*done_by*/, uint32& damage)
 {
-    if (m_InvinceabilityHpLevel > 0 && me->GetHealth() < m_InvinceabilityHpLevel+damage)
+    if (m_InvincibilityHpLevel > 0 && me->GetHealth() < m_InvincibilityHpLevel+damage)
     {
-        if (me->GetHealth() <= m_InvinceabilityHpLevel)
+        if (me->GetHealth() <= m_InvincibilityHpLevel)
             damage = 0;
         else
-            damage = me->GetHealth() - m_InvinceabilityHpLevel;
+            damage = me->GetHealth() - m_InvincibilityHpLevel;
     }
 }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/AI/EventAI/CreatureEventAI.h
--- a/src/server/game/AI/EventAI/CreatureEventAI.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/AI/EventAI/CreatureEventAI.h	Mon Apr 16 14:29:17 2012 +0300
@@ -641,6 +641,6 @@
         bool m_MeleeEnabled;                                  // If we allow melee auto attack
         float m_AttackDistance;                               // Distance to attack from
         float m_AttackAngle;                                  // Angle of attack
-        uint32 m_InvinceabilityHpLevel;                       // Minimal health level allowed at damage apply
+        uint32 m_InvincibilityHpLevel;                       // Minimal health level allowed at damage apply
 };
 #endif
diff -r b4c056460923 -r da13f4f7a26c src/server/game/AI/EventAI/CreatureEventAIMgr.cpp
--- a/src/server/game/AI/EventAI/CreatureEventAIMgr.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/AI/EventAI/CreatureEventAIMgr.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -38,7 +38,7 @@
     // Load EventAI Text
     sObjectMgr->LoadTrinityStrings("creature_ai_texts", MIN_CREATURE_AI_TEXT_STRING_ID, MAX_CREATURE_AI_TEXT_STRING_ID);
 
-    // Gather Additional data from EventAI Texts
+    // Gather Additional data from EventAI Texts       0      1      2       3       4
     QueryResult result = WorldDatabase.Query("SELECT entry, sound, type, language, emote FROM creature_ai_texts");
 
     if (!result)
@@ -56,10 +56,10 @@
         StringTextData temp;
 
         int32 i             = fields[0].GetInt32();
-        temp.SoundId        = fields[1].GetInt32();
-        temp.Type           = fields[2].GetInt32();
-        temp.Language       = fields[3].GetInt32();
-        temp.Emote          = fields[4].GetInt32();
+        temp.SoundId        = fields[1].GetUInt32();
+        temp.Type           = fields[2].GetUInt8();
+        temp.Language       = fields[3].GetUInt8();
+        temp.Emote          = fields[4].GetUInt16();
 
         // range negative
         if (i > MIN_CREATURE_AI_TEXT_STRING_ID || i <= MAX_CREATURE_AI_TEXT_STRING_ID)
@@ -187,7 +187,7 @@
         temp.creature_id = fields[1].GetUInt32();
         uint32 creature_id = temp.creature_id;
 
-        uint32 e_type = fields[2].GetUInt32();
+        uint32 e_type = fields[2].GetUInt8();
         //Report any errors in event
         if (e_type >= EVENT_T_END)
         {
@@ -196,13 +196,13 @@
         }
         temp.event_type = EventAI_Type(e_type);
 
-        temp.event_inverse_phase_mask = fields[3].GetUInt32();
-        temp.event_chance = fields[4].GetUInt8();
-        temp.event_flags  = fields[5].GetUInt8();
-        temp.raw.param1 = fields[6].GetUInt32();
-        temp.raw.param2 = fields[7].GetUInt32();
-        temp.raw.param3 = fields[8].GetUInt32();
-        temp.raw.param4 = fields[9].GetUInt32();
+        temp.event_inverse_phase_mask = fields[3].GetInt32();
+        temp.event_chance = fields[4].GetUInt32();
+        temp.event_flags  = fields[5].GetUInt32();
+        temp.raw.param1 = fields[6].GetInt32();
+        temp.raw.param2 = fields[7].GetInt32();
+        temp.raw.param3 = fields[8].GetInt32();
+        temp.raw.param4 = fields[9].GetInt32();
 
         //Creature does not exist in database
         if (!sObjectMgr->GetCreatureTemplate(temp.creature_id))
@@ -399,7 +399,7 @@
 
         for (uint32 j = 0; j < MAX_ACTIONS; j++)
         {
-            uint16 action_type = fields[10+(j*4)].GetUInt16();
+            uint16 action_type = fields[10+(j*4)].GetUInt8();
             if (action_type >= ACTION_T_END)
             {
                 sLog->outErrorDb("CreatureEventAI:  Event %u Action %u has incorrect action type (%u), replace by ACTION_T_NONE.", i, j+1, action_type);
@@ -410,9 +410,9 @@
             CreatureEventAI_Action& action = temp.action[j];
 
             action.type = EventAI_ActionType(action_type);
-            action.raw.param1 = fields[11+(j*4)].GetUInt32();
-            action.raw.param2 = fields[12+(j*4)].GetUInt32();
-            action.raw.param3 = fields[13+(j*4)].GetUInt32();
+            action.raw.param1 = fields[11+(j*4)].GetInt32();
+            action.raw.param2 = fields[12+(j*4)].GetInt32();
+            action.raw.param3 = fields[13+(j*4)].GetInt32();
 
             //Report any errors in actions
             switch (action.type)
diff -r b4c056460923 -r da13f4f7a26c src/server/game/AI/ScriptedAI/ScriptedCreature.cpp
--- a/src/server/game/AI/ScriptedAI/ScriptedCreature.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/AI/ScriptedAI/ScriptedCreature.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -30,18 +30,6 @@
     }
 }
 
-void SummonList::DoAction(uint32 entry, int32 info)
-{
-    for (iterator i = begin(); i != end();)
-    {
-        Creature* summon = Unit::GetCreature(*me, *i);
-        ++i;
-        if (summon && summon->IsAIEnabled
-            && (!entry || summon->GetEntry() == entry))
-            summon->AI()->DoAction(info);
-    }
-}
-
 void SummonList::DespawnEntry(uint32 entry)
 {
     for (iterator i = begin(); i != end();)
@@ -126,15 +114,7 @@
     if (!UpdateVictim())
         return;
 
-    if (me->isAttackReady())
-    {
-        //If we are within range melee the target
-        if (me->IsWithinMeleeRange(me->getVictim()))
-        {
-            me->AttackerStateUpdate(me->getVictim());
-            me->resetAttackTimer();
-        }
-    }
+    DoMeleeAttackIfReady();
 }
 
 void ScriptedAI::DoStartMovement(Unit* victim, float distance, float angle)
@@ -189,11 +169,11 @@
 {
     //No target so we can't cast
     if (!target)
-        return false;
+        return NULL;
 
     //Silenced so we can't cast
     if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SILENCED))
-        return false;
+        return NULL;
 
     //Using the extended script system we first create a list of viable spells
     SpellInfo const* apSpell[CREATURE_MAX_SPELLS];
@@ -274,7 +254,7 @@
 
     for (std::list<HostileReference*>::iterator itr = threatlist.begin(); itr != threatlist.end(); ++itr)
     {
-        Unit* unit = Unit::GetUnit((*me), (*itr)->getUnitGuid());
+        Unit* unit = Unit::GetUnit(*me, (*itr)->getUnitGuid());
 
         if (unit && DoGetThreat(unit))
             DoModifyThreatPercent(unit, -100);
@@ -309,14 +289,13 @@
 
 void ScriptedAI::DoTeleportPlayer(Unit* unit, float x, float y, float z, float o)
 {
-    if (!unit || unit->GetTypeId() != TYPEID_PLAYER)
-    {
-        if (unit)
-            sLog->outError("TSCR: Creature " UI64FMTD " (Entry: %u) Tried to teleport non-player unit (Type: %u GUID: " UI64FMTD ") to x: %f y:%f z: %f o: %f. Aborted.", me->GetGUID(), me->GetEntry(), unit->GetTypeId(), unit->GetGUID(), x, y, z, o);
+    if (!unit)
         return;
-    }
 
-    CAST_PLR(unit)->TeleportTo(unit->GetMapId(), x, y, z, o, TELE_TO_NOT_LEAVE_COMBAT);
+    if (Player* player = unit->ToPlayer())
+        player->TeleportTo(unit->GetMapId(), x, y, z, o, TELE_TO_NOT_LEAVE_COMBAT);
+    else
+        sLog->outError("TSCR: Creature " UI64FMTD " (Entry: %u) Tried to teleport non-player unit (Type: %u GUID: " UI64FMTD ") to x: %f y:%f z: %f o: %f. Aborted.", me->GetGUID(), me->GetEntry(), unit->GetTypeId(), unit->GetGUID(), x, y, z, o);
 }
 
 void ScriptedAI::DoTeleportAll(float x, float y, float z, float o)
diff -r b4c056460923 -r da13f4f7a26c src/server/game/AI/ScriptedAI/ScriptedCreature.h
--- a/src/server/game/AI/ScriptedAI/ScriptedCreature.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/AI/ScriptedAI/ScriptedCreature.h	Mon Apr 16 14:29:17 2012 +0300
@@ -40,7 +40,18 @@
         void Despawn(Creature* summon) { remove(summon->GetGUID()); }
         void DespawnEntry(uint32 entry);
         void DespawnAll();
-        void DoAction(uint32 entry, int32 info);
+
+        template <class Predicate> void DoAction(int32 info, Predicate& predicate, uint16 max = 0)
+        {
+            Trinity::Containers::RandomResizeList<uint64, Predicate>(*this, predicate, max);
+            for (iterator i = begin(); i != end(); )
+            {
+                Creature* summon = Unit::GetCreature(*me, *i++);
+                if (summon && summon->IsAIEnabled)
+                    summon->AI()->DoAction(info);
+            }
+        }
+
         void DoZoneInCombat(uint32 entry = 0);
         void RemoveNotExisting();
         bool HasEntry(uint32 entry);
@@ -48,6 +59,22 @@
         Creature* me;
 };
 
+class EntryCheckPredicate
+{
+    public:
+        EntryCheckPredicate(uint32 entry) : _entry(entry) {}
+        bool operator()(uint64 guid) { return GUID_ENPART(guid) == _entry; }
+
+    private:
+        uint32 _entry;
+};
+
+class DummyEntryCheckPredicate
+{
+    public:
+        bool operator()(uint64) { return true; }
+};
+
 struct ScriptedAI : public CreatureAI
 {
     explicit ScriptedAI(Creature* creature);
diff -r b4c056460923 -r da13f4f7a26c src/server/game/AI/SmartScripts/SmartAI.cpp
--- a/src/server/game/AI/SmartScripts/SmartAI.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/AI/SmartScripts/SmartAI.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -68,12 +68,14 @@
     mFollowCredit = 0;
     mFollowArrivedEntry = 0;
     mFollowCreditType = 0;
-    mInvinceabilityHpLevel = 0;
+    mInvincibilityHpLevel = 0;
 }
 
 void SmartAI::UpdateDespawn(const uint32 diff)
 {
-    if (mDespawnState <= 1 || mDespawnState > 3) return;
+    if (mDespawnState <= 1 || mDespawnState > 3)
+        return;
+
     if (mDespawnTime < diff)
     {
         if (mDespawnState == 2)
@@ -638,8 +640,8 @@
 void SmartAI::DamageTaken(Unit* doneBy, uint32& damage)
 {
     GetScript()->ProcessEventsFor(SMART_EVENT_DAMAGED, doneBy, damage);
-    if ((me->GetHealth() - damage) <= mInvinceabilityHpLevel)
-        damage -= mInvinceabilityHpLevel;
+    if ((me->GetHealth() - damage) <= mInvincibilityHpLevel)
+        damage = me->GetHealth() - mInvincibilityHpLevel;
 }
 
 void SmartAI::HealReceived(Unit* doneBy, uint32& addhealth)
@@ -852,7 +854,7 @@
     return PERMIT_BASE_NO;
 }
 
-void SmartGameObjectAI::UpdateAI(const uint32 diff)
+void SmartGameObjectAI::UpdateAI(uint32 diff)
 {
     GetScript()->OnUpdate(diff);
 }
diff -r b4c056460923 -r da13f4f7a26c src/server/game/AI/SmartScripts/SmartAI.h
--- a/src/server/game/AI/SmartScripts/SmartAI.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/AI/SmartScripts/SmartAI.h	Mon Apr 16 14:29:17 2012 +0300
@@ -174,7 +174,7 @@
 
         void SetSwim(bool swim = true);
 
-        void SetInvinceabilityHpLevel(uint32 level) { mInvinceabilityHpLevel = level; }
+        void SetInvincibilityHpLevel(uint32 level) { mInvincibilityHpLevel = level; }
 
         void sGossipHello(Player* player);
         void sGossipSelect(Player* player, uint32 sender, uint32 action);
@@ -223,7 +223,7 @@
         bool mCanAutoAttack;
         bool mCanCombatMove;
         bool mForcedPaused;
-        uint32 mInvinceabilityHpLevel;
+        uint32 mInvincibilityHpLevel;
 
         bool AssistPlayerInCombat(Unit* who);
 
@@ -239,13 +239,13 @@
     SmartGameObjectAI(GameObject* g) : GameObjectAI(g), go(g) {}
     ~SmartGameObjectAI() {}
 
-    void UpdateAI(const uint32 diff);
+    void UpdateAI(uint32 diff);
     void InitializeAI();
     void Reset();
     SmartScript* GetScript() { return &mScript; }
     static int Permissible(const GameObject* g);
 
-    bool GossipHello(Player* player) ;
+    bool GossipHello(Player* player);
     bool GossipSelect(Player* player, uint32 sender, uint32 action);
     bool GossipSelectCode(Player* /*player*/, uint32 /*sender*/, uint32 /*action*/, const char* /*code*/);
     bool QuestAccept(Player* player, Quest const* quest);
diff -r b4c056460923 -r da13f4f7a26c src/server/game/AI/SmartScripts/SmartScript.cpp
--- a/src/server/game/AI/SmartScripts/SmartScript.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/AI/SmartScripts/SmartScript.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -108,8 +108,11 @@
     ResetBaseObject();
     for (SmartAIEventList::iterator i = mEvents.begin(); i != mEvents.end(); ++i)
     {
-        InitTimer((*i));
-        (*i).runOnce = false;
+        if (!((*i).event.event_flags & SMART_EVENT_FLAG_DONT_RESET))
+        {
+            InitTimer((*i));
+            (*i).runOnce = false;
+        }
     }
     ProcessEventsFor(SMART_EVENT_RESET);
     mLastInvoker = 0;
@@ -1043,9 +1046,9 @@
                 break;
 
             if (e.action.invincHP.percent)
-                ai->SetInvinceabilityHpLevel(me->CountPctFromMaxHealth(e.action.invincHP.percent));
+                ai->SetInvincibilityHpLevel(me->CountPctFromMaxHealth(e.action.invincHP.percent));
             else
-                ai->SetInvinceabilityHpLevel(e.action.invincHP.minHP);
+                ai->SetInvincibilityHpLevel(e.action.invincHP.minHP);
             break;
         }
         case SMART_ACTION_SET_DATA:
@@ -1364,13 +1367,14 @@
                 e.GetTargetType() == SMART_TARGET_CREATURE_DISTANCE || e.GetTargetType() == SMART_TARGET_GAMEOBJECT_RANGE ||
                 e.GetTargetType() == SMART_TARGET_GAMEOBJECT_GUID || e.GetTargetType() == SMART_TARGET_GAMEOBJECT_DISTANCE ||
                 e.GetTargetType() == SMART_TARGET_CLOSEST_CREATURE || e.GetTargetType() == SMART_TARGET_CLOSEST_GAMEOBJECT ||
-                e.GetTargetType() == SMART_TARGET_OWNER_OR_SUMMONER)
+                e.GetTargetType() == SMART_TARGET_OWNER_OR_SUMMONER || e.GetTargetType() == SMART_TARGET_ACTION_INVOKER)
             {
                 ObjectList* targets = GetTargets(e, unit);
                 if (!targets)
                     break;
 
                 target = targets->front();
+                delete targets;
             }
 
             if (!target)
@@ -1861,19 +1865,26 @@
             if (!targets)
                 break;
 
+            ObjectList* storedTargets = GetTargetList(e.action.sendTargetToTarget.id);
+            if (!storedTargets)
+            {
+                delete targets;
+                return;
+            }
+
             for (ObjectList::const_iterator itr = targets->begin(); itr != targets->end(); ++itr)
             {
                 if (IsCreature(*itr))
                 {
                     if (SmartAI* ai = CAST_AI(SmartAI, (*itr)->ToCreature()->AI()))
-                        ai->GetScript()->StoreTargetList(GetTargetList(e.action.sendTargetToTarget.id), e.action.sendTargetToTarget.id);
+                        ai->GetScript()->StoreTargetList(new ObjectList(*storedTargets), e.action.sendTargetToTarget.id);   // store a copy of target list
                     else
                         sLog->outErrorDb("SmartScript: Action target for SMART_ACTION_SEND_TARGET_TO_TARGET is not using SmartAI, skipping");
                 }
                 else if (IsGameObject(*itr))
                 {
                     if (SmartGameObjectAI* ai = CAST_AI(SmartGameObjectAI, (*itr)->ToGameObject()->AI()))
-                        ai->GetScript()->StoreTargetList(GetTargetList(e.action.sendTargetToTarget.id), e.action.sendTargetToTarget.id);
+                        ai->GetScript()->StoreTargetList(new ObjectList(*storedTargets), e.action.sendTargetToTarget.id);   // store a copy of target list
                     else
                         sLog->outErrorDb("SmartScript: Action target for SMART_ACTION_SEND_TARGET_TO_TARGET is not using SmartGameObjectAI, skipping");
                 }
@@ -1953,7 +1964,8 @@
             }
         case SMARTAI_TEMPLATE_CAGED_NPC_PART:
             {
-                if (!me) return;
+                if (!me)
+                    return;
                 //store cage as id1
                 AddEvent(SMART_EVENT_DATA_SET, 0, 0, 0, 0, 0, SMART_ACTION_STORE_TARGET_LIST, 1, 0, 0, 0, 0, 0, SMART_TARGET_CLOSEST_GAMEOBJECT, e.action.installTtemplate.param1, 10, 0, 0);
 
@@ -1975,7 +1987,8 @@
             }
         case SMARTAI_TEMPLATE_CAGED_GO_PART:
             {
-                if (!go) return;
+                if (!go)
+                    return;
                 //store hostage as id1
                 AddEvent(SMART_EVENT_GOSSIP_HELLO, 0, 0, 0, 0, 0, SMART_ACTION_STORE_TARGET_LIST, 1, 0, 0, 0, 0, 0, SMART_TARGET_CLOSEST_CREATURE, e.action.installTtemplate.param1, 10, 0, 0);
                 //store invoker as id2
@@ -2838,8 +2851,12 @@
 
 bool SmartScript::ConditionValid(Unit* u, int32 c, int32 v1, int32 v2, int32 v3)
 {
-    if (c == 0) return true;
-    if (!u || !u->ToPlayer()) return false;
+    if (c == 0)
+        return true;
+
+    if (!u || !u->ToPlayer())
+        return false;
+
     Condition cond;
     cond.ConditionType = ConditionTypes(uint32(c));
     cond.ConditionValue1 = uint32(v1);
@@ -3006,7 +3023,9 @@
 {
     ProcessEventsFor(SMART_EVENT_OOC_LOS, who);
 
-    if (!me) return;
+    if (!me)
+        return;
+
     if (me->getVictim())
         return;
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/AI/SmartScripts/SmartScriptMgr.cpp
--- a/src/server/game/AI/SmartScripts/SmartScriptMgr.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/AI/SmartScripts/SmartScriptMgr.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -35,6 +35,14 @@
 {
     uint32 oldMSTime = getMSTime();
 
+    for (UNORDERED_MAP<uint32, WPPath*>::iterator itr = waypoint_map.begin(); itr != waypoint_map.end(); ++itr)
+    {
+        for (WPPath::iterator pathItr = itr->second->begin(); pathItr != itr->second->end(); ++pathItr)
+            delete pathItr->second;
+
+        delete itr->second;
+    }
+
     waypoint_map.clear();
 
     PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_SMARTAI_WP);
@@ -84,6 +92,19 @@
     sLog->outString();
 }
 
+SmartWaypointMgr::~SmartWaypointMgr()
+{
+    for (UNORDERED_MAP<uint32, WPPath*>::iterator itr = waypoint_map.begin(); itr != waypoint_map.end(); ++itr)
+    {
+        for (WPPath::iterator pathItr = itr->second->begin(); pathItr != itr->second->end(); ++pathItr)
+            delete pathItr->second;
+
+        delete itr->second;
+    }
+
+    waypoint_map.clear();
+}
+
 void SmartAIMgr::LoadSmartAIFromDB()
 {
     uint32 oldMSTime = getMSTime();
@@ -177,7 +198,6 @@
         temp.event.raw.param4 = fields[11].GetUInt32();
 
         temp.action.type = (SMART_ACTION)fields[12].GetUInt8();
-
         temp.action.raw.param1 = fields[13].GetUInt32();
         temp.action.raw.param2 = fields[14].GetUInt32();
         temp.action.raw.param3 = fields[15].GetUInt32();
@@ -317,8 +337,11 @@
     if (e.GetScriptType() == SMART_SCRIPT_TYPE_TIMED_ACTIONLIST)
     {
         e.event.type = SMART_EVENT_UPDATE_OOC;//force default OOC, can change when calling the script!
-        if (!IsMinMaxValid(e, e.event.minMaxRepeat.min, e.event.minMaxRepeat.max)) return false;
-        if (!IsMinMaxValid(e, e.event.minMaxRepeat.repeatMin, e.event.minMaxRepeat.repeatMax)) return false;
+        if (!IsMinMaxValid(e, e.event.minMaxRepeat.min, e.event.minMaxRepeat.max))
+            return false;
+
+        if (!IsMinMaxValid(e, e.event.minMaxRepeat.repeatMin, e.event.minMaxRepeat.repeatMax))
+            return false;
     }
     else
     {
@@ -336,8 +359,11 @@
             case SMART_EVENT_DAMAGED:
             case SMART_EVENT_DAMAGED_TARGET:
             case SMART_EVENT_RECEIVE_HEAL:
-                if (!IsMinMaxValid(e, e.event.minMaxRepeat.min, e.event.minMaxRepeat.max)) return false;
-                if (!IsMinMaxValid(e, e.event.minMaxRepeat.repeatMin, e.event.minMaxRepeat.repeatMax)) return false;
+                if (!IsMinMaxValid(e, e.event.minMaxRepeat.min, e.event.minMaxRepeat.max))
+                    return false;
+
+                if (!IsMinMaxValid(e, e.event.minMaxRepeat.repeatMin, e.event.minMaxRepeat.repeatMax))
+                    return false;
                 break;
             case SMART_EVENT_SPELLHIT:
             case SMART_EVENT_SPELLHIT_TARGET:
@@ -355,11 +381,13 @@
                         return false;
                     }
                 }
-                if (!IsMinMaxValid(e, e.event.spellHit.cooldownMin, e.event.spellHit.cooldownMax)) return false;
+                if (!IsMinMaxValid(e, e.event.spellHit.cooldownMin, e.event.spellHit.cooldownMax))
+                    return false;
                 break;
             case SMART_EVENT_OOC_LOS:
             case SMART_EVENT_IC_LOS:
-                if (!IsMinMaxValid(e, e.event.los.cooldownMin, e.event.los.cooldownMax)) return false;
+                if (!IsMinMaxValid(e, e.event.los.cooldownMin, e.event.los.cooldownMax))
+                    return false;
                 break;
             case SMART_EVENT_RESPAWN:
                 if (e.event.respawn.type == SMART_SCRIPT_RESPAWN_CONDITION_MAP && !sMapStore.LookupEntry(e.event.respawn.map))
@@ -374,32 +402,48 @@
                 }
                 break;
             case SMART_EVENT_FRIENDLY_HEALTH:
-                if (!NotNULL(e, e.event.friendlyHealt.radius)) return false;
-                if (!IsMinMaxValid(e, e.event.friendlyHealt.repeatMin, e.event.friendlyHealt.repeatMax)) return false;
+                if (!NotNULL(e, e.event.friendlyHealt.radius))
+                    return false;
+
+                if (!IsMinMaxValid(e, e.event.friendlyHealt.repeatMin, e.event.friendlyHealt.repeatMax))
+                    return false;
                 break;
             case SMART_EVENT_FRIENDLY_IS_CC:
-                if (!IsMinMaxValid(e, e.event.friendlyCC.repeatMin, e.event.friendlyCC.repeatMax)) return false;
+                if (!IsMinMaxValid(e, e.event.friendlyCC.repeatMin, e.event.friendlyCC.repeatMax))
+                    return false;
                 break;
             case SMART_EVENT_FRIENDLY_MISSING_BUFF:
             {
-                if (!IsSpellValid(e, e.event.missingBuff.spell)) return false;
-                if (!NotNULL(e, e.event.missingBuff.radius)) return false;
-                if (!IsMinMaxValid(e, e.event.missingBuff.repeatMin, e.event.missingBuff.repeatMax)) return false;
+                if (!IsSpellValid(e, e.event.missingBuff.spell))
+                    return false;
+
+                if (!NotNULL(e, e.event.missingBuff.radius))
+                    return false;
+
+                if (!IsMinMaxValid(e, e.event.missingBuff.repeatMin, e.event.missingBuff.repeatMax))
+                    return false;
                 break;
             }
             case SMART_EVENT_KILL:
-                if (!IsMinMaxValid(e, e.event.kill.cooldownMin, e.event.kill.cooldownMax)) return false;
-                if (e.event.kill.creature && !IsCreatureValid(e, e.event.kill.creature)) return false;
+                if (!IsMinMaxValid(e, e.event.kill.cooldownMin, e.event.kill.cooldownMax))
+                    return false;
+
+                if (e.event.kill.creature && !IsCreatureValid(e, e.event.kill.creature))
+                    return false;
                 break;
             case SMART_EVENT_TARGET_CASTING:
             case SMART_EVENT_PASSENGER_BOARDED:
             case SMART_EVENT_PASSENGER_REMOVED:
-                if (!IsMinMaxValid(e, e.event.minMax.repeatMin, e.event.minMax.repeatMax)) return false;
+                if (!IsMinMaxValid(e, e.event.minMax.repeatMin, e.event.minMax.repeatMax))
+                    return false;
                 break;
             case SMART_EVENT_SUMMON_DESPAWNED:
             case SMART_EVENT_SUMMONED_UNIT:
-                if (e.event.summoned.creature && !IsCreatureValid(e, e.event.summoned.creature)) return false;
-                if (!IsMinMaxValid(e, e.event.summoned.cooldownMin, e.event.summoned.cooldownMax)) return false;
+                if (e.event.summoned.creature && !IsCreatureValid(e, e.event.summoned.creature))
+                    return false;
+
+                if (!IsMinMaxValid(e, e.event.summoned.cooldownMin, e.event.summoned.cooldownMax))
+                    return false;
                 break;
             case SMART_EVENT_ACCEPTED_QUEST:
             case SMART_EVENT_REWARD_QUEST:
@@ -408,20 +452,27 @@
                 break;
             case SMART_EVENT_RECEIVE_EMOTE:
             {
-                if (e.event.emote.emote && !IsTextEmoteValid(e, e.event.emote.emote)) return false;
-                if (!IsMinMaxValid(e, e.event.emote.cooldownMin, e.event.emote.cooldownMax)) return false;
+                if (e.event.emote.emote && !IsTextEmoteValid(e, e.event.emote.emote))
+                    return false;
+
+                if (!IsMinMaxValid(e, e.event.emote.cooldownMin, e.event.emote.cooldownMax))
+                    return false;
                 break;
             }
             case SMART_EVENT_HAS_AURA:
             case SMART_EVENT_TARGET_BUFFED:
             {
-                if (!IsSpellValid(e, e.event.aura.spell)) return false;
-                if (!IsMinMaxValid(e, e.event.aura.repeatMin, e.event.aura.repeatMax)) return false;
+                if (!IsSpellValid(e, e.event.aura.spell))
+                    return false;
+
+                if (!IsMinMaxValid(e, e.event.aura.repeatMin, e.event.aura.repeatMax))
+                    return false;
                 break;
             }
             case SMART_EVENT_TRANSPORT_ADDCREATURE:
                 {
-                    if (e.event.transportAddCreature.creature && !IsCreatureValid(e, e.event.transportAddCreature.creature)) return false;
+                    if (e.event.transportAddCreature.creature && !IsCreatureValid(e, e.event.transportAddCreature.creature))
+                        return false;
                     break;
                 }
             case SMART_EVENT_MOVEMENTINFORM:
@@ -435,12 +486,14 @@
                 }
             case SMART_EVENT_DATA_SET:
                 {
-                    if (!IsMinMaxValid(e, e.event.dataSet.cooldownMin, e.event.dataSet.cooldownMax)) return false;
+                    if (!IsMinMaxValid(e, e.event.dataSet.cooldownMin, e.event.dataSet.cooldownMax))
+                        return false;
                     break;
                 }
             case SMART_EVENT_AREATRIGGER_ONTRIGGER:
                 {
-                    if (e.event.areatrigger.id && !IsAreaTriggerValid(e, e.event.areatrigger.id)) return false;
+                    if (e.event.areatrigger.id && !IsAreaTriggerValid(e, e.event.areatrigger.id))
+                        return false;
                     break;
                 }
             case SMART_EVENT_TEXT_OVER:
@@ -456,8 +509,11 @@
                     break;
                 }
             case SMART_EVENT_DUMMY_EFFECT:
-                if (!IsSpellValid(e, e.event.dummy.spell)) return false;
-                if (e.event.dummy.effIndex > EFFECT_2) return false;
+                if (!IsSpellValid(e, e.event.dummy.spell))
+                    return false;
+
+                if (e.event.dummy.effIndex > EFFECT_2)
+                    return false;
                 break;
             case SMART_EVENT_IS_BEHIND_TARGET:
                 if (!IsMinMaxValid(e, e.event.behindTarget.cooldownMin, e.event.behindTarget.cooldownMax))
@@ -554,11 +610,13 @@
             break;
         case SMART_ACTION_SET_EMOTE_STATE:
         case SMART_ACTION_PLAY_EMOTE:
-            if (!IsEmoteValid(e, e.action.emote.emote)) return false;
+            if (!IsEmoteValid(e, e.action.emote.emote))
+                return false;
             break;
         case SMART_ACTION_FAIL_QUEST:
         case SMART_ACTION_ADD_QUEST:
-            if (!e.action.quest.quest || !IsQuestValid(e, e.action.quest.quest)) return false;
+            if (!e.action.quest.quest || !IsQuestValid(e, e.action.quest.quest))
+                return false;
             break;
         case SMART_ACTION_ACTIVATE_TAXI:
             {
@@ -570,17 +628,29 @@
                 break;
             }
         case SMART_ACTION_RANDOM_EMOTE:
-            if (e.action.randomEmote.emote1 && !IsEmoteValid(e, e.action.randomEmote.emote1)) return false;
-            if (e.action.randomEmote.emote2 && !IsEmoteValid(e, e.action.randomEmote.emote2)) return false;
-            if (e.action.randomEmote.emote3 && !IsEmoteValid(e, e.action.randomEmote.emote3)) return false;
-            if (e.action.randomEmote.emote4 && !IsEmoteValid(e, e.action.randomEmote.emote4)) return false;
-            if (e.action.randomEmote.emote5 && !IsEmoteValid(e, e.action.randomEmote.emote5)) return false;
-            if (e.action.randomEmote.emote6 && !IsEmoteValid(e, e.action.randomEmote.emote6)) return false;
+            if (e.action.randomEmote.emote1 && !IsEmoteValid(e, e.action.randomEmote.emote1))
+                return false;
+
+            if (e.action.randomEmote.emote2 && !IsEmoteValid(e, e.action.randomEmote.emote2))
+                return false;
+
+            if (e.action.randomEmote.emote3 && !IsEmoteValid(e, e.action.randomEmote.emote3))
+                return false;
+
+            if (e.action.randomEmote.emote4 && !IsEmoteValid(e, e.action.randomEmote.emote4))
+                return false;
+
+            if (e.action.randomEmote.emote5 && !IsEmoteValid(e, e.action.randomEmote.emote5))
+                return false;
+
+            if (e.action.randomEmote.emote6 && !IsEmoteValid(e, e.action.randomEmote.emote6))
+                return false;
             break;
         case SMART_ACTION_ADD_AURA:
         case SMART_ACTION_CAST:
         case SMART_ACTION_INVOKER_CAST:
-            if (!IsSpellValid(e, e.action.cast.spell)) return false;
+            if (!IsSpellValid(e, e.action.cast.spell))
+                return false;
             break;
         case SMART_ACTION_CALL_AREAEXPLOREDOREVENTHAPPENS:
         case SMART_ACTION_CALL_GROUPEVENTHAPPENS:
@@ -599,8 +669,11 @@
             }
             break;
         case SMART_ACTION_SEND_CASTCREATUREORGO:
-            if (!IsQuestValid(e, e.action.castCreatureOrGO.quest)) return false;
-            if (!IsSpellValid(e, e.action.castCreatureOrGO.spell)) return false;
+            if (!IsQuestValid(e, e.action.castCreatureOrGO.quest))
+                return false;
+
+            if (!IsSpellValid(e, e.action.castCreatureOrGO.spell))
+                return false;
             break;
 
 
@@ -624,11 +697,15 @@
             }
             break;
         case SMART_ACTION_CALL_CASTEDCREATUREORGO:
-            if (!IsCreatureValid(e, e.action.castedCreatureOrGO.creature)) return false;
-            if (!IsSpellValid(e, e.action.castedCreatureOrGO.spell)) return false;
+            if (!IsCreatureValid(e, e.action.castedCreatureOrGO.creature))
+                return false;
+
+            if (!IsSpellValid(e, e.action.castedCreatureOrGO.spell))
+                return false;
             break;
         case SMART_ACTION_REMOVEAURASFROMSPELL:
-            if (!IsSpellValid(e, e.action.removeAura.spell)) return false;
+            if (!IsSpellValid(e, e.action.removeAura.spell))
+                return false;
             break;
         case SMART_ACTION_RANDOM_PHASE:
             {
@@ -652,11 +729,13 @@
                     sLog->outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u attempts to set invalid phase, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType());
                     return false;
                 }
-                if (!IsMinMaxValid(e, e.action.randomPhaseRange.phaseMin, e.action.randomPhaseRange.phaseMax)) return false;
+                if (!IsMinMaxValid(e, e.action.randomPhaseRange.phaseMin, e.action.randomPhaseRange.phaseMax))
+                    return false;
                 break;
             }
         case SMART_ACTION_SUMMON_CREATURE:
-            if (!IsCreatureValid(e, e.action.summonCreature.creature)) return false;
+            if (!IsCreatureValid(e, e.action.summonCreature.creature))
+                return false;
             if (e.action.summonCreature.type < TEMPSUMMON_TIMED_OR_DEAD_DESPAWN || e.action.summonCreature.type > TEMPSUMMON_MANUAL_DESPAWN)
             {
                 sLog->outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u uses incorrect TempSummonType %u, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), e.action.summonCreature.type);
@@ -664,10 +743,12 @@
             }
             break;
         case SMART_ACTION_CALL_KILLEDMONSTER:
-            if (!IsCreatureValid(e, e.action.killedMonster.creature)) return false;
+            if (!IsCreatureValid(e, e.action.killedMonster.creature))
+                return false;
             break;
         case SMART_ACTION_UPDATE_TEMPLATE:
-            if (e.action.updateTemplate.creature && !IsCreatureValid(e, e.action.updateTemplate.creature)) return false;
+            if (e.action.updateTemplate.creature && !IsCreatureValid(e, e.action.updateTemplate.creature))
+                return false;
             break;
         case SMART_ACTION_SET_SHEATH:
             if (e.action.setSheath.sheath && e.action.setSheath.sheath >= MAX_SHEATH_STATE)
@@ -686,12 +767,16 @@
                 break;
             }
         case SMART_ACTION_SUMMON_GO:
-            if (!IsGameObjectValid(e, e.action.summonGO.entry)) return false;
+            if (!IsGameObjectValid(e, e.action.summonGO.entry))
+                return false;
             break;
         case SMART_ACTION_ADD_ITEM:
         case SMART_ACTION_REMOVE_ITEM:
-            if (!IsItemValid(e, e.action.item.entry)) return false;
-            if (!NotNULL(e, e.action.item.count)) return false;
+            if (!IsItemValid(e, e.action.item.entry))
+                return false;
+
+            if (!NotNULL(e, e.action.item.count))
+                return false;
             break;
         case SMART_ACTION_TELEPORT:
             if (!sMapStore.LookupEntry(e.action.teleport.mapID))
@@ -708,7 +793,8 @@
             }
             break;
         case SMART_ACTION_WP_STOP:
-            if (e.action.wpStop.quest && !IsQuestValid(e, e.action.wpStop.quest)) return false;
+            if (e.action.wpStop.quest && !IsQuestValid(e, e.action.wpStop.quest))
+                return false;
             break;
         case SMART_ACTION_WP_START:
             {
@@ -717,7 +803,8 @@
                     sLog->outErrorDb("SmartAIMgr: Creature %d Event %u Action %u uses non-existent WaypointPath id %u, skipped.", e.entryOrGuid, e.event_id, e.GetActionType(), e.action.wpStart.pathID);
                     return false;
                 }
-                if (e.action.wpStart.quest && !IsQuestValid(e, e.action.wpStart.quest)) return false;
+                if (e.action.wpStart.quest && !IsQuestValid(e, e.action.wpStart.quest))
+                    return false;
                 if (e.action.wpStart.reactState > REACT_AGGRESSIVE)
                 {
                     sLog->outErrorDb("SmartAIMgr: Creature %d Event %u Action %u uses invalid React State %u, skipped.", e.entryOrGuid, e.event_id, e.GetActionType(), e.action.wpStart.reactState);
@@ -727,8 +814,11 @@
             }
         case SMART_ACTION_CREATE_TIMED_EVENT:
         {
-            if (!IsMinMaxValid(e, e.action.timeEvent.min, e.action.timeEvent.max)) return false;
-            if (!IsMinMaxValid(e, e.action.timeEvent.repeatMin, e.action.timeEvent.repeatMax)) return false;
+            if (!IsMinMaxValid(e, e.action.timeEvent.min, e.action.timeEvent.max))
+                return false;
+
+            if (!IsMinMaxValid(e, e.action.timeEvent.repeatMin, e.action.timeEvent.repeatMax))
+                return false;
             break;
         }
         case SMART_ACTION_FOLLOW:
diff -r b4c056460923 -r da13f4f7a26c src/server/game/AI/SmartScripts/SmartScriptMgr.h
--- a/src/server/game/AI/SmartScripts/SmartScriptMgr.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/AI/SmartScripts/SmartScriptMgr.h	Mon Apr 16 14:29:17 2012 +0300
@@ -1165,14 +1165,15 @@
 
 enum SmartEventFlags
 {
-    SMART_EVENT_FLAG_NOT_REPEATABLE        = 0x01,                     //Event can not repeat
-    SMART_EVENT_FLAG_DIFFICULTY_0          = 0x02,                     //Event only occurs in instance difficulty 0
-    SMART_EVENT_FLAG_DIFFICULTY_1          = 0x04,                     //Event only occurs in instance difficulty 1
-    SMART_EVENT_FLAG_DIFFICULTY_2          = 0x08,                     //Event only occurs in instance difficulty 2
-    SMART_EVENT_FLAG_DIFFICULTY_3          = 0x10,                     //Event only occurs in instance difficulty 3
-    SMART_EVENT_FLAG_RESERVED_5            = 0x20,
-    SMART_EVENT_FLAG_RESERVED_6            = 0x40,
-    SMART_EVENT_FLAG_DEBUG_ONLY            = 0x80,                     //Event only occurs in debug build
+    SMART_EVENT_FLAG_NOT_REPEATABLE        = 0x001,                     //Event can not repeat
+    SMART_EVENT_FLAG_DIFFICULTY_0          = 0x002,                     //Event only occurs in instance difficulty 0
+    SMART_EVENT_FLAG_DIFFICULTY_1          = 0x004,                     //Event only occurs in instance difficulty 1
+    SMART_EVENT_FLAG_DIFFICULTY_2          = 0x008,                     //Event only occurs in instance difficulty 2
+    SMART_EVENT_FLAG_DIFFICULTY_3          = 0x010,                     //Event only occurs in instance difficulty 3
+    SMART_EVENT_FLAG_RESERVED_5            = 0x020,
+    SMART_EVENT_FLAG_RESERVED_6            = 0x040,
+    SMART_EVENT_FLAG_DEBUG_ONLY            = 0x080,                     //Event only occurs in debug build
+    SMART_EVENT_FLAG_DONT_RESET            = 0x100,                     //Event will not reset in SmartScript::OnReset()
 
     SMART_EVENT_FLAG_DIFFICULTY_ALL        = (SMART_EVENT_FLAG_DIFFICULTY_0|SMART_EVENT_FLAG_DIFFICULTY_1|SMART_EVENT_FLAG_DIFFICULTY_2|SMART_EVENT_FLAG_DIFFICULTY_3)
 };
@@ -1230,9 +1231,9 @@
 class SmartWaypointMgr
 {
     friend class ACE_Singleton<SmartWaypointMgr, ACE_Null_Mutex>;
-    SmartWaypointMgr(){};
+    SmartWaypointMgr() {}
     public:
-        ~SmartWaypointMgr(){};
+        ~SmartWaypointMgr();
 
         void LoadFromDB();
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Accounts/AccountMgr.cpp
--- a/src/server/game/Accounts/AccountMgr.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Accounts/AccountMgr.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -53,12 +53,21 @@
 
 AccountOpResult DeleteAccount(uint32 accountId)
 {
-    QueryResult result = LoginDatabase.PQuery("SELECT 1 FROM account WHERE id='%d'", accountId);
+    // Check if accounts exists
+    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_ACCOUNT_BY_ID);
+    stmt->setUInt32(0, accountId);
+    PreparedQueryResult result = LoginDatabase.Query(stmt);
+
     if (!result)
-        return AOR_NAME_NOT_EXIST;                          // account doesn't exist
+        return AOR_NAME_NOT_EXIST;
 
-    // existed characters list
-    result = CharacterDatabase.PQuery("SELECT guid FROM characters WHERE account='%d'", accountId);
+    // Obtain accounts characters
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARS_BY_ACCOUNT_ID);
+
+    stmt->setUInt32(0, accountId);
+
+    result = CharacterDatabase.Query(stmt);
+
     if (result)
     {
         do
@@ -66,7 +75,7 @@
             uint32 guidLow = (*result)[0].GetUInt32();
             uint64 guid = MAKE_NEW_GUID(guidLow, 0, HIGHGUID_PLAYER);
 
-            // kick if player is online
+            // Kick if player is online
             if (Player* p = ObjectAccessor::FindPlayer(guid))
             {
                 WorldSession* s = p->GetSession();
@@ -79,7 +88,7 @@
     }
 
     // table realm specific but common for all characters of account for realm
-    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_TUTORIALS);
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_TUTORIALS);
     stmt->setUInt32(0, accountId);
     CharacterDatabase.Execute(stmt);
     stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ACCOUNT_DATA);
@@ -88,9 +97,17 @@
 
     SQLTransaction trans = LoginDatabase.BeginTransaction();
 
-    trans->PAppend("DELETE FROM account WHERE id='%d'", accountId);
-    trans->PAppend("DELETE FROM account_access WHERE id ='%d'", accountId);
-    trans->PAppend("DELETE FROM realmcharacters WHERE acctid='%d'", accountId);
+    stmt = LoginDatabase.GetPreparedStatement(LOGIN_DEL_ACCOUNT);
+    stmt->setUInt32(0, accountId);
+    trans->Append(stmt);
+
+    stmt = LoginDatabase.GetPreparedStatement(LOGIN_DEL_ACCOUNT_ACCESS);
+    stmt->setUInt32(0, accountId);
+    trans->Append(stmt);
+
+    stmt = LoginDatabase.GetPreparedStatement(LOGIN_DEL_REALM_CHARACTERS);
+    stmt->setUInt32(0, accountId);
+    trans->Append(stmt);
 
     LoginDatabase.CommitTransaction(trans);
 
@@ -99,9 +116,13 @@
 
 AccountOpResult ChangeUsername(uint32 accountId, std::string newUsername, std::string newPassword)
 {
-    QueryResult result = LoginDatabase.PQuery("SELECT 1 FROM account WHERE id='%d'", accountId);
+    // Check if accounts exists
+    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_ACCOUNT_BY_ID);
+    stmt->setUInt32(0, accountId);
+    PreparedQueryResult result = LoginDatabase.Query(stmt);
+
     if (!result)
-        return AOR_NAME_NOT_EXIST;                          // account doesn't exist
+        return AOR_NAME_NOT_EXIST;
 
     if (utf8length(newUsername) > MAX_ACCOUNT_STR)
         return AOR_NAME_TOO_LONG;
@@ -112,7 +133,7 @@
     normalizeString(newUsername);
     normalizeString(newPassword);
 
-    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_UPD_USERNAME);
+    stmt = LoginDatabase.GetPreparedStatement(LOGIN_UPD_USERNAME);
 
     stmt->setString(0, newUsername);
     stmt->setString(1, CalculateShaPassHash(newUsername, newPassword));
@@ -148,28 +169,38 @@
 
 uint32 GetId(std::string username)
 {
-    LoginDatabase.EscapeString(username);
-    QueryResult result = LoginDatabase.PQuery("SELECT id FROM account WHERE username = '%s'", username.c_str());
+    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_GET_ACCOUNT_ID_BY_USERNAME);
+    stmt->setString(0, username);
+    PreparedQueryResult result = LoginDatabase.Query(stmt);
+
     return (result) ? (*result)[0].GetUInt32() : 0;
 }
 
 uint32 GetSecurity(uint32 accountId)
 {
-    QueryResult result = LoginDatabase.PQuery("SELECT gmlevel FROM account_access WHERE id = '%u'", accountId);
-    return (result) ? (*result)[0].GetUInt32() : 0;
+    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_GET_ACCOUNT_ACCESS_GMLEVEL);
+    stmt->setUInt32(0, accountId);
+    PreparedQueryResult result = LoginDatabase.Query(stmt);
+
+    return (result) ? (*result)[0].GetUInt8() : uint32(SEC_PLAYER);
 }
 
-uint32 GetSecurity(uint64 accountId, int32 realmId)
+uint32 GetSecurity(uint32 accountId, int32 realmId)
 {
-    QueryResult result = (realmId == -1)
-        ? LoginDatabase.PQuery("SELECT gmlevel FROM account_access WHERE id = '%u' AND RealmID = '%d'", accountId, realmId)
-        : LoginDatabase.PQuery("SELECT gmlevel FROM account_access WHERE id = '%u' AND (RealmID = '%d' OR RealmID = '-1')", accountId, realmId);
-    return (result) ? (*result)[0].GetUInt32() : 0;
+    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_GET_GMLEVEL_BY_REALMID);
+    stmt->setUInt32(0, accountId);
+    stmt->setInt32(1, realmId);
+    PreparedQueryResult result = LoginDatabase.Query(stmt);
+
+    return (result) ? (*result)[0].GetUInt8() : uint32(SEC_PLAYER);
 }
 
 bool GetName(uint32 accountId, std::string& name)
 {
-    QueryResult result = LoginDatabase.PQuery("SELECT username FROM account WHERE id = '%u'", accountId);
+    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_GET_USERNAME_BY_ID);
+    stmt->setUInt32(0, accountId);
+    PreparedQueryResult result = LoginDatabase.Query(stmt);
+
     if (result)
     {
         name = (*result)[0].GetString();
@@ -189,15 +220,22 @@
     normalizeString(username);
     normalizeString(password);
 
-    QueryResult result = LoginDatabase.PQuery("SELECT 1 FROM account WHERE id='%d' AND sha_pass_hash='%s'", accountId, CalculateShaPassHash(username, password).c_str());
+    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_CHECK_PASSWORD);
+    stmt->setUInt32(0, accountId);
+    stmt->setString(1, CalculateShaPassHash(username, password));
+    PreparedQueryResult result = LoginDatabase.Query(stmt);
+
     return (result) ? true : false;
 }
 
 uint32 GetCharactersCount(uint32 accountId)
 {
     // check character count
-    QueryResult result = CharacterDatabase.PQuery("SELECT COUNT(guid) FROM characters WHERE account = '%d'", accountId);
-    return (result) ? (*result)[0].GetUInt32() : 0;
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_SUM_CHARS);
+    stmt->setUInt32(0, accountId);
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+    return (result) ? (*result)[0].GetUInt64() : 0;
 }
 
 bool normalizeString(std::string& utf8String)
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Accounts/AccountMgr.h
--- a/src/server/game/Accounts/AccountMgr.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Accounts/AccountMgr.h	Mon Apr 16 14:29:17 2012 +0300
@@ -44,7 +44,7 @@
 
     uint32 GetId(std::string username);
     uint32 GetSecurity(uint32 accountId);
-    uint32 GetSecurity(uint64 accountId, int32 realmId);
+    uint32 GetSecurity(uint32 accountId, int32 realmId);
     bool GetName(uint32 accountId, std::string& name);
     uint32 GetCharactersCount(uint32 accountId);
     std::string CalculateShaPassHash(std::string& name, std::string& password);
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Achievements/AchievementMgr.cpp
--- a/src/server/game/Achievements/AchievementMgr.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Achievements/AchievementMgr.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -514,8 +514,15 @@
 void AchievementMgr::DeleteFromDB(uint32 lowguid)
 {
     SQLTransaction trans = CharacterDatabase.BeginTransaction();
-    trans->PAppend("DELETE FROM character_achievement WHERE guid = %u", lowguid);
-    trans->PAppend("DELETE FROM character_achievement_progress WHERE guid = %u", lowguid);
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACHIEVEMENT);
+    stmt->setUInt32(0, lowguid);
+    trans->Append(stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACHIEVEMENT_PROGRESS);
+    stmt->setUInt32(0, lowguid);
+    trans->Append(stmt);
+
     CharacterDatabase.CommitTransaction(trans);
 }
 
@@ -643,7 +650,7 @@
 
             // title achievement rewards are retroactive
             if (AchievementReward const* reward = sAchievementMgr->GetAchievementReward(achievement))
-                if (uint32 titleId = reward->titleId[GetPlayer()->GetTeam() == ALLIANCE ? 0 : 1])
+                if (uint32 titleId = reward->titleId[Player::TeamForRace(GetPlayer()->getRace()) == ALLIANCE ? 0 : 1])
                     if (CharTitlesEntry const* titleEntry = sCharTitlesStore.LookupEntry(titleId))
                         if (!GetPlayer()->HasTitle(titleEntry))
                             GetPlayer()->SetTitle(titleEntry);
@@ -1503,7 +1510,7 @@
                 if (!miscValue1)
                 {
                     uint32 points = 0;
-                    for (CompletedAchievementMap::iterator itr =  m_completedAchievements.begin(); itr != m_completedAchievements.end(); ++itr)
+                    for (CompletedAchievementMap::iterator itr = m_completedAchievements.begin(); itr != m_completedAchievements.end(); ++itr)
                         if (AchievementEntry const* pAchievement = sAchievementStore.LookupEntry(itr->first))
                             points += pAchievement->points;
                     SetCriteriaProgress(achievementCriteria, points, PROGRESS_SET);
@@ -2050,7 +2057,7 @@
         return;
 
     SendAchievementEarned(achievement);
-    CompletedAchievementData& ca =  m_completedAchievements[achievement->ID];
+    CompletedAchievementData& ca = m_completedAchievements[achievement->ID];
     ca.date = time(NULL);
     ca.changed = true;
 
@@ -2081,7 +2088,7 @@
     // mail
     if (reward->sender)
     {
-        Item* item = reward->itemId ? Item::CreateItem(reward->itemId, 1, GetPlayer ()) : NULL;
+        Item* item = reward->itemId ? Item::CreateItem(reward->itemId, 1, GetPlayer()) : NULL;
 
         int loc_idx = GetPlayer()->GetSession()->GetSessionDbLocaleIndex();
 
@@ -2302,7 +2309,7 @@
             continue;
         }
 
-        uint32 dataType = fields[1].GetUInt32();
+        uint32 dataType = fields[1].GetUInt8();
         const char* scriptName = fields[4].GetCString();
         uint32 scriptId = 0;
         if (strcmp(scriptName, "")) // not empty
@@ -2435,7 +2442,7 @@
     {
         Field* fields = result->Fetch();
 
-        uint32 achievementId = fields[0].GetUInt32();
+        uint16 achievementId = fields[0].GetUInt16();
         const AchievementEntry* achievement = sAchievementStore.LookupEntry(achievementId);
         if (!achievement)
         {
diff -r b4c056460923 -r da13f4f7a26c src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.cpp
--- a/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -843,7 +843,7 @@
         QueryResult results = QueryResult(NULL);
         char npcQuery[] = "SELECT distinct item FROM npc_vendor";
         results = WorldDatabase.Query(npcQuery);
-        if (results != NULL)
+        if (results)
         {
             do
             {
@@ -869,7 +869,7 @@
             "SELECT item FROM skinning_loot_template";
 
         results = WorldDatabase.Query(lootQuery);
-        if (results != NULL)
+        if (results)
         {
             do
             {
diff -r b4c056460923 -r da13f4f7a26c src/server/game/AuctionHouse/AuctionHouseMgr.cpp
--- a/src/server/game/AuctionHouse/AuctionHouseMgr.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/AuctionHouse/AuctionHouseMgr.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -487,7 +487,9 @@
     if (AuctionsMap.empty())
         return;
 
-    QueryResult result = CharacterDatabase.PQuery("SELECT id FROM auctionhouse WHERE time <= %u ORDER BY TIME ASC", (uint32)curTime+60);
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_AUCTION_BY_TIME);
+    stmt->setUInt32(0, (uint32)curTime+60);
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
 
     if (!result)
         return;
@@ -798,7 +800,7 @@
 
         AuctionEntry* auction = new AuctionEntry();
 
-         // Can't use LoadFromDB() because it assumes the auction map is loaded
+        // Can't use LoadFromDB() because it assumes the auction map is loaded
         if (!auction->LoadFromFieldList(fields))
         {
             // For some reason the record in the DB is broken (possibly corrupt
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Battlegrounds/ArenaTeam.cpp
--- a/src/server/game/Battlegrounds/ArenaTeam.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Battlegrounds/ArenaTeam.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -145,7 +145,7 @@
 
     uint32 matchMakerRating;
     if (result)
-        matchMakerRating = (*result)[0].GetUInt32();
+        matchMakerRating = (*result)[0].GetUInt16();
     else
         matchMakerRating = sWorld->getIntConfig(CONFIG_ARENA_START_MATCHMAKER_RATING);
 
@@ -306,11 +306,13 @@
 {
     // Remove member from team
     for (MemberList::iterator itr = Members.begin(); itr != Members.end(); ++itr)
+    {
         if (itr->Guid == guid)
         {
             Members.erase(itr);
             break;
         }
+    }
 
     // Inform player and remove arena team info from player data
     if (Player* player = ObjectAccessor::FindPlayer(guid))
@@ -721,7 +723,7 @@
 void ArenaTeam::MemberLost(Player* player, uint32 againstMatchmakerRating, int32 MatchmakerRatingChange)
 {
     // Called for each participant of a match after losing
-    for (MemberList::iterator itr = Members.begin(); itr !=  Members.end(); ++itr)
+    for (MemberList::iterator itr = Members.begin(); itr != Members.end(); ++itr)
     {
         if (itr->Guid == player->GetGUID())
         {
@@ -747,7 +749,7 @@
 void ArenaTeam::OfflineMemberLost(uint64 guid, uint32 againstMatchmakerRating, int32 MatchmakerRatingChange)
 {
     // Called for offline player after ending rated arena match!
-    for (MemberList::iterator itr = Members.begin(); itr !=  Members.end(); ++itr)
+    for (MemberList::iterator itr = Members.begin(); itr != Members.end(); ++itr)
     {
         if (itr->Guid == guid)
         {
@@ -769,7 +771,7 @@
 void ArenaTeam::MemberWon(Player* player, uint32 againstMatchmakerRating, int32 MatchmakerRatingChange)
 {
     // called for each participant after winning a match
-    for (MemberList::iterator itr = Members.begin(); itr !=  Members.end(); ++itr)
+    for (MemberList::iterator itr = Members.begin(); itr != Members.end(); ++itr)
     {
         if (itr->Guid == player->GetGUID())
         {
@@ -804,7 +806,7 @@
     // To get points, a player has to participate in at least 30% of the matches
     uint32 requiredGames = (uint32)ceil(Stats.WeekGames * 0.3f);
 
-    for (MemberList::const_iterator itr = Members.begin(); itr !=  Members.end(); ++itr)
+    for (MemberList::const_iterator itr = Members.begin(); itr != Members.end(); ++itr)
     {
         // The player participated in enough games, update his points
         uint32 pointsToAdd = 0;
@@ -840,7 +842,7 @@
     stmt->setUInt32(6, GetId());
     trans->Append(stmt);
 
-    for (MemberList::const_iterator itr = Members.begin(); itr !=  Members.end(); ++itr)
+    for (MemberList::const_iterator itr = Members.begin(); itr != Members.end(); ++itr)
     {
         stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_ARENA_TEAM_MEMBER);
         stmt->setUInt16(0, itr->PersonalRating);
@@ -869,7 +871,7 @@
     Stats.WeekWins = 0;
 
     // Reset member stats
-    for (MemberList::iterator itr = Members.begin(); itr !=  Members.end(); ++itr)
+    for (MemberList::iterator itr = Members.begin(); itr != Members.end(); ++itr)
     {
         itr->WeekGames = 0;
         itr->WeekWins = 0;
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Battlegrounds/ArenaTeamMgr.cpp
--- a/src/server/game/Battlegrounds/ArenaTeamMgr.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Battlegrounds/ArenaTeamMgr.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -94,10 +94,10 @@
     // Clean out the trash before loading anything
     CharacterDatabase.Execute("DELETE FROM arena_team_member WHERE arenaTeamId NOT IN (SELECT arenaTeamId FROM arena_team)");       // One-time query
 
-    //                                                                   0        1         2         3          4              5            6            7           8
-    QueryResult result = CharacterDatabase.Query("SELECT arena_team.arenaTeamId, name, captainGuid, type, backgroundColor, emblemStyle, emblemColor, borderStyle, borderColor, "
-        //                                               9        10        11         12           13       14
-        "rating, weekGames, weekWins, seasonGames, seasonWins, rank FROM arena_team ORDER BY arena_team.arenaTeamId ASC");
+    //                                                        0        1         2         3          4              5            6            7           8
+    QueryResult result = CharacterDatabase.Query("SELECT arenaTeamId, name, captainGuid, type, backgroundColor, emblemStyle, emblemColor, borderStyle, borderColor, "
+    //      9        10        11         12           13       14
+        "rating, weekGames, weekWins, seasonGames, seasonWins, rank FROM arena_team ORDER BY arenaTeamId ASC");
 
     if (!result)
     {
@@ -153,6 +153,8 @@
 
     SQLTransaction trans = CharacterDatabase.BeginTransaction();
 
+    PreparedStatement* stmt;
+
     // Cycle that gives points to all players
     for (std::map<uint32, uint32>::iterator playerItr = PlayerPoints.begin(); playerItr != PlayerPoints.end(); ++playerItr)
     {
@@ -160,7 +162,12 @@
         if (Player* player = HashMapHolder<Player>::Find(playerItr->first))
             player->ModifyArenaPoints(playerItr->second, &trans);
         else    // Update database
-            trans->PAppend("UPDATE characters SET arenaPoints=arenaPoints+%u WHERE guid=%u", playerItr->second, playerItr->first);
+        {
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_ARENA_POINTS);
+            stmt->setUInt32(0, playerItr->second);
+            stmt->setUInt32(1, playerItr->first);
+            trans->Append(stmt);
+        }
     }
 
     CharacterDatabase.CommitTransaction(trans);
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Battlegrounds/Battleground.cpp
--- a/src/server/game/Battlegrounds/Battleground.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Battlegrounds/Battleground.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -21,7 +21,6 @@
 #include "ArenaTeamMgr.h"
 #include "World.h"
 #include "WorldPacket.h"
-
 #include "ArenaTeam.h"
 #include "Battleground.h"
 #include "BattlegroundMgr.h"
@@ -66,7 +65,7 @@
         private:
             void do_helper(WorldPacket& data, char const* text)
             {
-                uint64 target_guid = _source  ? _source ->GetGUID() : 0;
+                uint64 target_guid = _source ? _source->GetGUID() : 0;
 
                 data << uint8 (_msgtype);
                 data << uint32(LANG_UNIVERSAL);
@@ -145,6 +144,7 @@
     m_Winner            = 2;
     m_StartTime         = 0;
     m_ResetStatTimer    = 0;
+    m_ValidStartPositionTimer = 0;
     m_Events            = 0;
     m_IsRated           = false;
     m_BuffChange        = false;
@@ -178,6 +178,8 @@
     m_ArenaTeamIds[BG_TEAM_ALLIANCE]   = 0;
     m_ArenaTeamIds[BG_TEAM_HORDE]      = 0;
 
+    m_StartMaxDist = 0.0f;
+
     m_ArenaTeamRatingChanges[BG_TEAM_ALLIANCE]   = 0;
     m_ArenaTeamRatingChanges[BG_TEAM_HORDE]      = 0;
 
@@ -259,9 +261,7 @@
     {
         case STATUS_WAIT_JOIN:
             if (GetPlayersSize())
-            {
                 _ProcessJoin(diff);
-            }
             break;
         case STATUS_IN_PROGRESS:
             _ProcessOfflineQueue();
@@ -294,6 +294,7 @@
     // Update start time and reset stats timer
     m_StartTime += diff;
     m_ResetStatTimer += diff;
+    m_ValidStartPositionTimer += diff;
 
     PostUpdateImpl(diff);
 }
@@ -425,7 +426,7 @@
     // *********************************************************
     ModifyStartDelayTime(diff);
 
-    if (m_ResetStatTimer <= 5000)
+    if (m_ResetStatTimer > 5000)
     {
         m_ResetStatTimer = 0;
         for (BattlegroundPlayerMap::const_iterator itr = GetPlayers().begin(); itr != GetPlayers().end(); ++itr)
@@ -456,19 +457,19 @@
         // First start warning - 2 or 1 minute
         SendMessageToAll(StartMessageIds[BG_STARTING_EVENT_FIRST], CHAT_MSG_BG_SYSTEM_NEUTRAL);
     }
-    // After 1 minute or 30 seconds, warning is signalled
+    // After 1 minute or 30 seconds, warning is signaled
     else if (GetStartDelayTime() <= StartDelayTimes[BG_STARTING_EVENT_SECOND] && !(m_Events & BG_STARTING_EVENT_2))
     {
         m_Events |= BG_STARTING_EVENT_2;
         SendMessageToAll(StartMessageIds[BG_STARTING_EVENT_SECOND], CHAT_MSG_BG_SYSTEM_NEUTRAL);
     }
-    // After 30 or 15 seconds, warning is signalled
+    // After 30 or 15 seconds, warning is signaled
     else if (GetStartDelayTime() <= StartDelayTimes[BG_STARTING_EVENT_THIRD] && !(m_Events & BG_STARTING_EVENT_3))
     {
         m_Events |= BG_STARTING_EVENT_3;
         SendMessageToAll(StartMessageIds[BG_STARTING_EVENT_THIRD], CHAT_MSG_BG_SYSTEM_NEUTRAL);
     }
-    // Delay expired (atfer 2 or 1 minute)
+    // Delay expired (after 2 or 1 minute)
     else if (GetStartDelayTime() <= 0 && !(m_Events & BG_STARTING_EVENT_4))
     {
         m_Events |= BG_STARTING_EVENT_4;
@@ -529,6 +530,33 @@
                 sWorld->SendWorldText(LANG_BG_STARTED_ANNOUNCE_WORLD, GetName(), GetMinLevel(), GetMaxLevel());
         }
     }
+
+    // Find if the player left our start zone; if so, teleport it back
+    if (m_ValidStartPositionTimer > 1000)
+    {
+        m_ValidStartPositionTimer = 0;
+        float maxDist = GetStartMaxDist();
+        if (maxDist > 0.0f)
+        {
+            for (BattlegroundPlayerMap::const_iterator itr = GetPlayers().begin(); itr != GetPlayers().end(); ++itr)
+            {
+                if (Player *plr = ObjectAccessor::FindPlayer(itr->first))
+                {
+                    float x, y, z, o;
+                    uint32 team = plr->GetBGTeam();
+                    GetTeamStartLoc(team, x, y, z, o);
+
+                    float dist = plr->GetDistance(x, y, z);
+
+                    if (dist >= maxDist)
+                    {
+                        sLog->outError("BATTLEGROUND: Sending %s back to start location (possible exploit)", plr->GetName());
+                        plr->TeleportTo(GetMapId(), x, y, z, o);
+                    }
+                }
+            }
+        }
+    }
 }
 
 inline void Battleground::_ProcessLeave(uint32 diff)
@@ -1469,9 +1497,8 @@
         // If doors are open, close it
         if (obj->getLootState() == GO_ACTIVATED && obj->GetGoState() != GO_STATE_READY)
         {
-            // Change state to allow door to be closed
             obj->SetLootState(GO_READY);
-            obj->UseDoorOrButton(RESPAWN_ONE_DAY);
+            obj->SetGoState(GO_STATE_READY);
         }
     }
     else
@@ -1483,9 +1510,8 @@
 {
     if (GameObject* obj = GetBgMap()->GetGameObject(BgObjects[type]))
     {
-        // Change state to be sure they will be opened
-        obj->SetLootState(GO_READY);
-        obj->UseDoorOrButton(RESPAWN_ONE_DAY);
+        obj->SetLootState(GO_ACTIVATED);
+        obj->SetGoState(GO_STATE_ACTIVE);
     }
     else
         sLog->outError("Battleground::DoorOpen: door gameobject (type: %u, GUID: %u) not found for BG (map: %u, instance id: %u)!",
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Battlegrounds/Battleground.h
--- a/src/server/game/Battlegrounds/Battleground.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Battlegrounds/Battleground.h	Mon Apr 16 14:29:17 2012 +0300
@@ -442,6 +442,8 @@
             Z = m_TeamStartLocZ[idx];
             O = m_TeamStartLocO[idx];
         }
+        void SetStartMaxDist(float startMaxDist) { m_StartMaxDist = startMaxDist; }
+        float GetStartMaxDist() const { return m_StartMaxDist; }
 
         // Packet Transfer
         // method that should fill worldpacket with actual world states (not yet implemented for all battlegrounds!)
@@ -616,6 +618,7 @@
         uint32 m_ClientInstanceID;                          // the instance-id which is sent to the client and without any other internal use
         uint32 m_StartTime;
         uint32 m_ResetStatTimer;
+        uint32 m_ValidStartPositionTimer;
         int32 m_EndTime;                                    // it is set to 120000 when bg is ending and it decreases itself
         uint32 m_LastResurrectTime;
         BattlegroundBracketId m_BracketId;
@@ -697,6 +700,7 @@
         float m_TeamStartLocY[BG_TEAMS_COUNT];
         float m_TeamStartLocZ[BG_TEAMS_COUNT];
         float m_TeamStartLocO[BG_TEAMS_COUNT];
+        float m_StartMaxDist;
         uint32 ScriptId;
 };
 #endif
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Battlegrounds/BattlegroundMgr.cpp
--- a/src/server/game/Battlegrounds/BattlegroundMgr.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Battlegrounds/BattlegroundMgr.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -660,6 +660,7 @@
     bg->SetName(data.BattlegroundName);
     bg->SetTeamStartLoc(ALLIANCE, data.Team1StartLocX, data.Team1StartLocY, data.Team1StartLocZ, data.Team1StartLocO);
     bg->SetTeamStartLoc(HORDE,    data.Team2StartLocX, data.Team2StartLocY, data.Team2StartLocZ, data.Team2StartLocO);
+    bg->SetStartMaxDist(data.StartMaxDist);
     bg->SetLevelRange(data.LevelMin, data.LevelMax);
     bg->SetScriptId(data.scriptId);
 
@@ -677,8 +678,8 @@
     uint8 selectionWeight;
     BattlemasterListEntry const* bl;
 
-    //                                               0   1                  2                  3       4       5                 6               7              8            9       10
-    QueryResult result = WorldDatabase.Query("SELECT id, MinPlayersPerTeam, MaxPlayersPerTeam, MinLvl, MaxLvl, AllianceStartLoc, AllianceStartO, HordeStartLoc, HordeStartO, Weight, ScriptName FROM battleground_template");
+    //                                               0   1                  2                  3       4       5                 6               7              8            9             10      11
+    QueryResult result = WorldDatabase.Query("SELECT id, MinPlayersPerTeam, MaxPlayersPerTeam, MinLvl, MaxLvl, AllianceStartLoc, AllianceStartO, HordeStartLoc, HordeStartO, StartMaxDist, Weight, ScriptName FROM battleground_template");
 
     if (!result)
     {
@@ -708,21 +709,24 @@
         CreateBattlegroundData data;
         data.bgTypeId = BattlegroundTypeId(bgTypeID_);
         data.IsArena = (bl->type == TYPE_ARENA);
-        data.MinPlayersPerTeam = fields[1].GetUInt32();
-        data.MaxPlayersPerTeam = fields[2].GetUInt32();
-        data.LevelMin = fields[3].GetUInt32();
-        data.LevelMax = fields[4].GetUInt32();
-        //check values from DB
-        if (data.MaxPlayersPerTeam == 0 || data.MinPlayersPerTeam == 0 || data.MinPlayersPerTeam > data.MaxPlayersPerTeam)
+        data.MinPlayersPerTeam = fields[1].GetUInt16();
+        data.MaxPlayersPerTeam = fields[2].GetUInt16();
+        data.LevelMin = fields[3].GetUInt8();
+        data.LevelMax = fields[4].GetUInt8();
+
+        // check values from DB
+        if (data.MaxPlayersPerTeam == 0 || data.MinPlayersPerTeam > data.MaxPlayersPerTeam)
         {
-            data.MinPlayersPerTeam = 0;                          // by default now expected strong full bg requirement
-            data.MaxPlayersPerTeam = 40;
+            sLog->outErrorDb("Table `battleground_template` for id %u has bad values for MinPlayersPerTeam (%u) and MaxPlayersPerTeam(%u)",
+                data.bgTypeId, data.MinPlayersPerTeam, data.MaxPlayersPerTeam);
+            continue;
         }
+
         if (data.LevelMin == 0 || data.LevelMax == 0 || data.LevelMin > data.LevelMax)
         {
-            //TO-DO: FIX ME
-            data.LevelMin = 0;//bl->minlvl;
-            data.LevelMax = 80;//bl->maxlvl;
+            sLog->outErrorDb("Table `battleground_template` for id %u has bad values for LevelMin (%u) and LevelMax(%u)",
+                data.bgTypeId, data.LevelMin, data.LevelMax);
+            continue;
         }
 
         startId = fields[5].GetUInt32();
@@ -767,8 +771,10 @@
             continue;
         }
 
-        selectionWeight = fields[9].GetUInt8();
-        data.scriptId = sObjectMgr->GetScriptId(fields[10].GetCString());
+        data.StartMaxDist = fields[9].GetFloat();
+        
+        selectionWeight = fields[10].GetUInt8();
+        data.scriptId = sObjectMgr->GetScriptId(fields[11].GetCString());
         data.BattlegroundName = bl->name[sWorld->GetDefaultDbcLocale()];
         data.MapID = bl->mapid[0];
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Battlegrounds/BattlegroundMgr.h
--- a/src/server/game/Battlegrounds/BattlegroundMgr.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Battlegrounds/BattlegroundMgr.h	Mon Apr 16 14:29:17 2012 +0300
@@ -50,6 +50,7 @@
     float Team2StartLocY;
     float Team2StartLocZ;
     float Team2StartLocO;
+    float StartMaxDist;
     uint32 scriptId;
 };
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Battlegrounds/BattlegroundQueue.cpp
--- a/src/server/game/Battlegrounds/BattlegroundQueue.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Battlegrounds/BattlegroundQueue.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -129,7 +129,7 @@
 // add group or player (grp == NULL) to bg queue with the given leader and bg specifications
 GroupQueueInfo* BattlegroundQueue::AddGroup(Player* leader, Group* grp, BattlegroundTypeId BgTypeId, PvPDifficultyEntry const*  bracketEntry, uint8 ArenaType, bool isRated, bool isPremade, uint32 ArenaRating, uint32 MatchmakerRating, uint32 arenateamid)
 {
-    BattlegroundBracketId bracketId =  bracketEntry->GetBracketId();
+    BattlegroundBracketId bracketId = bracketEntry->GetBracketId();
 
     // create new ginfo
     GroupQueueInfo* ginfo            = new GroupQueueInfo;
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp
--- a/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -549,7 +549,7 @@
 
 bool BattlegroundAB::SetupBattleground()
 {
-    for (int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT; ++i)
+    for (int i = 0; i < BG_AB_DYNAMIC_NODES_COUNT; ++i)
     {
         if (!AddObject(BG_AB_OBJECT_BANNER_NEUTRAL + 8*i, BG_AB_OBJECTID_NODE_BANNER_0 + i, BG_AB_NodePositions[i][0], BG_AB_NodePositions[i][1], BG_AB_NodePositions[i][2], BG_AB_NodePositions[i][3], 0, 0, sin(BG_AB_NodePositions[i][3]/2), cos(BG_AB_NodePositions[i][3]/2), RESPAWN_ONE_DAY)
             || !AddObject(BG_AB_OBJECT_BANNER_CONT_A + 8*i, BG_AB_OBJECTID_BANNER_CONT_A, BG_AB_NodePositions[i][0], BG_AB_NodePositions[i][1], BG_AB_NodePositions[i][2], BG_AB_NodePositions[i][3], 0, 0, sin(BG_AB_NodePositions[i][3]/2), cos(BG_AB_NodePositions[i][3]/2), RESPAWN_ONE_DAY)
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Battlegrounds/Zones/BattlegroundAB.h
--- a/src/server/game/Battlegrounds/Zones/BattlegroundAB.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundAB.h	Mon Apr 16 14:29:17 2012 +0300
@@ -184,7 +184,8 @@
 #define AB_EVENT_START_BATTLE               9158 // Achievement: Let's Get This Done
 
 // x, y, z, o
-const float BG_AB_NodePositions[BG_AB_DYNAMIC_NODES_COUNT][4] = {
+const float BG_AB_NodePositions[BG_AB_DYNAMIC_NODES_COUNT][4] =
+{
     {1166.785f, 1200.132f, -56.70859f, 0.9075713f},         // stables
     {977.0156f, 1046.616f, -44.80923f, -2.600541f},         // blacksmith
     {806.1821f, 874.2723f, -55.99371f, -2.303835f},         // farm
@@ -193,7 +194,8 @@
 };
 
 // x, y, z, o, rot0, rot1, rot2, rot3
-const float BG_AB_DoorPositions[2][8] = {
+const float BG_AB_DoorPositions[2][8] =
+{
     {1284.597f, 1281.167f, -15.97792f, 0.7068594f, 0.012957f, -0.060288f, 0.344959f, 0.93659f},
     {708.0903f, 708.4479f, -17.8342f, -2.391099f, 0.050291f, 0.015127f, 0.929217f, -0.365784f}
 };
@@ -206,7 +208,8 @@
 const uint32 BG_AB_GraveyardIds[BG_AB_ALL_NODES_COUNT] = {895, 894, 893, 897, 896, 898, 899};
 
 // x, y, z, o
-const float BG_AB_BuffPositions[BG_AB_DYNAMIC_NODES_COUNT][4] = {
+const float BG_AB_BuffPositions[BG_AB_DYNAMIC_NODES_COUNT][4] =
+{
     {1185.71f, 1185.24f, -56.36f, 2.56f},                   // stables
     {990.75f, 1008.18f, -42.60f, 2.43f},                    // blacksmith
     {817.66f, 843.34f, -56.54f, 3.01f},                     // farm
@@ -215,7 +218,8 @@
 };
 
 // x, y, z, o
-const float BG_AB_SpiritGuidePos[BG_AB_ALL_NODES_COUNT][4] = {
+const float BG_AB_SpiritGuidePos[BG_AB_ALL_NODES_COUNT][4] =
+{
     {1200.03f, 1171.09f, -56.47f, 5.15f},                   // stables
     {1017.43f, 960.61f, -42.95f, 4.88f},                    // blacksmith
     {833.00f, 793.00f, -57.25f, 5.27f},                     // farm
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Battlegrounds/Zones/BattlegroundAV.cpp
--- a/src/server/game/Battlegrounds/Zones/BattlegroundAV.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundAV.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -1208,7 +1208,7 @@
     }
 
     //spawn node-objects
-    for (uint8 i = BG_AV_NODES_FIRSTAID_STATION ; i < BG_AV_NODES_MAX; ++i)
+    for (uint8 i = BG_AV_NODES_FIRSTAID_STATION; i < BG_AV_NODES_MAX; ++i)
     {
         if (i <= BG_AV_NODES_FROSTWOLF_HUT)
         {
@@ -1293,7 +1293,7 @@
             return false;
         }
     }
-    for (uint16 i= 0 ; i <= (BG_AV_OBJECT_MINE_SUPPLY_S_MAX-BG_AV_OBJECT_MINE_SUPPLY_S_MIN); i++)
+    for (uint16 i= 0; i <= (BG_AV_OBJECT_MINE_SUPPLY_S_MAX-BG_AV_OBJECT_MINE_SUPPLY_S_MIN); i++)
     {
         if (!AddObject(BG_AV_OBJECT_MINE_SUPPLY_S_MIN+i, BG_AV_OBJECTID_MINE_S, BG_AV_ObjectPos[AV_OPLACE_MINE_SUPPLY_S_MIN+i][0], BG_AV_ObjectPos[AV_OPLACE_MINE_SUPPLY_S_MIN+i][1], BG_AV_ObjectPos[AV_OPLACE_MINE_SUPPLY_S_MIN+i][2], BG_AV_ObjectPos[AV_OPLACE_MINE_SUPPLY_S_MIN+i][3], 0, 0, sin(BG_AV_ObjectPos[AV_OPLACE_MINE_SUPPLY_S_MIN+i][3]/2), cos(BG_AV_ObjectPos[AV_OPLACE_MINE_SUPPLY_S_MIN+i][3]/2), RESPAWN_ONE_DAY))
         {
@@ -1324,30 +1324,39 @@
     // Initial Nodes
     for (i = 0; i < BG_AV_OBJECT_MAX; i++)
         SpawnBGObject(i, RESPAWN_ONE_DAY);
-    for (i = BG_AV_OBJECT_FLAG_A_FIRSTAID_STATION; i <= BG_AV_OBJECT_FLAG_A_STONEHEART_GRAVE ; i++){
+
+    for (i = BG_AV_OBJECT_FLAG_A_FIRSTAID_STATION; i <= BG_AV_OBJECT_FLAG_A_STONEHEART_GRAVE; i++)
+    {
         SpawnBGObject(BG_AV_OBJECT_AURA_A_FIRSTAID_STATION+3*i, RESPAWN_IMMEDIATELY);
         SpawnBGObject(i, RESPAWN_IMMEDIATELY);
     }
-    for (i = BG_AV_OBJECT_FLAG_A_DUNBALDAR_SOUTH; i <= BG_AV_OBJECT_FLAG_A_STONEHEART_BUNKER ; i++)
+
+    for (i = BG_AV_OBJECT_FLAG_A_DUNBALDAR_SOUTH; i <= BG_AV_OBJECT_FLAG_A_STONEHEART_BUNKER; i++)
         SpawnBGObject(i, RESPAWN_IMMEDIATELY);
-    for (i = BG_AV_OBJECT_FLAG_H_ICEBLOOD_GRAVE; i <= BG_AV_OBJECT_FLAG_H_FROSTWOLF_WTOWER ; i++){
+
+    for (i = BG_AV_OBJECT_FLAG_H_ICEBLOOD_GRAVE; i <= BG_AV_OBJECT_FLAG_H_FROSTWOLF_WTOWER; i++)
+    {
         SpawnBGObject(i, RESPAWN_IMMEDIATELY);
         if (i <= BG_AV_OBJECT_FLAG_H_FROSTWOLF_HUT)
             SpawnBGObject(BG_AV_OBJECT_AURA_H_FIRSTAID_STATION+3*GetNodeThroughObject(i), RESPAWN_IMMEDIATELY);
     }
+
     for (i = BG_AV_OBJECT_TFLAG_A_DUNBALDAR_SOUTH; i <= BG_AV_OBJECT_TFLAG_A_STONEHEART_BUNKER; i+=2)
     {
         SpawnBGObject(i, RESPAWN_IMMEDIATELY); //flag
         SpawnBGObject(i+16, RESPAWN_IMMEDIATELY); //aura
     }
+
     for (i = BG_AV_OBJECT_TFLAG_H_ICEBLOOD_TOWER; i <= BG_AV_OBJECT_TFLAG_H_FROSTWOLF_WTOWER; i+=2)
     {
         SpawnBGObject(i, RESPAWN_IMMEDIATELY); //flag
         SpawnBGObject(i+16, RESPAWN_IMMEDIATELY); //aura
     }
+
     //snowfall and the doors
     for (i = BG_AV_OBJECT_FLAG_N_SNOWFALL_GRAVE; i <= BG_AV_OBJECT_DOOR_A; i++)
         SpawnBGObject(i, RESPAWN_IMMEDIATELY);
+
     SpawnBGObject(BG_AV_OBJECT_AURA_N_SNOWFALL_GRAVE, RESPAWN_IMMEDIATELY);
 
     //creatures
@@ -1472,7 +1481,7 @@
     {
         for (uint8 j=0; j<9; j++)
             m_Team_QuestStatus[i][j]=0;
-    m_Team_Scores[i]=BG_AV_SCORE_INITIAL_POINTS;
+        m_Team_Scores[i]=BG_AV_SCORE_INITIAL_POINTS;
         m_IsInformedNearVictory[i]=false;
         m_CaptainAlive[i] = true;
         m_CaptainBuffTimer[i] = 120000 + urand(0, 4)* 60; //as far as i could see, the buff is randomly so i make 2minutes (thats the duration of the buff itself) + 0-4minutes TODO get the right times
@@ -1493,7 +1502,6 @@
     for (uint16 i = 0; i < AV_CPLACE_MAX+AV_STATICCPLACE_MAX; i++)
         if (BgCreatures[i])
             DelCreature(i);
-
 }
 
 bool BattlegroundAV::IsBothMinesControlledByTeam(uint32 team) const
@@ -1553,4 +1561,4 @@
     }
 
     return false;
-}
\ No newline at end of file
+}
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Battlegrounds/Zones/BattlegroundAV.h
--- a/src/server/game/Battlegrounds/Zones/BattlegroundAV.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundAV.h	Mon Apr 16 14:29:17 2012 +0300
@@ -356,7 +356,9 @@
 
     AV_OPLACE_MAX                         = 149
 };
-const float BG_AV_ObjectPos[AV_OPLACE_MAX][4] = {
+
+const float BG_AV_ObjectPos[AV_OPLACE_MAX][4] =
+{
     {638.592f, -32.422f, 46.0608f, -1.62316f }, //firstaid station
     {669.007f, -294.078f, 30.2909f, 2.77507f }, //stormpike
     {77.8013f, -404.7f, 46.7549f, -0.872665f }, //stone grave
@@ -527,7 +529,8 @@
     {-951.394f, -193.695f, 67.634f, 0.802851f}
 };
 
-const float BG_AV_DoorPositons[2][4] = {
+const float BG_AV_DoorPositons[2][4] =
+{
     {780.487f, -493.024f, 99.9553f, 3.0976f},   //alliance
     {-1375.193f, -538.981f, 55.2824f, 0.72178f} //horde
 };
@@ -623,7 +626,8 @@
 };
 
 //x, y, z, o
-const float BG_AV_CreaturePos[AV_CPLACE_MAX][4] = {
+const float BG_AV_CreaturePos[AV_CPLACE_MAX][4] =
+{
     //spiritguides
     {643.000000f, 44.000000f, 69.740196f, -0.001854f},
     {676.000000f, -374.000000f, 30.000000f, -0.001854f},
@@ -1039,7 +1043,8 @@
 
 //entry, team, minlevel, maxlevel
 //TODO this array should be removed, the only needed things are the entrys (for spawning(?) and handlekillunit)
-const uint32 BG_AV_CreatureInfo[AV_NPC_INFO_MAX][4] = {
+const uint32 BG_AV_CreatureInfo[AV_NPC_INFO_MAX][4] =
+{
     { 12050, 1216, 58, 58 }, //Stormpike Defender
     { 13326, 1216, 59, 59 }, //Seasoned Defender
     { 13331, 1216, 60, 60 }, //Veteran Defender
@@ -1099,7 +1104,9 @@
 };
 
 //x, y, z, o, static_creature_info-id
-const float BG_AV_StaticCreaturePos[AV_STATICCPLACE_MAX][5] = { //static creatures
+const float BG_AV_StaticCreaturePos[AV_STATICCPLACE_MAX][5] =
+{
+    //static creatures
     {-1235.31f, -340.777f, 60.5088f, 3.31613f, 0 }, //2225 - Zora Guthrek
     {-1244.02f, -323.795f, 61.0485f, 5.21853f, 1 }, //3343 - Grelkor
     {-1235.16f, -332.302f, 60.2985f, 2.96706f, 2 }, //3625 - Rarck
@@ -1226,7 +1233,8 @@
 
 };
 
-const uint32 BG_AV_StaticCreatureInfo[51][4] = {
+const uint32 BG_AV_StaticCreatureInfo[51][4] =
+{
     { 2225, 1215, 55, 55 }, //Zora Guthrek
     { 3343, 1215, 55, 55 }, //Grelkor
     { 3625, 1215, 55, 55 }, //Rarck
@@ -1293,16 +1301,17 @@
     AV_GRAVE_MAIN_HORDE        = 610
 };
 
-const uint32 BG_AV_GraveyardIds[9]= {
-  AV_GRAVE_STORM_AID,
-  AV_GRAVE_STORM_GRAVE,
-  AV_GRAVE_STONE_GRAVE,
-  AV_GRAVE_SNOWFALL,
-  AV_GRAVE_ICE_GRAVE,
-  AV_GRAVE_FROSTWOLF,
-  AV_GRAVE_FROST_HUT,
-  AV_GRAVE_MAIN_ALLIANCE,
-  AV_GRAVE_MAIN_HORDE
+const uint32 BG_AV_GraveyardIds[9]=
+{
+    AV_GRAVE_STORM_AID,
+    AV_GRAVE_STORM_GRAVE,
+    AV_GRAVE_STONE_GRAVE,
+    AV_GRAVE_SNOWFALL,
+    AV_GRAVE_ICE_GRAVE,
+    AV_GRAVE_FROSTWOLF,
+    AV_GRAVE_FROST_HUT,
+    AV_GRAVE_MAIN_ALLIANCE,
+    AV_GRAVE_MAIN_HORDE
 };
 
 enum BG_AV_BUFF
@@ -1434,13 +1443,15 @@
 };
 
 //alliance_control neutral_control horde_control
-const uint32 BG_AV_MineWorldStates[2][3] = {
+const uint32 BG_AV_MineWorldStates[2][3] =
+{
     {1358, 1360, 1359},
     {1355, 1357, 1356}
 };
 
 //alliance_control alliance_assault h_control h_assault
-const uint32 BG_AV_NodeWorldStates[16][4] = {
+const uint32 BG_AV_NodeWorldStates[16][4] =
+{
     //Stormpike first aid station
     {1325, 1326, 1327, 1328},
     //Stormpike Graveyard
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Battlegrounds/Zones/BattlegroundEY.cpp
--- a/src/server/game/Battlegrounds/Zones/BattlegroundEY.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundEY.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -29,7 +29,8 @@
 #include "Util.h"
 
 // these variables aren't used outside of this file, so declare them only here
-uint32 BG_EY_HonorScoreTicks[BG_HONOR_MODE_NUM] = {
+uint32 BG_EY_HonorScoreTicks[BG_HONOR_MODE_NUM] =
+{
     260, // normal honor
     160  // holiday
 };
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Battlegrounds/Zones/BattlegroundEY.h
--- a/src/server/game/Battlegrounds/Zones/BattlegroundEY.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundEY.h	Mon Apr 16 14:29:17 2012 +0300
@@ -258,7 +258,8 @@
 };
 
 // x, y, z, o
-const float BG_EY_TriggerPositions[EY_POINTS_MAX][4] = {
+const float BG_EY_TriggerPositions[EY_POINTS_MAX][4] =
+{
     {2044.28f, 1729.68f, 1189.96f, 0.017453f},  // FEL_REAVER center
     {2048.83f, 1393.65f, 1194.49f, 0.20944f},   // BLOOD_ELF center
     {2286.56f, 1402.36f, 1197.11f, 3.72381f},   // DRAENEI_RUINS center
@@ -326,7 +327,7 @@
 class BattlegroundEYScore : public BattlegroundScore
 {
     public:
-        BattlegroundEYScore () : FlagCaptures(0) {};
+        BattlegroundEYScore() : FlagCaptures(0) {};
         virtual ~BattlegroundEYScore() {};
         uint32 FlagCaptures;
 };
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Battlegrounds/Zones/BattlegroundIC.cpp
--- a/src/server/game/Battlegrounds/Zones/BattlegroundIC.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundIC.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -47,7 +47,7 @@
     resourceTimer = IC_RESOURCE_TIME;
 
     for (uint8 i = NODE_TYPE_REFINERY; i < MAX_NODE_TYPES; i++)
-        nodePoint[i] =  nodePointInitial[i];
+        nodePoint[i] = nodePointInitial[i];
 
     siegeEngineWorkshopTimer = WORKSHOP_UPDATE_TIME;
 
@@ -359,7 +359,7 @@
         data << uint32(uws) << uint32(1);
     }
 
-    for (uint8 i = 0 ; i < MAX_NODE_TYPES ; i++)
+    for (uint8 i = 0; i < MAX_NODE_TYPES; i++)
         data << uint32(nodePoint[i].worldStates[nodePoint[i].nodeState]) << uint32(1);
 }
 
@@ -971,7 +971,7 @@
 
     float x = t->m_WayPoints[0].x;
     float y = t->m_WayPoints[0].y;
-    float z =  t->m_WayPoints[0].z;
+    float z = t->m_WayPoints[0].z;
     float o = 1;
 
     // creates the Gameobject
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Battlegrounds/Zones/BattlegroundRV.cpp
--- a/src/server/game/Battlegrounds/Zones/BattlegroundRV.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundRV.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -32,7 +32,7 @@
     StartDelayTimes[BG_STARTING_EVENT_SECOND] = BG_START_DELAY_30S;
     StartDelayTimes[BG_STARTING_EVENT_THIRD]  = BG_START_DELAY_15S;
     StartDelayTimes[BG_STARTING_EVENT_FOURTH] = BG_START_DELAY_NONE;
-    //we must set messageIds
+    // we must set messageIds
     StartMessageIds[BG_STARTING_EVENT_FIRST]  = LANG_ARENA_ONE_MINUTE;
     StartMessageIds[BG_STARTING_EVENT_SECOND] = LANG_ARENA_THIRTY_SECONDS;
     StartMessageIds[BG_STARTING_EVENT_THIRD]  = LANG_ARENA_FIFTEEN_SECONDS;
@@ -46,40 +46,32 @@
 
 void BattlegroundRV::PostUpdateImpl(uint32 diff)
 {
+    if (GetStatus() != STATUS_IN_PROGRESS)
+        return;
+
     if (getTimer() < diff)
     {
         switch (getState())
         {
             case BG_RV_STATE_OPEN_FENCES:
-                setTimer(BG_RV_PILAR_TO_FIRE_TIMER);
+                // Open fire (only at game start)
+                for (uint8 i = BG_RV_OBJECT_FIRE_1; i <= BG_RV_OBJECT_FIREDOOR_2; ++i)
+                    DoorOpen(i);
+                setTimer(BG_RV_CLOSE_FIRE_TIMER);
                 setState(BG_RV_STATE_CLOSE_FIRE);
                 break;
             case BG_RV_STATE_CLOSE_FIRE:
                 for (uint8 i = BG_RV_OBJECT_FIRE_1; i <= BG_RV_OBJECT_FIREDOOR_2; ++i)
                     DoorClose(i);
-                setTimer(BG_RV_FIRE_TO_PILAR_TIMER);
-                setState(BG_RV_STATE_OPEN_PILARS);
+                // Fire got closed after five seconds, leaves twenty seconds before toggling pillars
+                setTimer(BG_RV_FIRE_TO_PILLAR_TIMER);
+                setState(BG_RV_STATE_SWITCH_PILLARS);
                 break;
-            case BG_RV_STATE_OPEN_PILARS:
+            case BG_RV_STATE_SWITCH_PILLARS:
                 for (uint8 i = BG_RV_OBJECT_PILAR_1; i <= BG_RV_OBJECT_PULLEY_2; ++i)
                     DoorOpen(i);
-                TogglePillarCollision(false);
-                setTimer(BG_RV_PILAR_TO_FIRE_TIMER);
-                setState(BG_RV_STATE_OPEN_FIRE);
-                break;
-            case BG_RV_STATE_OPEN_FIRE:
-                // FIXME: after 3.2.0 it's only decorative and should be opened only one time at battle start
-                for (uint8 i = BG_RV_OBJECT_FIRE_1; i <= BG_RV_OBJECT_FIREDOOR_2; ++i)
-                    DoorOpen(i);
-                setTimer(BG_RV_FIRE_TO_PILAR_TIMER);
-                setState(BG_RV_STATE_CLOSE_PILARS);
-                break;
-            case BG_RV_STATE_CLOSE_PILARS:
-                for (uint8 i = BG_RV_OBJECT_PILAR_1; i <= BG_RV_OBJECT_PULLEY_2; ++i)
-                    DoorOpen(i);
-                TogglePillarCollision(true);
-                setTimer(BG_RV_PILAR_TO_FIRE_TIMER);
-                setState(BG_RV_STATE_CLOSE_FIRE);
+                TogglePillarCollision();
+                setTimer(BG_RV_PILLAR_SWITCH_TIMER);
                 break;
         }
     }
@@ -103,7 +95,9 @@
     setState(BG_RV_STATE_OPEN_FENCES);
     setTimer(BG_RV_FIRST_TIMER);
     
-    TogglePillarCollision(true);
+    // Should be false at first, TogglePillarCollision will do it.
+    SetPillarCollision(true);
+    TogglePillarCollision();
 }
 
 void BattlegroundRV::AddPlayer(Player* player)
@@ -227,8 +221,10 @@
 }
 
 
-void BattlegroundRV::TogglePillarCollision(bool apply)
+void BattlegroundRV::TogglePillarCollision()
 {
+    bool apply = GetPillarCollision();
+
     for (uint8 i = BG_RV_OBJECT_PILAR_1; i <= BG_RV_OBJECT_PILAR_COLLISION_4; ++i)
     {
         if (GameObject* gob = GetBgMap()->GetGameObject(BgObjects[i]))
@@ -249,4 +245,6 @@
                     gob->SendUpdateToPlayer(player);
         }
     }
+    
+    SetPillarCollision(!apply);
 }
\ No newline at end of file
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Battlegrounds/Zones/BattlegroundRV.h
--- a/src/server/game/Battlegrounds/Zones/BattlegroundRV.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundRV.h	Mon Apr 16 14:29:17 2012 +0300
@@ -79,12 +79,12 @@
 enum BattlegroundRVData
 {
     BG_RV_STATE_OPEN_FENCES,
-    BG_RV_STATE_OPEN_PILARS,
-    BG_RV_STATE_CLOSE_PILARS,
-    BG_RV_STATE_OPEN_FIRE,
+    BG_RV_STATE_SWITCH_PILLARS,
     BG_RV_STATE_CLOSE_FIRE,
-    BG_RV_FIRE_TO_PILAR_TIMER                    = 20000,
-    BG_RV_PILAR_TO_FIRE_TIMER                    =  5000,
+
+    BG_RV_PILLAR_SWITCH_TIMER                    = 25000,
+    BG_RV_FIRE_TO_PILLAR_TIMER                   = 20000,
+    BG_RV_CLOSE_FIRE_TIMER                       =  5000,
     BG_RV_FIRST_TIMER                            = 20133,
     BG_RV_WORLD_STATE_A                          = 0xe10,
     BG_RV_WORLD_STATE_H                          = 0xe11,
@@ -120,6 +120,7 @@
     private:
         uint32 Timer;
         uint32 State;
+        bool   PillarCollision;
 
         virtual void PostUpdateImpl(uint32 diff);
 
@@ -129,6 +130,8 @@
 
         uint32 getState() { return State; };
         void setState(uint32 state) { State = state; };
-        void TogglePillarCollision(bool apply);
+        void TogglePillarCollision();
+        bool GetPillarCollision() { return PillarCollision; }
+        void SetPillarCollision(bool apply) { PillarCollision = apply; }
 };
 #endif
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Battlegrounds/Zones/BattlegroundSA.cpp
--- a/src/server/game/Battlegrounds/Zones/BattlegroundSA.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundSA.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -37,6 +37,11 @@
     SignaledRoundTwo = false;
     SignaledRoundTwoHalfMin = false;
     InitSecondRound = false;
+
+    //! This is here to prevent an uninitialised variable warning
+    //! The warning only occurs when SetUpBattleGround fails though.
+    //! In the future this function should be called BEFORE sending initial worldstates.
+    memset(&GraveyardStatus, 0, sizeof(GraveyardStatus));
 }
 
 BattlegroundSA::~BattlegroundSA()
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Battlegrounds/Zones/BattlegroundWS.cpp
--- a/src/server/game/Battlegrounds/Zones/BattlegroundWS.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundWS.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -37,7 +37,8 @@
     BG_WSG_REWARD_NUM
 };
 
-uint32 BG_WSG_Honor[BG_HONOR_MODE_NUM][BG_WSG_REWARD_NUM] = {
+uint32 BG_WSG_Honor[BG_HONOR_MODE_NUM][BG_WSG_REWARD_NUM] =
+{
     {20, 40, 40}, // normal honor
     {60, 40, 80}  // holiday
 };
@@ -178,20 +179,20 @@
 
 void BattlegroundWS::StartingEventOpenDoors()
 {
-    for (uint32 i = BG_WS_OBJECT_DOOR_A_1; i <= BG_WS_OBJECT_DOOR_A_4; ++i)
+    for (uint32 i = BG_WS_OBJECT_DOOR_A_1; i <= BG_WS_OBJECT_DOOR_A_6; ++i)
         DoorOpen(i);
-    for (uint32 i = BG_WS_OBJECT_DOOR_H_1; i <= BG_WS_OBJECT_DOOR_H_2; ++i)
+    for (uint32 i = BG_WS_OBJECT_DOOR_H_1; i <= BG_WS_OBJECT_DOOR_H_4; ++i)
         DoorOpen(i);
 
+    for (uint32 i = BG_WS_OBJECT_A_FLAG; i <= BG_WS_OBJECT_BERSERKBUFF_2; ++i)
+        SpawnBGObject(i, RESPAWN_IMMEDIATELY);
+
     SpawnBGObject(BG_WS_OBJECT_DOOR_A_5, RESPAWN_ONE_DAY);
     SpawnBGObject(BG_WS_OBJECT_DOOR_A_6, RESPAWN_ONE_DAY);
     SpawnBGObject(BG_WS_OBJECT_DOOR_H_3, RESPAWN_ONE_DAY);
     SpawnBGObject(BG_WS_OBJECT_DOOR_H_4, RESPAWN_ONE_DAY);
 
-    for (uint32 i = BG_WS_OBJECT_A_FLAG; i <= BG_WS_OBJECT_BERSERKBUFF_2; ++i)
-        SpawnBGObject(i, RESPAWN_IMMEDIATELY);
-
-    // players joining later are not egible
+    // players joining later are not eligibles
     StartTimedAchievement(ACHIEVEMENT_TIMED_TYPE_EVENT, WS_EVENT_START_BATTLE);
 }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/CMakeLists.txt
--- a/src/server/game/CMakeLists.txt	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/CMakeLists.txt	Mon Apr 16 14:29:17 2012 +0300
@@ -111,7 +111,6 @@
 include_directories(
   ${CMAKE_BINARY_DIR}
   ${CMAKE_SOURCE_DIR}/dep/g3dlite/include
-  ${CMAKE_SOURCE_DIR}/dep/mersennetwister
   ${CMAKE_SOURCE_DIR}/dep/SFMT
   ${CMAKE_SOURCE_DIR}/dep/zlib
   ${CMAKE_SOURCE_DIR}/src/server/collision
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Chat/Channels/Channel.cpp
--- a/src/server/game/Chat/Channels/Channel.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Chat/Channels/Channel.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -49,7 +49,6 @@
     }
     else                                                    // it's custom channel
     {
-        channel_id = 0;
         m_flags |= CHANNEL_FLAG_CUSTOM;
 
         // If storing custom channels in the db is enabled either load or save the channel
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Chat/Chat.cpp
--- a/src/server/game/Chat/Chat.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Chat/Chat.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -394,7 +394,6 @@
         { "linkgrave",      SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleLinkGraveCommand>,           "", NULL },
         { "neargrave",      SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleNearGraveCommand>,           "", NULL },
         { "explorecheat",   SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleExploreCheatCommand>,        "", NULL },
-        { "hover",          SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleHoverCommand>,               "", NULL },
         { "levelup",        SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleLevelUpCommand>,             "", NULL },
         { "showarea",       SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleShowAreaCommand>,            "", NULL },
         { "hidearea",       SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleHideAreaCommand>,            "", NULL },
@@ -414,7 +413,7 @@
         { "cometome",       SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleComeToMeCommand>,            "", NULL },
         { "damage",         SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleDamageCommand>,              "", NULL },
         { "heal",           SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleHealCommand>,                "", NULL },
-        { "combatstop",     SEC_GAMEMASTER,     false, OldHandler<&ChatHandler::HandleCombatStopCommand>,          "", NULL },
+        { "combatstop",     SEC_GAMEMASTER,     true,  OldHandler<&ChatHandler::HandleCombatStopCommand>,          "", NULL },
         { "flusharenapoints", SEC_ADMINISTRATOR, false, OldHandler<&ChatHandler::HandleFlushArenaPointsCommand>,    "", NULL },
         { "repairitems",    SEC_GAMEMASTER,     true,  OldHandler<&ChatHandler::HandleRepairitemsCommand>,         "", NULL },
         { "waterwalk",      SEC_GAMEMASTER,     false, OldHandler<&ChatHandler::HandleWaterwalkCommand>,           "", NULL },
@@ -458,7 +457,10 @@
                 added += appendCommandTable(commandTableCache + added, *it);
         }
 
-        QueryResult result = WorldDatabase.Query("SELECT name, security, help FROM command");
+        PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_COMMANDS);
+
+        PreparedQueryResult result = WorldDatabase.Query(stmt);
+
         if (result)
         {
             do
@@ -466,7 +468,7 @@
                 Field* fields = result->Fetch();
                 std::string name = fields[0].GetString();
 
-                SetDataForCommandInTable(commandTableCache, name.c_str(), fields[1].GetUInt16(), fields[2].GetString(), name);
+                SetDataForCommandInTable(commandTableCache, name.c_str(), fields[1].GetUInt8(), fields[2].GetString(), name);
 
             } while (result->NextRow());
         }
@@ -1346,7 +1348,7 @@
     // id, or string, or [name] Shift-click form |color|Htele:id|h[name]|h|r
     char* cId = extractKeyFromLink(text, "Htele");
     if (!cId)
-        return false;
+        return NULL;
 
     // id case (explicit or from shift link)
     if (cId[0] >= '0' || cId[0] >= '9')
@@ -1518,7 +1520,7 @@
     {
         char* space = strtok(args, "\"");
         if (!space)
-            return false;
+            return NULL;
         return strtok(NULL, "\"");
     }
 }
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Chat/Chat.h
--- a/src/server/game/Chat/Chat.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Chat/Chat.h	Mon Apr 16 14:29:17 2012 +0300
@@ -288,7 +288,6 @@
         bool HandleActivateObjectCommand(const char* args);
         bool HandleSpawnTransportCommand(const char* args);
         bool HandleExploreCheatCommand(const char* args);
-        bool HandleHoverCommand(const char* args);
         bool HandleWaterwalkCommand(const char* args);
         bool HandleLevelUpCommand(const char* args);
         bool HandleShowAreaCommand(const char* args);
@@ -352,8 +351,8 @@
         bool HandleSaveAllCommand(const char* args);
 
         // Utility methods for commands
-        bool LookupPlayerSearchCommand(QueryResult result, int32 limit);
-        bool HandleBanListHelper(QueryResult result);
+        bool LookupPlayerSearchCommand(PreparedQueryResult result, int32 limit);
+        bool HandleBanListHelper(PreparedQueryResult result);
         bool HandleBanHelper(BanMode mode, char const* args);
         bool HandleBanInfoHelper(uint32 accountid, char const* accountname);
         bool HandleUnBanHelper(BanMode mode, char const* args);
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Chat/Commands/Level0.cpp
--- a/src/server/game/Chat/Commands/Level0.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Chat/Commands/Level0.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -17,10 +17,8 @@
  */
 
 #include "Common.h"
-#include "DatabaseEnv.h"
 #include "World.h"
 #include "Player.h"
-#include "Opcodes.h"
 #include "Chat.h"
 #include "ObjectAccessor.h"
 #include "Language.h"
@@ -54,31 +52,31 @@
 
 bool ChatHandler::HandleStartCommand(const char* /*args*/)
 {
-    Player* chr = m_session->GetPlayer();
+    Player* player = m_session->GetPlayer();
 
-    if (chr->isInFlight())
+    if (player->isInFlight())
     {
         SendSysMessage(LANG_YOU_IN_FLIGHT);
         SetSentErrorMessage(true);
         return false;
     }
 
-    if (chr->isInCombat())
+    if (player->isInCombat())
     {
         SendSysMessage(LANG_YOU_IN_COMBAT);
         SetSentErrorMessage(true);
         return false;
     }
 
-    if (chr->isDead() || chr->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+    if (player->isDead() || player->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
     {
         // if player is dead and stuck, send ghost to graveyard
-        chr->RepopAtGraveyard();
+        player->RepopAtGraveyard();
         return true;
     }
 
     // cast spell Stuck
-    chr->CastSpell(chr, 7355, false);
+    player->CastSpell(player, 7355, false);
     return true;
 }
 
@@ -107,23 +105,25 @@
 
 bool ChatHandler::HandleDismountCommand(const char* /*args*/)
 {
+    Player* player = m_session->GetPlayer();
+
     //If player is not mounted, so go out :)
-    if (!m_session->GetPlayer()->IsMounted())
+    if (!player->IsMounted())
     {
         SendSysMessage(LANG_CHAR_NON_MOUNTED);
         SetSentErrorMessage(true);
         return false;
     }
 
-    if (m_session->GetPlayer()->isInFlight())
+    if (player->isInFlight())
     {
         SendSysMessage(LANG_YOU_IN_FLIGHT);
         SetSentErrorMessage(true);
         return false;
     }
 
-    m_session->GetPlayer()->Dismount();
-    m_session->GetPlayer()->RemoveAurasByType(SPELL_AURA_MOUNTED);
+    player->Dismount();
+    player->RemoveAurasByType(SPELL_AURA_MOUNTED);
     return true;
 }
 
@@ -144,7 +144,7 @@
 
     // save if the player has last been saved over 20 seconds ago
     uint32 save_interval = sWorld->getIntConfig(CONFIG_INTERVAL_SAVE);
-    if (save_interval == 0 || (save_interval > 20*IN_MILLISECONDS && player->GetSaveTimer() <= save_interval - 20*IN_MILLISECONDS))
+    if (save_interval == 0 || (save_interval > 20 * IN_MILLISECONDS && player->GetSaveTimer() <= save_interval - 20 * IN_MILLISECONDS))
         player->SaveToDB();
 
     return true;
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Chat/Commands/Level1.cpp
--- a/src/server/game/Chat/Commands/Level1.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Chat/Commands/Level1.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -488,7 +488,7 @@
                         continue;
 
                     name = areaEntry->area_name[loc];
-                    if (name.empty ())
+                    if (name.empty())
                         continue;
 
                     if (Utf8FitTo (name, wnamepart))
@@ -511,7 +511,7 @@
                 else
                     ss << areaEntry->ID << " - " << name << ' ' << localeNames[loc];
 
-                SendSysMessage (ss.str ().c_str());
+                SendSysMessage(ss.str().c_str());
 
                 if (!found)
                     found = true;
@@ -520,7 +520,7 @@
     }
 
     if (!found)
-        SendSysMessage (LANG_COMMAND_NOAREAFOUND);
+        SendSysMessage(LANG_COMMAND_NOAREAFOUND);
 
     return true;
 }
@@ -693,7 +693,7 @@
     }
 
     Map* gmMap = m_session->GetPlayer()->GetMap();
-    bool to_instance =  gmMap->Instanceable();
+    bool to_instance = gmMap->Instanceable();
 
     // we are in instance, and can summon only player in our group with us as lead
     if (to_instance && (
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Chat/Commands/Level2.cpp
--- a/src/server/game/Chat/Commands/Level2.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Chat/Commands/Level2.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -42,6 +42,7 @@
 #include "Transport.h"
 #include "TargetedMovementGenerator.h"                      // for HandleNpcUnFollowCommand
 #include "CreatureGroups.h"
+#include "ace/INET_Addr.h"
 #include "OutdoorPvPWG.h"
 
 //mute player for some times
@@ -285,18 +286,18 @@
     else if (!extractPlayerTarget((char*)args, &target, &target_guid, &target_name))
         return false;
 
-    uint32 accId = 0;
-    uint32 money = 0;
+    uint32 accId             = 0;
+    uint32 money             = 0;
     uint32 total_player_time = 0;
-    uint8 level = 0;
-    uint32 latency = 0;
+    uint8 level              = 0;
+    uint32 latency           = 0;
     uint8 race;
     uint8 Class;
-    int64 muteTime = 0;
-    int64 banTime = -1;
+    int64 muteTime           = 0;
+    int64 banTime            = -1;
     uint32 mapId;
     uint32 areaId;
-    uint32 phase = 0;
+    uint32 phase             = 0;
 
     // get additional information from Player object
     if (target)
@@ -305,17 +306,17 @@
         if (HasLowerSecurity(target, 0))
             return false;
 
-        accId = target->GetSession()->GetAccountId();
-        money = target->GetMoney();
+        accId             = target->GetSession()->GetAccountId();
+        money             = target->GetMoney();
         total_player_time = target->GetTotalPlayedTime();
-        level = target->getLevel();
-        latency = target->GetSession()->GetLatency();
-        race = target->getRace();
-        Class = target->getClass();
-        muteTime = target->GetSession()->m_muteTime;
-        mapId = target->GetMapId();
-        areaId = target->GetAreaId();
-        phase = target->GetPhaseMask();
+        level             = target->getLevel();
+        latency           = target->GetSession()->GetLatency();
+        race              = target->getRace();
+        Class             = target->getClass();
+        muteTime          = target->GetSession()->m_muteTime;
+        mapId             = target->GetMapId();
+        areaId            = target->GetAreaId();
+        phase             = target->GetPhaseMask();
     }
     // get additional information from DB
     else
@@ -324,41 +325,42 @@
         if (HasLowerSecurity(NULL, target_guid))
             return false;
 
-        //                                                     0          1      2      3        4     5      6    7
-        QueryResult result = CharacterDatabase.PQuery("SELECT totaltime, level, money, account, race, class, map, zone FROM characters "
-                                                      "WHERE guid = '%u'", GUID_LOPART(target_guid));
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_PINFO);
+        stmt->setUInt32(0, GUID_LOPART(target_guid));
+        PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
         if (!result)
             return false;
 
-        Field* fields = result->Fetch();
+        Field* fields     = result->Fetch();
         total_player_time = fields[0].GetUInt32();
-        level = fields[1].GetUInt32();
-        money = fields[2].GetUInt32();
-        accId = fields[3].GetUInt32();
-        race = fields[4].GetUInt8();
-        Class = fields[5].GetUInt8();
-        mapId = fields[6].GetUInt16();
-        areaId = fields[7].GetUInt16();
+        level             = fields[1].GetUInt8();
+        money             = fields[2].GetUInt32();
+        accId             = fields[3].GetUInt32();
+        race              = fields[4].GetUInt8();
+        Class             = fields[5].GetUInt8();
+        mapId             = fields[6].GetUInt16();
+        areaId            = fields[7].GetUInt16();
     }
 
-    std::string username = GetTrinityString(LANG_ERROR);
-    std::string email = GetTrinityString(LANG_ERROR);
-    std::string last_ip = GetTrinityString(LANG_ERROR);
-    uint32 security = 0;
+    std::string username   = GetTrinityString(LANG_ERROR);
+    std::string email      = GetTrinityString(LANG_ERROR);
+    std::string last_ip    = GetTrinityString(LANG_ERROR);
+    uint32 security        = 0;
     std::string last_login = GetTrinityString(LANG_ERROR);
 
-    QueryResult result = LoginDatabase.PQuery("SELECT a.username, aa.gmlevel, a.email, a.last_ip, a.last_login, a.mutetime "
-                                                "FROM account a "
-                                                "LEFT JOIN account_access aa "
-                                                "ON (a.id = aa.id AND (aa.RealmID = -1 OR aa.RealmID = %u)) "
-                                                "WHERE a.id = '%u'", realmID, accId);
+    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_PINFO);
+    stmt->setInt32(0, int32(realmID));
+    stmt->setUInt32(1, accId);
+    PreparedQueryResult result = LoginDatabase.Query(stmt);
+
     if (result)
     {
         Field* fields = result->Fetch();
-        username = fields[0].GetString();
-        security = fields[1].GetUInt32();
-        email = fields[2].GetString();
-        muteTime = fields[5].GetUInt64();
+        username      = fields[0].GetString();
+        security      = fields[1].GetUInt8();
+        email         = fields[2].GetString();
+        muteTime      = fields[5].GetUInt64();
 
         if (email.empty())
             email = "-";
@@ -367,6 +369,25 @@
         {
             last_ip = fields[3].GetString();
             last_login = fields[4].GetString();
+
+            uint32 ip = inet_addr(last_ip.c_str());
+#if TRINITY_ENDIAN == BIGENDIAN
+            EndianConvertReverse(ip);
+#endif
+
+            PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_IP2NATION_COUNTRY);
+
+            stmt->setUInt32(0, ip);
+
+            PreparedQueryResult result2 = WorldDatabase.Query(stmt);
+
+            if (result2)
+            {
+                Field* fields2 = result2->Fetch();
+                last_ip.append(" (");
+                last_ip.append(fields2[0].GetString());
+                last_ip.append(")");
+            }
         }
         else
         {
@@ -381,21 +402,23 @@
 
     std::string bannedby = "unknown";
     std::string banreason = "";
-    if (QueryResult result2 = LoginDatabase.PQuery("SELECT unbandate, bandate = unbandate, bannedby, banreason FROM account_banned "
-                                                  "WHERE id = '%u' AND active ORDER BY bandate ASC LIMIT 1", accId))
+
+    stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_PINFO_BANS);
+    stmt->setUInt32(0, accId);
+    PreparedQueryResult result2 = LoginDatabase.Query(stmt);
+    if (!result2)
+    {
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PINFO_BANS);
+        stmt->setUInt32(0, GUID_LOPART(target_guid));
+        result2 = CharacterDatabase.Query(stmt);
+    }
+
+    if (result2)
     {
         Field* fields = result2->Fetch();
-        banTime = fields[1].GetBool() ? 0 : fields[0].GetUInt64();
-        bannedby = fields[2].GetString();
-        banreason = fields[3].GetString();
-    }
-    else if (QueryResult result3 = CharacterDatabase.PQuery("SELECT unbandate, bandate = unbandate, bannedby, banreason FROM character_banned "
-                                                           "WHERE guid = '%u' AND active ORDER BY bandate ASC LIMIT 1", GUID_LOPART(target_guid)))
-    {
-        Field* fields = result3->Fetch();
-        banTime = fields[1].GetBool() ? 0 : fields[0].GetUInt64();
-        bannedby = fields[2].GetString();
-        banreason = fields[3].GetString();
+        banTime       = int64(fields[1].GetBool() ? 0 : fields[0].GetUInt32());
+        bannedby      = fields[2].GetString();
+        banreason     = fields[3].GetString();
     }
 
     if (muteTime > 0)
@@ -710,9 +733,22 @@
 
 bool ChatHandler::HandleCombatStopCommand(const char* args)
 {
-    Player* target;
-    if (!extractPlayerTarget((char*)args, &target))
-        return false;
+    Player* target = NULL;
+    
+    if (args && strlen(args) > 0)
+    {
+        target = sObjectAccessor->FindPlayerByName(args);
+        if (!target)
+        {
+            SendSysMessage(LANG_PLAYER_NOT_FOUND);
+            SetSentErrorMessage(true);
+            return false;
+        }
+    }
+    
+    if (!target)
+        if (!extractPlayerTarget((char*)args, &target))
+            return false;
 
     // check online security
     if (HasLowerSecurity(target, 0))
@@ -746,9 +782,9 @@
         limit = limit_str ? atoi (limit_str) : -1;
     }
 
-    LoginDatabase.EscapeString(ip);
-
-    QueryResult result = LoginDatabase.PQuery("SELECT id, username FROM account WHERE last_ip = '%s'", ip.c_str());
+    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_ACCOUNT_BY_IP);
+    stmt->setString(0, ip);
+    PreparedQueryResult result = LoginDatabase.Query(stmt);
 
     return LookupPlayerSearchCommand(result, limit);
 }
@@ -765,9 +801,9 @@
     if (!AccountMgr::normalizeString (account))
         return false;
 
-    LoginDatabase.EscapeString (account);
-
-    QueryResult result = LoginDatabase.PQuery ("SELECT id, username FROM account WHERE username = '%s'", account.c_str ());
+    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_ACCOUNT_LIST_BY_NAME);
+    stmt->setString(0, account);
+    PreparedQueryResult result = LoginDatabase.Query(stmt);
 
     return LookupPlayerSearchCommand (result, limit);
 }
@@ -781,14 +817,14 @@
     char* limit_str = strtok (NULL, " ");
     int32 limit = limit_str ? atoi (limit_str) : -1;
 
-    LoginDatabase.EscapeString (email);
-
-    QueryResult result = LoginDatabase.PQuery ("SELECT id, username FROM account WHERE email = '%s'", email.c_str ());
+    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_ACCOUNT_LIST_BY_EMAIL);
+    stmt->setString(0, email);
+    PreparedQueryResult result = LoginDatabase.Query(stmt);
 
     return LookupPlayerSearchCommand(result, limit);
 }
 
-bool ChatHandler::LookupPlayerSearchCommand(QueryResult result, int32 limit)
+bool ChatHandler::LookupPlayerSearchCommand(PreparedQueryResult result, int32 limit)
 {
     if (!result)
     {
@@ -812,8 +848,11 @@
         uint32 acc_id = fields[0].GetUInt32();
         std::string acc_name = fields[1].GetString();
 
-        QueryResult chars = CharacterDatabase.PQuery("SELECT guid, name FROM characters WHERE account = '%u'", acc_id);
-        if (chars)
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_GUID_NAME_BY_ACC);
+        stmt->setUInt32(0, acc_id);
+        PreparedQueryResult result2 = CharacterDatabase.Query(stmt);
+
+        if (result2)
         {
             PSendSysMessage(LANG_LOOKUP_PLAYER_ACCOUNT, acc_name.c_str(), acc_id);
 
@@ -822,14 +861,14 @@
 
             do
             {
-                Field* charfields = chars->Fetch();
+                Field* charfields = result2->Fetch();
                 guid = charfields[0].GetUInt64();
                 name = charfields[1].GetString();
 
                 PSendSysMessage(LANG_LOOKUP_PLAYER_CHARACTER, name.c_str(), guid);
                 ++i;
 
-            } while (chars->NextRow() && (limit == -1 || i < limit));
+            } while (result2->NextRow() && (limit == -1 || i < limit));
         }
     } while (result->NextRow());
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Chat/Commands/Level3.cpp
--- a/src/server/game/Chat/Commands/Level3.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Chat/Commands/Level3.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -569,7 +569,7 @@
         return false;
     }
 
-    int32 level = atol (level_p);
+    int32 level = atol(level_p);
 
     Player* target = getSelectedPlayer();
     if (!target)
@@ -694,7 +694,11 @@
         {
             std::string itemName = citemName+1;
             WorldDatabase.EscapeString(itemName);
-            QueryResult result = WorldDatabase.PQuery("SELECT entry FROM item_template WHERE name = '%s'", itemName.c_str());
+
+            PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_ITEM_TEMPLATE_BY_NAME);
+            stmt->setString(0, itemName);
+            PreparedQueryResult result = WorldDatabase.Query(stmt);
+
             if (!result)
             {
                 PSendSysMessage(LANG_COMMAND_COULDNOTFIND, citemName+1);
@@ -882,22 +886,22 @@
         return false;
     uint32 count = uint32(_count);
 
-    QueryResult result;
+    PreparedQueryResult result;
 
     // inventory case
     uint32 inv_count = 0;
-    result = CharacterDatabase.PQuery("SELECT COUNT(itemEntry) FROM character_inventory ci INNER JOIN item_instance ii ON ii.guid = ci.item WHERE itemEntry = '%u'", item_id);
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_INVENTORY_COUNT_ITEM);
+    stmt->setUInt32(0, item_id);
+    result = CharacterDatabase.Query(stmt);
+
     if (result)
-        inv_count = (*result)[0].GetUInt32();
-
-    result=CharacterDatabase.PQuery(
-    //          0        1               2        3        4          5
-        "SELECT ci.item, cb.slot AS bag, ci.slot, ci.guid, c.account, c.name FROM characters c "
-        "INNER JOIN character_inventory ci ON ci.guid = c.guid "
-        "INNER JOIN item_instance ii ON ii.guid = ci.item "
-        "LEFT JOIN character_inventory cb ON cb.item = ci.bag "
-        "WHERE ii.itemEntry = '%u' LIMIT %u ",
-        item_id, count);
+        inv_count = (*result)[0].GetUInt64();
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_INVENTORY_ITEM_BY_ENTRY);
+    stmt->setUInt32(0, item_id);
+    stmt->setUInt32(1, count);
+    result = CharacterDatabase.Query(stmt);
 
     if (result)
     {
@@ -906,7 +910,7 @@
             Field* fields = result->Fetch();
             uint32 item_guid = fields[0].GetUInt32();
             uint32 item_bag = fields[1].GetUInt32();
-            uint32 item_slot = fields[2].GetUInt32();
+            uint8 item_slot = fields[2].GetUInt8();
             uint32 owner_guid = fields[3].GetUInt32();
             uint32 owner_acc = fields[4].GetUInt32();
             std::string owner_name = fields[5].GetString();
@@ -935,24 +939,23 @@
 
     // mail case
     uint32 mail_count = 0;
-    result = CharacterDatabase.PQuery("SELECT COUNT(itemEntry) FROM mail_items mi INNER JOIN item_instance ii ON ii.guid = mi.item_guid WHERE itemEntry = '%u'", item_id);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_MAIL_COUNT_ITEM);
+    stmt->setUInt32(0, item_id);
+    result = CharacterDatabase.Query(stmt);
+
     if (result)
-        mail_count = (*result)[0].GetUInt32();
+        mail_count = (*result)[0].GetUInt64();
 
     if (count > 0)
     {
-        result = CharacterDatabase.PQuery(
-        //          0             1         2           3           4        5           6
-            "SELECT mi.item_guid, m.sender, m.receiver, cs.account, cs.name, cr.account, cr.name FROM mail m "
-            "INNER JOIN mail_items mi ON mi.mail_id = m.id "
-            "INNER JOIN item_instance ii ON ii.guid = mi.item_guid "
-            "INNER JOIN characters cs ON cs.guid = m.sender "
-            "INNER JOIN characters cr ON cr.guid = m.receiver "
-            "WHERE ii.itemEntry = '%u' LIMIT %u",
-            item_id, count);
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_MAIL_ITEMS_BY_ENTRY);
+        stmt->setUInt32(0, item_id);
+        stmt->setUInt32(1, count);
+        result = CharacterDatabase.Query(stmt);
     }
     else
-        result = QueryResult(NULL);
+        result = PreparedQueryResult(NULL);
 
     if (result)
     {
@@ -983,21 +986,23 @@
 
     // auction case
     uint32 auc_count = 0;
-    result=CharacterDatabase.PQuery("SELECT COUNT(itemEntry) FROM auctionhouse ah INNER JOIN item_instance ii ON ii.guid = ah.itemguid WHERE itemEntry = '%u'", item_id);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_AUCTIONHOUSE_COUNT_ITEM);
+    stmt->setUInt32(0, item_id);
+    result = CharacterDatabase.Query(stmt);
+
     if (result)
-        auc_count = (*result)[0].GetUInt32();
+        auc_count = (*result)[0].GetUInt64();
 
     if (count > 0)
     {
-        result = CharacterDatabase.PQuery(
-        //           0            1             2          3
-            "SELECT  ah.itemguid, ah.itemowner, c.account, c.name FROM auctionhouse ah "
-            "INNER JOIN characters c ON c.guid = ah.itemowner "
-            "INNER JOIN item_instance ii ON ii.guid = ah.itemguid "
-            "WHERE ii.itemEntry = '%u' LIMIT %u", item_id, count);
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_AUCTIONHOUSE_ITEM_BY_ENTRY);
+        stmt->setUInt32(0, item_id);
+        stmt->setUInt32(1, count);
+        result = CharacterDatabase.Query(stmt);
     }
     else
-        result = QueryResult(NULL);
+        result = PreparedQueryResult(NULL);
 
     if (result)
     {
@@ -1018,17 +1023,18 @@
 
     // guild bank case
     uint32 guild_count = 0;
-    result = CharacterDatabase.PQuery("SELECT COUNT(itemEntry) FROM guild_bank_item gbi INNER JOIN item_instance ii ON ii.guid = gbi.item_guid WHERE itemEntry = '%u'", item_id);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GUILD_BANK_COUNT_ITEM);
+    stmt->setUInt32(0, item_id);
+    result = CharacterDatabase.Query(stmt);
+
     if (result)
-        guild_count = (*result)[0].GetUInt32();
-
-    result = CharacterDatabase.PQuery(
-        //      0             1           2
-        "SELECT gi.item_guid, gi.guildid, g.name FROM guild_bank_item gi "
-        "INNER JOIN guild g ON g.guildid = gi.guildid "
-        "INNER JOIN item_instance ii ON ii.guid = gi.item_guid "
-        "WHERE ii.itemEntry = '%u' LIMIT %u ",
-        item_id, count);
+        guild_count = (*result)[0].GetUInt64();
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GUILD_BANK_ITEM_BY_ENTRY);
+    stmt->setUInt32(0, item_id);
+    stmt->setUInt32(1, count);
+    result = CharacterDatabase.Query(stmt);
 
     if (result)
     {
@@ -1101,7 +1107,7 @@
     uint32 obj_count = 0;
     result = WorldDatabase.PQuery("SELECT COUNT(guid) FROM gameobject WHERE id='%u'", go_id);
     if (result)
-        obj_count = (*result)[0].GetUInt32();
+        obj_count = (*result)[0].GetUInt64();
 
     if (m_session)
     {
@@ -1173,7 +1179,7 @@
     uint32 cr_count = 0;
     result = WorldDatabase.PQuery("SELECT COUNT(guid) FROM creature WHERE id='%u'", cr_id);
     if (result)
-        cr_count = (*result)[0].GetUInt32();
+        cr_count = (*result)[0].GetUInt64();
 
     if (m_session)
     {
@@ -1702,7 +1708,7 @@
         uint8 localeIndex = GetSessionDbLocaleIndex();
         if (CreatureLocale const* cl = sObjectMgr->GetCreatureLocale(id))
         {
-            if (cl->Name.size() > localeIndex && !cl->Name[localeIndex].empty ())
+            if (cl->Name.size() > localeIndex && !cl->Name[localeIndex].empty())
             {
                 std::string name = cl->Name[localeIndex];
 
@@ -1715,9 +1721,9 @@
                     }
 
                     if (m_session)
-                        PSendSysMessage (LANG_CREATURE_ENTRY_LIST_CHAT, id, id, name.c_str ());
+                        PSendSysMessage(LANG_CREATURE_ENTRY_LIST_CHAT, id, id, name.c_str());
                     else
-                        PSendSysMessage (LANG_CREATURE_ENTRY_LIST_CONSOLE, id, name.c_str ());
+                        PSendSysMessage(LANG_CREATURE_ENTRY_LIST_CONSOLE, id, name.c_str());
 
                     if (!found)
                         found = true;
@@ -1728,7 +1734,7 @@
         }
 
         std::string name = itr->second.Name;
-        if (name.empty ())
+        if (name.empty())
             continue;
 
         if (Utf8FitTo(name, wnamepart))
@@ -1740,9 +1746,9 @@
             }
 
             if (m_session)
-                PSendSysMessage (LANG_CREATURE_ENTRY_LIST_CHAT, id, id, name.c_str ());
+                PSendSysMessage(LANG_CREATURE_ENTRY_LIST_CHAT, id, id, name.c_str());
             else
-                PSendSysMessage (LANG_CREATURE_ENTRY_LIST_CONSOLE, id, name.c_str ());
+                PSendSysMessage(LANG_CREATURE_ENTRY_LIST_CONSOLE, id, name.c_str());
 
             if (!found)
                 found = true;
@@ -1750,7 +1756,7 @@
     }
 
     if (!found)
-        SendSysMessage (LANG_COMMAND_NOCREATUREFOUND);
+        SendSysMessage(LANG_COMMAND_NOCREATUREFOUND);
 
     return true;
 }
@@ -1838,7 +1844,7 @@
         return false;
 
     // Can be NULL at console call
-    Player* target = getSelectedPlayer ();
+    Player* target = getSelectedPlayer();
 
     std::string namepart = args;
     std::wstring wnamepart;
@@ -1990,10 +1996,10 @@
 
                 // send taxinode in "id - [name] (Map:m X:x Y:y Z:z)" format
                 if (m_session)
-                    PSendSysMessage (LANG_TAXINODE_ENTRY_LIST_CHAT, id, id, name.c_str(), localeNames[loc],
+                    PSendSysMessage(LANG_TAXINODE_ENTRY_LIST_CHAT, id, id, name.c_str(), localeNames[loc],
                         nodeEntry->map_id, nodeEntry->x, nodeEntry->y, nodeEntry->z);
                 else
-                    PSendSysMessage (LANG_TAXINODE_ENTRY_LIST_CONSOLE, id, name.c_str(), localeNames[loc],
+                    PSendSysMessage(LANG_TAXINODE_ENTRY_LIST_CONSOLE, id, name.c_str(), localeNames[loc],
                         nodeEntry->map_id, nodeEntry->x, nodeEntry->y, nodeEntry->z);
 
                 if (!found)
@@ -2142,16 +2148,16 @@
 
     if (target->GetGuildId())
     {
-        SendSysMessage (LANG_PLAYER_IN_GUILD);
+        SendSysMessage(LANG_PLAYER_IN_GUILD);
         return true;
     }
 
     Guild* guild = new Guild;
-    if (!guild->Create (target, guildname))
+    if (!guild->Create(target, guildname))
     {
         delete guild;
-        SendSysMessage (LANG_GUILD_NOT_CREATED);
-        SetSentErrorMessage (true);
+        SendSysMessage(LANG_GUILD_NOT_CREATED);
+        SetSentErrorMessage(true);
         return false;
     }
 
@@ -2178,7 +2184,7 @@
         return false;
 
     std::string glName = guildStr;
-    Guild* targetGuild = sGuildMgr->GetGuildByName (glName);
+    Guild* targetGuild = sGuildMgr->GetGuildByName(glName);
     if (!targetGuild)
         return false;
 
@@ -2193,12 +2199,11 @@
     if (!extractPlayerTarget((char*)args, &target, &target_guid))
         return false;
 
-    uint32 glId   = target ? target->GetGuildId () : Player::GetGuildIdFromDB (target_guid);
-
+    uint32 glId = target ? target->GetGuildId() : Player::GetGuildIdFromDB(target_guid);
     if (!glId)
         return false;
 
-    Guild* targetGuild = sGuildMgr->GetGuildById (glId);
+    Guild* targetGuild = sGuildMgr->GetGuildById(glId);
     if (!targetGuild)
         return false;
 
@@ -2220,7 +2225,7 @@
     if (!extractPlayerTarget(nameStr, &target, &target_guid, &target_name))
         return false;
 
-    uint32 glId   = target ? target->GetGuildId () : Player::GetGuildIdFromDB (target_guid);
+    uint32 glId = target ? target->GetGuildId() : Player::GetGuildIdFromDB(target_guid);
     if (!glId)
         return false;
 
@@ -2243,11 +2248,11 @@
 
     std::string gld = guildStr;
 
-    Guild* targetGuild = sGuildMgr->GetGuildByName (gld);
+    Guild* targetGuild = sGuildMgr->GetGuildByName(gld);
     if (!targetGuild)
         return false;
 
-    targetGuild->Disband ();
+    targetGuild->Disband();
 
     return true;
 }
@@ -2353,7 +2358,7 @@
     {
         m_session->GetPlayer()->DealDamage(target, damage, NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
         if (target != m_session->GetPlayer())
-            m_session->GetPlayer()->SendAttackStateUpdate (HITINFO_NORMALSWING2, target, 1, SPELL_SCHOOL_MASK_NORMAL, damage, 0, 0, VICTIMSTATE_HIT, 0);
+            m_session->GetPlayer()->SendAttackStateUpdate (HITINFO_AFFECTS_VICTIM, target, 1, SPELL_SCHOOL_MASK_NORMAL, damage, 0, 0, VICTIMSTATE_HIT, 0);
         return true;
     }
 
@@ -2383,7 +2388,7 @@
 
         m_session->GetPlayer()->DealDamageMods(target, damage, &absorb);
         m_session->GetPlayer()->DealDamage(target, damage, NULL, DIRECT_DAMAGE, schoolmask, NULL, false);
-        m_session->GetPlayer()->SendAttackStateUpdate (HITINFO_NORMALSWING2, target, 1, schoolmask, damage, absorb, resist, VICTIMSTATE_HIT, 0);
+        m_session->GetPlayer()->SendAttackStateUpdate (HITINFO_AFFECTS_VICTIM, target, 1, schoolmask, damage, absorb, resist, VICTIMSTATE_HIT, 0);
         return true;
     }
 
@@ -2520,7 +2525,7 @@
     else
         return false;
 
-    WorldSafeLocsEntry const* graveyard =  sWorldSafeLocsStore.LookupEntry(g_id);
+    WorldSafeLocsEntry const* graveyard = sWorldSafeLocsStore.LookupEntry(g_id);
 
     if (!graveyard)
     {
@@ -2654,25 +2659,6 @@
     return true;
 }
 
-bool ChatHandler::HandleHoverCommand(const char *args)
-{
-    char* px = strtok((char*)args, " ");
-    uint32 flag;
-    if (!px)
-        flag = 1;
-    else
-        flag = atoi(px);
-
-    m_session->GetPlayer()->SetHover(flag);
-
-    if (flag)
-        SendSysMessage(LANG_HOVER_ENABLED);
-    else
-        SendSysMessage(LANG_HOVER_DISABLED);
-
-    return true;
-}
-
 void ChatHandler::HandleCharacterLevel(Player* player, uint64 playerGuid, uint32 oldLevel, uint32 newLevel)
 {
     if (player)
@@ -3721,7 +3707,7 @@
 
     std::string filter(cFilter);
     PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GUID_BY_NAME_FILTER);
-    stmt->setString(0, filter.c_str());
+    stmt->setString(0, filter);
     PreparedQueryResult result = CharacterDatabase.Query(stmt);
     if (!result)
     {
@@ -3798,25 +3784,27 @@
 
 bool ChatHandler::HandleBanListAccountCommand(const char *args)
 {
-    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_DEL_OLD_BANS);
+    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_DEL_EXPIRED_IP_BANS);
     LoginDatabase.Execute(stmt);
 
     char* cFilter = strtok((char*)args, " ");
     std::string filter = cFilter ? cFilter : "";
-    LoginDatabase.EscapeString(filter);
-
-    QueryResult result;
+
+    PreparedQueryResult result;
 
     if (filter.empty())
     {
-        result = LoginDatabase.Query("SELECT account.id, username FROM account, account_banned"
-            " WHERE account.id = account_banned.id AND active = 1 GROUP BY account.id");
+        PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_ACCOUNT_BANNED_ALL);
+
+        result = LoginDatabase.Query(stmt);
     }
     else
     {
-        result = LoginDatabase.PQuery("SELECT account.id, username FROM account, account_banned"
-            " WHERE account.id = account_banned.id AND active = 1 AND username "_LIKE_" "_CONCAT3_("'%%'", "'%s'", "'%%'")" GROUP BY account.id",
-            filter.c_str());
+        PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_ACCOUNT_BANNED_BY_USERNAME);
+
+        stmt->setString(0, filter);
+
+        result = LoginDatabase.Query(stmt);
     }
 
     if (!result)
@@ -3828,7 +3816,7 @@
     return HandleBanListHelper(result);
 }
 
-bool ChatHandler::HandleBanListHelper(QueryResult result)
+bool ChatHandler::HandleBanListHelper(PreparedQueryResult result)
 {
     PSendSysMessage(LANG_BANLIST_MATCHINGACCOUNT);
 
@@ -3858,7 +3846,7 @@
         {
             SendSysMessage("-------------------------------------------------------------------------------");
             Field* fields = result->Fetch();
-            uint32 account_id = fields[0].GetUInt32 ();
+            uint32 account_id = fields[0].GetUInt32();
 
             std::string account_name;
 
@@ -3904,26 +3892,28 @@
 
 bool ChatHandler::HandleBanListIPCommand(const char *args)
 {
-    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_DEL_OLD_IP_BANS);
+    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_DEL_EXPIRED_IP_BANS);
     LoginDatabase.Execute(stmt);
 
     char* cFilter = strtok((char*)args, " ");
     std::string filter = cFilter ? cFilter : "";
     LoginDatabase.EscapeString(filter);
 
-    QueryResult result;
+    PreparedQueryResult result;
 
     if (filter.empty())
     {
-        result = LoginDatabase.Query ("SELECT ip, bandate, unbandate, bannedby, banreason FROM ip_banned"
-            " WHERE (bandate=unbandate OR unbandate>UNIX_TIMESTAMP())"
-            " ORDER BY unbandate");
+        PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_IP_BANNED_ALL);
+
+        result = LoginDatabase.Query(stmt);
     }
     else
     {
-        result = LoginDatabase.PQuery("SELECT ip, bandate, unbandate, bannedby, banreason FROM ip_banned"
-            " WHERE (bandate=unbandate OR unbandate>UNIX_TIMESTAMP()) AND ip "_LIKE_" "_CONCAT3_("'%%'", "'%s'", "'%%'")
-            " ORDER BY unbandate", filter.c_str());
+        PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_IP_BANNED_BY_IP);
+
+        stmt->setString(0, filter);
+
+        result = LoginDatabase.Query(stmt);
     }
 
     if (!result)
@@ -4955,7 +4945,7 @@
     if (!*args)
         return false;
     char *channel = strtok((char*)args, " ");
-    char *argstr =  strtok(NULL, "");
+    char *argstr = strtok(NULL, "");
 
     if (!channel || !argstr)
         return false;
@@ -5085,53 +5075,58 @@
 {
     std::string name;
     Player* player;
-    char *TargetName = strtok((char*)args, " "); //get entered name
-    if (!TargetName) //if no name entered use target
+    char* targetName = strtok((char*)args, " "); // Get entered name
+
+    if (targetName)
     {
-        player = getSelectedPlayer();
-        if (player) //prevent crash with creature as target
-            name = player->GetName();
-    }
-
-    else // if name entered
-    {
-        name = TargetName;
+        name = targetName;
         normalizePlayerName(name);
         player = sObjectAccessor->FindPlayerByName(name.c_str());
     }
-
-    //effect
+    else // If no name was entered - use target
+    {
+        player = getSelectedPlayer();
+        if (player)
+            name = player->GetName();
+    }
+
     if (player)
     {
         PSendSysMessage(LANG_COMMAND_UNFREEZE, name.c_str());
 
-        //Reset player faction + allow combat + allow duels
+        // Reset player faction + allow combat + allow duels
         player->setFactionForRace(player->getRace());
         player->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
 
-        //allow movement and spells
+        // Remove Freeze spell (allowing movement and spells)
         player->RemoveAurasDueToSpell(9454);
 
-        //save player
+        // Save player
         player->SaveToDB();
     }
-
-    if (!player)
+    else
     {
-        if (TargetName)
+        if (targetName)
         {
-            //check for offline players
-            QueryResult result = CharacterDatabase.PQuery("SELECT characters.guid FROM characters WHERE characters.name = '%s'", name.c_str());
+            // Check for offline players
+            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_GUID_BY_NAME);
+            stmt->setString(0, name);
+            PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
             if (!result)
             {
                 SendSysMessage(LANG_COMMAND_FREEZE_WRONG);
                 return true;
             }
-            //if player found: delete his freeze aura
-            Field* fields=result->Fetch();
-            uint64 pguid = fields[0].GetUInt64();
-
-            CharacterDatabase.PQuery("DELETE FROM character_aura WHERE character_aura.spell = 9454 AND character_aura.guid = '%u'", pguid);
+
+            // If player found: delete his freeze aura
+            Field* fields = result->Fetch();
+            uint32 lowGuid = fields[0].GetUInt32();
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_AURA_FROZEN);
+            stmt->setUInt32(0, lowGuid);
+            CharacterDatabase.Execute(stmt);
+
             PSendSysMessage(LANG_COMMAND_UNFREEZE, name.c_str());
             return true;
         }
@@ -5147,8 +5142,11 @@
 
 bool ChatHandler::HandleListFreezeCommand(const char * /*args*/)
 {
-    //Get names from DB
-    QueryResult result = CharacterDatabase.Query("SELECT characters.name FROM characters LEFT JOIN character_aura ON (characters.guid = character_aura.guid) WHERE character_aura.spell = 9454");
+    // Get names from DB
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_AURA_FROZEN);
+
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
     if (!result)
     {
         SendSysMessage(LANG_COMMAND_NO_FROZEN_PLAYERS);
@@ -5246,9 +5244,11 @@
 
 bool ChatHandler::HandleUnbindSightCommand(const char * /*args*/)
 {
-    if (m_session->GetPlayer()->isPossessing())
-        return false;
-
-    m_session->GetPlayer()->StopCastingBindSight();
+    Player* player = m_session->GetPlayer();
+
+    if (player->isPossessing())
+        return false;
+
+    player->StopCastingBindSight();
     return true;
 }
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Combat/ThreatManager.h
--- a/src/server/game/Combat/ThreatManager.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Combat/ThreatManager.h	Mon Apr 16 14:29:17 2012 +0300
@@ -242,7 +242,7 @@
         // methods to access the lists from the outside to do some dirty manipulation (scriping and such)
         // I hope they are used as little as possible.
         std::list<HostileReference*>& getThreatList() { return iThreatContainer.getThreatList(); }
-        std::list<HostileReference*>& getOfflieThreatList() { return iThreatOfflineContainer.getThreatList(); }
+        std::list<HostileReference*>& getOfflineThreatList() { return iThreatOfflineContainer.getThreatList(); }
         ThreatContainer& getOnlineContainer() { return iThreatContainer; }
         ThreatContainer& getOfflineContainer() { return iThreatOfflineContainer; }
     private:
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Conditions/ConditionMgr.cpp
--- a/src/server/game/Conditions/ConditionMgr.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Conditions/ConditionMgr.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -274,6 +274,12 @@
             condMeets = object->GetPhaseMask() & ConditionValue1;
             break;
         }
+        case CONDITION_TITLE:
+        {
+            if (Player* player = object->ToPlayer())
+                condMeets = player->HasTitle(ConditionValue1);
+            break;
+        }
         default:
             condMeets = false;
             break;
@@ -422,6 +428,9 @@
         case CONDITION_PHASEMASK:
             mask |= GRID_MAP_TYPE_MASK_ALL;
             break;
+        case CONDITION_TITLE:
+            mask |= GRID_MAP_TYPE_MASK_PLAYER;
+            break;
         default:
             ASSERT(false && "Condition::GetSearcherTypeMaskForCondition - missing condition handling!");
             break;
@@ -719,8 +728,8 @@
         Condition* cond = new Condition();
         int32 iSourceTypeOrReferenceId   = fields[0].GetInt32();
         cond->SourceGroup               = fields[1].GetUInt32();
-        cond->SourceEntry               = fields[2].GetInt32();
-        cond->SourceId                  = fields[3].GetUInt32();
+        cond->SourceEntry               = fields[2].GetUInt32();
+        cond->SourceId                  = fields[3].GetInt32();
         cond->ElseGroup                 = fields[4].GetUInt32();
         int32 iConditionTypeOrReference  = fields[5].GetInt32();
         cond->ConditionTarget           = fields[6].GetUInt8();
@@ -1826,9 +1835,16 @@
                 sLog->outErrorDb("Phasemask condition has useless data in value3 (%u)!", cond->ConditionValue3);
             break;
         }
-        case CONDITION_UNUSED_18:
-            sLog->outErrorDb("Found ConditionTypeOrReference = CONDITION_UNUSED_18 in `conditions` table - ignoring");
-            return false;
+        case CONDITION_TITLE:
+        {
+            CharTitlesEntry const* titleEntry = sCharTitlesStore.LookupEntry(cond->ConditionValue1);
+            if (!titleEntry)
+            {
+                sLog->outErrorDb("Title condition has non existing title in value1 (%u), skipped", cond->ConditionValue1);
+                return false;
+            }
+            break;
+        }
         case CONDITION_UNUSED_19:
             sLog->outErrorDb("Found ConditionTypeOrReference = CONDITION_UNUSED_19 in `conditions` table - ignoring");
             return false;
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Conditions/ConditionMgr.h
--- a/src/server/game/Conditions/ConditionMgr.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Conditions/ConditionMgr.h	Mon Apr 16 14:29:17 2012 +0300
@@ -48,7 +48,7 @@
     CONDITION_CLASS                 = 15,                   // class            0              0                  true if player's class is equal to class
     CONDITION_RACE                  = 16,                   // race             0              0                  true if player's race is equal to race
     CONDITION_ACHIEVEMENT           = 17,                   // achievement_id   0              0                  true if achievement is complete
-    CONDITION_UNUSED_18             = 18,                   //
+    CONDITION_TITLE                 = 18,                   // title id         0              0                  true if player has title
     CONDITION_UNUSED_19             = 19,                   //
     CONDITION_UNUSED_20             = 20,                   //
     CONDITION_UNUSED_21             = 21,                   //
diff -r b4c056460923 -r da13f4f7a26c src/server/game/DataStores/DBCStores.cpp
--- a/src/server/game/DataStores/DBCStores.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/DataStores/DBCStores.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -536,7 +536,7 @@
     // include existed nodes that have at least single not spell base (scripted) path
     {
         std::set<uint32> spellPaths;
-        for (uint32 i = 1; i < sSpellStore.GetNumRows (); ++i)
+        for (uint32 i = 1; i < sSpellStore.GetNumRows(); ++i)
             if (SpellEntry const* sInfo = sSpellStore.LookupEntry (i))
                 for (int j = 0; j < MAX_SPELL_EFFECTS; ++j)
                     if (sInfo->Effect[j] == SPELL_EFFECT_SEND_TAXI)
diff -r b4c056460923 -r da13f4f7a26c src/server/game/DataStores/DBCStructure.h
--- a/src/server/game/DataStores/DBCStructure.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/DataStores/DBCStructure.h	Mon Apr 16 14:29:17 2012 +0300
@@ -1292,6 +1292,7 @@
     bool IsBattleground() const { return map_type == MAP_BATTLEGROUND; }
     bool IsBattleArena() const { return map_type == MAP_ARENA; }
     bool IsBattlegroundOrArena() const { return map_type == MAP_BATTLEGROUND || map_type == MAP_ARENA; }
+    bool IsWorldMap() const { return map_type == MAP_COMMON; }
 
     bool GetEntrancePos(int32 &mapid, float &x, float &y) const
     {
diff -r b4c056460923 -r da13f4f7a26c src/server/game/DungeonFinding/LFGMgr.cpp
--- a/src/server/game/DungeonFinding/LFGMgr.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/DungeonFinding/LFGMgr.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -38,7 +38,8 @@
     m_update = sWorld->getBoolConfig(CONFIG_DUNGEON_FINDER_ENABLE);
     if (m_update)
     {
-        new LFGScripts();
+        new LFGPlayerScript();
+        new LFGGroupScript();
 
         // Initialize dungeon cache
         for (uint32 i = 0; i < sLFGDungeonStore.GetNumRows(); ++i)
@@ -1022,7 +1023,7 @@
     // Select a random dungeon from the compatible list
     // TODO - Select the dungeon based on group item Level, not just random
     // Create a new proposal
-    pProposal = new LfgProposal(SelectRandomContainerElement(compatibleDungeons));
+    pProposal = new LfgProposal(Trinity::Containers::SelectRandomContainerElement(compatibleDungeons));
     pProposal->cancelTime = time_t(time(NULL)) + LFG_TIME_PROPOSAL;
     pProposal->state = LFG_PROPOSAL_INITIATING;
     pProposal->queues = check;
@@ -1166,7 +1167,7 @@
         }
 
         m_QueueInfoMap[gguid] = pqInfo;
-        if(GetState(gguid) != LFG_STATE_NONE)
+        if (GetState(gguid) != LFG_STATE_NONE)
         {
             LfgGuidList& currentQueue = m_currentQueue[team];
             currentQueue.push_front(gguid);
diff -r b4c056460923 -r da13f4f7a26c src/server/game/DungeonFinding/LFGScripts.cpp
--- a/src/server/game/DungeonFinding/LFGScripts.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/DungeonFinding/LFGScripts.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -27,9 +27,45 @@
 #include "LFGScripts.h"
 #include "LFGMgr.h"
 
-LFGScripts::LFGScripts(): GroupScript("LFGScripts"), PlayerScript("LFGScripts") {}
+LFGPlayerScript::LFGPlayerScript() : PlayerScript("LFGPlayerScript")
+{
+}
 
-void LFGScripts::OnAddMember(Group* group, uint64 guid)
+void LFGPlayerScript::OnLevelChanged(Player* player, uint8 /*oldLevel*/)
+{
+    sLFGMgr->InitializeLockedDungeons(player);
+}
+
+void LFGPlayerScript::OnLogout(Player* player)
+{
+    sLFGMgr->Leave(player);
+    LfgUpdateData updateData = LfgUpdateData(LFG_UPDATETYPE_REMOVED_FROM_QUEUE);
+    player->GetSession()->SendLfgUpdateParty(updateData);
+    player->GetSession()->SendLfgUpdatePlayer(updateData);
+    player->GetSession()->SendLfgUpdateSearch(false);
+    uint64 guid = player->GetGUID();
+    // TODO - Do not remove, add timer before deleting
+    sLFGMgr->RemovePlayerData(guid);
+}
+
+void LFGPlayerScript::OnLogin(Player* player)
+{
+    sLFGMgr->InitializeLockedDungeons(player);
+    // TODO - Restore LfgPlayerData and send proper status to player if it was in a group
+}
+
+void LFGPlayerScript::OnBindToInstance(Player* player, Difficulty difficulty, uint32 mapId, bool /*permanent*/)
+{
+    MapEntry const* mapEntry = sMapStore.LookupEntry(mapId);
+    if (mapEntry->IsDungeon() && difficulty > DUNGEON_DIFFICULTY_NORMAL)
+        sLFGMgr->InitializeLockedDungeons(player);
+}
+
+LFGGroupScript::LFGGroupScript() : GroupScript("LFGGroupScript")
+{
+}
+
+void LFGGroupScript::OnAddMember(Group* group, uint64 guid)
 {
     uint64 gguid = group->GetGUID();
     if (!gguid)
@@ -55,7 +91,7 @@
             sLFGMgr->Leave(player);
 }
 
-void LFGScripts::OnRemoveMember(Group* group, uint64 guid, RemoveMethod method, uint64 kicker, const char* reason)
+void LFGGroupScript::OnRemoveMember(Group* group, uint64 guid, RemoveMethod method, uint64 kicker, char const* reason)
 {
     uint64 gguid = group->GetGUID();
     if (!gguid || method == GROUP_REMOVEMETHOD_DEFAULT)
@@ -102,7 +138,7 @@
         sLFGMgr->OfferContinue(group);
 }
 
-void LFGScripts::OnDisband(Group* group)
+void LFGGroupScript::OnDisband(Group* group)
 {
     uint64 gguid = group->GetGUID();
     sLog->outDebug(LOG_FILTER_LFG, "LFGScripts::OnDisband [" UI64FMTD "]", gguid);
@@ -110,7 +146,7 @@
     sLFGMgr->RemoveGroupData(gguid);
 }
 
-void LFGScripts::OnChangeLeader(Group* group, uint64 newLeaderGuid, uint64 oldLeaderGuid)
+void LFGGroupScript::OnChangeLeader(Group* group, uint64 newLeaderGuid, uint64 oldLeaderGuid)
 {
     uint64 gguid = group->GetGUID();
     if (!gguid)
@@ -131,7 +167,7 @@
     }
 }
 
-void LFGScripts::OnInviteMember(Group* group, uint64 guid)
+void LFGGroupScript::OnInviteMember(Group* group, uint64 guid)
 {
     uint64 gguid = group->GetGUID();
     if (!gguid)
@@ -140,33 +176,3 @@
     sLog->outDebug(LOG_FILTER_LFG, "LFGScripts::OnInviteMember [" UI64FMTD "]: invite [" UI64FMTD "] leader [" UI64FMTD "]", gguid, guid, group->GetLeaderGUID());
     sLFGMgr->Leave(NULL, group);
 }
-
-void LFGScripts::OnLevelChanged(Player* player, uint8 /*oldLevel*/)
-{
-    sLFGMgr->InitializeLockedDungeons(player);
-}
-
-void LFGScripts::OnLogout(Player* player)
-{
-    sLFGMgr->Leave(player);
-    LfgUpdateData updateData = LfgUpdateData(LFG_UPDATETYPE_REMOVED_FROM_QUEUE);
-    player->GetSession()->SendLfgUpdateParty(updateData);
-    player->GetSession()->SendLfgUpdatePlayer(updateData);
-    player->GetSession()->SendLfgUpdateSearch(false);
-    uint64 guid = player->GetGUID();
-    // TODO - Do not remove, add timer before deleting
-    sLFGMgr->RemovePlayerData(guid);
-}
-
-void LFGScripts::OnLogin(Player* player)
-{
-    sLFGMgr->InitializeLockedDungeons(player);
-    // TODO - Restore LfgPlayerData and send proper status to player if it was in a group
-}
-
-void LFGScripts::OnBindToInstance(Player* player, Difficulty difficulty, uint32 mapId, bool /*permanent*/)
-{
-    MapEntry const* mapEntry = sMapStore.LookupEntry(mapId);
-    if (mapEntry->IsDungeon() && difficulty > DUNGEON_DIFFICULTY_NORMAL)
-        sLFGMgr->InitializeLockedDungeons(player);
-}
diff -r b4c056460923 -r da13f4f7a26c src/server/game/DungeonFinding/LFGScripts.h
--- a/src/server/game/DungeonFinding/LFGScripts.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/DungeonFinding/LFGScripts.h	Mon Apr 16 14:29:17 2012 +0300
@@ -26,17 +26,10 @@
 class Player;
 class Group;
 
-class LFGScripts: public GroupScript, public PlayerScript
+class LFGPlayerScript : public PlayerScript
 {
     public:
-        LFGScripts();
-
-        // Group Hooks
-        void OnAddMember(Group* group, uint64 guid);
-        void OnRemoveMember(Group* group, uint64 guid, RemoveMethod method, uint64 kicker, const char* reason);
-        void OnDisband(Group* group);
-        void OnChangeLeader(Group* group, uint64 newLeaderGuid, uint64 oldLeaderGuid);
-        void OnInviteMember(Group* group, uint64 guid);
+        LFGPlayerScript();
 
         // Player Hooks
         void OnLevelChanged(Player* player, uint8 oldLevel);
@@ -44,3 +37,16 @@
         void OnLogin(Player* player);
         void OnBindToInstance(Player* player, Difficulty difficulty, uint32 mapId, bool permanent);
 };
+
+class LFGGroupScript : public GroupScript
+{
+    public:
+        LFGGroupScript();
+
+        // Group Hooks
+        void OnAddMember(Group* group, uint64 guid);
+        void OnRemoveMember(Group* group, uint64 guid, RemoveMethod method, uint64 kicker, char const* reason);
+        void OnDisband(Group* group);
+        void OnChangeLeader(Group* group, uint64 newLeaderGuid, uint64 oldLeaderGuid);
+        void OnInviteMember(Group* group, uint64 guid);
+};
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Entities/Creature/Creature.cpp
--- a/src/server/game/Entities/Creature/Creature.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Entities/Creature/Creature.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -199,7 +199,7 @@
         if (m_zoneScript)
             m_zoneScript->OnCreatureRemove(this);
         if (m_formation)
-            FormationMgr::RemoveCreatureFromGroup(m_formation, this);
+            sFormationMgr->RemoveCreatureFromGroup(m_formation, this);
         Unit::RemoveFromWorld();
         sObjectAccessor->RemoveObject(this);
     }
@@ -224,9 +224,9 @@
     if (!lowguid)
         return;
 
-    CreatureGroupInfoType::iterator frmdata = CreatureGroupMap.find(lowguid);
-    if (frmdata != CreatureGroupMap.end())
-        FormationMgr::AddCreatureToGroup(frmdata->second->leaderGUID, this);
+    CreatureGroupInfoType::iterator frmdata = sFormationMgr->CreatureGroupMap.find(lowguid);
+    if (frmdata != sFormationMgr->CreatureGroupMap.end())
+        sFormationMgr->AddCreatureToGroup(frmdata->second->leaderGUID, this);
 }
 
 void Creature::RemoveCorpse(bool setSpawnTime)
@@ -433,8 +433,8 @@
         in relation to DisableGravity also.
 
     else if (GetByteValue(UNIT_FIELD_BYTES_1, 3) & UNIT_BYTE_1_FLAG_HOVER)
-        SetHover(true); 
-        
+        SetHover(true);
+
     */
 
     // TODO: Shouldn't we check whether or not the creature is in water first?
@@ -758,16 +758,14 @@
         return false;
     }
 
+    //! Relocate before CreateFromProto, to initialize coords and allow
+    //! returning correct zone id for selecting OutdoorPvP/Battlefield script
+    Relocate(x, y, z, ang);
+
     //oX = x;     oY = y;    dX = x;    dY = y;    m_moveTime = 0;    m_startMove = 0;
     if (!CreateFromProto(guidlow, Entry, vehId, team, data))
         return false;
 
-    //! Need to be called after CreateFromProto
-    if (HasUnitMovementFlag(MOVEMENTFLAG_HOVER))
-        z += GetFloatValue(UNIT_FIELD_HOVERHEIGHT);
-
-    Relocate(x, y, z, ang);
-
     if (!IsPositionValid())
     {
         sLog->outError("Creature::Create(): given coordinates for creature (guidlow %d, entry %d) are not valid (X: %f, Y: %f, Z: %f, O: %f)", guidlow, Entry, x, y, z, ang);
@@ -794,6 +792,14 @@
     }
 
     LoadCreaturesAddon();
+
+    //! Need to be called after LoadCreaturesAddon - MOVEMENTFLAG_HOVER is set there
+    if (HasUnitMovementFlag(MOVEMENTFLAG_HOVER))
+        z += GetFloatValue(UNIT_FIELD_HOVERHEIGHT);
+
+    //! Relocate again with updated Z coord
+    Relocate(x, y, z, ang);
+
     uint32 displayID = GetNativeDisplayId();
     CreatureModelInfo const* minfo = sObjectMgr->GetCreatureModelRandomGender(&displayID);
     if (minfo && !isTotem())                               // Cancel load if no model defined or if totem
@@ -1093,32 +1099,34 @@
     // update in DB
     SQLTransaction trans = WorldDatabase.BeginTransaction();
 
-    trans->PAppend("DELETE FROM creature WHERE guid = '%u'", m_DBTableGuid);
-
-    std::ostringstream ss;
-    ss << "INSERT INTO creature VALUES ("
-        << m_DBTableGuid << ','
-        << GetEntry() << ','
-        << mapid << ','
-        << uint32(spawnMask) << ','                         // cast to prevent save as symbol
-        << uint16(GetPhaseMask()) << ','                    // prevent out of range error
-        << displayId << ','
-        << GetEquipmentId() << ','
-        << GetPositionX() << ','
-        << GetPositionY() << ','
-        << GetPositionZ() << ','
-        << GetOrientation() << ','
-        << m_respawnDelay << ','                            //respawn time
-        << (float) m_respawnradius << ','                   //spawn distance (float)
-        << (uint32) (0) << ','                              //currentwaypoint
-        << GetHealth() << ','                               //curhealth
-        << GetPower(POWER_MANA) << ','                      //curmana
-        << GetDefaultMovementType() << ','                  //default movement generator type
-        << npcflag << ','
-        << unit_flags << ','
-        << dynamicflags << ')';
-
-    trans->Append(ss.str().c_str());
+    PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_DEL_CREATURE);
+    stmt->setUInt32(0, m_DBTableGuid);
+    trans->Append(stmt);
+
+    uint8 index = 0;
+
+    stmt = WorldDatabase.GetPreparedStatement(WORLD_INS_CREATURE);
+    stmt->setUInt32(index++, m_DBTableGuid);
+    stmt->setUInt32(index++, GetEntry());
+    stmt->setUInt16(index++, uint16(mapid));
+    stmt->setUInt8(index++, spawnMask);
+    stmt->setUInt16(index++, uint16(GetPhaseMask()));
+    stmt->setUInt32(index++, displayId);
+    stmt->setInt32(index++, int32(GetEquipmentId()));
+    stmt->setFloat(index++, GetPositionX());
+    stmt->setFloat(index++, GetPositionY());
+    stmt->setFloat(index++, GetPositionZ());
+    stmt->setFloat(index++, GetOrientation());
+    stmt->setUInt32(index++, m_respawnDelay);
+    stmt->setFloat(index++, m_respawnradius);
+    stmt->setUInt32(index++, 0);
+    stmt->setUInt32(index++, GetHealth());
+    stmt->setUInt32(index++, GetPower(POWER_MANA));
+    stmt->setUInt8(index++, uint8(GetDefaultMovementType()));
+    stmt->setUInt32(index++, npcflag);
+    stmt->setUInt32(index++, unit_flags);
+    stmt->setUInt32(index, dynamicflags);
+    trans->Append(stmt);
 
     WorldDatabase.CommitTransaction(trans);
 }
@@ -1391,10 +1399,23 @@
     sObjectMgr->DeleteCreatureData(m_DBTableGuid);
 
     SQLTransaction trans = WorldDatabase.BeginTransaction();
-    trans->PAppend("DELETE FROM creature WHERE guid = '%u'", m_DBTableGuid);
-    trans->PAppend("DELETE FROM creature_addon WHERE guid = '%u'", m_DBTableGuid);
-    trans->PAppend("DELETE FROM game_event_creature WHERE guid = '%u'", m_DBTableGuid);
-    trans->PAppend("DELETE FROM game_event_model_equip WHERE guid = '%u'", m_DBTableGuid);
+
+    PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_DEL_CREATURE);
+    stmt->setUInt32(0, m_DBTableGuid);
+    trans->Append(stmt);
+
+    stmt = WorldDatabase.GetPreparedStatement(WORLD_DEL_CREATURE_ADDON);
+    stmt->setUInt32(0, m_DBTableGuid);
+    trans->Append(stmt);
+
+    stmt = WorldDatabase.GetPreparedStatement(WORLD_DEL_GAME_EVENT_CREATURE);
+    stmt->setUInt32(0, m_DBTableGuid);
+    trans->Append(stmt);
+
+    stmt = WorldDatabase.GetPreparedStatement(WORLD_DEL_GAME_EVENT_MODEL_EQUIP);
+    stmt->setUInt32(0, m_DBTableGuid);
+    trans->Append(stmt);
+
     WorldDatabase.CommitTransaction(trans);
 }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Entities/Creature/Creature.h
--- a/src/server/game/Entities/Creature/Creature.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Entities/Creature/Creature.h	Mon Apr 16 14:29:17 2012 +0300
@@ -266,7 +266,6 @@
 // `creature_addon` table
 struct CreatureAddon
 {
-    uint32 guidOrEntry;
     uint32 path_id;
     uint32 mount;
     uint32 bytes1;
@@ -338,7 +337,9 @@
 
     VendorItem* GetItem(uint32 slot) const
     {
-        if (slot >= m_items.size()) return NULL;
+        if (slot >= m_items.size())
+            return NULL;
+
         return m_items[slot];
     }
     bool Empty() const { return m_items.empty(); }
@@ -373,7 +374,7 @@
 {
     TrainerSpell() : spell(0), spellCost(0), reqSkill(0), reqSkillValue(0), reqLevel(0)
     {
-        for (uint8 i = 0; i < MAX_SPELL_EFFECTS ; ++i)
+        for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
             learnedSpell[i] = 0;
     }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Entities/Creature/CreatureGroups.cpp
--- a/src/server/game/Entities/Creature/CreatureGroups.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Entities/Creature/CreatureGroups.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -24,12 +24,13 @@
 
 #define MAX_DESYNC 5.0f
 
-CreatureGroupInfoType   CreatureGroupMap;
+FormationMgr::~FormationMgr()
+{
+    for (CreatureGroupInfoType::iterator itr = CreatureGroupMap.begin(); itr != CreatureGroupMap.end(); ++itr)
+        delete itr->second;
+}
 
-namespace FormationMgr
-{
-
-void AddCreatureToGroup(uint32 groupId, Creature* member)
+void FormationMgr::AddCreatureToGroup(uint32 groupId, Creature* member)
 {
     Map* map = member->FindMap();
     if (!map)
@@ -53,7 +54,7 @@
     }
 }
 
-void RemoveCreatureFromGroup(CreatureGroup* group, Creature* member)
+void FormationMgr::RemoveCreatureFromGroup(CreatureGroup* group, Creature* member)
 {
     sLog->outDebug(LOG_FILTER_UNITS, "Deleting member pointer to GUID: %u from group %u", group->GetId(), member->GetDBTableGUIDLow());
     group->RemoveMember(member);
@@ -70,7 +71,7 @@
     }
 }
 
-void LoadCreatureFormations()
+void FormationMgr::LoadCreatureFormations()
 {
     uint32 oldMSTime = getMSTime();
 
@@ -97,10 +98,10 @@
         fields = result->Fetch();
 
         //Load group member data
-        group_member                        = new FormationInfo;
+        group_member                        = new FormationInfo();
         group_member->leaderGUID            = fields[0].GetUInt32();
         uint32 memberGUID                   = fields[1].GetUInt32();
-        group_member->groupAI               = fields[4].GetUInt8();
+        group_member->groupAI               = fields[4].GetUInt32();
         //If creature is group leader we may skip loading of dist/angle
         if (group_member->leaderGUID != memberGUID)
         {
@@ -133,14 +134,12 @@
         CreatureGroupMap[memberGUID] = group_member;
         ++count;
     }
-    while (result->NextRow()) ;
+    while (result->NextRow());
 
     sLog->outString(">> Loaded %u creatures in formations in %u ms", count, GetMSTimeDiffToNow(oldMSTime));
     sLog->outString();
 }
 
-} // Namespace
-
 void CreatureGroup::AddMember(Creature* member)
 {
     sLog->outDebug(LOG_FILTER_UNITS, "CreatureGroup::AddMember: Adding unit GUID: %u.", member->GetGUIDLow());
@@ -152,7 +151,7 @@
         m_leader = member;
     }
 
-    m_members[member] = CreatureGroupMap.find(member->GetDBTableGUIDLow())->second;
+    m_members[member] = sFormationMgr->CreatureGroupMap.find(member->GetDBTableGUIDLow())->second;
     member->SetFormation(this);
 }
 
@@ -167,7 +166,7 @@
 
 void CreatureGroup::MemberAttackStart(Creature* member, Unit* target)
 {
-    uint8 groupAI = CreatureGroupMap[member->GetDBTableGUIDLow()]->groupAI;
+    uint8 groupAI = sFormationMgr->CreatureGroupMap[member->GetDBTableGUIDLow()]->groupAI;
     if (!groupAI)
         return;
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Entities/Creature/CreatureGroups.h
--- a/src/server/game/Entities/Creature/CreatureGroups.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Entities/Creature/CreatureGroups.h	Mon Apr 16 14:29:17 2012 +0300
@@ -34,16 +34,19 @@
     uint8 groupAI;
 };
 
-namespace FormationMgr
-{
-    void AddCreatureToGroup(uint32 group_id, Creature* creature);
-    void RemoveCreatureFromGroup(CreatureGroup* group, Creature* creature);
-    void LoadCreatureFormations();
-};
-
 typedef UNORDERED_MAP<uint32/*memberDBGUID*/, FormationInfo*>   CreatureGroupInfoType;
 
-extern CreatureGroupInfoType CreatureGroupMap;
+class FormationMgr
+{
+    friend class ACE_Singleton<FormationMgr, ACE_Null_Mutex>;
+    public:
+        FormationMgr() { }
+        ~FormationMgr();
+        void AddCreatureToGroup(uint32 group_id, Creature* creature);
+        void RemoveCreatureFromGroup(CreatureGroup* group, Creature* creature);
+        void LoadCreatureFormations();
+        CreatureGroupInfoType CreatureGroupMap;
+};
 
 class CreatureGroup
 {
@@ -73,4 +76,6 @@
         void MemberAttackStart(Creature* member, Unit* target);
 };
 
+#define sFormationMgr ACE_Singleton<FormationMgr, ACE_Null_Mutex>::instance()
+
 #endif
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Entities/Creature/GossipDef.cpp
--- a/src/server/game/Entities/Creature/GossipDef.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Entities/Creature/GossipDef.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -47,10 +47,7 @@
             for (GossipMenuItemContainer::const_iterator itr = _menuItems.begin(); itr != _menuItems.end(); ++itr)
             {
                 if (int32(itr->first) > menuItemId)
-                {
-                    menuItemId = menuItemId;
                     break;
-                }
 
                 menuItemId = itr->first + 1;
             }
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Entities/GameObject/GameObject.cpp
--- a/src/server/game/Entities/GameObject/GameObject.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Entities/GameObject/GameObject.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -135,10 +135,10 @@
         sObjectAccessor->AddObject(this);
         bool startOpen = (GetGoType() == GAMEOBJECT_TYPE_DOOR || GetGoType() == GAMEOBJECT_TYPE_BUTTON ? GetGOInfo()->door.startOpen : false);
         // The state can be changed after GameObject::Create but before GameObject::AddToWorld
-        bool toggledState = GetGoState() == GO_STATE_READY;
+        bool toggledState = GetGOData() ? GetGOData()->go_state == GO_STATE_READY : false;
         if (m_model)
             GetMap()->Insert(*m_model);
-        if ((startOpen && !toggledState) || (!startOpen && toggledState))
+        if (startOpen ^ toggledState)
             EnableCollision(false);
 
         WorldObject::AddToWorld();
@@ -691,29 +691,34 @@
     data.spawnMask = spawnMask;
     data.artKit = GetGoArtKit();
 
-    // update in DB
-    std::ostringstream ss;
-    ss << "INSERT INTO gameobject VALUES ("
-        << m_DBTableGuid << ','
-        << GetEntry() << ','
-        << mapid << ','
-        << uint32(spawnMask) << ','                         // cast to prevent save as symbol
-        << uint16(GetPhaseMask()) << ','                    // prevent out of range error
-        << GetPositionX() << ','
-        << GetPositionY() << ','
-        << GetPositionZ() << ','
-        << GetOrientation() << ','
-        << GetFloatValue(GAMEOBJECT_PARENTROTATION) << ','
-        << GetFloatValue(GAMEOBJECT_PARENTROTATION+1) << ','
-        << GetFloatValue(GAMEOBJECT_PARENTROTATION+2) << ','
-        << GetFloatValue(GAMEOBJECT_PARENTROTATION+3) << ','
-        << m_respawnDelayTime << ','
-        << uint32(GetGoAnimProgress()) << ','
-        << uint32(GetGoState()) << ')';
+    // Update in DB
+    SQLTransaction trans = WorldDatabase.BeginTransaction();
 
-    SQLTransaction trans = WorldDatabase.BeginTransaction();
-    trans->PAppend("DELETE FROM gameobject WHERE guid = '%u'", m_DBTableGuid);
-    trans->Append(ss.str().c_str());
+    uint8 index = 0;
+
+    PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_DEL_GAMEOBJECT);
+    stmt->setUInt32(0, m_DBTableGuid);
+    trans->Append(stmt);
+
+    stmt = WorldDatabase.GetPreparedStatement(WORLD_INS_GAMEOBJECT);
+    stmt->setUInt32(index++, m_DBTableGuid);
+    stmt->setUInt32(index++, GetEntry());
+    stmt->setUInt16(index++, uint16(mapid));
+    stmt->setUInt8(index++, spawnMask);
+    stmt->setUInt16(index++, uint16(GetPhaseMask()));
+    stmt->setFloat(index++, GetPositionX());
+    stmt->setFloat(index++, GetPositionY());
+    stmt->setFloat(index++, GetPositionZ());
+    stmt->setFloat(index++, GetOrientation());
+    stmt->setFloat(index++, GetFloatValue(GAMEOBJECT_PARENTROTATION));
+    stmt->setFloat(index++, GetFloatValue(GAMEOBJECT_PARENTROTATION+1));
+    stmt->setFloat(index++, GetFloatValue(GAMEOBJECT_PARENTROTATION+2));
+    stmt->setFloat(index++, GetFloatValue(GAMEOBJECT_PARENTROTATION+3));
+    stmt->setInt32(index++, int32(m_respawnDelayTime));
+    stmt->setUInt8(index++, GetGoAnimProgress());
+    stmt->setUInt8(index++, uint8(GetGoState()));
+    trans->Append(stmt);
+
     WorldDatabase.CommitTransaction(trans);
 }
 
@@ -840,7 +845,9 @@
 {
     // If something is marked as a transport, don't transmit an out of range packet for it.
     GameObjectTemplate const* gInfo = GetGOInfo();
-    if (!gInfo) return false;
+    if (!gInfo)
+        return false;
+
     return gInfo->type == GAMEOBJECT_TYPE_TRANSPORT || gInfo->type == GAMEOBJECT_TYPE_MO_TRANSPORT;
 }
 
@@ -849,7 +856,9 @@
 {
     // If something is marked as a transport, don't transmit an out of range packet for it.
     GameObjectTemplate const* gInfo = GetGOInfo();
-    if (!gInfo) return false;
+    if (!gInfo)
+        return false;
+
     return gInfo->type == GAMEOBJECT_TYPE_MO_TRANSPORT || (gInfo->type == GAMEOBJECT_TYPE_TRANSPORT && !gInfo->transport.pause);
 }
 
@@ -1428,7 +1437,7 @@
                 if (info->summoningRitual.casterTargetSpell && info->summoningRitual.casterTargetSpell != 1) // No idea why this field is a bool in some cases
                     for (uint32 i = 0; i < info->summoningRitual.casterTargetSpellTargets; i++)
                         // m_unique_users can contain only player GUIDs
-                        if (Player* target = ObjectAccessor::GetPlayer(*this, SelectRandomContainerElement(m_unique_users)))
+                        if (Player* target = ObjectAccessor::GetPlayer(*this, Trinity::Containers::SelectRandomContainerElement(m_unique_users)))
                             spellCaster->CastSpell(target, info->summoningRitual.casterTargetSpell, true);
 
                 // finish owners spell
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Entities/GameObject/GameObject.h
--- a/src/server/game/Entities/GameObject/GameObject.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Entities/GameObject/GameObject.h	Mon Apr 16 14:29:17 2012 +0300
@@ -730,7 +730,9 @@
         bool IsInSkillupList(uint32 PlayerGuidLow) const
         {
             for (std::list<uint32>::const_iterator i = m_SkillupList.begin(); i != m_SkillupList.end(); ++i)
-                if (*i == PlayerGuidLow) return true;
+                if (*i == PlayerGuidLow)
+                    return true;
+
             return false;
         }
         void ClearSkillupList() { m_SkillupList.clear(); }
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Entities/Item/Item.cpp
--- a/src/server/game/Entities/Item/Item.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Entities/Item/Item.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -343,8 +343,8 @@
             }
             stmt->setString(++index, ssEnchants.str());
 
-            stmt->setInt32 (++index, GetItemRandomPropertyId());
-            stmt->setUInt32(++index, GetUInt32Value(ITEM_FIELD_DURABILITY));
+            stmt->setInt16 (++index, GetItemRandomPropertyId());
+            stmt->setUInt16(++index, GetUInt32Value(ITEM_FIELD_DURABILITY));
             stmt->setUInt32(++index, GetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME));
             stmt->setString(++index, m_text);
             stmt->setUInt32(++index, guid);
@@ -486,7 +486,7 @@
 /*static*/
 void Item::DeleteFromInventoryDB(SQLTransaction& trans, uint32 itemGuid)
 {
-    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_INVENTORY_ITEM);
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INVENTORY_BY_ITEM);
     stmt->setUInt32(0, itemGuid);
     trans->Append(stmt);
 }
@@ -765,7 +765,7 @@
 
     if (Player* owner = GetOwner())
     {
-        if (owner->CanUnequipItem(GetPos(), false) !=  EQUIP_ERR_OK)
+        if (owner->CanUnequipItem(GetPos(), false) != EQUIP_ERR_OK)
             return false;
         if (owner->GetLootGUID() == GetGUID())
             return false;
@@ -791,16 +791,16 @@
 
 uint32 Item::GetEnchantRequiredLevel() const
 {
-  uint32 level = 0;
+    uint32 level = 0;
 
-  // Check all enchants for required level
-  for (uint32 enchant_slot = PERM_ENCHANTMENT_SLOT; enchant_slot < MAX_ENCHANTMENT_SLOT; ++enchant_slot)
-    if (uint32 enchant_id = GetEnchantmentId(EnchantmentSlot(enchant_slot)))
-      if (SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id))
-    if (enchantEntry->requiredLevel > level)
-      level = enchantEntry->requiredLevel;
+    // Check all enchants for required level
+    for (uint32 enchant_slot = PERM_ENCHANTMENT_SLOT; enchant_slot < MAX_ENCHANTMENT_SLOT; ++enchant_slot)
+        if (uint32 enchant_id = GetEnchantmentId(EnchantmentSlot(enchant_slot)))
+            if (SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id))
+                if (enchantEntry->requiredLevel > level)
+                    level = enchantEntry->requiredLevel;
 
-  return level;
+    return level;
 }
 
 bool Item::IsBoundByEnchant() const
@@ -1082,16 +1082,30 @@
 void Item::SaveRefundDataToDB()
 {
     SQLTransaction trans = CharacterDatabase.BeginTransaction();
-    trans->PAppend("DELETE FROM item_refund_instance WHERE item_guid = '%u'", GetGUIDLow());
-    trans->PAppend("INSERT INTO item_refund_instance (`item_guid`, `player_guid`, `paidMoney`, `paidExtendedCost`)"
-    " VALUES('%u', '%u', '%u', '%u')", GetGUIDLow(), GetRefundRecipient(), GetPaidMoney(), GetPaidExtendedCost());
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_REFUND_INSTANCE);
+    stmt->setUInt32(0, GetGUIDLow());
+    trans->Append(stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_ITEM_REFUND_INSTANCE);
+    stmt->setUInt32(0, GetGUIDLow());
+    stmt->setUInt32(1, GetRefundRecipient());
+    stmt->setUInt32(2, GetPaidMoney());
+    stmt->setUInt16(3, uint16(GetPaidExtendedCost()));
+    trans->Append(stmt);
+
     CharacterDatabase.CommitTransaction(trans);
 }
 
 void Item::DeleteRefundDataFromDB(SQLTransaction* trans)
 {
     if (trans && !trans->null())
-        (*trans)->PAppend("DELETE FROM item_refund_instance WHERE item_guid = '%u'", GetGUIDLow());
+    {
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_REFUND_INSTANCE);
+        stmt->setUInt32(0, GetGUIDLow());
+        (*trans)->Append(stmt);
+
+    }
 }
 
 void Item::SetNotRefundable(Player* owner, bool changestate /*=true*/, SQLTransaction* trans /*=NULL*/)
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Entities/Item/Item.h
--- a/src/server/game/Entities/Item/Item.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Entities/Item/Item.h	Mon Apr 16 14:29:17 2012 +0300
@@ -211,7 +211,7 @@
         static Item* CreateItem(uint32 item, uint32 count, Player const* player = NULL);
         Item* CloneItem(uint32 count, Player const* player = NULL) const;
 
-        Item ();
+        Item();
 
         virtual bool Create(uint32 guidlow, uint32 itemid, Player const* owner);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Entities/Item/ItemEnchantmentMgr.cpp
--- a/src/server/game/Entities/Item/ItemEnchantmentMgr.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Entities/Item/ItemEnchantmentMgr.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -49,6 +49,7 @@
 
     RandomItemEnch.clear();                                 // for reload case
 
+    //                                                 0      1      2
     QueryResult result = WorldDatabase.Query("SELECT entry, ench, chance FROM item_enchantment_template");
 
     if (result)
@@ -101,18 +102,20 @@
     {
         fCount += ench_iter->chance;
 
-        if (fCount > dRoll) return ench_iter->ench;
+        if (fCount > dRoll)
+            return ench_iter->ench;
     }
 
     //we could get here only if sum of all enchantment chances is lower than 100%
-    dRoll =  (irand(0, (int)floor(fCount * 100) + 1)) / 100;
+    dRoll = (irand(0, (int)floor(fCount * 100) + 1)) / 100;
     fCount = 0;
 
     for (EnchStoreList::const_iterator ench_iter = tab->second.begin(); ench_iter != tab->second.end(); ++ench_iter)
     {
         fCount += ench_iter->chance;
 
-        if (fCount > dRoll) return ench_iter->ench;
+        if (fCount > dRoll)
+            return ench_iter->ench;
     }
 
     return 0;
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Entities/Object/Object.cpp
--- a/src/server/game/Entities/Object/Object.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Entities/Object/Object.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -1458,7 +1458,9 @@
 
 float Position::GetAngle(const Position* obj) const
 {
-    if (!obj) return 0;
+    if (!obj)
+        return 0;
+
     return GetAngle(obj->GetPositionX(), obj->GetPositionY());
 }
 
@@ -1509,7 +1511,7 @@
     if (angle > M_PI)
         angle -= 2.0f*M_PI;
 
-    float lborder =  -1 * (arc/2.0f);                       // in range -pi..0
+    float lborder = -1 * (arc/2.0f);                        // in range -pi..0
     float rborder = (arc/2.0f);                             // in range 0..pi
     return ((angle >= lborder) && (angle <= rborder));
 }
@@ -1629,7 +1631,7 @@
         default:
         {
             float ground_z = GetBaseMap()->GetHeight(GetPhaseMask(), x, y, z, true);
-            if(ground_z > INVALID_HEIGHT)
+            if (ground_z > INVALID_HEIGHT)
                 z = ground_z;
             break;
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Entities/Object/Object.h
--- a/src/server/game/Entities/Object/Object.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Entities/Object/Object.h	Mon Apr 16 14:29:17 2012 +0300
@@ -122,7 +122,7 @@
 class Object
 {
     public:
-        virtual ~Object ();
+        virtual ~Object();
 
         bool IsInWorld() const { return m_inWorld; }
 
@@ -227,7 +227,9 @@
 
         bool HasFlag(uint16 index, uint32 flag) const
         {
-            if (index >= m_valuesCount && !PrintIndexError(index, false)) return false;
+            if (index >= m_valuesCount && !PrintIndexError(index, false))
+                return false;
+
             return (m_uint32Values[index] & flag) != 0;
         }
 
@@ -313,7 +315,7 @@
         Corpse const* ToCorpse() const { if (GetTypeId() == TYPEID_CORPSE) return (const Corpse*)((Corpse*)this); else return NULL; }
     protected:
 
-        Object ();
+        Object();
 
         void _InitValues();
         void _Create (uint32 guidlow, uint32 entry, HighGuid guidhigh);
@@ -879,20 +881,6 @@
 
 namespace Trinity
 {
-    template<class T>
-    void RandomResizeList(std::list<T> &_list, uint32 _size)
-    {
-        size_t list_size = _list.size();
-
-        while (list_size > _size)
-        {
-            typename std::list<T>::iterator itr = _list.begin();
-            std::advance(itr, urand(0, list_size - 1));
-            _list.erase(itr);
-            --list_size;
-        }
-    }
-
     // Binary predicate to sort WorldObjects based on the distance to a reference WorldObject
     class ObjectDistanceOrderPred
     {
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Entities/Object/ObjectPosSelector.cpp
--- a/src/server/game/Entities/Object/ObjectPosSelector.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Entities/Object/ObjectPosSelector.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -75,9 +75,9 @@
 
 bool ObjectPosSelector::FirstAngle(float& angle)
 {
-    if (m_UsedPosLists[USED_POS_PLUS].empty() && !m_UsedPosLists[USED_POS_MINUS].empty() )
+    if (m_UsedPosLists[USED_POS_PLUS].empty() && !m_UsedPosLists[USED_POS_MINUS].empty())
         return NextAngleFor(*m_UsedPosLists[USED_POS_MINUS].begin(), 1.0f, USED_POS_PLUS, angle);
-    else if (m_UsedPosLists[USED_POS_MINUS].empty() && !m_UsedPosLists[USED_POS_PLUS].empty() )
+    else if (m_UsedPosLists[USED_POS_MINUS].empty() && !m_UsedPosLists[USED_POS_PLUS].empty())
         return NextAngleFor(*m_UsedPosLists[USED_POS_PLUS].begin(), -1.0f, USED_POS_MINUS, angle);
 
     return false;
@@ -100,7 +100,7 @@
 bool ObjectPosSelector::NextUsedAngle(float& angle)
 {
     while (m_nextUsedPos[USED_POS_PLUS]!=m_UsedPosLists[USED_POS_PLUS].end() ||
-        m_nextUsedPos[USED_POS_MINUS]!=m_UsedPosLists[USED_POS_MINUS].end() )
+        m_nextUsedPos[USED_POS_MINUS]!=m_UsedPosLists[USED_POS_MINUS].end())
     {
         // calculate next possible angle
         if (!NextPosibleAngle(angle))
@@ -114,7 +114,7 @@
 {
     // ++ direction less updated
     if (m_nextUsedPos[USED_POS_PLUS]!=m_UsedPosLists[USED_POS_PLUS].end() &&
-        (m_nextUsedPos[USED_POS_MINUS]==m_UsedPosLists[USED_POS_MINUS].end() || m_nextUsedPos[USED_POS_PLUS]->first <= m_nextUsedPos[USED_POS_MINUS]->first) )
+        (m_nextUsedPos[USED_POS_MINUS]==m_UsedPosLists[USED_POS_MINUS].end() || m_nextUsedPos[USED_POS_PLUS]->first <= m_nextUsedPos[USED_POS_MINUS]->first))
     {
         bool ok;
         if (m_smallStepOk[USED_POS_PLUS])
@@ -133,7 +133,7 @@
         if (m_smallStepOk[USED_POS_MINUS])
             ok = NextSmallStepAngle(-1.0f, USED_POS_MINUS, angle);
         else
-            ok =  NextAngleFor(*m_nextUsedPos[USED_POS_MINUS], -1.0f, USED_POS_MINUS, angle);
+            ok = NextAngleFor(*m_nextUsedPos[USED_POS_MINUS], -1.0f, USED_POS_MINUS, angle);
 
         if (!ok)
             ++m_nextUsedPos[USED_POS_MINUS];
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Entities/Pet/Pet.cpp
--- a/src/server/game/Entities/Pet/Pet.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Entities/Pet/Pet.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -97,30 +97,42 @@
 
     uint32 ownerid = owner->GetGUIDLow();
 
-    QueryResult result;
+    PreparedStatement* stmt;
+    PreparedQueryResult result;
 
     if (petnumber)
-        // known petnumber entry                  0   1      2(?)   3        4      5    6           7     8     9        10         11       12            13      14        15              16
-        result = CharacterDatabase.PQuery("SELECT id, entry, owner, modelid, level, exp, Reactstate, slot, name, renamed, curhealth, curmana, curhappiness, abdata, savetime, CreatedBySpell, PetType "
-            "FROM character_pet WHERE owner = '%u' AND id = '%u'",
-            ownerid, petnumber);
+    {
+        // Known petnumber entry
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_PET_BY_ENTRY);
+        stmt->setUInt32(0, ownerid);
+        stmt->setUInt32(1, petnumber);
+    }
     else if (current)
-        // current pet (slot 0)                   0   1      2(?)   3        4      5    6           7     8     9        10         11       12            13      14        15              16
-        result = CharacterDatabase.PQuery("SELECT id, entry, owner, modelid, level, exp, Reactstate, slot, name, renamed, curhealth, curmana, curhappiness, abdata, savetime, CreatedBySpell, PetType "
-            "FROM character_pet WHERE owner = '%u' AND slot = '%u'",
-            ownerid, PET_SAVE_AS_CURRENT);
+    {
+        // Current pet (slot 0)
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_PET_BY_ENTRY_AND_SLOT);
+        stmt->setUInt32(0, ownerid);
+        stmt->setUInt8(1, uint8(PET_SAVE_AS_CURRENT));
+    }
     else if (petentry)
+    {
         // known petentry entry (unique for summoned pet, but non unique for hunter pet (only from current or not stabled pets)
-        //                                        0   1      2(?)   3        4      5    6           7     8     9        10         11       12           13       14        15              16
-        result = CharacterDatabase.PQuery("SELECT id, entry, owner, modelid, level, exp, Reactstate, slot, name, renamed, curhealth, curmana, curhappiness, abdata, savetime, CreatedBySpell, PetType "
-            "FROM character_pet WHERE owner = '%u' AND entry = '%u' AND (slot = '%u' OR slot > '%u') ",
-            ownerid, petentry, PET_SAVE_AS_CURRENT, PET_SAVE_LAST_STABLE_SLOT);
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_PET_BY_ENTRY_AND_SLOT_2);
+        stmt->setUInt32(0, ownerid);
+        stmt->setUInt32(1, petentry);
+        stmt->setUInt8(2, uint8(PET_SAVE_AS_CURRENT));
+        stmt->setUInt8(3, uint8(PET_SAVE_LAST_STABLE_SLOT));
+    }
     else
-        // any current or other non-stabled pet (for hunter "call pet")
-        //                                        0   1      2(?)   3        4      5    6           7     8     9        10         11       12            13      14        15              16
-        result = CharacterDatabase.PQuery("SELECT id, entry, owner, modelid, level, exp, Reactstate, slot, name, renamed, curhealth, curmana, curhappiness, abdata, savetime, CreatedBySpell, PetType "
-            "FROM character_pet WHERE owner = '%u' AND (slot = '%u' OR slot > '%u') ",
-            ownerid, PET_SAVE_AS_CURRENT, PET_SAVE_LAST_STABLE_SLOT);
+    {
+        // Any current or other non-stabled pet (for hunter "call pet")
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_PET_BY_SLOT);
+        stmt->setUInt32(0, ownerid);
+        stmt->setUInt8(1, uint8(PET_SAVE_AS_CURRENT));
+        stmt->setUInt8(2, uint8(PET_SAVE_LAST_STABLE_SLOT));
+    }
+
+    result = CharacterDatabase.Query(stmt);
 
     if (!result)
     {
@@ -254,10 +266,20 @@
     if (fields[7].GetUInt8())
     {
         SQLTransaction trans = CharacterDatabase.BeginTransaction();
-        trans->PAppend("UPDATE character_pet SET slot = '%u' WHERE owner = '%u' AND slot = '%u' AND id <> '%u'",
-            PET_SAVE_NOT_IN_SLOT, ownerid, PET_SAVE_AS_CURRENT, m_charmInfo->GetPetNumber());
-        trans->PAppend("UPDATE character_pet SET slot = '%u' WHERE owner = '%u' AND id = '%u'",
-            PET_SAVE_AS_CURRENT, ownerid, m_charmInfo->GetPetNumber());
+
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UDP_CHAR_PET_SLOT_BY_SLOT_EXCLUDE_ID);
+        stmt->setUInt8(0, uint8(PET_SAVE_NOT_IN_SLOT));
+        stmt->setUInt32(1, ownerid);
+        stmt->setUInt8(2, uint8(PET_SAVE_AS_CURRENT));
+        stmt->setUInt32(3, m_charmInfo->GetPetNumber());
+        trans->Append(stmt);
+
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_PET_SLOT_BY_ID);
+        stmt->setUInt8(0, uint8(PET_SAVE_AS_CURRENT));
+        stmt->setUInt32(1, ownerid);
+        stmt->setUInt32(2, m_charmInfo->GetPetNumber());
+        trans->Append(stmt);
+
         CharacterDatabase.CommitTransaction(trans);
     }
 
@@ -310,7 +332,10 @@
 
     if (getPetType() == HUNTER_PET)
     {
-        result = CharacterDatabase.PQuery("SELECT genitive, dative, accusative, instrumental, prepositional FROM character_pet_declinedname WHERE owner = '%u' AND id = '%u'", owner->GetGUIDLow(), GetCharmInfo()->GetPetNumber());
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PET_DECLINED_NAME);
+        stmt->setUInt32(0, owner->GetGUIDLow());
+        stmt->setUInt32(1, GetCharmInfo()->GetPetNumber());
+        PreparedQueryResult result = CharacterDatabase.Query(stmt);
 
         if (result)
         {
@@ -385,17 +410,31 @@
         CharacterDatabase.EscapeString(name);
         trans = CharacterDatabase.BeginTransaction();
         // remove current data
-        trans->PAppend("DELETE FROM character_pet WHERE owner = '%u' AND id = '%u'", ownerLowGUID, m_charmInfo->GetPetNumber());
+
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_PET_BY_ID);
+        stmt->setUInt32(0, m_charmInfo->GetPetNumber());
+        trans->Append(stmt);
 
         // prevent duplicate using slot (except PET_SAVE_NOT_IN_SLOT)
         if (mode <= PET_SAVE_LAST_STABLE_SLOT)
-            trans->PAppend("UPDATE character_pet SET slot = '%u' WHERE owner = '%u' AND slot = '%u'",
-                PET_SAVE_NOT_IN_SLOT, ownerLowGUID, uint32(mode));
+        {
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_UDP_CHAR_PET_SLOT_BY_SLOT);
+            stmt->setUInt8(0, uint8(PET_SAVE_NOT_IN_SLOT));
+            stmt->setUInt32(1, ownerLowGUID);
+            stmt->setUInt8(2, uint8(mode));
+            trans->Append(stmt);
+        }
 
         // prevent existence another hunter pet in PET_SAVE_AS_CURRENT and PET_SAVE_NOT_IN_SLOT
         if (getPetType() == HUNTER_PET && (mode == PET_SAVE_AS_CURRENT || mode > PET_SAVE_LAST_STABLE_SLOT))
-            trans->PAppend("DELETE FROM character_pet WHERE owner = '%u' AND (slot = '%u' OR slot > '%u')",
-                ownerLowGUID, PET_SAVE_AS_CURRENT, PET_SAVE_LAST_STABLE_SLOT);
+        {
+            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_PET_BY_SLOT);
+            stmt->setUInt32(0, ownerLowGUID);
+            stmt->setUInt8(1, uint8(PET_SAVE_AS_CURRENT));
+            stmt->setUInt8(2, uint8(PET_SAVE_LAST_STABLE_SLOT));
+            trans->Append(stmt);
+        }
+
         // save pet
         std::ostringstream ss;
         ss  << "INSERT INTO character_pet (id, entry,  owner, modelid, level, exp, Reactstate, slot, name, renamed, curhealth, curmana, curhappiness, abdata, savetime, CreatedBySpell, PetType) "
@@ -417,7 +456,7 @@
         for (uint32 i = ACTION_BAR_INDEX_START; i < ACTION_BAR_INDEX_END; ++i)
         {
             ss << uint32(m_charmInfo->GetActionBarEntry(i)->GetType()) << ' '
-               << uint32(m_charmInfo->GetActionBarEntry(i)->GetAction()) << ' ';
+                << uint32(m_charmInfo->GetActionBarEntry(i)->GetAction()) << ' ';
         };
 
         ss  << "', "
@@ -439,11 +478,27 @@
 void Pet::DeleteFromDB(uint32 guidlow)
 {
     SQLTransaction trans = CharacterDatabase.BeginTransaction();
-    trans->PAppend("DELETE FROM character_pet WHERE id = '%u'", guidlow);
-    trans->PAppend("DELETE FROM character_pet_declinedname WHERE id = '%u'", guidlow);
-    trans->PAppend("DELETE FROM pet_aura WHERE guid = '%u'", guidlow);
-    trans->PAppend("DELETE FROM pet_spell WHERE guid = '%u'", guidlow);
-    trans->PAppend("DELETE FROM pet_spell_cooldown WHERE guid = '%u'", guidlow);
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_PET_BY_ID);
+    stmt->setUInt32(0, guidlow);
+    trans->Append(stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_PET_DECLINEDNAME);
+    stmt->setUInt32(0, guidlow);
+    trans->Append(stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PET_AURAS);
+    stmt->setUInt32(0, guidlow);
+    trans->Append(stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PET_SPELLS);
+    stmt->setUInt32(0, guidlow);
+    trans->Append(stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PET_SPELL_COOLDOWNS);
+    stmt->setUInt32(0, guidlow);
+    trans->Append(stmt);
+
     CharacterDatabase.CommitTransaction(trans);
 }
 
@@ -912,7 +967,7 @@
                         SetCreateHealth(40*petlevel);
                         SetCreateMana(28 + 10*petlevel);
                     }
-                    SetBonusDamage(m_owner->SpellBaseDamageBonus(SPELL_SCHOOL_MASK_FIRE) * 0.5f);
+                    SetBonusDamage(int32(m_owner->SpellBaseDamageBonus(SPELL_SCHOOL_MASK_FIRE) * 0.5f));
                     SetBaseWeaponDamage(BASE_ATTACK, MINDAMAGE, float(petlevel * 4 - petlevel));
                     SetBaseWeaponDamage(BASE_ATTACK, MAXDAMAGE, float(petlevel * 4 + petlevel));
                     break;
@@ -986,6 +1041,13 @@
                     SetBaseWeaponDamage(BASE_ATTACK, MAXDAMAGE, float(petlevel + (petlevel / 4)));
                     break;
                 }
+                case 28017: // Bloodworms
+                {
+                    SetCreateHealth(4 * petlevel);
+                    SetBonusDamage(int32(m_owner->GetTotalAttackPowerValue(BASE_ATTACK) * 0.006f));
+                    SetBaseWeaponDamage(BASE_ATTACK, MINDAMAGE, float(petlevel - 30 - (petlevel / 4)));
+                    SetBaseWeaponDamage(BASE_ATTACK, MAXDAMAGE, float(petlevel - 30 + (petlevel / 4)));
+                }
             }
             break;
         }
@@ -1037,7 +1099,9 @@
     m_CreatureSpellCooldowns.clear();
     m_CreatureCategoryCooldowns.clear();
 
-    QueryResult result = CharacterDatabase.PQuery("SELECT spell, time FROM pet_spell_cooldown WHERE guid = '%u'", m_charmInfo->GetPetNumber());
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PET_SPELL_COOLDOWN);
+    stmt->setUInt32(0, m_charmInfo->GetPetNumber());
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
 
     if (result)
     {
@@ -1080,7 +1144,9 @@
 
 void Pet::_SaveSpellCooldowns(SQLTransaction& trans)
 {
-    trans->PAppend("DELETE FROM pet_spell_cooldown WHERE guid = '%u'", m_charmInfo->GetPetNumber());
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PET_SPELL_COOLDOWNS);
+    stmt->setUInt32(0, m_charmInfo->GetPetNumber());
+    trans->Append(stmt);
 
     time_t curTime = time(NULL);
 
@@ -1091,7 +1157,12 @@
             m_CreatureSpellCooldowns.erase(itr++);
         else
         {
-            trans->PAppend("INSERT INTO pet_spell_cooldown (guid, spell, time) VALUES ('%u', '%u', '%u')", m_charmInfo->GetPetNumber(), itr->first, uint32(itr->second));
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_PET_SPELL_COOLDOWN);
+            stmt->setUInt32(0, m_charmInfo->GetPetNumber());
+            stmt->setUInt32(1, itr->first);
+            stmt->setUInt32(2, uint32(itr->second));
+            trans->Append(stmt);
+
             ++itr;
         }
     }
@@ -1099,7 +1170,9 @@
 
 void Pet::_LoadSpells()
 {
-    QueryResult result = CharacterDatabase.PQuery("SELECT spell, active FROM pet_spell WHERE guid = '%u'", m_charmInfo->GetPetNumber());
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PET_SPELL);
+    stmt->setUInt32(0, m_charmInfo->GetPetNumber());
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
 
     if (result)
     {
@@ -1123,18 +1196,37 @@
         if (itr->second.type == PETSPELL_FAMILY)
             continue;
 
+        PreparedStatement* stmt;
+
         switch (itr->second.state)
         {
             case PETSPELL_REMOVED:
-                trans->PAppend("DELETE FROM pet_spell WHERE guid = '%u' and spell = '%u'", m_charmInfo->GetPetNumber(), itr->first);
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PET_SPELL_BY_SPELL);
+                stmt->setUInt32(0, m_charmInfo->GetPetNumber());
+                stmt->setUInt32(1, itr->first);
+                trans->Append(stmt);
+
                 m_spells.erase(itr);
                 continue;
             case PETSPELL_CHANGED:
-                trans->PAppend("DELETE FROM pet_spell WHERE guid = '%u' and spell = '%u'", m_charmInfo->GetPetNumber(), itr->first);
-                trans->PAppend("INSERT INTO pet_spell (guid, spell, active) VALUES ('%u', '%u', '%u')", m_charmInfo->GetPetNumber(), itr->first, itr->second.active);
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PET_SPELL_BY_SPELL);
+                stmt->setUInt32(0, m_charmInfo->GetPetNumber());
+                stmt->setUInt32(1, itr->first);
+                trans->Append(stmt);
+
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_PET_SPELL);
+                stmt->setUInt32(0, m_charmInfo->GetPetNumber());
+                stmt->setUInt32(1, itr->first);
+                stmt->setUInt8(2, itr->second.active);
+                trans->Append(stmt);
+
                 break;
             case PETSPELL_NEW:
-                trans->PAppend("INSERT INTO pet_spell (guid, spell, active) VALUES ('%u', '%u', '%u')", m_charmInfo->GetPetNumber(), itr->first, itr->second.active);
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_PET_SPELL);
+                stmt->setUInt32(0, m_charmInfo->GetPetNumber());
+                stmt->setUInt32(1, itr->first);
+                stmt->setUInt8(2, itr->second.active);
+                trans->Append(stmt);
                 break;
             case PETSPELL_UNCHANGED:
                 continue;
@@ -1147,7 +1239,9 @@
 {
     sLog->outDebug(LOG_FILTER_PETS, "Loading auras for pet %u", GetGUIDLow());
 
-    QueryResult result = CharacterDatabase.PQuery("SELECT caster_guid, spell, effect_mask, recalculate_mask, stackcount, amount0, amount1, amount2, base_amount0, base_amount1, base_amount2, maxduration, remaintime, remaincharges FROM pet_aura WHERE guid = '%u'", m_charmInfo->GetPetNumber());
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PET_AURA);
+    stmt->setUInt32(0, m_charmInfo->GetPetNumber());
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
 
     if (result)
     {
@@ -1217,9 +1311,11 @@
 
 void Pet::_SaveAuras(SQLTransaction& trans)
 {
-    trans->PAppend("DELETE FROM pet_aura WHERE guid = '%u'", m_charmInfo->GetPetNumber());
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PET_AURAS);
+    stmt->setUInt32(0, m_charmInfo->GetPetNumber());
+    trans->Append(stmt);
 
-    for (AuraMap::const_iterator itr = m_ownedAuras.begin(); itr != m_ownedAuras.end() ; ++itr)
+    for (AuraMap::const_iterator itr = m_ownedAuras.begin(); itr != m_ownedAuras.end(); ++itr)
     {
         // check if the aura has to be saved
         if (!itr->second->CanBeSaved() || IsPetAura(itr->second))
@@ -1251,11 +1347,26 @@
         // don't save guid of caster in case we are caster of the spell - guid for pet is generated every pet load, so it won't match saved guid anyways
         uint64 casterGUID = (itr->second->GetCasterGUID() == GetGUID()) ? 0 : itr->second->GetCasterGUID();
 
-        trans->PAppend("INSERT INTO pet_aura (guid, caster_guid, spell, effect_mask, recalculate_mask, stackcount, amount0, amount1, amount2, base_amount0, base_amount1, base_amount2, maxduration, remaintime, remaincharges) "
-            "VALUES ('%u', '" UI64FMTD "', '%u', '%u', '%u', '%u', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%u')",
-            m_charmInfo->GetPetNumber(), casterGUID, itr->second->GetId(), effMask, recalculateMask,
-            itr->second->GetStackAmount(), damage[0], damage[1], damage[2], baseDamage[0], baseDamage[1], baseDamage[2],
-            itr->second->GetMaxDuration(), itr->second->GetDuration(), itr->second->GetCharges());
+        uint8 index = 0;
+
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_PET_AURA);
+        stmt->setUInt32(index++, m_charmInfo->GetPetNumber());
+        stmt->setUInt64(index++, casterGUID);
+        stmt->setUInt32(index++, itr->second->GetId());
+        stmt->setUInt8(index++, effMask);
+        stmt->setUInt8(index++, recalculateMask);
+        stmt->setUInt8(index++, itr->second->GetStackAmount());
+        stmt->setInt32(index++, damage[0]);
+        stmt->setInt32(index++, damage[1]);
+        stmt->setInt32(index++, damage[2]);
+        stmt->setInt32(index++, baseDamage[0]);
+        stmt->setInt32(index++, baseDamage[1]);
+        stmt->setInt32(index++, baseDamage[2]);
+        stmt->setInt32(index++, itr->second->GetMaxDuration());
+        stmt->setInt32(index++, itr->second->GetDuration());
+        stmt->setUInt8(index++, itr->second->GetCharges());
+
+        trans->Append(stmt);
     }
 }
 
@@ -1630,18 +1741,19 @@
     // now need only reset for offline pets (all pets except online case)
     uint32 except_petnumber = online_pet ? online_pet->GetCharmInfo()->GetPetNumber() : 0;
 
-    QueryResult resultPets = CharacterDatabase.PQuery(
-        "SELECT id FROM character_pet WHERE owner = '%u' AND id <> '%u'",
-        owner->GetGUIDLow(), except_petnumber);
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_PET);
+    stmt->setUInt32(0, owner->GetGUIDLow());
+    stmt->setUInt32(1, except_petnumber);
+    PreparedQueryResult resultPets = CharacterDatabase.Query(stmt);
 
     // no offline pets
     if (!resultPets)
         return;
 
-    QueryResult result = CharacterDatabase.PQuery(
-        "SELECT DISTINCT pet_spell.spell FROM pet_spell, character_pet "
-        "WHERE character_pet.owner = '%u' AND character_pet.id = pet_spell.guid AND character_pet.id <> %u",
-        owner->GetGUIDLow(), except_petnumber);
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PET_SPELL_LIST);
+    stmt->setUInt32(0, owner->GetGUIDLow());
+    stmt->setUInt32(1, except_petnumber);
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
 
     if (!result)
         return;
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Entities/Player/Player.cpp
--- a/src/server/game/Entities/Player/Player.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Entities/Player/Player.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -862,10 +862,14 @@
 
     isDebugAreaTriggers = false;
 
+    m_WeeklyQuestChanged = false;
+
+    m_SeasonalQuestChanged = false;
+
     SetPendingBind(0, 0);
 }
 
-Player::~Player ()
+Player::~Player()
 {
     // it must be unloaded already in PlayerLogout and accessed only for loggined player
     //m_social = NULL;
@@ -885,7 +889,7 @@
     }
 
     //all mailed items should be deleted, also all mail should be deallocated
-    for (PlayerMails::iterator itr =  m_mail.begin(); itr != m_mail.end(); ++itr)
+    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end(); ++itr)
         delete *itr;
 
     for (ItemMap::iterator iter = mMitems.begin(); iter != mMitems.end(); ++iter)
@@ -932,7 +936,8 @@
     PlayerInfo const* info = sObjectMgr->GetPlayerInfo(createInfo->Race, createInfo->Class);
     if (!info)
     {
-        sLog->outError("Player (Name %s) has incorrect race/class pair. Can't be loaded.", m_name.c_str());
+        sLog->outError("Player::Create: Possible hacking-attempt: Account %u tried creating a character named '%s' with an invalid race/class pair (%u/%u) - refusing to do so.",
+                GetSession()->GetAccountId(), m_name.c_str(), createInfo->Race, createInfo->Class);
         return false;
     }
 
@@ -944,7 +949,8 @@
     ChrClassesEntry const* cEntry = sChrClassesStore.LookupEntry(createInfo->Class);
     if (!cEntry)
     {
-        sLog->outError("Class %u not found in DBC (Wrong DBC files?)", createInfo->Class);
+        sLog->outError("Player::Create: Possible hacking-attempt: Account %u tried creating a character named '%s' with an invalid character class (%u) - refusing to do so (wrong DBC-files?)",
+                GetSession()->GetAccountId(), m_name.c_str(), createInfo->Class);
         return false;
     }
 
@@ -959,7 +965,8 @@
 
     if (!IsValidGender(createInfo->Gender))
     {
-        sLog->outError("Player has invalid gender (%hu), can't be loaded.", createInfo->Gender);
+        sLog->outError("Player::Create: Possible hacking-attempt: Account %u tried creating a character named '%s' with an invalid gender (%hu) - refusing to do so",
+                GetSession()->GetAccountId(), m_name.c_str(), createInfo->Gender);
         return false;
     }
 
@@ -1920,7 +1927,7 @@
 
     uint32 charFlags = 0;
     uint32 playerFlags = fields[14].GetUInt32();
-    uint32 atLoginFlags = fields[15].GetUInt32();
+    uint16 atLoginFlags = fields[15].GetUInt16();
     if (playerFlags & PLAYER_FLAGS_HIDE_HELM)
         charFlags |= CHARACTER_FLAG_HIDE_HELM;
     if (playerFlags & PLAYER_FLAGS_HIDE_CLOAK)
@@ -2943,7 +2950,7 @@
     if (xp < 1)
         return;
 
-    if (!isAlive())
+    if (!isAlive() && !GetBattlegroundId())
         return;
 
     if (HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_NO_XP_GAIN))
@@ -3152,7 +3159,7 @@
     // reset before any aura state sources (health set/aura apply)
     SetUInt32Value(UNIT_FIELD_AURASTATE, 0);
 
-    UpdateSkillsForLevel ();
+    UpdateSkillsForLevel();
 
     // set default cast time multiplier
     SetFloatValue(UNIT_MOD_CAST_SPEED, 1.0f);
@@ -3431,7 +3438,7 @@
     else                                                    // not ready and no have ready mails
     {
         if (!m_nextMailDelivereTime || m_nextMailDelivereTime > deliver_time)
-            m_nextMailDelivereTime =  deliver_time;
+            m_nextMailDelivereTime = deliver_time;
     }
 }
 
@@ -3806,7 +3813,7 @@
         uint32 new_skill_max_value = spellLearnSkill->maxvalue == 0 ? maxskill : spellLearnSkill->maxvalue;
 
         if (skill_max_value < new_skill_max_value)
-            skill_max_value =  new_skill_max_value;
+            skill_max_value = new_skill_max_value;
 
         SetSkill(spellLearnSkill->skill, spellLearnSkill->step, skill_value, skill_max_value);
     }
@@ -4316,7 +4323,9 @@
 
 void Player::_SaveSpellCooldowns(SQLTransaction& trans)
 {
-    trans->PAppend("DELETE FROM character_spell_cooldown WHERE guid = '%u'", GetGUIDLow());
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SPELL_COOLDOWN);
+    stmt->setUInt32(0, GetGUIDLow());
+    trans->Append(stmt);
 
     time_t curTime = time(NULL);
     time_t infTime = curTime + infinityCooldownDelayCheck;
@@ -4696,7 +4705,7 @@
         return TRAINER_SPELL_RED;
 
     bool hasSpell = true;
-    for (uint8 i = 0; i < MAX_SPELL_EFFECTS ; ++i)
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
     {
         if (!trainer_spell->learnedSpell[i])
             continue;
@@ -4719,7 +4728,7 @@
     if (getLevel() < trainer_spell->reqLevel)
         return TRAINER_SPELL_RED;
 
-    for (uint8 i = 0; i < MAX_SPELL_EFFECTS ; ++i)
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
     {
         if (!trainer_spell->learnedSpell[i])
             continue;
@@ -4746,7 +4755,7 @@
 
     // check primary prof. limit
     // first rank of primary profession spell when there are no proffesions avalible is disabled
-    for (uint8 i = 0; i < MAX_SPELL_EFFECTS ; ++i)
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
     {
         if (!trainer_spell->learnedSpell[i])
             continue;
@@ -4798,7 +4807,10 @@
     LeaveAllArenaTeams(playerguid);
 
     // the player was uninvited already on logout so just remove from group
-    QueryResult resultGroup = CharacterDatabase.PQuery("SELECT guid FROM group_member WHERE memberGuid=%u", guid);
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GROUP_MEMBER);
+    stmt->setUInt32(0, guid);
+    PreparedQueryResult resultGroup = CharacterDatabase.Query(stmt);
+
     if (resultGroup)
         if (Group* group = sGroupMgr->GetGroupByDbStoreId((*resultGroup)[0].GetUInt32()))
             RemoveFromGroup(group, playerguid);
@@ -4812,32 +4824,41 @@
         case CHAR_DELETE_REMOVE:
         {
             SQLTransaction trans = CharacterDatabase.BeginTransaction();
-            // Return back all mails with COD and Item                 0  1           2              3      4       5          6     7
-            QueryResult resultMail = CharacterDatabase.PQuery("SELECT id, messageType, mailTemplateId, sender, subject, body, money, has_items FROM mail WHERE receiver='%u' AND has_items<>0 AND cod<>0", guid);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_COD_ITEM_MAIL);
+            stmt->setUInt32(0, guid);
+            PreparedQueryResult resultMail = CharacterDatabase.Query(stmt);
+
             if (resultMail)
             {
                 do
                 {
-                    Field* fields = resultMail->Fetch();
-
-                    uint32 mail_id       = fields[0].GetUInt32();
-                    uint16 mailType      = fields[1].GetUInt16();
-                    uint16 mailTemplateId= fields[2].GetUInt16();
-                    uint32 sender        = fields[3].GetUInt32();
-                    std::string subject  = fields[4].GetString();
-                    std::string body     = fields[5].GetString();
-                    uint32 money         = fields[6].GetUInt32();
-                    bool has_items       = fields[7].GetBool();
+                    Field* mailFields = resultMail->Fetch();
+
+                    uint32 mail_id       = mailFields[0].GetUInt32();
+                    uint8 mailType       = mailFields[1].GetUInt8();
+                    uint16 mailTemplateId= mailFields[2].GetUInt16();
+                    uint32 sender        = mailFields[3].GetUInt32();
+                    std::string subject  = mailFields[4].GetString();
+                    std::string body     = mailFields[5].GetString();
+                    uint32 money         = mailFields[6].GetUInt32();
+                    bool has_items       = mailFields[7].GetBool();
 
                     // We can return mail now
                     // So firstly delete the old one
-                    trans->PAppend("DELETE FROM mail WHERE id = '%u'", mail_id);
+                    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_BY_ID);
+                    stmt->setUInt32(0, mail_id);
+                    trans->Append(stmt);
 
                     // Mail is not from player
                     if (mailType != MAIL_NORMAL)
                     {
                         if (has_items)
-                            trans->PAppend("DELETE FROM mail_items WHERE mail_id = '%u'", mail_id);
+                        {
+                            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM_BY_ID);
+                            stmt->setUInt32(0, mail_id);
+                            trans->Append(stmt);
+                        }
                         continue;
                     }
 
@@ -4855,9 +4876,9 @@
                         {
                             do
                             {
-                                Field* fields2 = resultItems->Fetch();
-                                uint32 item_guidlow = fields2[11].GetUInt32();
-                                uint32 item_template = fields2[12].GetUInt32();
+                                Field* itemFields = resultItems->Fetch();
+                                uint32 item_guidlow = itemFields[11].GetUInt32();
+                                uint32 item_template = itemFields[12].GetUInt32();
 
                                 ItemTemplate const* itemProto = sObjectMgr->GetItemTemplate(item_template);
                                 if (!itemProto)
@@ -4869,7 +4890,7 @@
                                 }
 
                                 Item* pItem = NewItemOrBag(itemProto);
-                                if (!pItem->LoadFromDB(item_guidlow, MAKE_NEW_GUID(guid, 0, HIGHGUID_PLAYER), fields, item_template))
+                                if (!pItem->LoadFromDB(item_guidlow, MAKE_NEW_GUID(guid, 0, HIGHGUID_PLAYER), itemFields, item_template))
                                 {
                                     pItem->FSetState(ITEM_REMOVED);
                                     pItem->SaveToDB(trans);              // it also deletes item object!
@@ -4882,7 +4903,9 @@
                         }
                     }
 
-                    trans->PAppend("DELETE FROM mail_items WHERE mail_id = '%u'", mail_id);
+                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM_BY_ID);
+                    stmt->setUInt32(0, mail_id);
+                    trans->Append(stmt);
 
                     uint32 pl_account = sObjectMgr->GetPlayerAccountIdByGUID(MAKE_NEW_GUID(guid, 0, HIGHGUID_PLAYER));
 
@@ -4893,7 +4916,11 @@
 
             // Unsummon and delete for pets in world is not required: player deleted from CLI or character list with not loaded pet.
             // NOW we can finally clear other DB data related to character
-            if (QueryResult resultPets = CharacterDatabase.PQuery("SELECT id FROM character_pet WHERE owner = '%u'", guid))
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_PETS);
+            stmt->setUInt32(0, guid);
+            PreparedQueryResult resultPets = CharacterDatabase.Query(stmt);
+
+            if (resultPets)
             {
                 do
                 {
@@ -4903,7 +4930,11 @@
             }
 
             // Delete char from social list of online chars
-            if (QueryResult resultFriends = CharacterDatabase.PQuery("SELECT DISTINCT guid FROM character_social WHERE friend = '%u'", guid))
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_SOCIAL);
+            stmt->setUInt32(0, guid);
+            PreparedQueryResult resultFriends = CharacterDatabase.Query(stmt);
+
+            if (resultFriends)
             {
                 do
                 {
@@ -4918,48 +4949,134 @@
                 } while (resultFriends->NextRow());
             }
 
-            trans->PAppend("DELETE FROM characters WHERE guid = '%u'", guid);
-            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_ACCOUNT_DATA);
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHARACTER);
             stmt->setUInt32(0, guid);
             trans->Append(stmt);
-            trans->PAppend("DELETE FROM character_declinedname WHERE guid = '%u'", guid);
-            trans->PAppend("DELETE FROM character_action WHERE guid = '%u'", guid);
-            trans->PAppend("DELETE FROM character_aura WHERE guid = '%u'", guid);
-            trans->PAppend("DELETE FROM character_gifts WHERE guid = '%u'", guid);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_ACCOUNT_DATA);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_DECLINED_NAME);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACTION);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_AURA);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_GIFT);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
             stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_HOMEBIND);
             stmt->setUInt32(0, guid);
             trans->Append(stmt);
-            trans->PAppend("DELETE FROM character_instance WHERE guid = '%u'", guid);
-            trans->PAppend("DELETE FROM character_inventory WHERE guid = '%u'", guid);
-            trans->PAppend("DELETE FROM character_queststatus WHERE guid = '%u'", guid);
-            trans->PAppend("DELETE FROM character_queststatus_rewarded WHERE guid = '%u'", guid);
-            trans->PAppend("DELETE FROM character_reputation WHERE guid = '%u'", guid);
-            trans->PAppend("DELETE FROM character_spell WHERE guid = '%u'", guid);
-            trans->PAppend("DELETE FROM character_spell_cooldown WHERE guid = '%u'", guid);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INSTANCE);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INVENTORY);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_REWARDED);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_REPUTATION);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SPELL);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SPELL_COOLDOWN);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
             stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_GM_TICKETS);
             stmt->setUInt32(0, guid);
             trans->Append(stmt);
-            trans->PAppend("DELETE FROM item_instance WHERE owner_guid = '%u'", guid);
-            trans->PAppend("DELETE FROM character_social WHERE guid = '%u' OR friend='%u'", guid, guid);
-            trans->PAppend("DELETE FROM mail WHERE receiver = '%u'", guid);
-            trans->PAppend("DELETE FROM mail_items WHERE receiver = '%u'", guid);
-            trans->PAppend("DELETE FROM character_pet WHERE owner = '%u'", guid);
-            trans->PAppend("DELETE FROM character_pet_declinedname WHERE owner = '%u'", guid);
-            trans->PAppend("DELETE FROM character_achievement WHERE guid = '%u' "   // NOTE: These achievements have flags & 256 in DBC.
-                                        "AND achievement NOT BETWEEN '456' AND '467' "          // Realm First Level 80
-                                        "AND achievement NOT BETWEEN '1400' AND '1427' "        // Realm First Raid Achievements
-                                        "AND achievement NOT IN(1463, 3117, 3259) ", guid);     // Realm First Northen Vanguard + Raid Achievements
-            trans->PAppend("DELETE FROM character_achievement_progress WHERE guid = '%u'", guid);
-            trans->PAppend("DELETE FROM character_equipmentsets WHERE guid = '%u'", guid);
-            trans->PAppend("DELETE FROM guild_eventlog WHERE PlayerGuid1 = '%u' OR PlayerGuid2 = '%u'", guid, guid);
-            trans->PAppend("DELETE FROM guild_bank_eventlog WHERE PlayerGuid = '%u'", guid);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SOCIAL_BY_FRIEND);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SOCIAL_BY_GUID);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEMS);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_PET_BY_OWNER);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_PET_DECLINEDNAME_BY_OWNER);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACHIEVEMENTS);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACHIEVEMENT_PROGRESS);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_EQUIPMENTSETS);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GUILD_EVENTLOG_BY_PLAYER);
+            stmt->setUInt32(0, guid);
+            stmt->setUInt32(1, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GUILD_BANK_EVENTLOG_BY_PLAYER);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
             stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_BGDATA);
             stmt->setUInt32(0, guid);
             trans->Append(stmt);
-            trans->PAppend("DELETE FROM character_glyphs WHERE guid = '%u'", guid);
-            trans->PAppend("DELETE FROM character_queststatus_daily WHERE guid = '%u'", guid);
-            trans->PAppend("DELETE FROM character_talent WHERE guid = '%u'", guid);
-            trans->PAppend("DELETE FROM character_skills WHERE guid = '%u'", guid);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_GLYPHS);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_DAILY);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_TALENT);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SKILLS);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
 
             CharacterDatabase.CommitTransaction(trans);
             break;
@@ -5007,15 +5124,19 @@
 {
     sLog->outString("Player::DeleteOldChars: Deleting all characters which have been deleted %u days before...", keepDays);
 
-    QueryResult resultChars = CharacterDatabase.PQuery("SELECT guid, deleteInfos_Account FROM characters WHERE deleteDate IS NOT NULL AND deleteDate < '%u'", uint32(time(NULL) - time_t(keepDays * DAY)));
-    if (resultChars)
-    {
-         sLog->outString("Player::DeleteOldChars: Found " UI64FMTD " character(s) to delete", resultChars->GetRowCount());
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_OLD_CHARS);
+    stmt->setUInt32(0, uint32(time(NULL) - time_t(keepDays * DAY)));
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+    if (result)
+    {
+         sLog->outString("Player::DeleteOldChars: Found " UI64FMTD " character(s) to delete", result->GetRowCount());
          do
          {
-            Field* charFields = resultChars->Fetch();
-            Player::DeleteFromDB(charFields[0].GetUInt64(), charFields[1].GetUInt32(), true, true);
-        } while (resultChars->NextRow());
+            Field* fields = result->Fetch();
+            Player::DeleteFromDB(fields[0].GetUInt32(), fields[1].GetUInt32(), true, true);
+         }
+         while (result->NextRow());
     }
 }
 
@@ -5256,7 +5377,7 @@
             iDisplayID = m_items[i]->GetTemplate()->DisplayInfoID;
             iIventoryType = m_items[i]->GetTemplate()->InventoryType;
 
-            _cfi =  iDisplayID | (iIventoryType << 24);
+            _cfi = iDisplayID | (iIventoryType << 24);
             corpse->SetUInt32Value(CORPSE_FIELD_ITEM + i, _cfi);
         }
     }
@@ -5312,7 +5433,7 @@
     if (!item)
         return;
 
-    uint32 pMaxDurability =  item ->GetUInt32Value(ITEM_FIELD_MAXDURABILITY);
+    uint32 pMaxDurability = item ->GetUInt32Value(ITEM_FIELD_MAXDURABILITY);
 
     if (!pMaxDurability)
         return;
@@ -6556,7 +6677,7 @@
         return 0;
 
     int32 result = int32(SKILL_VALUE(GetUInt32Value(PLAYER_SKILL_VALUE_INDEX(itr->second.pos))));
-    result +=  SKILL_PERM_BONUS(GetUInt32Value(PLAYER_SKILL_BONUS_INDEX(itr->second.pos)));
+    result += SKILL_PERM_BONUS(GetUInt32Value(PLAYER_SKILL_BONUS_INDEX(itr->second.pos)));
     return result < 0 ? 0 : result;
 }
 
@@ -7329,29 +7450,46 @@
 
 void Player::ModifyHonorPoints(int32 value, SQLTransaction* trans /*=NULL*/)
 {
+    PreparedStatement* stmt = NULL;
+
     int32 newValue = int32(GetHonorPoints()) + value;
     if (newValue < 0)
         newValue = 0;
     SetHonorPoints(uint32(newValue));
 
     if (trans && !trans->null())
-        (*trans)->PAppend("UPDATE characters SET totalHonorPoints=%u WHERE guid=%u", newValue, GetGUIDLow());
+    {
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_UDP_CHAR_HONOR_POINTS);
+        stmt->setUInt32(0, newValue);
+        stmt->setUInt32(1, GetGUIDLow());
+        (*trans)->Append(stmt);
+    }
 }
 
 void Player::ModifyArenaPoints(int32 value, SQLTransaction* trans /*=NULL*/)
 {
+    PreparedStatement* stmt = NULL;
+
     int32 newValue = int32(GetArenaPoints()) + value;
     if (newValue < 0)
         newValue = 0;
     SetArenaPoints(uint32(newValue));
 
     if (trans && !trans->null())
-        (*trans)->PAppend("UPDATE characters SET arenaPoints=%u WHERE guid=%u", newValue, GetGUIDLow());
+    {
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_UDP_CHAR_ARENA_POINTS);
+        stmt->setUInt32(0, newValue);
+        stmt->setUInt32(1, GetGUIDLow());
+        (*trans)->Append(stmt);
+    }
 }
 
 uint32 Player::GetGuildIdFromDB(uint64 guid)
 {
-    QueryResult result = CharacterDatabase.PQuery("SELECT guildid FROM guild_member WHERE guid='%u'", GUID_LOPART(guid));
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GUILD_MEMBER);
+    stmt->setUInt32(0, GUID_LOPART(guid));
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
     if (!result)
         return 0;
 
@@ -7361,10 +7499,13 @@
 
 uint8 Player::GetRankFromDB(uint64 guid)
 {
-    QueryResult result = CharacterDatabase.PQuery("SELECT rank FROM guild_member WHERE guid='%u'", GUID_LOPART(guid));
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GUILD_MEMBER);
+    stmt->setUInt32(0, GUID_LOPART(guid));
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
     if (result)
     {
-        uint32 v = result->Fetch()[0].GetUInt8();
+        uint32 v = result->Fetch()[1].GetUInt8();
         return v;
     }
     else
@@ -7373,7 +7514,11 @@
 
 uint32 Player::GetArenaTeamIdFromDB(uint64 guid, uint8 type)
 {
-    QueryResult result = CharacterDatabase.PQuery("SELECT arena_team_member.arenateamid FROM arena_team_member JOIN arena_team ON arena_team_member.arenateamid = arena_team.arenateamid WHERE guid='%u' AND type='%u' LIMIT 1", GUID_LOPART(guid), type);
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_ARENA_TEAM_ID_BY_PLAYER_GUID);
+    stmt->setUInt32(0, GUID_LOPART(guid));
+    stmt->setUInt8(1, type);
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
     if (!result)
         return 0;
 
@@ -7384,7 +7529,10 @@
 uint32 Player::GetZoneIdFromDB(uint64 guid)
 {
     uint32 guidLow = GUID_LOPART(guid);
-    QueryResult result = CharacterDatabase.PQuery("SELECT zone FROM characters WHERE guid='%u'", guidLow);
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_ZONE);
+    stmt->setUInt32(0, guidLow);
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
     if (!result)
         return 0;
     Field* fields = result->Fetch();
@@ -7393,7 +7541,10 @@
     if (!zone)
     {
         // stored zone is zero, use generic and slow zone detection
-        result = CharacterDatabase.PQuery("SELECT map, position_x, position_y, position_z FROM characters WHERE guid='%u'", guidLow);
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_POSITION_XYZ);
+        stmt->setUInt32(0, guidLow);
+        PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
         if (!result)
             return 0;
         fields = result->Fetch();
@@ -7420,7 +7571,10 @@
 
 uint32 Player::GetLevelFromDB(uint64 guid)
 {
-    QueryResult result = CharacterDatabase.PQuery("SELECT level FROM characters WHERE guid='%u'", GUID_LOPART(guid));
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_LEVEL);
+    stmt->setUInt32(0, GUID_LOPART(guid));
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
     if (!result)
         return 0;
 
@@ -7464,17 +7618,15 @@
     }
 
     // group update
-    if (GetGroup())
+    if (Group* group = GetGroup())
     {
         SetGroupUpdateFlag(GROUP_UPDATE_FULL);
-        Group* grp = GetGroup();
-        if (GetSession() && grp->isLFGGroup() && sLFGMgr->IsTeleported(GetGUID()))
-        {
-            for (GroupReference* itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
-            {
-                Player* tempplr = itr->getSource();
-                if (tempplr)
-                    GetSession()->SendNameQueryOpcode(tempplr->GetGUID());
+        if (GetSession() && group->isLFGGroup() && sLFGMgr->IsTeleported(GetGUID()))
+        {
+            for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                if (Player* member = itr->getSource())
+                    GetSession()->SendNameQueryOpcode(member->GetGUID());
             }
         }
     }
@@ -7491,9 +7643,8 @@
 
     if (sWorld->getBoolConfig(CONFIG_WEATHER))
     {
-        Weather* wth = WeatherMgr::FindWeather(zone->ID);
-        if (wth)
-            wth->SendWeatherUpdateToPlayer(this);
+        if (Weather* weather = WeatherMgr::FindWeather(zone->ID))
+            weather->SendWeatherUpdateToPlayer(this);
         else
         {
             if (!WeatherMgr::AddWeather(zone->ID))
@@ -7525,7 +7676,7 @@
             break;
     }
 
-    if (zone->flags & AREA_FLAG_CAPITAL)                     // in capital city
+    if (zone->flags & AREA_FLAG_CAPITAL)                     // Is in a capital city
     {
         if (!pvpInfo.inHostileArea || zone->IsSanctuary())
         {
@@ -7535,19 +7686,21 @@
         }
         pvpInfo.inNoPvPArea = true;
     }
-    else                                                    // anywhere else
-    {
-        if (HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING))     // but resting (walk from city or maybe in tavern or leave tavern recently)
-        {
-            if (GetRestType() == REST_TYPE_IN_TAVERN)        // has been in tavern. Is still in?
-            {
-                if (GetMapId() != GetInnPosMapId() || sqrt((GetPositionX()-GetInnPosX())*(GetPositionX()-GetInnPosX())+(GetPositionY()-GetInnPosY())*(GetPositionY()-GetInnPosY())+(GetPositionZ()-GetInnPosZ())*(GetPositionZ()-GetInnPosZ()))>40)
+    else
+    {
+        if (HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING))
+        {
+            if (GetRestType() == REST_TYPE_IN_TAVERN)        // Still inside a tavern or has recently left
+            {
+                // Remove rest state if we have recently left a tavern.
+                // Why is 40 yd hardcoded?
+                if (GetMapId() != GetInnPosMapId() || GetExactDist(GetInnPosX(), GetInnPosY(), GetInnPosZ()) > 40.0f)
                 {
                     RemoveFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING);
                     SetRestType(REST_TYPE_NO);
                 }
             }
-            else                                            // not in tavern (leave city then)
+            else                                             // Recently left a capital city
             {
                 RemoveFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING);
                 SetRestType(REST_TYPE_NO);
@@ -8123,6 +8276,10 @@
 
 void Player::_ApplyWeaponDependentAuraCritMod(Item* item, WeaponAttackType attackType, AuraEffect const* aura, bool apply)
 {
+    // don't apply mod if item is broken or cannot be used
+    if (item->IsBroken() || !CanUseAttackType(attackType))
+        return;
+
     // generic not weapon specific case processes in aura code
     if (aura->GetSpellInfo()->EquippedItemClass == -1)
         return;
@@ -8136,13 +8293,13 @@
         default: return;
     }
 
-    if (!item->IsBroken()&&item->IsFitToSpellRequirements(aura->GetSpellInfo()))
+    if (item->IsFitToSpellRequirements(aura->GetSpellInfo()))
         HandleBaseModValue(mod, FLAT_MOD, float (aura->GetAmount()), apply);
 }
 
 void Player::_ApplyWeaponDependentAuraDamageMod(Item* item, WeaponAttackType attackType, AuraEffect const* aura, bool apply)
 {
-    //don't apply mod if item is broken
+    // don't apply mod if item is broken or cannot be used
     if (item->IsBroken() || !CanUseAttackType(attackType))
         return;
 
@@ -8381,7 +8538,7 @@
             if (pEnchant->type[s] != ITEM_ENCHANTMENT_TYPE_COMBAT_SPELL)
                 continue;
 
-            SpellEnchantProcEntry const* entry =  sSpellMgr->GetSpellEnchantProcEvent(enchant_id);
+            SpellEnchantProcEntry const* entry = sSpellMgr->GetSpellEnchantProcEvent(enchant_id);
 
             if (entry && entry->procEx)
             {
@@ -8772,7 +8929,7 @@
 
         if (go->getLootState() == GO_READY)
         {
-            uint32 lootid =  go->GetGOInfo()->GetLootId();
+            uint32 lootid = go->GetGOInfo()->GetLootId();
 
             //TODO: fix this big hack
             if ((go->GetEntry() == BG_AV_OBJECTID_MINE_N || go->GetEntry() == BG_AV_OBJECTID_MINE_S))
@@ -11600,8 +11757,8 @@
                     Item* offItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
                     ItemPosCountVec off_dest;
                     if (offItem && (!not_loading ||
-                        CanUnequipItem(uint16(INVENTORY_SLOT_BAG_0) << 8 | EQUIPMENT_SLOT_OFFHAND, false) !=  EQUIP_ERR_OK ||
-                        CanStoreItem(NULL_BAG, NULL_SLOT, off_dest, offItem, false) !=  EQUIP_ERR_OK))
+                        CanUnequipItem(uint16(INVENTORY_SLOT_BAG_0) << 8 | EQUIPMENT_SLOT_OFFHAND, false) != EQUIP_ERR_OK ||
+                        CanStoreItem(NULL_BAG, NULL_SLOT, off_dest, offItem, false) != EQUIP_ERR_OK))
                         return swap ? EQUIP_ERR_ITEMS_CANT_BE_SWAPPED : EQUIP_ERR_INVENTORY_FULL;
                 }
             }
@@ -14401,15 +14558,15 @@
     {
         case GOSSIP_OPTION_GOSSIP:
         {
+            if (menuItemData->GossipActionPoi)
+                PlayerTalkClass->SendPointOfInterest(menuItemData->GossipActionPoi);
+
             if (menuItemData->GossipActionMenuId)
             {
                 PrepareGossipMenu(source, menuItemData->GossipActionMenuId);
                 SendPreparedGossip(source);
             }
 
-            if (menuItemData->GossipActionPoi)
-                PlayerTalkClass->SendPointOfInterest(menuItemData->GossipActionPoi);
-
             break;
         }
         case GOSSIP_OPTION_OUTDOORPVP:
@@ -16596,7 +16753,7 @@
         EquipmentSet eqSet;
 
         eqSet.Guid      = fields[0].GetUInt64();
-        uint32 index    = fields[1].GetUInt32();
+        uint8 index    = fields[1].GetUInt8();
         eqSet.Name      = fields[2].GetString();
         eqSet.IconName  = fields[3].GetString();
         eqSet.state     = EQUIPMENT_SET_UNCHANGED;
@@ -16638,7 +16795,10 @@
 
 bool Player::LoadPositionFromDB(uint32& mapid, float& x, float& y, float& z, float& o, bool& in_flight, uint64 guid)
 {
-    QueryResult result = CharacterDatabase.PQuery("SELECT position_x, position_y, position_z, orientation, map, taxi_path FROM characters WHERE guid = '%u'", GUID_LOPART(guid));
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_POSITION);
+    stmt->setUInt32(0, GUID_LOPART(guid));
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
     if (!result)
         return false;
 
@@ -16820,12 +16980,12 @@
     InitPrimaryProfessions();                               // to max set before any spell loaded
 
     // init saved position, and fix it later if problematic
-    uint32 transGUID = uint32(fields[30].GetUInt64());   // field type is uint64 but lowguid is saved
+    uint32 transGUID = fields[30].GetUInt32();
     Relocate(fields[12].GetFloat(), fields[13].GetFloat(), fields[14].GetFloat(), fields[16].GetFloat());
     uint32 mapId = fields[15].GetUInt16();
-    uint32 instanceId = fields[58].GetUInt8();
-
-    uint32 dungeonDiff = fields[38].GetUInt32() & 0x0F;
+    uint32 instanceId = fields[58].GetUInt32();
+
+    uint32 dungeonDiff = fields[38].GetUInt8() & 0x0F;
     if (dungeonDiff >= MAX_DUNGEON_DIFFICULTY)
         dungeonDiff = DUNGEON_DIFFICULTY_NORMAL;
     uint32 raidDiff = (fields[38].GetUInt8() >> 4) & 0x0F;
@@ -17170,7 +17330,7 @@
         float bubble0 = 0.031f;
         //speed collect rest bonus in offline, in logout, in tavern, city (section/in hour)
         float bubble1 = 0.125f;
-        float bubble = fields[23].GetUInt32() > 0
+        float bubble = fields[23].GetUInt8() > 0
             ? bubble1*sWorld->getRate(RATE_REST_OFFLINE_IN_TAVERN_OR_CITY)
             : bubble0*sWorld->getRate(RATE_REST_OFFLINE_IN_WILDERNESS);
 
@@ -17318,7 +17478,7 @@
     }
 
     // RaF stuff.
-    m_grantableLevels = fields[66].GetUInt32();
+    m_grantableLevels = fields[66].GetUInt8();
     if (GetSession()->IsARecruiter() || (GetSession()->GetRecruiterId() != 0))
         SetFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_REFER_A_FRIEND);
 
@@ -17601,7 +17761,7 @@
                         err = CanStoreItem(itr->second->GetSlot(), slot, dest, item);
                         if (err == EQUIP_ERR_OK)
                         {
-                            itr->second->StoreItem(slot, item, true);
+                            item = StoreItem(dest, item, true);
                             //It's a bit hacky, I think...
                             AddItemDurations(item);
                         }
@@ -17644,6 +17804,7 @@
 
 Item* Player::_LoadItem(SQLTransaction& trans, uint32 zoneId, uint32 timeDiff, Field* fields)
 {
+    PreparedStatement* stmt = NULL;
     Item* item = NULL;
     uint32 itemGuid  = fields[13].GetUInt32();
     uint32 itemEntry = fields[14].GetUInt32();
@@ -17673,7 +17834,11 @@
                 {
                     sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Player::_LoadInventory: player (GUID: %u, name: '%s') has item (GUID: %u, entry: %u) with expired refund time (%u). Deleting refund data and removing refundable flag.",
                         GetGUIDLow(), GetName(), item->GetGUIDLow(), item->GetEntry(), item->GetPlayedTime());
-                    trans->PAppend("DELETE FROM item_refund_instance WHERE item_guid = '%u'", item->GetGUIDLow());
+
+                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_REFUND_INSTANCE);
+                    stmt->setUInt32(0, item->GetGUIDLow());
+                    trans->Append(stmt);
+
                     item->RemoveFlag(ITEM_FIELD_FLAGS, ITEM_FLAG_REFUNDABLE);
                 }
                 else
@@ -17819,38 +17984,42 @@
     //set a count of unread mails
     //QueryResult* resultMails = CharacterDatabase.PQuery("SELECT COUNT(id) FROM mail WHERE receiver = '%u' AND (checked & 1)=0 AND deliver_time <= '" UI64FMTD "'", GUID_LOPART(playerGuid), (uint64)cTime);
     if (resultUnread)
-        unReadMails = (*resultUnread)[0].GetUInt8();
+        unReadMails = uint8((*resultUnread)[0].GetUInt64());
 
     // store nearest delivery time (it > 0 and if it < current then at next player update SendNewMaill will be called)
     //resultMails = CharacterDatabase.PQuery("SELECT MIN(deliver_time) FROM mail WHERE receiver = '%u' AND (checked & 1)=0", GUID_LOPART(playerGuid));
     if (resultDelivery)
-        m_nextMailDelivereTime = (time_t)(*resultDelivery)[0].GetUInt64();
+        m_nextMailDelivereTime = time_t((*resultDelivery)[0].GetUInt32());
 }
 
 void Player::_LoadMail()
 {
     m_mail.clear();
-    //mails are in right order                             0  1           2      3        4       5          6         7           8            9     10  11      12         13
-    QueryResult result = CharacterDatabase.PQuery("SELECT id, messageType, sender, receiver, subject, body, has_items, expire_time, deliver_time, money, cod, checked, stationery, mailTemplateId FROM mail WHERE receiver = '%u' ORDER BY id DESC", GetGUIDLow());
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_MAIL);
+    stmt->setUInt32(0, GetGUIDLow());
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
     if (result)
     {
         do
         {
             Field* fields = result->Fetch();
             Mail* m = new Mail;
-            m->messageID = fields[0].GetUInt32();
-            m->messageType = fields[1].GetUInt8();
-            m->sender = fields[2].GetUInt32();
-            m->receiver = fields[3].GetUInt32();
-            m->subject = fields[4].GetString();
-            m->body = fields[5].GetString();
-            bool has_items = fields[6].GetBool();
-            m->expire_time = time_t(fields[7].GetUInt32());
-            m->deliver_time = time_t(fields[8].GetUInt32());
-            m->money = fields[9].GetUInt32();
-            m->COD = fields[10].GetUInt32();
-            m->checked = fields[11].GetUInt32();
-            m->stationery = fields[12].GetUInt8();
+
+            m->messageID      = fields[0].GetUInt32();
+            m->messageType    = fields[1].GetUInt8();
+            m->sender         = fields[2].GetUInt32();
+            m->receiver       = fields[3].GetUInt32();
+            m->subject        = fields[4].GetString();
+            m->body           = fields[5].GetString();
+            bool has_items    = fields[6].GetBool();
+            m->expire_time    = time_t(fields[7].GetUInt32());
+            m->deliver_time   = time_t(fields[8].GetUInt32());
+            m->money          = fields[9].GetUInt32();
+            m->COD            = fields[10].GetUInt32();
+            m->checked        = fields[11].GetUInt8();
+            m->stationery     = fields[12].GetUInt8();
             m->mailTemplateId = fields[13].GetInt16();
 
             if (m->mailTemplateId && !sMailTemplateStore.LookupEntry(m->mailTemplateId))
@@ -17907,14 +18076,8 @@
                 QuestStatusData& questStatusData = m_QuestStatus[quest_id];
 
                 uint8 qstatus = fields[1].GetUInt8();
-                if (qstatus < MAX_QUEST_STATUS && qstatus > QUEST_STATUS_NONE)
+                if (qstatus < MAX_QUEST_STATUS)
                     questStatusData.Status = QuestStatus(qstatus);
-                else if (qstatus == QUEST_STATUS_NONE)
-                {
-                    sLog->outError("Player %s (GUID: %u) has QUEST_STATUS_NONE for quest %u and should be removed from character_queststatus.",
-                        GetName(), GetGUIDLow(), quest_id);
-                    continue;
-                }
                 else
                 {
                     questStatusData.Status = QUEST_STATUS_INCOMPLETE;
@@ -18049,7 +18212,7 @@
             uint32 quest_id = fields[0].GetUInt32();
 
             // save _any_ from daily quest times (it must be after last reset anyway)
-            m_lastDailyQuestTime = (time_t)fields[1].GetUInt64();
+            m_lastDailyQuestTime = time_t(fields[1].GetUInt32());
 
             Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
             if (!quest)
@@ -18198,7 +18361,7 @@
 
             if (deleteInstance)
             {
-                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INSTANCE);
+                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INSTANCE_BY_INSTANCE_GUID);
 
                 stmt->setUInt32(0, GetGUIDLow());
                 stmt->setUInt32(1, instanceId);
@@ -18254,7 +18417,7 @@
     {
         if (!unload)
         {
-            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INSTANCE);
+            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INSTANCE_BY_INSTANCE_GUID);
 
             stmt->setUInt32(0, GetGUIDLow());
             stmt->setUInt32(1, itr->second.save->GetInstanceId());
@@ -18262,10 +18425,10 @@
             CharacterDatabase.Execute(stmt);
         }
 
-        itr->second.save->RemovePlayer(this);               // save can become invalid
         if (itr->second.perm)
             GetSession()->SendCalendarRaidLockout(itr->second.save, false);
 
+        itr->second.save->RemovePlayer(this);               // save can become invalid
         m_boundInstances[difficulty].erase(itr++);
     }
 }
@@ -18620,7 +18783,7 @@
     outDebugValues();
 
     PreparedStatement* stmt = NULL;
-    uint16 index = 0;
+    uint8 index = 0;
 
     if (create)
     {
@@ -18659,12 +18822,12 @@
         //save, far from tavern/city
         //save, but in tavern/city
         stmt->setUInt32(index++, m_resetTalentsCost);
-        stmt->setUInt32(index++, m_resetTalentsTime);
+        stmt->setUInt32(index++, uint32(m_resetTalentsTime));
         stmt->setUInt16(index++, (uint16)m_ExtraFlags);
         stmt->setUInt8(index++,  m_stableSlots);
         stmt->setUInt16(index++, (uint16)m_atLoginFlags);
         stmt->setUInt16(index++, GetZoneId());
-        stmt->setUInt32(index++, m_deathExpireTime);
+        stmt->setUInt32(index++, uint32(m_deathExpireTime));
 
         ss.str("");
         ss << m_taxi.SaveTaxiDestinationsToString();
@@ -18770,12 +18933,12 @@
         //save, far from tavern/city
         //save, but in tavern/city
         stmt->setUInt32(index++, m_resetTalentsCost);
-        stmt->setUInt32(index++, m_resetTalentsTime);
+        stmt->setUInt32(index++, uint32(m_resetTalentsTime));
         stmt->setUInt16(index++, (uint16)m_ExtraFlags);
         stmt->setUInt8(index++,  m_stableSlots);
         stmt->setUInt16(index++, (uint16)m_atLoginFlags);
         stmt->setUInt16(index++, GetZoneId());
-        stmt->setUInt32(index++, m_deathExpireTime);
+        stmt->setUInt32(index++, uint32(m_deathExpireTime));
 
         ss.str("");
         ss << m_taxi.SaveTaxiDestinationsToString();
@@ -18891,29 +19054,51 @@
 
 void Player::SaveGoldToDB(SQLTransaction& trans)
 {
-    trans->PAppend("UPDATE characters SET money = '%u' WHERE guid = '%u'", GetMoney(), GetGUIDLow());
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UDP_CHAR_MONEY);
+    stmt->setUInt32(0, GetMoney());
+    stmt->setUInt32(1, GetGUIDLow());
+    trans->Append(stmt);
 }
 
 void Player::_SaveActions(SQLTransaction& trans)
 {
+    PreparedStatement* stmt = NULL;
+
     for (ActionButtonList::iterator itr = m_actionButtons.begin(); itr != m_actionButtons.end();)
     {
         switch (itr->second.uState)
         {
             case ACTIONBUTTON_NEW:
-                trans->PAppend("INSERT INTO character_action (guid, spec, button, action, type) VALUES ('%u', '%u', '%u', '%u', '%u')",
-                    GetGUIDLow(), m_activeSpec, (uint32)itr->first, (uint32)itr->second.GetAction(), (uint32)itr->second.GetType());
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_ACTION);
+                stmt->setUInt32(0, GetGUIDLow());
+                stmt->setUInt8(1, m_activeSpec);
+                stmt->setUInt8(2, itr->first);
+                stmt->setUInt32(3, itr->second.GetAction());
+                stmt->setUInt8(4, uint8(itr->second.GetType()));
+                trans->Append(stmt);
+
                 itr->second.uState = ACTIONBUTTON_UNCHANGED;
                 ++itr;
                 break;
             case ACTIONBUTTON_CHANGED:
-                trans->PAppend("UPDATE character_action SET action = '%u', type = '%u' WHERE guid = '%u' AND button = '%u' AND spec = '%u'",
-                    (uint32)itr->second.GetAction(), (uint32)itr->second.GetType(), GetGUIDLow(), (uint32)itr->first, m_activeSpec);
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_ACTION);
+                stmt->setUInt32(0, itr->second.GetAction());
+                stmt->setUInt8(1, uint8(itr->second.GetType()));
+                stmt->setUInt32(2,  GetGUIDLow());
+                stmt->setUInt8(3, itr->first);
+                stmt->setUInt8(4, m_activeSpec);
+                trans->Append(stmt);
+
                 itr->second.uState = ACTIONBUTTON_UNCHANGED;
                 ++itr;
                 break;
             case ACTIONBUTTON_DELETED:
-                trans->PAppend("DELETE FROM character_action WHERE guid = '%u' and button = '%u' and spec = '%u'", GetGUIDLow(), (uint32)itr->first, m_activeSpec);
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACTION_BY_BUTTON_SPEC);
+                stmt->setUInt32(0, GetGUIDLow());
+                stmt->setUInt8(1, itr->first);
+                stmt->setUInt8(2, m_activeSpec);
+                trans->Append(stmt);
+
                 m_actionButtons.erase(itr++);
                 break;
             default:
@@ -18925,11 +19110,11 @@
 
 void Player::_SaveAuras(SQLTransaction& trans)
 {
-    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_AURA);
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_AURA);
     stmt->setUInt32(0, GetGUIDLow());
     trans->Append(stmt);
 
-    for (AuraMap::const_iterator itr = m_ownedAuras.begin(); itr != m_ownedAuras.end() ; ++itr)
+    for (AuraMap::const_iterator itr = m_ownedAuras.begin(); itr != m_ownedAuras.end(); ++itr)
     {
         if (!itr->second->CanBeSaved())
             continue;
@@ -18981,6 +19166,7 @@
 
 void Player::_SaveInventory(SQLTransaction& trans)
 {
+    PreparedStatement* stmt = NULL;
     // force items in buyback slots to new state
     // and remove those that aren't already
     for (uint8 i = BUYBACK_SLOT_START; i < BUYBACK_SLOT_END; ++i)
@@ -18988,8 +19174,12 @@
         Item* item = m_items[i];
         if (!item || item->GetState() == ITEM_NEW)
             continue;
-        trans->PAppend("DELETE FROM character_inventory WHERE item = '%u'", item->GetGUIDLow());
-        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE);
+
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INVENTORY_BY_ITEM);
+        stmt->setUInt32(0, item->GetGUIDLow());
+        trans->Append(stmt);
+
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE);
         stmt->setUInt32(0, item->GetGUIDLow());
         trans->Append(stmt);
         m_items[i]->FSetState(ITEM_NEW);
@@ -19047,7 +19237,12 @@
                     bagTestGUID = test2->GetGUIDLow();
                 sLog->outError("Player(GUID: %u Name: %s)::_SaveInventory - the bag(%u) and slot(%u) values for the item with guid %u (state %d) are incorrect, the player doesn't have an item at that position!", lowGuid, GetName(), item->GetBagSlot(), item->GetSlot(), item->GetGUIDLow(), (int32)item->GetState());
                 // according to the test that was just performed nothing should be in this slot, delete
-                trans->PAppend("DELETE FROM character_inventory WHERE bag=%u AND slot=%u AND guid=%u", bagTestGUID, item->GetSlot(), lowGuid);
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INVENTORY_BY_BAG_SLOT);
+                stmt->setUInt32(0, bagTestGUID);
+                stmt->setUInt8(1, item->GetSlot());
+                stmt->setUInt32(2, lowGuid);
+                trans->Append(stmt);
+
                 // also THIS item should be somewhere else, cheat attempt
                 item->FSetState(ITEM_REMOVED); // we are IN updateQueue right now, can't use SetState which modifies the queue
                 DeleteRefundReference(item->GetGUIDLow());
@@ -19078,7 +19273,7 @@
                 trans->Append(stmt);
                 break;
             case ITEM_REMOVED:
-                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_INVENTORY_ITEM);
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INVENTORY_BY_ITEM);
                 stmt->setUInt32(0, item->GetGUIDLow());
                 trans->Append(stmt);
             case ITEM_UNCHANGED:
@@ -19095,17 +19290,32 @@
     if (!m_mailsLoaded)
         return;
 
+    PreparedStatement* stmt = NULL;
+
     for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end(); ++itr)
     {
         Mail* m = (*itr);
         if (m->state == MAIL_STATE_CHANGED)
         {
-            trans->PAppend("UPDATE mail SET has_items = '%u', expire_time = '" UI64FMTD "', deliver_time = '" UI64FMTD "', money = '%u', cod = '%u', checked = '%u' WHERE id = '%u'",
-                m->HasItems() ? 1 : 0, (uint64)m->expire_time, (uint64)m->deliver_time, m->money, m->COD, m->checked, m->messageID);
+            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_MAIL);
+            stmt->setUInt8(0, uint8(m->HasItems() ? 1 : 0));
+            stmt->setUInt32(1, uint32(m->expire_time));
+            stmt->setUInt32(2, uint32(m->deliver_time));
+            stmt->setUInt32(3, m->money);
+            stmt->setUInt32(4, m->COD);
+            stmt->setUInt8(5, uint8(m->checked));
+            stmt->setUInt32(6, m->messageID);
+
+            trans->Append(stmt);
+
             if (!m->removedItems.empty())
             {
                 for (std::vector<uint32>::iterator itr2 = m->removedItems.begin(); itr2 != m->removedItems.end(); ++itr2)
-                    trans->PAppend("DELETE FROM mail_items WHERE item_guid = '%u'", *itr2);
+                {
+                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM);
+                    stmt->setUInt32(0, *itr2);
+                    trans->Append(stmt);
+                }
                 m->removedItems.clear();
             }
             m->state = MAIL_STATE_UNCHANGED;
@@ -19122,8 +19332,13 @@
                     trans->Append(stmt);
                 }
             }
-            trans->PAppend("DELETE FROM mail WHERE id = '%u'", m->messageID);
-            trans->PAppend("DELETE FROM mail_items WHERE mail_id = '%u'", m->messageID);
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_BY_ID);
+            stmt->setUInt32(0, m->messageID);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM_BY_ID);
+            stmt->setUInt32(0, m->messageID);
+            trans->Append(stmt);
         }
     }
 
@@ -19152,6 +19367,7 @@
 
     QuestStatusSaveMap::iterator saveItr;
     QuestStatusMap::iterator statusItr;
+    PreparedStatement* stmt = NULL;
 
     bool keepAbandoned = !(sWorld->GetCleaningFlags() & CharacterDatabaseCleaner::CLEANING_FLAG_QUESTSTATUS);
 
@@ -19161,12 +19377,33 @@
         {
             statusItr = m_QuestStatus.find(saveItr->first);
             if (statusItr != m_QuestStatus.end() && (keepAbandoned || statusItr->second.Status != QUEST_STATUS_NONE))
-                trans->PAppend("REPLACE INTO character_queststatus (guid, quest, status, explored, timer, mobcount1, mobcount2, mobcount3, mobcount4, itemcount1, itemcount2, itemcount3, itemcount4, playercount) "
-                    "VALUES ('%u', '%u', '%u', '%u', '" UI64FMTD "', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u')",
-                    GetGUIDLow(), statusItr->first, statusItr->second.Status, statusItr->second.Explored, uint64(statusItr->second.Timer / IN_MILLISECONDS+ sWorld->GetGameTime()), statusItr->second.CreatureOrGOCount[0], statusItr->second.CreatureOrGOCount[1], statusItr->second.CreatureOrGOCount[2], statusItr->second.CreatureOrGOCount[3], statusItr->second.ItemCount[0], statusItr->second.ItemCount[1], statusItr->second.ItemCount[2], statusItr->second.ItemCount[3], statusItr->second.PlayerCount);
-        }
-        else
-            trans->PAppend("DELETE FROM character_queststatus WHERE guid = %u AND quest = %u", GetGUIDLow(), saveItr->first);
+            {
+                uint8 index = 0;
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_CHAR_QUESTSTATUS);
+
+                stmt->setUInt32(index++, GetGUIDLow());
+                stmt->setUInt32(index++, statusItr->first);
+                stmt->setUInt8(index++, uint8(statusItr->second.Status));
+                stmt->setBool(index++, statusItr->second.Explored);
+                stmt->setUInt32(index++, uint32(statusItr->second.Timer / IN_MILLISECONDS+ sWorld->GetGameTime()));
+
+                for (uint8 i = 0; i < 4; i++)
+                    stmt->setUInt16(index++, statusItr->second.CreatureOrGOCount[i]);
+
+                for (uint8 i = 0; i < 4; i++)
+                    stmt->setUInt16(index++, statusItr->second.ItemCount[i]);
+
+                stmt->setUInt16(index, statusItr->second.PlayerCount);
+                trans->Append(stmt);
+            }
+        }
+        else
+        {
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_BY_QUEST);
+            stmt->setUInt32(0, GetGUIDLow());
+            stmt->setUInt32(1, saveItr->first);
+            trans->Append(stmt);
+        }
     }
 
     m_QuestStatusSave.clear();
@@ -19174,9 +19411,20 @@
     for (saveItr = m_RewardedQuestsSave.begin(); saveItr != m_RewardedQuestsSave.end(); ++saveItr)
     {
         if (saveItr->second)
-            trans->PAppend("INSERT IGNORE INTO character_queststatus_rewarded (guid, quest) VALUES (%u, %u)", GetGUIDLow(), saveItr->first);
+        {
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_QUESTSTATUS);
+            stmt->setUInt32(0, GetGUIDLow());
+            stmt->setUInt32(1, saveItr->first);
+            trans->Append(stmt);
+
+        }
         else if (!keepAbandoned)
-            trans->PAppend("DELETE FROM character_queststatus_rewarded WHERE guid = %u AND quest = %u", GetGUIDLow(), saveItr->first);
+        {
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_REWARDED_BY_QUEST);
+            stmt->setUInt32(0, GetGUIDLow());
+            stmt->setUInt32(1, saveItr->first);
+            trans->Append(stmt);
+        }
     }
 
     m_RewardedQuestsSave.clear();
@@ -19276,6 +19524,7 @@
 
 void Player::_SaveSkills(SQLTransaction& trans)
 {
+    PreparedStatement* stmt = NULL;
     // we don't need transactions here.
     for (SkillStatusMap::iterator itr = mSkillStatus.begin(); itr != mSkillStatus.end();)
     {
@@ -19287,7 +19536,11 @@
 
         if (itr->second.uState == SKILL_DELETED)
         {
-            trans->PAppend("DELETE FROM character_skills WHERE guid = '%u' AND skill = '%u' ", GetGUIDLow(), itr->first);
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SKILL_BY_SKILL);
+            stmt->setUInt32(0, GetGUIDLow());
+            stmt->setUInt32(1, itr->first);
+            trans->Append(stmt);
+
             mSkillStatus.erase(itr++);
             continue;
         }
@@ -19299,12 +19552,22 @@
         switch (itr->second.uState)
         {
             case SKILL_NEW:
-                trans->PAppend("INSERT INTO character_skills (guid, skill, value, max) VALUES ('%u', '%u', '%u', '%u')",
-                    GetGUIDLow(), itr->first, value, max);
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_SKILLS);
+                stmt->setUInt32(0, GetGUIDLow());
+                stmt->setUInt16(1, uint16(itr->first));
+                stmt->setUInt16(2, value);
+                stmt->setUInt16(3, max);
+                trans->Append(stmt);
+
                 break;
             case SKILL_CHANGED:
-                trans->PAppend("UPDATE character_skills SET value = '%u', max = '%u'WHERE guid = '%u' AND skill = '%u' ",
-                    value, max, GetGUIDLow(), itr->first);
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_UDP_CHAR_SKILLS);
+                stmt->setUInt16(0, value);
+                stmt->setUInt16(1, max);
+                stmt->setUInt32(2, GetGUIDLow());
+                stmt->setUInt16(3, uint16(itr->first));
+                trans->Append(stmt);
+
                 break;
             default:
                 break;
@@ -19317,14 +19580,28 @@
 
 void Player::_SaveSpells(SQLTransaction& trans)
 {
+    PreparedStatement* stmt = NULL;
+
     for (PlayerSpellMap::iterator itr = m_spells.begin(); itr != m_spells.end();)
     {
         if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->state == PLAYERSPELL_CHANGED)
-            trans->PAppend("DELETE FROM character_spell WHERE guid = '%u' and spell = '%u'", GetGUIDLow(), itr->first);
+        {
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SPELL_BY_SPELL);
+            stmt->setUInt32(0, itr->first);
+            stmt->setUInt32(1, GetGUIDLow());
+            trans->Append(stmt);
+        }
 
         // add only changed/new not dependent spells
         if (!itr->second->dependent && (itr->second->state == PLAYERSPELL_NEW || itr->second->state == PLAYERSPELL_CHANGED))
-            trans->PAppend("INSERT INTO character_spell (guid, spell, active, disabled) VALUES ('%u', '%u', '%u', '%u')", GetGUIDLow(), itr->first, itr->second->active ? 1 : 0, itr->second->disabled ? 1 : 0);
+        {
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_SPELL);
+            stmt->setUInt32(0, GetGUIDLow());
+            stmt->setUInt32(1, itr->first);
+            stmt->setBool(2, itr->second->active);
+            stmt->setBool(3, itr->second->disabled);
+            trans->Append(stmt);
+        }
 
         if (itr->second->state == PLAYERSPELL_REMOVED)
         {
@@ -19347,31 +19624,39 @@
     if (!sWorld->getIntConfig(CONFIG_MIN_LEVEL_STAT_SAVE) || getLevel() < sWorld->getIntConfig(CONFIG_MIN_LEVEL_STAT_SAVE))
         return;
 
-    trans->PAppend("DELETE FROM character_stats WHERE guid = '%u'", GetGUIDLow());
-    std::ostringstream ss;
-    ss << "INSERT INTO character_stats (guid, maxhealth, maxpower1, maxpower2, maxpower3, maxpower4, maxpower5, maxpower6, maxpower7, "
-        "strength, agility, stamina, intellect, spirit, armor, resHoly, resFire, resNature, resFrost, resShadow, resArcane, "
-        "blockPct, dodgePct, parryPct, critPct, rangedCritPct, spellCritPct, attackPower, rangedAttackPower, spellPower, resilience) VALUES ("
-        << GetGUIDLow() << ','
-        << GetMaxHealth() << ',';
+    PreparedStatement* stmt = NULL;
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_STATS);
+    stmt->setUInt32(0, GetGUIDLow());
+    trans->Append(stmt);
+
+    uint8 index = 0;
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_STATS);
+    stmt->setUInt32(index++, GetGUIDLow());
+    stmt->setUInt32(index++, GetMaxHealth());
+
     for (uint8 i = 0; i < MAX_POWERS; ++i)
-        ss << GetMaxPower(Powers(i)) << ',';
+        stmt->setUInt32(index++, GetMaxPower(Powers(i)));
+
     for (uint8 i = 0; i < MAX_STATS; ++i)
-        ss << GetStat(Stats(i)) << ',';
-    // armor + school resistances
+        stmt->setUInt32(index++, GetStat(Stats(i)));
+
     for (int i = 0; i < MAX_SPELL_SCHOOL; ++i)
-        ss << GetResistance(SpellSchools(i)) << ',';
-    ss << GetFloatValue(PLAYER_BLOCK_PERCENTAGE) << ','
-       << GetFloatValue(PLAYER_DODGE_PERCENTAGE) << ','
-       << GetFloatValue(PLAYER_PARRY_PERCENTAGE) << ','
-       << GetFloatValue(PLAYER_CRIT_PERCENTAGE) << ','
-       << GetFloatValue(PLAYER_RANGED_CRIT_PERCENTAGE) << ','
-       << GetFloatValue(PLAYER_SPELL_CRIT_PERCENTAGE1) << ','
-       << GetUInt32Value(UNIT_FIELD_ATTACK_POWER) << ','
-       << GetUInt32Value(UNIT_FIELD_RANGED_ATTACK_POWER) << ','
-       << GetBaseSpellPowerBonus() << ','
-       << GetUInt32Value(PLAYER_FIELD_COMBAT_RATING_1 + CR_CRIT_TAKEN_SPELL) << ')';
-    trans->Append(ss.str().c_str());
+        stmt->setUInt32(index++, GetResistance(SpellSchools(i)));
+
+    stmt->setFloat(index++, GetFloatValue(PLAYER_BLOCK_PERCENTAGE));
+    stmt->setFloat(index++, GetFloatValue(PLAYER_DODGE_PERCENTAGE));
+    stmt->setFloat(index++, GetFloatValue(PLAYER_PARRY_PERCENTAGE));
+    stmt->setFloat(index++, GetFloatValue(PLAYER_CRIT_PERCENTAGE));
+    stmt->setFloat(index++, GetFloatValue(PLAYER_RANGED_CRIT_PERCENTAGE));
+    stmt->setFloat(index++, GetFloatValue(PLAYER_SPELL_CRIT_PERCENTAGE1));
+    stmt->setUInt32(index++, GetUInt32Value(UNIT_FIELD_ATTACK_POWER));
+    stmt->setUInt32(index++, GetUInt32Value(UNIT_FIELD_RANGED_ATTACK_POWER));
+    stmt->setUInt32(index++, GetBaseSpellPowerBonus());
+    stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_COMBAT_RATING_1 + CR_CRIT_TAKEN_SPELL));
+
+    trans->Append(stmt);
 }
 
 void Player::outDebugValues() const
@@ -19470,8 +19755,10 @@
 
 void Player::Customize(uint64 guid, uint8 gender, uint8 skin, uint8 face, uint8 hairStyle, uint8 hairColor, uint8 facialHair)
 {
-    //                                                     0
-    QueryResult result = CharacterDatabase.PQuery("SELECT playerBytes2 FROM characters WHERE guid = '%u'", GUID_LOPART(guid));
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_PLAYERBYTES2);
+    stmt->setUInt32(0, GUID_LOPART(guid));
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
     if (!result)
         return;
 
@@ -19481,7 +19768,7 @@
     playerBytes2 &= ~0xFF;
     playerBytes2 |= facialHair;
 
-    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_GENDER_PLAYERBYTES);
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_GENDER_PLAYERBYTES);
 
     stmt->setUInt8(0, gender);
     stmt->setUInt32(1, skin | (face << 8) | (hairStyle << 16) | (hairColor << 24));
@@ -20314,16 +20601,24 @@
 {
     WorldPacket data(SMSG_SET_PROFICIENCY, 1 + 4);
     data << uint8(itemClass) << uint32(itemSubclassMask);
-    GetSession()->SendPacket (&data);
+    GetSession()->SendPacket(&data);
 }
 
 void Player::RemovePetitionsAndSigns(uint64 guid, uint32 type)
 {
-    QueryResult result = QueryResult(NULL);
+    PreparedStatement* stmt;
+
     if (type == 10)
-        result = CharacterDatabase.PQuery("SELECT ownerguid, petitionguid FROM petition_sign WHERE playerguid = '%u'", GUID_LOPART(guid));
-    else
-        result = CharacterDatabase.PQuery("SELECT ownerguid, petitionguid FROM petition_sign WHERE playerguid = '%u' AND type = '%u'", GUID_LOPART(guid), type);
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_SIG_BY_GUID);
+    else
+    {
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_SIG_BY_GUID_TYPE);
+        stmt->setUInt8(0, uint8(type));
+    }
+
+    stmt->setUInt32(0, GUID_LOPART(guid));
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
     if (result)
     {
         do                                                  // this part effectively does nothing, since the deletion / modification only takes place _after_ the PetitionQuery. Though I don't know if the result remains intact if I execute the delete query beforehand.
@@ -20360,13 +20655,25 @@
     SQLTransaction trans = CharacterDatabase.BeginTransaction();
     if (type == 10)
     {
-        trans->PAppend("DELETE FROM petition WHERE ownerguid = '%u'", GUID_LOPART(guid));
-        trans->PAppend("DELETE FROM petition_sign WHERE ownerguid = '%u'", GUID_LOPART(guid));
-    }
-    else
-    {
-        trans->PAppend("DELETE FROM petition WHERE ownerguid = '%u' AND type = '%u'", GUID_LOPART(guid), type);
-        trans->PAppend("DELETE FROM petition_sign WHERE ownerguid = '%u' AND type = '%u'", GUID_LOPART(guid), type);
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_BY_OWNER);
+        stmt->setUInt32(0, GUID_LOPART(guid));
+        trans->Append(stmt);
+
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_SIGNATURE_BY_OWNER);
+        stmt->setUInt32(0, GUID_LOPART(guid));
+        trans->Append(stmt);
+    }
+    else
+    {
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_BY_OWNER_AND_TYPE);
+        stmt->setUInt32(0, GUID_LOPART(guid));
+        stmt->setUInt8(1, uint8(type));
+        trans->Append(stmt);
+
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_SIGNATURE_BY_OWNER_AND_TYPE);
+        stmt->setUInt32(0, GUID_LOPART(guid));
+        stmt->setUInt8(1, uint8(type));
+        trans->Append(stmt);
     }
     CharacterDatabase.CommitTransaction(trans);
 }
@@ -20963,10 +21270,10 @@
     }
 
     uint32 price = 0;
-    if(crItem->IsGoldRequired(pProto) && pProto->BuyPrice > 0) //Assume price cannot be negative (do not know why it is int32)
+    if (crItem->IsGoldRequired(pProto) && pProto->BuyPrice > 0) //Assume price cannot be negative (do not know why it is int32)
     {
         uint32 maxCount = MAX_MONEY_AMOUNT / pProto->BuyPrice;
-        if((uint32)count > maxCount)
+        if ((uint32)count > maxCount)
         {
             sLog->outError("Player %s tried to buy %u item id %u, causing overflow", GetName(), (uint32)count, pProto->ItemId);
             count = (uint8)maxCount;
@@ -23080,7 +23387,8 @@
     else
         delay = GetCorpseReclaimDelay(pvp);
 
-    if (!delay) return;
+    if (!delay)
+        return;
 
     //! corpse reclaim delay 30 * 1000ms or longer at often deaths
     WorldPacket data(SMSG_CORPSE_RECLAIM_DELAY, 4);
@@ -23629,7 +23937,8 @@
     GetSession()->SendPacket(&data);
 }
 
-static RuneType runeSlotTypes[MAX_RUNES] = {
+static RuneType runeSlotTypes[MAX_RUNES] =
+{
     /*0*/ RUNE_BLOOD,
     /*1*/ RUNE_BLOOD,
     /*2*/ RUNE_UNHOLY,
@@ -24383,14 +24692,38 @@
 
 void Player::SendMovementSetCanTransitionBetweenSwimAndFly(bool apply)
 {
-    WorldPacket data(apply ? 
-        SMSG_MOVE_SET_CAN_TRANSITION_BETWEEN_SWIM_AND_FLY : 
+    WorldPacket data(apply ?
+        SMSG_MOVE_SET_CAN_TRANSITION_BETWEEN_SWIM_AND_FLY :
         SMSG_MOVE_UNSET_CAN_TRANSITION_BETWEEN_SWIM_AND_FLY, 12);
     data.append(GetPackGUID());
     data << uint32(0);          //! movement counter
     SendDirectMessage(&data);
 }
 
+void Player::SendMovementSetHover(bool apply)
+{
+    WorldPacket data(apply ? SMSG_MOVE_SET_HOVER : SMSG_MOVE_UNSET_HOVER, 12);
+    data.append(GetPackGUID());
+    data << uint32(0);          //! movement counter
+    SendDirectMessage(&data);
+}
+
+void Player::SendMovementSetWaterWalking(bool apply)
+{
+    WorldPacket data(apply ? SMSG_MOVE_WATER_WALK : SMSG_MOVE_LAND_WALK, 12);
+    data.append(GetPackGUID());
+    data << uint32(0);          //! movement counter
+    SendDirectMessage(&data);
+}
+
+void Player::SendMovementSetFeatherFall(bool apply)
+{
+    WorldPacket data(apply ? SMSG_MOVE_FEATHER_FALL : SMSG_MOVE_NORMAL_FALL, 12);
+    data.append(GetPackGUID());
+    data << uint32(0);          //! movement counter
+    SendDirectMessage(&data);
+}
+
 void Player::BuildPlayerTalentsInfoData(WorldPacket* data)
 {
     *data << uint32(GetFreeTalentPoints());                 // unspentTalentPoints
@@ -24800,11 +25133,24 @@
 
 void Player::_SaveGlyphs(SQLTransaction& trans)
 {
-    trans->PAppend("DELETE FROM character_glyphs WHERE guid='%u'", GetGUIDLow());
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_GLYPHS);
+    stmt->setUInt32(0, GetGUIDLow());
+    trans->Append(stmt);
+
+
     for (uint8 spec = 0; spec < m_specsCount; ++spec)
     {
-        trans->PAppend("INSERT INTO character_glyphs VALUES('%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u')",
-            GetGUIDLow(), spec, m_Glyphs[spec][0], m_Glyphs[spec][1], m_Glyphs[spec][2], m_Glyphs[spec][3], m_Glyphs[spec][4], m_Glyphs[spec][5]);
+        uint8 index = 0;
+
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_GLYPHS);
+        stmt->setUInt32(index++, GetGUIDLow());
+
+        stmt->setUInt8(index++, spec);
+
+        for (uint8 i = 0; i < MAX_GLYPH_SLOT_INDEX; ++i)
+            stmt->setUInt16(index++, uint16(m_Glyphs[spec][i]));
+
+        trans->Append(stmt);
     }
 }
 
@@ -24814,22 +25160,36 @@
     if (result)
     {
         do
-            AddTalent((*result)[0].GetUInt32(), (*result)[1].GetUInt32(), false);
+            AddTalent((*result)[0].GetUInt32(), (*result)[1].GetUInt8(), false);
         while (result->NextRow());
     }
 }
 
 void Player::_SaveTalents(SQLTransaction& trans)
 {
+    PreparedStatement* stmt = NULL;
+
     for (uint8 i = 0; i < MAX_TALENT_SPECS; ++i)
     {
         for (PlayerTalentMap::iterator itr = m_talents[i]->begin(); itr != m_talents[i]->end();)
         {
             if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->state == PLAYERSPELL_CHANGED)
-                trans->PAppend("DELETE FROM character_talent WHERE guid = '%u' and spell = '%u' and spec = '%u'", GetGUIDLow(), itr->first, itr->second->spec);
+            {
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_TALENT_BY_SPELL_SPEC);
+                stmt->setUInt32(0, GetGUIDLow());
+                stmt->setUInt32(1, itr->first);
+                stmt->setUInt8(2, itr->second->spec);
+                trans->Append(stmt);
+            }
 
             if (itr->second->state == PLAYERSPELL_NEW || itr->second->state == PLAYERSPELL_CHANGED)
-                trans->PAppend("INSERT INTO character_talent (guid, spell, spec) VALUES ('%u', '%u', '%u')", GetGUIDLow(), itr->first, itr->second->spec);
+            {
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_TALENT);
+                stmt->setUInt32(0, GetGUIDLow());
+                stmt->setUInt32(1, itr->first);
+                stmt->setUInt8(2, itr->second->spec);
+                trans->Append(stmt);
+            }
 
             if (itr->second->state == PLAYERSPELL_REMOVED)
             {
@@ -24855,20 +25215,33 @@
         ActivateSpec(0);
 
     SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    PreparedStatement* stmt = NULL;
 
     // Copy spec data
     if (count > curCount)
     {
         _SaveActions(trans); // make sure the button list is cleaned up
         for (ActionButtonList::iterator itr = m_actionButtons.begin(); itr != m_actionButtons.end(); ++itr)
-            trans->PAppend("INSERT INTO character_action (guid, button, action, type, spec) VALUES ('%u', '%u', '%u', '%u', '%u')",
-            GetGUIDLow(), uint32(itr->first), uint32(itr->second.GetAction()), uint32(itr->second.GetType()), 1);
+        {
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_ACTION);
+            stmt->setUInt32(0, GetGUIDLow());
+            stmt->setUInt8(1, 1);
+            stmt->setUInt8(2, itr->first);
+            stmt->setUInt32(3, itr->second.GetAction());
+            stmt->setUInt8(4, uint8(itr->second.GetType()));
+            trans->Append(stmt);
+        }
     }
     // Delete spec data for removed spec.
     else if (count < curCount)
     {
         _SaveActions(trans);
-        trans->PAppend("DELETE FROM character_action WHERE spec<>'%u' AND guid='%u'", m_activeSpec, GetGUIDLow());
+
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACTION_EXCEPT_SPEC);
+        stmt->setUInt8(0, m_activeSpec);
+        stmt->setUInt32(1, GetGUIDLow());
+        trans->Append(stmt);
+
         m_activeSpec = 0;
     }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Entities/Player/Player.h
--- a/src/server/game/Entities/Player/Player.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Entities/Player/Player.h	Mon Apr 16 14:29:17 2012 +0300
@@ -1085,7 +1085,7 @@
     friend void Item::RemoveFromUpdateQueueOf(Player* player);
     public:
         explicit Player (WorldSession* session);
-        ~Player ();
+        ~Player();
 
         //AnticheatData anticheatData;
 
@@ -1536,7 +1536,7 @@
         static uint32 GetLevelFromDB(uint64 guid);
         static bool   LoadPositionFromDB(uint32& mapid, float& x, float& y, float& z, float& o, bool& in_flight, uint64 guid);
 
-        static bool IsValidGender(uint8 Gender) { return Gender <= GENDER_FEMALE ; }
+        static bool IsValidGender(uint8 Gender) { return Gender <= GENDER_FEMALE; }
 
         /*********************************************************/
         /***                   SAVE SYSTEM                     ***/
@@ -2511,14 +2511,14 @@
         void AddWhisperWhiteList(uint64 guid) { WhisperList.push_back(guid); }
         bool IsInWhisperWhiteList(uint64 guid);
 
-        #pragma region Player Movement
-
-                
         /*! These methods send different packets to the client in apply and unapply case.
             These methods are only sent to the current unit.
         */
         void SendMovementSetCanFly(bool apply);
         void SendMovementSetCanTransitionBetweenSwimAndFly(bool apply);
+        void SendMovementSetHover(bool apply);
+        void SendMovementSetWaterWalking(bool apply);
+        void SendMovementSetFeatherFall(bool apply);
 
         bool CanFly() const { return m_movementInfo.HasMovementFlag(MOVEMENTFLAG_CAN_FLY); }
 
@@ -2555,8 +2555,6 @@
                 return modelData->CollisionHeight;
             }
         }
-        #pragma endregion Player Movement
-
 
     protected:
         // Gamemaster whisper whitelist
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Entities/Player/SocialMgr.cpp
--- a/src/server/game/Entities/Player/SocialMgr.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Entities/Player/SocialMgr.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -61,7 +61,7 @@
             return false;
     }
 
-    uint32 flag = SOCIAL_FLAG_FRIEND;
+    uint8 flag = SOCIAL_FLAG_FRIEND;
     if (ignore)
         flag = SOCIAL_FLAG_IGNORED;
 
@@ -70,7 +70,7 @@
     {
         PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_ADD_CHARACTER_SOCIAL_FLAGS);
 
-        stmt->setUInt8(0, uint8(flag));
+        stmt->setUInt8(0, flag);
         stmt->setUInt32(1, GetPlayerGUID());
         stmt->setUInt32(2, friendGuid);
 
@@ -84,7 +84,7 @@
 
         stmt->setUInt32(0, GetPlayerGUID());
         stmt->setUInt32(1, friendGuid);
-        stmt->setUInt8(2, uint8(flag));
+        stmt->setUInt8(2, flag);
 
         CharacterDatabase.Execute(stmt);
 
@@ -101,7 +101,7 @@
     if (itr == m_playerSocialMap.end())                     // not exist
         return;
 
-    uint32 flag = SOCIAL_FLAG_FRIEND;
+    uint8 flag = SOCIAL_FLAG_FRIEND;
     if (ignore)
         flag = SOCIAL_FLAG_IGNORED;
 
@@ -121,7 +121,7 @@
     {
         PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_REM_CHARACTER_SOCIAL_FLAGS);
 
-        stmt->setUInt8(0, uint8(flag));
+        stmt->setUInt8(0, flag);
         stmt->setUInt32(1, GetPlayerGUID());
         stmt->setUInt32(2, friendGuid);
 
@@ -321,7 +321,7 @@
     }
 }
 
-PlayerSocial *SocialMgr::LoadFromDB(PreparedQueryResult result, uint32 guid)
+PlayerSocial* SocialMgr::LoadFromDB(PreparedQueryResult result, uint32 guid)
 {
     PlayerSocial *social = &m_socialMap[guid];
     social->SetPlayerGUID(guid);
@@ -330,7 +330,7 @@
         return social;
 
     uint32 friend_guid = 0;
-    uint32 flags = 0;
+    uint8 flags = 0;
     std::string note = "";
 
     do
@@ -338,7 +338,7 @@
         Field* fields = result->Fetch();
 
         friend_guid = fields[0].GetUInt32();
-        flags = fields[1].GetUInt32();
+        flags = fields[1].GetUInt8();
         note = fields[2].GetString();
 
         social->m_playerSocialMap[friend_guid] = FriendInfo(flags, note);
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Entities/Player/SocialMgr.h
--- a/src/server/game/Entities/Player/SocialMgr.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Entities/Player/SocialMgr.h	Mon Apr 16 14:29:17 2012 +0300
@@ -48,7 +48,7 @@
 struct FriendInfo
 {
     FriendStatus Status;
-    uint32 Flags;
+    uint8 Flags;
     uint32 Area;
     uint8 Level;
     uint8 Class;
@@ -64,7 +64,7 @@
         Note = "";
     }
 
-    FriendInfo(uint32 flags, const std::string& note)
+    FriendInfo(uint8 flags, const std::string& note)
     {
         Status = FRIEND_STATUS_OFFLINE;
         Flags = flags;
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Entities/Transport/Transport.cpp
--- a/src/server/game/Entities/Transport/Transport.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Entities/Transport/Transport.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -206,8 +206,8 @@
 {
     uint32 oldMSTime = getMSTime();
 
-    //                                                         0    1          2                3             4             5             6             7
-    QueryResult result = WorldDatabase.PQuery("SELECT guid, npc_entry, transport_entry, TransOffsetX, TransOffsetY, TransOffsetZ, TransOffsetO, emote FROM creature_transport");
+    //                                                 0       1            2                3             4             5             6        7
+    QueryResult result = WorldDatabase.Query("SELECT guid, npc_entry, transport_entry, TransOffsetX, TransOffsetY, TransOffsetZ, TransOffsetO, emote FROM creature_transport");
 
     if (!result)
     {
@@ -221,14 +221,14 @@
     do
     {
         Field* fields = result->Fetch();
-        uint32 guid = fields[0].GetUInt32();
-        uint32 entry = fields[1].GetUInt32();
-        uint32 transportEntry = fields[2].GetUInt32();
+        uint32 guid = fields[0].GetInt32();
+        uint32 entry = fields[1].GetInt32();
+        uint32 transportEntry = fields[2].GetInt32();
         float tX = fields[3].GetFloat();
         float tY = fields[4].GetFloat();
         float tZ = fields[5].GetFloat();
         float tO = fields[6].GetFloat();
-        uint32 anim = fields[7].GetUInt32();
+        uint32 anim = fields[7].GetInt32();
 
         for (MapManager::TransportSet::iterator itr = m_Transports.begin(); itr != m_Transports.end(); ++itr)
         {
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Entities/Unit/StatSystem.cpp
--- a/src/server/game/Entities/Unit/StatSystem.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Entities/Unit/StatSystem.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -398,7 +398,7 @@
                 break;
             }
             case CLASS_MAGE:
-                val2 =  GetStat(STAT_STRENGTH) - 10.0f;
+                val2 = GetStat(STAT_STRENGTH) - 10.0f;
                 break;
             case CLASS_PRIEST:
                 val2 = GetStat(STAT_STRENGTH) - 10.0f;
@@ -1068,6 +1068,7 @@
 #define ENTRY_TREANT            1964
 #define ENTRY_FIRE_ELEMENTAL    15438
 #define ENTRY_GHOUL             26125
+#define ENTRY_BLOODWORM         28017
 
 bool Guardian::UpdateStats(Stats stat)
 {
@@ -1229,6 +1230,7 @@
         case ENTRY_SUCCUBUS:    multiplicator = 9.1f;   break;
         case ENTRY_FELHUNTER:   multiplicator = 9.5f;   break;
         case ENTRY_FELGUARD:    multiplicator = 11.0f;  break;
+        case ENTRY_BLOODWORM:   multiplicator = 1.0f;   break;
         default:                multiplicator = 10.0f;  break;
     }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Entities/Unit/Unit.cpp
--- a/src/server/game/Entities/Unit/Unit.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Entities/Unit/Unit.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -72,7 +72,9 @@
     4.5f,                  // MOVE_FLIGHT_BACK
     3.14f                  // MOVE_PITCH_RATE
 };
-float playerBaseMoveSpeed[MAX_MOVE_TYPE] = {
+
+float playerBaseMoveSpeed[MAX_MOVE_TYPE] =
+{
     2.5f,                  // MOVE_WALK
     7.0f,                  // MOVE_RUN
     4.5f,                  // MOVE_RUN_BACK
@@ -111,23 +113,27 @@
     m_resist = 0;
     m_block = 0;
 }
+
 void DamageInfo::ModifyDamage(int32 amount)
 {
     amount = std::min(amount, int32(GetDamage()));
     m_damage += amount;
 }
+
 void DamageInfo::AbsorbDamage(uint32 amount)
 {
     amount = std::min(amount, GetDamage());
     m_absorb += amount;
     m_damage -= amount;
 }
+
 void DamageInfo::ResistDamage(uint32 amount)
 {
     amount = std::min(amount, GetDamage());
     m_resist += amount;
     m_damage -= amount;
 }
+
 void DamageInfo::BlockDamage(uint32 amount)
 {
     amount = std::min(amount, GetDamage());
@@ -454,7 +460,8 @@
 
 bool Unit::IsWithinCombatRange(const Unit* obj, float dist2compare) const
 {
-    if (!obj || !IsInMap(obj)) return false;
+    if (!obj || !IsInMap(obj))
+        return false;
 
     float dx = GetPositionX() - obj->GetPositionX();
     float dy = GetPositionY() - obj->GetPositionY();
@@ -469,7 +476,8 @@
 
 bool Unit::IsWithinMeleeRange(const Unit* obj, float dist) const
 {
-    if (!obj || !IsInMap(obj)) return false;
+    if (!obj || !IsInMap(obj))
+        return false;
 
     float dx = GetPositionX() - obj->GetPositionX();
     float dy = GetPositionY() - obj->GetPositionY();
@@ -565,6 +573,15 @@
     if (IsAIEnabled)
         GetAI()->DamageDealt(victim, damage, damagetype);
 
+    // Signal to pets that their owner was attacked
+    if (victim->GetTypeId() == TYPEID_PLAYER)
+    {
+        Pet* pet = victim->ToPlayer()->GetPet();
+
+        if (pet && pet->isAlive())
+            pet->AI()->OwnerDamagedBy(this);
+    }
+
     if (damagetype != NODAMAGE)
     {
         // interrupting auras with AURA_INTERRUPT_FLAG_DAMAGE before checking !damage (absorbed damage breaks that type of auras)
@@ -662,7 +679,7 @@
 
         duel_hasEnded = true;
     }
-    else if (victim->IsVehicle() && damage >= (health-1) && victim->GetCharmer() && victim->GetCharmer()->GetTypeId() ==  TYPEID_PLAYER)
+    else if (victim->IsVehicle() && damage >= (health-1) && victim->GetCharmer() && victim->GetCharmer()->GetTypeId() == TYPEID_PLAYER)
     {
         Player* victimRider = victim->GetCharmer()->ToPlayer();
 
@@ -1097,6 +1114,7 @@
 
     if (!victim)
         return;
+
     if (!isAlive() || !victim->isAlive())
         return;
 
@@ -1106,12 +1124,11 @@
         case BASE_ATTACK:
             damageInfo->procAttacker = PROC_FLAG_DONE_MELEE_AUTO_ATTACK | PROC_FLAG_DONE_MAINHAND_ATTACK;
             damageInfo->procVictim   = PROC_FLAG_TAKEN_MELEE_AUTO_ATTACK;
-            damageInfo->HitInfo      = HITINFO_NORMALSWING2;
             break;
         case OFF_ATTACK:
             damageInfo->procAttacker = PROC_FLAG_DONE_MELEE_AUTO_ATTACK | PROC_FLAG_DONE_OFFHAND_ATTACK;
             damageInfo->procVictim   = PROC_FLAG_TAKEN_MELEE_AUTO_ATTACK;
-            damageInfo->HitInfo = HITINFO_LEFTSWING;
+            damageInfo->HitInfo      = HITINFO_OFFHAND;
             break;
         default:
             return;
@@ -1147,29 +1164,29 @@
     switch (damageInfo->hitOutCome)
     {
         case MELEE_HIT_EVADE:
-            damageInfo->HitInfo    |= HITINFO_MISS|HITINFO_SWINGNOHITSOUND;
-            damageInfo->TargetState = VICTIMSTATE_EVADES;
-            damageInfo->procEx|=PROC_EX_EVADE;
+            damageInfo->HitInfo        |= HITINFO_MISS | HITINFO_SWINGNOHITSOUND;
+            damageInfo->TargetState     = VICTIMSTATE_EVADES;
+            damageInfo->procEx         |= PROC_EX_EVADE;
             damageInfo->damage = 0;
             damageInfo->cleanDamage = 0;
             return;
         case MELEE_HIT_MISS:
-            damageInfo->HitInfo    |= HITINFO_MISS;
-            damageInfo->TargetState = VICTIMSTATE_INTACT;
-            damageInfo->procEx |= PROC_EX_MISS;
-            damageInfo->damage  = 0;
-            damageInfo->cleanDamage = 0;
+            damageInfo->HitInfo        |= HITINFO_MISS;
+            damageInfo->TargetState     = VICTIMSTATE_INTACT;
+            damageInfo->procEx         |= PROC_EX_MISS;
+            damageInfo->damage          = 0;
+            damageInfo->cleanDamage     = 0;
             break;
         case MELEE_HIT_NORMAL:
-            damageInfo->TargetState = VICTIMSTATE_HIT;
-            damageInfo->procEx|=PROC_EX_NORMAL_HIT;
+            damageInfo->TargetState     = VICTIMSTATE_HIT;
+            damageInfo->procEx         |= PROC_EX_NORMAL_HIT;
             break;
         case MELEE_HIT_CRIT:
         {
-            damageInfo->HitInfo     |= HITINFO_CRITICALHIT;
-            damageInfo->TargetState  = VICTIMSTATE_HIT;
-
-            damageInfo->procEx      |= PROC_EX_CRITICAL_HIT;
+            damageInfo->HitInfo        |= HITINFO_CRITICALHIT;
+            damageInfo->TargetState     = VICTIMSTATE_HIT;
+
+            damageInfo->procEx         |= PROC_EX_CRITICAL_HIT;
             // Crit bonus calc
             damageInfo->damage += damageInfo->damage;
             float mod = 0.0f;
@@ -1230,8 +1247,8 @@
             if (leveldif > 3)
                 leveldif = 3;
             float reducePercent = 1 - leveldif * 0.1f;
-            damageInfo->cleanDamage += damageInfo->damage-uint32(reducePercent * damageInfo->damage);
-            damageInfo->damage   = uint32(reducePercent * damageInfo->damage);
+            damageInfo->cleanDamage += damageInfo->damage - uint32(reducePercent * damageInfo->damage);
+            damageInfo->damage = uint32(reducePercent * damageInfo->damage);
             break;
         }
         case MELEE_HIT_CRUSHING:
@@ -1245,6 +1262,10 @@
             break;
     }
 
+    // Always apply HITINFO_AFFECTS_VICTIM in case its not a miss
+    if (!(damageInfo->HitInfo & HITINFO_MISS))
+        damageInfo->HitInfo |= HITINFO_AFFECTS_VICTIM;
+
     int32 resilienceReduction = damageInfo->damage;
     if (attackType != RANGED_ATTACK)
         ApplyResilience(victim, NULL, &resilienceReduction, (damageInfo->hitOutCome == MELEE_HIT_CRIT), CR_CRIT_TAKEN_MELEE);
@@ -1260,14 +1281,17 @@
         damageInfo->procVictim |= PROC_FLAG_TAKEN_DAMAGE;
         // Calculate absorb & resists
         CalcAbsorbResist(damageInfo->target, SpellSchoolMask(damageInfo->damageSchoolMask), DIRECT_DAMAGE, damageInfo->damage, &damageInfo->absorb, &damageInfo->resist);
+
+        if (damageInfo->absorb)
+        {
+            damageInfo->HitInfo |= (damageInfo->damage - damageInfo->absorb == 0 ? HITINFO_FULL_ABSORB : HITINFO_PARTIAL_ABSORB);
+            damageInfo->procEx  |= PROC_EX_ABSORB;
+        }
+
+        if (damageInfo->resist)
+            damageInfo->HitInfo |= (damageInfo->damage - damageInfo->resist == 0 ? HITINFO_FULL_RESIST : HITINFO_PARTIAL_RESIST);
+
         damageInfo->damage -= damageInfo->absorb + damageInfo->resist;
-        if (damageInfo->absorb)
-        {
-            damageInfo->HitInfo |= HITINFO_ABSORB;
-            damageInfo->procEx  |= PROC_EX_ABSORB;
-        }
-        if (damageInfo->resist)
-            damageInfo->HitInfo |= HITINFO_RESIST;
     }
     else // Impossible get negative result but....
         damageInfo->damage = 0;
@@ -1471,7 +1495,7 @@
             }
             else
             {
-               if (ToPlayer() && ToPlayer()->HasItemFitToSpellRequirements((*itr)->GetSpellInfo()))
+                if (ToPlayer()->HasItemFitToSpellRequirements((*itr)->GetSpellInfo()))
                     bonusPct += (*itr)->GetAmount();
             }
         }
@@ -1481,6 +1505,7 @@
             maxArmorPen = float(400 + 85 * victim->getLevel());
         else
             maxArmorPen = 400 + 85 * victim->getLevel() + 4.5f * 85 * (victim->getLevel() - 59);
+
         // Cap armor penetration to this number
         maxArmorPen = std::min((armor + maxArmorPen) / 3, armor);
         // Figure out how much armor do we ignore
@@ -1517,7 +1542,8 @@
     DamageInfo dmgInfo = DamageInfo(this, victim, damage, spellInfo, schoolMask, damagetype);
 
     // Magic damage, check for resists
-    if ((schoolMask & SPELL_SCHOOL_MASK_NORMAL) == 0)
+    // Ignore spells that cant be resisted
+    if ((schoolMask & SPELL_SCHOOL_MASK_NORMAL) == 0 && (!spellInfo || (spellInfo->AttributesEx4 & SPELL_ATTR4_IGNORE_RESISTANCES) == 0))
     {
         float victimResistance = float(victim->GetResistance(schoolMask));
         victimResistance += float(GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_TARGET_RESISTANCE, schoolMask));
@@ -2158,8 +2184,8 @@
 {
     WorldPacket data(SMSG_ATTACKSTOP, (8+8+4));
     data.append(GetPackGUID());
-    data.append(victim ? victim->GetPackGUID() : 0);       // can be 0x00...
-    data << uint32(0);                                     // can be 0x1
+    data.append(victim ? victim->GetPackGUID() : 0);
+    data << uint32(0);                                     //! Can also take the value 0x01, which seems related to updating rotation
     SendMessageToSet(&data, true);
     sLog->outStaticDebug("WORLD: Sent SMSG_ATTACKSTOP");
 
@@ -2869,7 +2895,8 @@
 
     CurrentSpellTypes CSpellType = pSpell->GetCurrentContainer();
 
-    if (pSpell == m_currentSpells[CSpellType]) return;      // avoid breaking self
+    if (pSpell == m_currentSpells[CSpellType])             // avoid breaking self
+        return;
 
     // break same type spell if it is not delayed
     InterruptSpell(CSpellType, false);
@@ -2990,20 +3017,20 @@
         (withDelayed || m_currentSpells[CURRENT_GENERIC_SPELL]->getState() != SPELL_STATE_DELAYED))
     {
         if (!isAutoshoot || !(m_currentSpells[CURRENT_GENERIC_SPELL]->m_spellInfo->AttributesEx2 & SPELL_ATTR2_NOT_RESET_AUTO_ACTIONS))
-            return(true);
+            return true;
     }
     // channeled spells may be delayed, but they are still considered casted
     else if (!skipChanneled && m_currentSpells[CURRENT_CHANNELED_SPELL] &&
         (m_currentSpells[CURRENT_CHANNELED_SPELL]->getState() != SPELL_STATE_FINISHED))
     {
         if (!isAutoshoot || !(m_currentSpells[CURRENT_CHANNELED_SPELL]->m_spellInfo->AttributesEx2 & SPELL_ATTR2_NOT_RESET_AUTO_ACTIONS))
-            return(true);
+            return true;
     }
     // autorepeat spells may be finished or delayed, but they are still considered casted
     else if (!skipAutorepeat && m_currentSpells[CURRENT_AUTOREPEAT_SPELL])
-        return(true);
-
-    return(false);
+        return true;
+
+    return false;
 }
 
 void Unit::InterruptNonMeleeSpells(bool withDelayed, uint32 spell_id, bool withInstant)
@@ -3236,7 +3263,7 @@
     aura->HandleAuraSpecificMods(aurApp, caster, true, false);
 
     // apply effects of the aura
-    for (uint8 i = 0 ; i < MAX_SPELL_EFFECTS; ++i)
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
     {
         if (effMask & 1<<i && (!aurApp->GetRemoveMode()))
             aurApp->_HandleEffect(i, true);
@@ -3295,7 +3322,7 @@
     aura->_UnapplyForTarget(this, caster, aurApp);
 
     // remove effects of the spell - needs to be done after removing aura from lists
-    for (uint8 itr = 0 ; itr < MAX_SPELL_EFFECTS; ++itr)
+    for (uint8 itr = 0; itr < MAX_SPELL_EFFECTS; ++itr)
     {
         if (aurApp->HasEffect(itr))
             aurApp->_HandleEffect(itr, false);
@@ -3472,7 +3499,7 @@
     if (aurApp->GetRemoveMode())
     {
         // remove remaining effects of an aura
-        for (uint8 itr = 0 ; itr < MAX_SPELL_EFFECTS; ++itr)
+        for (uint8 itr = 0; itr < MAX_SPELL_EFFECTS; ++itr)
         {
             if (aurApp->HasEffect(itr))
                 aurApp->_HandleEffect(itr, false);
@@ -3583,8 +3610,9 @@
                         {
                             // final heal
                             int32 healAmount = aurEff->GetAmount();
-                            int32 stack = dispelInfo.GetRemovedCharges();
-                            CastCustomSpell(this, 33778, &healAmount, &stack, NULL, true, NULL, NULL, aura->GetCasterGUID());
+                            if (Unit* caster = aura->GetCaster())
+                                healAmount = caster->SpellHealingBonus(this, aura->GetSpellInfo(), healAmount, HEAL, dispelInfo.GetRemovedCharges());
+                            CastCustomSpell(this, 33778, &healAmount, NULL, NULL, true, NULL, NULL, aura->GetCasterGUID());
 
                             // mana
                             if (Unit* caster = aura->GetCaster())
@@ -4410,9 +4438,7 @@
     }
     // Add the highest of the Same Effect Stack Rule SpellGroups to the multiplier
     for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)
-    {
         AddPctN(multiplier, itr->second);
-    }
 
     return multiplier;
 }
@@ -4447,27 +4473,39 @@
 
 int32 Unit::GetTotalAuraModifierByMiscValue(AuraType auratype, int32 misc_value) const
 {
+    std::map<SpellGroup, int32> SameEffectSpellGroup;
     int32 modifier = 0;
 
     AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
     for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
     {
         if ((*i)->GetMiscValue() == misc_value)
-            modifier += (*i)->GetAmount();
-    }
+            if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*i)->GetSpellInfo(), (*i)->GetAmount(), SameEffectSpellGroup))
+                modifier += (*i)->GetAmount();
+    }
+
+    for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)
+        modifier += itr->second;
+
     return modifier;
 }
 
 float Unit::GetTotalAuraMultiplierByMiscValue(AuraType auratype, int32 misc_value) const
 {
+    std::map<SpellGroup, int32> SameEffectSpellGroup;
     float multiplier = 1.0f;
 
     AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
     for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
     {
         if ((*i)->GetMiscValue() == misc_value)
-            AddPctN(multiplier, (*i)->GetAmount());
-    }
+            if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*i)->GetSpellInfo(), (*i)->GetAmount(), SameEffectSpellGroup))
+                AddPctN(multiplier, (*i)->GetAmount());
+    }
+
+    for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)
+        AddPctN(multiplier, itr->second);
+
     return multiplier;
 }
 
@@ -4501,27 +4539,39 @@
 
 int32 Unit::GetTotalAuraModifierByAffectMask(AuraType auratype, SpellInfo const* affectedSpell) const
 {
+    std::map<SpellGroup, int32> SameEffectSpellGroup;
     int32 modifier = 0;
 
     AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
     for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
     {
         if ((*i)->IsAffectedOnSpell(affectedSpell))
-            modifier += (*i)->GetAmount();
-    }
+            if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*i)->GetSpellInfo(), (*i)->GetAmount(), SameEffectSpellGroup))
+                modifier += (*i)->GetAmount();
+    }
+
+    for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)
+        modifier += itr->second;
+
     return modifier;
 }
 
 float Unit::GetTotalAuraMultiplierByAffectMask(AuraType auratype, SpellInfo const* affectedSpell) const
 {
+    std::map<SpellGroup, int32> SameEffectSpellGroup;
     float multiplier = 1.0f;
 
     AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
     for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
     {
         if ((*i)->IsAffectedOnSpell(affectedSpell))
-            AddPctN(multiplier, (*i)->GetAmount());
-    }
+            if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*i)->GetSpellInfo(), (*i)->GetAmount(), SameEffectSpellGroup))
+                AddPctN(multiplier, (*i)->GetAmount());
+    }
+
+    for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)
+        AddPctN(multiplier, itr->second);
+
     return multiplier;
 }
 
@@ -4610,7 +4660,9 @@
 
 void Unit::AddGameObject(GameObject* gameObj)
 {
-    if (!gameObj || !gameObj->GetOwnerGUID() == 0) return;
+    if (!gameObj || !gameObj->GetOwnerGUID() == 0)
+        return;
+
     m_gameObj.push_back(gameObj);
     gameObj->SetOwnerGUID(GetGUID());
 
@@ -4626,7 +4678,8 @@
 
 void Unit::RemoveGameObject(GameObject* gameObj, bool del)
 {
-    if (!gameObj || !gameObj->GetOwnerGUID() == GetGUID()) return;
+    if (!gameObj || gameObj->GetOwnerGUID() != GetGUID())
+        return;
 
     gameObj->SetOwnerGUID(0);
 
@@ -4847,28 +4900,29 @@
         data << uint32(damageInfo->damage);                 // Sub Damage
     }
 
-    if (damageInfo->HitInfo & (HITINFO_ABSORB | HITINFO_ABSORB2))
+    if (damageInfo->HitInfo & (HITINFO_FULL_ABSORB | HITINFO_PARTIAL_ABSORB))
     {
         for (uint32 i = 0; i < count; ++i)
             data << uint32(damageInfo->absorb);             // Absorb
     }
 
-    if (damageInfo->HitInfo & (HITINFO_RESIST | HITINFO_RESIST2))
+    if (damageInfo->HitInfo & (HITINFO_FULL_RESIST | HITINFO_PARTIAL_RESIST))
     {
         for (uint32 i = 0; i < count; ++i)
             data << uint32(damageInfo->resist);             // Resist
     }
 
     data << uint8(damageInfo->TargetState);
-    data << uint32(0);
-    data << uint32(0);
+    data << uint32(0);  // Unknown attackerstate
+    data << uint32(0);  // Melee spellid
 
     if (damageInfo->HitInfo & HITINFO_BLOCK)
         data << uint32(damageInfo->blocked_amount);
 
-    if (damageInfo->HitInfo & HITINFO_UNK3)
+    if (damageInfo->HitInfo & HITINFO_RAGE_GAIN)
         data << uint32(0);
 
+    //! Probably used for debugging purposes, as it is not known to appear on retail servers
     if (damageInfo->HitInfo & HITINFO_UNK1)
     {
         data << uint32(0);
@@ -5513,6 +5567,13 @@
                     }
                     break;
                 }
+                case 71875: // Item - Black Bruise: Necrotic Touch Proc
+                case 71877:
+                {
+                    basepoints0 = CalculatePctN(int32(damage), triggerAmount);
+                    triggered_spell_id = 71879;
+                    break;
+                }
                 // Item - Shadowmourne Legendary
                 case 71903:
                 {
@@ -5694,7 +5755,7 @@
                 // Glyph of Polymorph
                 case 56375:
                 {
-                    if(!target)
+                    if (!target)
                         return false;
                     target->RemoveAurasByType(SPELL_AURA_PERIODIC_DAMAGE, 0, target->GetAura(32409)); // SW:D shall not be removed.
                     target->RemoveAurasByType(SPELL_AURA_PERIODIC_DAMAGE_PERCENT);
@@ -5753,7 +5814,7 @@
                 // Blessing of Ancient Kings (Val'anyr, Hammer of Ancient Kings)
                 case 64411:
                 {
-                    if(!victim)
+                    if (!victim)
                         return false;
                     basepoints0 = int32(CalculatePctN(damage, 15));
                     if (AuraEffect* aurEff = victim->GetAuraEffect(64413, 0, GetGUID()))
@@ -5941,6 +6002,8 @@
                 // Siphon Life
                 case 63108:
                 {
+                    if (!damage)
+                        break;
                     // Glyph of Siphon Life
                     if (HasAura(56216))
                         triggerAmount += triggerAmount / 4;
@@ -6064,7 +6127,7 @@
             // Divine Aegis
             if (dummySpell->SpellIconID == 2820)
             {
-                if(!target)
+                if (!target)
                     return false;
 
                 // Multiple effects stack, so let's try to find this aura.
@@ -6234,7 +6297,7 @@
                 // Glyph of Shred
                 case 54815:
                 {
-                    if(!target)
+                    if (!target)
                         return false;
 
                     // try to find spell Rip on the target
@@ -6540,7 +6603,7 @@
                     // Explosive Shot
                     if (procSpell->SpellFamilyFlags[2] & 0x200)
                     {
-                        if(!victim)
+                        if (!victim)
                             return false;
                         if (AuraEffect const* pEff = victim->GetAuraEffect(SPELL_AURA_PERIODIC_DUMMY, SPELLFAMILY_HUNTER, 0x0, 0x80000000, 0x0, GetGUID()))
                             basepoints0 = pEff->GetSpellInfo()->CalcPowerCost(this, SpellSchoolMask(pEff->GetSpellInfo()->SchoolMask)) * 4/10/3;
@@ -6597,9 +6660,11 @@
             {
                 case 34477: // Misdirection
                 {
+                    if (!GetMisdirectionTarget())
+                        return false;
                     triggered_spell_id = 35079; // 4 sec buff on self
                     target = this;
-                    return true;
+                    break;
                 }
                 case 57870: // Glyph of Mend Pet
                 {
@@ -7293,20 +7358,6 @@
                 triggered_spell_id = 63685;
                 break;
             }
-            // Storm, Earth and Fire
-            if (dummySpell->SpellIconID == 3063)
-            {
-                // Earthbind Totem summon only
-                if (procSpell->Id != 2484)
-                    return false;
-
-                float chance = (float)triggerAmount;
-                if (!roll_chance_f(chance))
-                    return false;
-
-                triggered_spell_id = 64695;
-                break;
-            }
             // Ancestral Awakening
             if (dummySpell->SpellIconID == 3065)
             {
@@ -7335,8 +7386,7 @@
                 if (GetTypeId() != TYPEID_PLAYER  || !victim || !victim->isAlive() || !castItem || !castItem->IsEquipped())
                     return false;
 
-                Player* player = ToPlayer();
-                WeaponAttackType attType = WeaponAttackType(player->GetAttackBySlot(castItem->GetSlot()));
+                WeaponAttackType attType = WeaponAttackType(Player::GetAttackBySlot(castItem->GetSlot()));
                 if ((attType != BASE_ATTACK && attType != OFF_ATTACK)
                     || (attType == BASE_ATTACK && procFlag & PROC_FLAG_DONE_OFFHAND_ATTACK)
                     || (attType == OFF_ATTACK && procFlag & PROC_FLAG_DONE_MAINHAND_ATTACK))
@@ -7927,11 +7977,7 @@
                     for (uint8 i = 1; i < stack; ++i)
                         dmg += mod * stack;
                     if (Unit* caster = triggeredByAura->GetCaster())
-                    {
                         caster->CastCustomSpell(70701, SPELLVALUE_BASE_POINT0, dmg);
-                        if (Creature* creature = caster->ToCreature())
-                            creature->DespawnOrUnsummon(1);
-                    }
                     break;
                 }
                 // Ball of Flames Proc
@@ -8142,6 +8188,16 @@
                     CastCustomSpell(this, 70845, &basepoints0, NULL, NULL, true);
                     break;
                 }
+                // Recklessness
+                case 1719:
+                {
+                    //! Possible hack alert
+                    //! Don't drop charges on proc, they will be dropped on SpellMod removal
+                    //! Before this change, it was dropping two charges per attack, one in ProcDamageAndSpellFor, and one in RemoveSpellMods.
+                    //! The reason of this behaviour is Recklessness having three auras, 2 of them can not proc (isTriggeredAura array) but the other one can, making the whole spell proc.
+                    *handled = true;
+                    break;
+                }
                 default:
                     break;
             }
@@ -8265,6 +8321,12 @@
                     RemoveAuraFromStack(auraSpellInfo->Id);
                     return false;
                 }
+                if (auraSpellInfo->Id == 50720)
+                {
+                    target = triggeredByAura->GetCaster();
+                    if (!target)
+                        return false;
+                }
                 break;
             case SPELLFAMILY_WARLOCK:
             {
@@ -8617,6 +8679,26 @@
                 }
                 break;
             }
+            case SPELLFAMILY_ROGUE:
+            {
+                switch (auraSpellInfo->Id)
+                {
+                    // Rogue T10 2P bonus, should only proc on caster
+                    case 70805:
+                    {
+                        if (victim != this)
+                            return false;
+                        break;
+                    }
+                    // Rogue T10 4P bonus, should proc on victim
+                    case 70803:
+                    {
+                        target = victim;
+                        break;
+                    }
+                }
+                break;
+            }
             default:
                  break;
         }
@@ -8781,7 +8863,7 @@
     }
 
     // Blade Barrier
-    if (auraSpellInfo->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT && auraSpellInfo->SpellIconID == 85)
+    if (auraSpellInfo->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT && auraSpellInfo->SpellIconID == 85 && procSpell)
     {
         Player* player = ToPlayer();
         if (!player || player->getClass() != CLASS_DEATH_KNIGHT)
@@ -8996,10 +9078,10 @@
         case 70893:
         {
             // check if we're doing a critical hit
-            if (!(procSpell->SpellFamilyFlags[1] & 0x10000000) && (procEx != PROC_EX_CRITICAL_HIT) )
+            if (!(procSpell->SpellFamilyFlags[1] & 0x10000000) && (procEx != PROC_EX_CRITICAL_HIT))
                 return false;
             // check if we're procced by Claw, Bite or Smack (need to use the spell icon ID to detect it)
-            if (!(procSpell->SpellIconID == 262 || procSpell->SpellIconID == 1680 || procSpell->SpellIconID == 473 ))
+            if (!(procSpell->SpellIconID == 262 || procSpell->SpellIconID == 1680 || procSpell->SpellIconID == 473))
                 return false;
             break;
         }
@@ -9480,6 +9562,16 @@
     if (meleeAttack)
         SendMeleeAttackStart(victim);
 
+    // Let the pet know we've started attacking someting. Handles melee attacks only
+    // Spells such as auto-shot and others handled in WorldSession::HandleCastSpellOpcode
+    if (this->GetTypeId() == TYPEID_PLAYER)
+    {
+        Pet* playerPet = this->ToPlayer()->GetPet();
+
+        if (playerPet && playerPet->isAlive())
+            playerPet->AI()->OwnerAttacked(victim);
+    }
+
     return true;
 }
 
@@ -11878,7 +11970,9 @@
 float Unit::GetPPMProcChance(uint32 WeaponSpeed, float PPM, const SpellInfo* spellProto) const
 {
     // proc per minute chance calculation
-    if (PPM <= 0) return 0.0f;
+    if (PPM <= 0)
+        return 0.0f;
+
     // Apply chance modifer aura
     if (spellProto)
         if (Player* modOwner = GetSpellModOwner())
@@ -12455,6 +12549,12 @@
         if (seer->GetGUID() == guid)
             return true;
 
+    if (Player const* seerPlayer = seer->ToPlayer())
+        if (Unit* owner =  GetOwner())
+            if (Player* ownerPlayer = owner->ToPlayer())
+                if (ownerPlayer->IsGroupVisibleFor(seerPlayer))
+                    return true;
+
     return false;
 }
 
@@ -12747,8 +12847,16 @@
         // remove aurastates allowing special moves
         ClearAllReactives();
         ClearDiminishings();
-        GetMotionMaster()->Clear(false);
-        GetMotionMaster()->MoveIdle();
+        if (IsInWorld())
+        {
+            // Only clear MotionMaster for entities that exists in world
+            // Avoids crashes in the following conditions :
+            //  * Using 'call pet' on dead pets
+            //  * Using 'call stabled pet'
+            //  * Logging in with dead pets
+            GetMotionMaster()->Clear(false);
+            GetMotionMaster()->MoveIdle();
+        }
         StopMoving();
         DisableSpline();
         // without this when removing IncreaseMaxHealth aura player may stuck with 1 hp
@@ -14874,7 +14982,7 @@
         return NULL;
 
     // select random
-    return SelectRandomContainerElement(targets);
+    return Trinity::Containers::SelectRandomContainerElement(targets);
 }
 
 void Unit::ApplyAttackTimePercentMod(WeaponAttackType att, float val, bool apply)
@@ -16425,7 +16533,41 @@
         return;
 
     if (IsInWorld())
-        RemoveNotOwnSingleTargetAuras(newPhaseMask);        // we can lost access to caster or target
+    {
+        RemoveNotOwnSingleTargetAuras(newPhaseMask);            // we can lost access to caster or target
+
+        // modify hostile references for new phasemask, some special cases deal with hostile references themselves
+        if (GetTypeId() == TYPEID_UNIT || (!ToPlayer()->isGameMaster() && !ToPlayer()->GetSession()->PlayerLogout()))
+        {
+            HostileRefManager& refManager = getHostileRefManager();
+            HostileReference* ref = refManager.getFirst();
+
+            while (ref)
+            {
+                if (Unit* unit = ref->getSource()->getOwner())
+                    if (Creature* creature = unit->ToCreature())
+                        refManager.setOnlineOfflineState(creature, creature->InSamePhase(newPhaseMask));
+
+                ref = ref->next();
+            }
+
+            // modify threat lists for new phasemask
+            if (GetTypeId() != TYPEID_PLAYER)
+            {
+                std::list<HostileReference*> threatList = getThreatManager().getThreatList();
+                std::list<HostileReference*> offlineThreatList = getThreatManager().getOfflineThreatList();
+
+                // merge expects sorted lists
+                threatList.sort();
+                offlineThreatList.sort();
+                threatList.merge(offlineThreatList);
+
+                for (std::list<HostileReference*>::const_iterator itr = threatList.begin(); itr != threatList.end(); ++itr)
+                    if (Unit* unit = (*itr)->getTarget())
+                        unit->getHostileRefManager().setOnlineOfflineState(ToCreature(), unit->InSamePhase(newPhaseMask));
+            }
+        }
+    }
 
     WorldObject::SetPhaseMask(newPhaseMask, update);
 
@@ -16984,7 +17126,7 @@
     //! to specify exit coordinates and either store those per passenger, or we need to
     //! init spline movement based on those coordinates in unapply handlers, and
     //! relocate exiting passengers based on Unit::moveSpline data. Either way,
-    //! Coming Soon�
+    //! Coming Soon(TM)
 }
 
 void Unit::_ExitVehicle(Position const* exitPosition)
@@ -17448,7 +17590,7 @@
     return true;
 }
 
-bool Unit::SetDisableGravity(bool disable)
+bool Unit::SetDisableGravity(bool disable, bool /*packetOnly = false*/)
 {
     if (disable == IsLevitating())
         return false;
@@ -17489,26 +17631,35 @@
 
 void Unit::SendMovementHover()
 {
+    if (GetTypeId() == TYPEID_PLAYER)
+        ToPlayer()->SendMovementSetHover(HasUnitMovementFlag(MOVEMENTFLAG_HOVER));
+
     WorldPacket data(MSG_MOVE_HOVER, 64);
     data.append(GetPackGUID());
     BuildMovementPacket(&data);
-    SendMessageToSet(&data, true);
+    SendMessageToSet(&data, false);
 }
 
 void Unit::SendMovementWaterWalking()
 {
+    if (GetTypeId() == TYPEID_PLAYER)
+        ToPlayer()->SendMovementSetWaterWalking(HasUnitMovementFlag(MOVEMENTFLAG_WATERWALKING));
+
     WorldPacket data(MSG_MOVE_WATER_WALK, 64);
     data.append(GetPackGUID());
     BuildMovementPacket(&data);
-    SendMessageToSet(&data, true);
+    SendMessageToSet(&data, false);
 }
 
 void Unit::SendMovementFeatherFall()
 {
+    if (GetTypeId() == TYPEID_PLAYER)
+        ToPlayer()->SendMovementSetFeatherFall(HasUnitMovementFlag(MOVEMENTFLAG_FALLING_SLOW));
+
     WorldPacket data(MSG_MOVE_FEATHER_FALL, 64);
     data.append(GetPackGUID());
     BuildMovementPacket(&data);
-    SendMessageToSet(&data, true);
+    SendMessageToSet(&data, false);
 }
 
 void Unit::SendMovementGravityChange()
@@ -17516,7 +17667,7 @@
     WorldPacket data(MSG_MOVE_GRAVITY_CHNG, 64);
     data.append(GetPackGUID());
     BuildMovementPacket(&data);
-    SendMessageToSet(&data, true);
+    SendMessageToSet(&data, false);
 }
 
 void Unit::SendMovementCanFlyChange()
@@ -17541,5 +17692,5 @@
     WorldPacket data(MSG_MOVE_UPDATE_CAN_FLY, 64);
     data.append(GetPackGUID());
     BuildMovementPacket(&data);
-    SendMessageToSet(&data, true);
-}
+    SendMessageToSet(&data, false);
+}
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Entities/Unit/Unit.h
--- a/src/server/game/Entities/Unit/Unit.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Entities/Unit/Unit.h	Mon Apr 16 14:29:17 2012 +0300
@@ -286,29 +286,29 @@
 {
     HITINFO_NORMALSWING         = 0x00000000,
     HITINFO_UNK1                = 0x00000001,               // req correct packet structure
-    HITINFO_NORMALSWING2        = 0x00000002,
-    HITINFO_LEFTSWING           = 0x00000004,
+    HITINFO_AFFECTS_VICTIM      = 0x00000002,
+    HITINFO_OFFHAND             = 0x00000004,
     HITINFO_UNK2                = 0x00000008,
     HITINFO_MISS                = 0x00000010,
-    HITINFO_ABSORB              = 0x00000020,               // absorbed damage
-    HITINFO_ABSORB2             = 0x00000040,               // absorbed damage
-    HITINFO_RESIST              = 0x00000080,               // resisted atleast some damage
-    HITINFO_RESIST2             = 0x00000100,               // resisted atleast some damage
+    HITINFO_FULL_ABSORB         = 0x00000020,
+    HITINFO_PARTIAL_ABSORB      = 0x00000040,
+    HITINFO_FULL_RESIST         = 0x00000080,
+    HITINFO_PARTIAL_RESIST      = 0x00000100,
     HITINFO_CRITICALHIT         = 0x00000200,               // critical hit
     // 0x00000400
     // 0x00000800
     // 0x00001000
     HITINFO_BLOCK               = 0x00002000,               // blocked damage
-    // 0x00004000
-    // 0x00008000
+    // 0x00004000                                           // Hides worldtext for 0 damage
+    // 0x00008000                                           // Related to blood visual
     HITINFO_GLANCING            = 0x00010000,
     HITINFO_CRUSHING            = 0x00020000,
-    HITINFO_NOACTION            = 0x00040000,               // guessed
+    HITINFO_NO_ANIMATION        = 0x00040000,
     // 0x00080000
     // 0x00100000
-    HITINFO_SWINGNOHITSOUND     = 0x00200000,               // guessed
+    HITINFO_SWINGNOHITSOUND     = 0x00200000,               // unused?
     // 0x00400000
-    HITINFO_UNK3                = 0x00800000
+    HITINFO_RAGE_GAIN           = 0x00800000
 };
 
 //i would like to remove this: (it is defined in item.h
@@ -707,6 +707,9 @@
     MOVEMENTFLAG_MASK_TURNING =
         MOVEMENTFLAG_LEFT | MOVEMENTFLAG_RIGHT,
 
+    MOVEMENTFLAG_MASK_MOVING_FLY =
+        MOVEMENTFLAG_FLYING | MOVEMENTFLAG_ASCENDING | MOVEMENTFLAG_DESCENDING,
+
     //! TODO if needed: add more flags to this masks that are exclusive to players
     MOVEMENTFLAG_MASK_PLAYER_ONLY =
         MOVEMENTFLAG_FLYING,
@@ -1236,7 +1239,7 @@
 
         typedef std::map<uint8, AuraApplication*> VisibleAuraMap;
 
-        virtual ~Unit ();
+        virtual ~Unit();
 
         UnitAI* GetAI() { return i_AI; }
         void SetAI(UnitAI* newAI) { i_AI = newAI; }
@@ -1336,7 +1339,7 @@
 
         float GetStat(Stats stat) const { return float(GetUInt32Value(UNIT_FIELD_STAT0+stat)); }
         void SetStat(Stats stat, int32 val) { SetStatInt32Value(UNIT_FIELD_STAT0+stat, val); }
-        uint32 GetArmor() const { return GetResistance(SPELL_SCHOOL_NORMAL) ; }
+        uint32 GetArmor() const { return GetResistance(SPELL_SCHOOL_NORMAL); }
         void SetArmor(int32 val) { SetResistance(SPELL_SCHOOL_NORMAL, val); }
 
         uint32 GetResistance(SpellSchools school) const { return GetUInt32Value(UNIT_FIELD_RESISTANCES+school); }
@@ -1644,7 +1647,7 @@
         bool IsLevitating() const { return m_movementInfo.HasMovementFlag(MOVEMENTFLAG_DISABLE_GRAVITY);}
         bool IsWalking() const { return m_movementInfo.HasMovementFlag(MOVEMENTFLAG_WALKING);}
         virtual bool SetWalk(bool enable);
-        virtual bool SetDisableGravity(bool disable);
+        virtual bool SetDisableGravity(bool disable, bool packetOnly = false);
         bool SetHover(bool enable);
 
         void SetInFront(Unit const* target);
@@ -2026,7 +2029,7 @@
         float GetAPMultiplier(WeaponAttackType attType, bool normalized);
         void ModifyAuraState(AuraStateType flag, bool apply);
         uint32 BuildAuraStateUpdateForTarget(Unit* target) const;
-        bool HasAuraState(AuraStateType flag, SpellInfo const* spellProto = NULL, Unit const* Caster = NULL) const ;
+        bool HasAuraState(AuraStateType flag, SpellInfo const* spellProto = NULL, Unit const* Caster = NULL) const;
         void UnsummonAllTotems();
         Unit* GetMagicHitRedirectTarget(Unit* victim, SpellInfo const* spellInfo);
         Unit* GetMeleeHitRedirectTarget(Unit* victim, SpellInfo const* spellInfo = NULL);
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Entities/Vehicle/Vehicle.cpp
--- a/src/server/game/Entities/Vehicle/Vehicle.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Entities/Vehicle/Vehicle.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -485,11 +485,12 @@
 
 void Vehicle::Dismiss()
 {
+    if (GetBase()->GetTypeId() != TYPEID_UNIT)
+        return;
+
     sLog->outDebug(LOG_FILTER_VEHICLES, "Vehicle::Dismiss Entry: %u, GuidLow %u", _creatureEntry, _me->GetGUIDLow());
     Uninstall();
-    _me->DestroyForNearbyPlayers();
-    _me->CombatStop();
-    _me->AddObjectToRemoveList();
+    GetBase()->ToCreature()->DespawnOrUnsummon();
 }
 
 void Vehicle::InitMovementInfoForBase()
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Events/GameEventMgr.cpp
--- a/src/server/game/Events/GameEventMgr.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Events/GameEventMgr.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -80,7 +80,7 @@
     if (mGameEvent[entry].state == GAMEEVENT_WORLD_CONDITIONS)
     {
         if (mGameEvent[entry].length)
-            return mGameEvent[entry].length * 60 ;
+            return mGameEvent[entry].length * 60;
         else
             return max_ge_check_delay;
     }
@@ -205,7 +205,7 @@
 {
     {
         uint32 oldMSTime = getMSTime();
-
+                                                //       1           2                           3                         4          5       6        7            8
         QueryResult result = WorldDatabase.Query("SELECT eventEntry, UNIX_TIMESTAMP(start_time), UNIX_TIMESTAMP(end_time), occurence, length, holiday, description, world_event FROM game_event");
         if (!result)
         {
@@ -220,7 +220,7 @@
         {
             Field* fields = result->Fetch();
 
-            uint16 event_id = fields[0].GetUInt16();
+            uint8 event_id = fields[0].GetUInt8();
             if (event_id == 0)
             {
                 sLog->outErrorDb("`game_event` game event entry 0 is reserved and can't be used.");
@@ -232,8 +232,8 @@
             pGameEvent.start        = time_t(starttime);
             uint64 endtime          = fields[2].GetUInt64();
             pGameEvent.end          = time_t(endtime);
-            pGameEvent.occurence    = fields[3].GetUInt32();
-            pGameEvent.length       = fields[4].GetUInt32();
+            pGameEvent.occurence    = fields[3].GetUInt64();
+            pGameEvent.length       = fields[4].GetUInt64();
             pGameEvent.holiday_id   = HolidayIds(fields[5].GetUInt32());
 
             pGameEvent.state        = (GameEventState)(fields[7].GetUInt8());
@@ -283,7 +283,7 @@
             {
                 Field* fields = result->Fetch();
 
-                uint16 event_id = fields[0].GetUInt16();
+                uint8 event_id = fields[0].GetUInt8();
 
                 if (event_id >= mGameEvent.size())
                 {
@@ -315,6 +315,7 @@
     {
         uint32 oldMSTime = getMSTime();
 
+        //                                                   0             1
         QueryResult result = WorldDatabase.Query("SELECT eventEntry, prerequisite_event FROM game_event_prerequisite");
         if (!result)
         {
@@ -328,7 +329,7 @@
             {
                 Field* fields = result->Fetch();
 
-                uint16 event_id = fields[0].GetUInt16();
+                uint16 event_id = fields[0].GetUInt8();
 
                 if (event_id >= mGameEvent.size())
                 {
@@ -338,7 +339,7 @@
 
                 if (mGameEvent[event_id].state != GAMEEVENT_NORMAL && mGameEvent[event_id].state != GAMEEVENT_INTERNAL)
                 {
-                    uint16 prerequisite_event = fields[1].GetUInt16();
+                    uint16 prerequisite_event = fields[1].GetUInt32();
                     if (prerequisite_event >= mGameEvent.size())
                     {
                         sLog->outErrorDb("`game_event_prerequisite` game event prerequisite id (%i) is out of range compared to max event id in `game_event`", prerequisite_event);
@@ -382,7 +383,7 @@
                 Field* fields = result->Fetch();
 
                 uint32 guid    = fields[0].GetUInt32();
-                int16 event_id = fields[1].GetInt16();
+                int16 event_id = fields[1].GetInt8();
 
                 int32 internal_event_id = mGameEvent.size() + event_id - 1;
 
@@ -408,7 +409,7 @@
     {
         uint32 oldMSTime = getMSTime();
 
-        //                                                      1                2
+        //                                                      0                1
         QueryResult result = WorldDatabase.Query("SELECT gameobject.guid, game_event_gameobject.eventEntry FROM gameobject"
                                                  " JOIN game_event_gameobject ON gameobject.guid=game_event_gameobject.guid");
 
@@ -425,7 +426,7 @@
                 Field* fields = result->Fetch();
 
                 uint32 guid    = fields[0].GetUInt32();
-                int16 event_id = fields[1].GetInt16();
+                int16 event_id = fields[1].GetInt8();
 
                 int32 internal_event_id = mGameEvent.size() + event_id - 1;
 
@@ -468,7 +469,7 @@
                 Field* fields = result->Fetch();
 
                 uint32 guid     = fields[0].GetUInt32();
-                uint16 event_id = fields[1].GetUInt16();
+                uint16 event_id = fields[1].GetUInt8();
 
                 if (event_id >= mGameEventModelEquip.size())
                 {
@@ -525,7 +526,7 @@
 
                 uint32 id       = fields[0].GetUInt32();
                 uint32 quest    = fields[1].GetUInt32();
-                uint16 event_id = fields[2].GetUInt16();
+                uint16 event_id = fields[2].GetUInt8();
 
                 if (event_id >= mGameEventCreatureQuests.size())
                 {
@@ -566,7 +567,7 @@
 
                 uint32 id       = fields[0].GetUInt32();
                 uint32 quest    = fields[1].GetUInt32();
-                uint16 event_id = fields[2].GetUInt16();
+                uint16 event_id = fields[2].GetUInt8();
 
                 if (event_id >= mGameEventGameObjectQuests.size())
                 {
@@ -590,7 +591,7 @@
     {
         uint32 oldMSTime = getMSTime();
 
-        //                                                 0       1         2           3
+        //                                                 0       1         2             3
         QueryResult result = WorldDatabase.Query("SELECT quest, eventEntry, condition_id, num FROM game_event_quest_condition");
 
         if (!result)
@@ -606,7 +607,7 @@
                 Field* fields = result->Fetch();
 
                 uint32 quest     = fields[0].GetUInt32();
-                uint16 event_id  = fields[1].GetUInt16();
+                uint16 event_id  = fields[1].GetUInt8();
                 uint32 condition = fields[2].GetUInt32();
                 float num       = fields[3].GetFloat();
 
@@ -648,7 +649,7 @@
             {
                 Field* fields = result->Fetch();
 
-                uint16 event_id  = fields[0].GetUInt16();
+                uint16 event_id  = fields[0].GetUInt8();
                 uint32 condition = fields[1].GetUInt32();
 
                 if (event_id >= mGameEvent.size())
@@ -659,8 +660,8 @@
 
                 mGameEvent[event_id].conditions[condition].reqNum = fields[2].GetFloat();
                 mGameEvent[event_id].conditions[condition].done = 0;
-                mGameEvent[event_id].conditions[condition].max_world_state = fields[3].GetUInt32();
-                mGameEvent[event_id].conditions[condition].done_world_state = fields[4].GetUInt32();
+                mGameEvent[event_id].conditions[condition].max_world_state = fields[3].GetUInt16();
+                mGameEvent[event_id].conditions[condition].done_world_state = fields[4].GetUInt16();
 
                 ++count;
             }
@@ -690,7 +691,7 @@
             {
                 Field* fields = result->Fetch();
 
-                uint16 event_id  = fields[0].GetUInt16();
+                uint16 event_id  = fields[0].GetUInt8();
                 uint32 condition = fields[1].GetUInt32();
 
                 if (event_id >= mGameEvent.size())
@@ -739,7 +740,7 @@
                 Field* fields = result->Fetch();
 
                 uint32 guid     = fields[0].GetUInt32();
-                uint16 event_id = fields[1].GetUInt16();
+                uint16 event_id = fields[1].GetUInt8();
                 uint32 npcflag  = fields[2].GetUInt32();
 
                 if (event_id >= mGameEvent.size())
@@ -763,7 +764,7 @@
     {
         uint32 oldMSTime = getMSTime();
 
-        //                                               0     1
+        //                                                  0          1
         QueryResult result = WorldDatabase.Query("SELECT questId, eventEntry FROM game_event_seasonal_questrelation");
 
         if (!result)
@@ -779,7 +780,7 @@
                 Field* fields = result->Fetch();
 
                 uint32 questId  = fields[0].GetUInt32();
-                uint16 eventEntry = fields[1].GetUInt16();
+                uint32 eventEntry = fields[1].GetUInt32(); // TODO: Change to uint8
 
                 if (!sObjectMgr->GetQuestTemplate(questId))
                 {
@@ -822,7 +823,7 @@
             {
                 Field* fields = result->Fetch();
 
-                uint16 event_id  = fields[0].GetUInt16();
+                uint8 event_id  = fields[0].GetUInt8();
 
                 if (event_id >= mGameEventVendors.size())
                 {
@@ -834,7 +835,7 @@
                 NPCVendorEntry newEntry;
                 uint32 guid = fields[1].GetUInt32();
                 newEntry.item = fields[2].GetUInt32();
-                newEntry.maxcount = fields[3].GetInt32();
+                newEntry.maxcount = fields[3].GetUInt32();
                 newEntry.incrtime = fields[4].GetUInt32();
                 newEntry.ExtendedCost = fields[5].GetUInt32();
                 // get the event npc flag for checking if the npc will be vendor during the event or not
@@ -888,7 +889,7 @@
             {
                 Field* fields = result->Fetch();
 
-                uint16 event_id = fields[0].GetUInt16();
+                uint16 event_id = fields[0].GetUInt8();
 
                 if (event_id >= mGameEvent.size())
                 {
@@ -911,7 +912,7 @@
     {
         uint32 oldMSTime = getMSTime();
 
-        //                                                       1                       2
+        //                                                               0                         1
         QueryResult result = WorldDatabase.Query("SELECT pool_template.entry, game_event_pool.eventEntry FROM pool_template"
                                                  " JOIN game_event_pool ON pool_template.entry = game_event_pool.pool_entry");
 
@@ -928,7 +929,7 @@
                 Field* fields = result->Fetch();
 
                 uint32 entry   = fields[0].GetUInt32();
-                int16 event_id = fields[1].GetInt16();
+                int16 event_id = fields[1].GetInt8();
 
                 int32 internal_event_id = mGameEvent.size() + event_id - 1;
 
@@ -981,7 +982,7 @@
     {
         Field* fields = result->Fetch();
 
-        uint32 maxEventId = fields[0].GetUInt16();
+        uint32 maxEventId = fields[0].GetUInt8();
 
         // Id starts with 1 and vector with 0, thus increment
         maxEventId++;
@@ -1019,7 +1020,7 @@
     }
 
     Field* fields = result->Fetch();
-    uint16 eventId = fields[0].GetUInt16();
+    uint16 eventId = fields[0].GetUInt8();
 
     if (eventId >= mGameEvent.size())
     {
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Globals/ObjectMgr.cpp
--- a/src/server/game/Globals/ObjectMgr.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Globals/ObjectMgr.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -252,6 +252,10 @@
         itr->second.Clear();
 
     _cacheTrainerSpellStore.clear();
+
+    for (DungeonEncounterContainer::iterator itr =_dungeonEncounterStore.begin(); itr != _dungeonEncounterStore.end(); ++itr)
+        for (DungeonEncounterList::iterator encounterItr = itr->second.begin(); encounterItr != itr->second.end(); ++encounterItr)
+            delete *encounterItr;
 }
 
 void ObjectMgr::AddLocaleString(std::string const& s, LocaleConstant locale, StringVector& data)
@@ -418,7 +422,7 @@
         creatureTemplate.GossipMenuId      = fields[13].GetUInt32();
         creatureTemplate.minlevel          = fields[14].GetUInt8();
         creatureTemplate.maxlevel          = fields[15].GetUInt8();
-        creatureTemplate.expansion         = uint32(fields[16].GetUInt16());
+        creatureTemplate.expansion         = uint32(fields[16].GetInt16());
         creatureTemplate.faction_A         = uint32(fields[17].GetUInt16());
         creatureTemplate.faction_H         = uint32(fields[18].GetUInt16());
         creatureTemplate.npcflag           = fields[19].GetUInt32();
@@ -451,7 +455,7 @@
         creatureTemplate.SkinLootId        = fields[46].GetUInt32();
 
         for (uint8 i = SPELL_SCHOOL_HOLY; i < MAX_SPELL_SCHOOL; ++i)
-            creatureTemplate.resistance[i] = fields[47 + i -1].GetInt32();
+            creatureTemplate.resistance[i] = fields[47 + i -1].GetInt16();
 
         for (uint8 i = 0; i < CREATURE_MAX_SPELLS; ++i)
             creatureTemplate.spells[i] = fields[53 + i].GetUInt32();
@@ -1127,7 +1131,7 @@
 
         uint32 modelId = fields[0].GetUInt32();
 
-        CreatureModelInfo& modelInfo =  _creatureModelStore[modelId];
+        CreatureModelInfo& modelInfo = _creatureModelStore[modelId];
 
         modelInfo.bounding_radius      = fields[1].GetFloat();
         modelInfo.combat_reach         = fields[2].GetFloat();
@@ -1167,6 +1171,7 @@
     uint32 oldMSTime = getMSTime();
 
     _linkedRespawnStore.clear();
+    //                                                 0        1          2
     QueryResult result = WorldDatabase.Query("SELECT guid, linkedGuid, linkType FROM linked_respawn ORDER BY guid ASC");
 
     if (!result)
@@ -1422,8 +1427,8 @@
     {
         Field* fields = result->Fetch();
 
-        uint32 guid         = fields[ 0].GetUInt32();
-        uint32 entry        = fields[ 1].GetUInt32();
+        uint32 guid         = fields[0].GetUInt32();
+        uint32 entry        = fields[1].GetUInt32();
 
         CreatureTemplate const* cInfo = GetCreatureTemplate(entry);
         if (!cInfo)
@@ -1434,14 +1439,14 @@
 
         CreatureData& data = _creatureDataStore[guid];
         data.id             = entry;
-        data.mapid          = fields[ 2].GetUInt32();
-        data.displayid      = fields[ 3].GetUInt32();
-        data.equipmentId    = fields[ 4].GetUInt32();
-        data.posX           = fields[ 5].GetFloat();
-        data.posY           = fields[ 6].GetFloat();
-        data.posZ           = fields[ 7].GetFloat();
-        data.orientation    = fields[ 8].GetFloat();
-        data.spawntimesecs  = fields[ 9].GetUInt32();
+        data.mapid          = fields[2].GetUInt16();
+        data.displayid      = fields[3].GetUInt32();
+        data.equipmentId    = fields[4].GetInt32();
+        data.posX           = fields[5].GetFloat();
+        data.posY           = fields[6].GetFloat();
+        data.posZ           = fields[7].GetFloat();
+        data.orientation    = fields[8].GetFloat();
+        data.spawntimesecs  = fields[9].GetUInt32();
         data.spawndist      = fields[10].GetFloat();
         data.currentwaypoint= fields[11].GetUInt32();
         data.curhealth      = fields[12].GetUInt32();
@@ -1449,7 +1454,7 @@
         data.movementType   = fields[14].GetUInt8();
         data.spawnMask      = fields[15].GetUInt8();
         data.phaseMask      = fields[16].GetUInt16();
-        int16 gameEvent     = fields[17].GetInt16();
+        int16 gameEvent     = fields[17].GetInt8();
         uint32 PoolId       = fields[18].GetUInt32();
         data.npcflag        = fields[19].GetUInt32();
         data.unit_flags     = fields[20].GetUInt32();
@@ -1731,8 +1736,8 @@
     {
         Field* fields = result->Fetch();
 
-        uint32 guid         = fields[ 0].GetUInt32();
-        uint32 entry        = fields[ 1].GetUInt32();
+        uint32 guid         = fields[0].GetUInt32();
+        uint32 entry        = fields[1].GetUInt32();
 
         GameObjectTemplate const* gInfo = GetGameObjectTemplate(entry);
         if (!gInfo)
@@ -1763,14 +1768,14 @@
         GameObjectData& data = _gameObjectDataStore[guid];
 
         data.id             = entry;
-        data.mapid          = fields[ 2].GetUInt32();
-        data.posX           = fields[ 3].GetFloat();
-        data.posY           = fields[ 4].GetFloat();
-        data.posZ           = fields[ 5].GetFloat();
-        data.orientation    = fields[ 6].GetFloat();
-        data.rotation0      = fields[ 7].GetFloat();
-        data.rotation1      = fields[ 8].GetFloat();
-        data.rotation2      = fields[ 9].GetFloat();
+        data.mapid          = fields[2].GetUInt16();
+        data.posX           = fields[3].GetFloat();
+        data.posY           = fields[4].GetFloat();
+        data.posZ           = fields[5].GetFloat();
+        data.orientation    = fields[6].GetFloat();
+        data.rotation0      = fields[7].GetFloat();
+        data.rotation1      = fields[8].GetFloat();
+        data.rotation2      = fields[9].GetFloat();
         data.rotation3      = fields[10].GetFloat();
         data.spawntimesecs  = fields[11].GetInt32();
 
@@ -1786,10 +1791,10 @@
             sLog->outErrorDb("Table `gameobject` has gameobject (GUID: %u Entry: %u) with `spawntimesecs` (0) value, but the gameobejct is marked as despawnable at action.", guid, data.id);
         }
 
-        data.animprogress   = fields[12].GetUInt32();
+        data.animprogress   = fields[12].GetUInt8();
         data.artKit         = 0;
 
-        uint32 go_state     = fields[13].GetUInt32();
+        uint32 go_state     = fields[13].GetUInt8();
         if (go_state >= MAX_GO_STATE)
         {
             sLog->outErrorDb("Table `gameobject` has gameobject (GUID: %u Entry: %u) with invalid `state` (%u) value, skip", guid, data.id, go_state);
@@ -1803,7 +1808,7 @@
             sLog->outErrorDb("Table `gameobject` has gameobject (GUID: %u Entry: %u) that has wrong spawn mask %u including not supported difficulty modes for map (Id: %u), skip", guid, data.id, data.spawnMask, data.mapid);
 
         data.phaseMask      = fields[15].GetUInt16();
-        int16 gameEvent     = fields[16].GetInt16();
+        int16 gameEvent     = fields[16].GetInt8();
         uint32 PoolId        = fields[17].GetUInt32();
 
         if (data.rotation2 < -1.0f || data.rotation2 > 1.0f)
@@ -1943,10 +1948,12 @@
 {
     uint64 guid = 0;
 
-    CharacterDatabase.EscapeString(name);
-
-    // Player name safe to sending to DB (checked at login) and this function using
-    QueryResult result = CharacterDatabase.PQuery("SELECT guid FROM characters WHERE name = '%s'", name.c_str());
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GUID_BY_NAME);
+
+    stmt->setString(0, name);
+
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
     if (result)
         guid = MAKE_NEW_GUID((*result)[0].GetUInt32(), 0, HIGHGUID_PLAYER);
 
@@ -1962,7 +1969,11 @@
         return true;
     }
 
-    QueryResult result = CharacterDatabase.PQuery("SELECT name FROM characters WHERE guid = '%u'", GUID_LOPART(guid));
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_NAME);
+
+    stmt->setUInt32(0, GUID_LOPART(guid));
+
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
 
     if (result)
     {
@@ -1981,7 +1992,11 @@
         return Player::TeamForRace(player->getRace());
     }
 
-    QueryResult result = CharacterDatabase.PQuery("SELECT race FROM characters WHERE guid = '%u'", GUID_LOPART(guid));
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_RACE);
+
+    stmt->setUInt32(0, GUID_LOPART(guid));
+
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
 
     if (result)
     {
@@ -2000,7 +2015,12 @@
         return player->GetSession()->GetAccountId();
     }
 
-    QueryResult result = CharacterDatabase.PQuery("SELECT account FROM characters WHERE guid = '%u'", GUID_LOPART(guid));
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_ACCOUNT_BY_GUID);
+
+    stmt->setUInt32(0, GUID_LOPART(guid));
+
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
     if (result)
     {
         uint32 acc = (*result)[0].GetUInt32();
@@ -2012,7 +2032,12 @@
 
 uint32 ObjectMgr::GetPlayerAccountIdByPlayerName(const std::string& name) const
 {
-    QueryResult result = CharacterDatabase.PQuery("SELECT account FROM characters WHERE name = '%s'", name.c_str());
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_ACCOUNT_BY_NAME);
+
+    stmt->setString(0, name);
+
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
     if (result)
     {
         uint32 acc = (*result)[0].GetUInt32();
@@ -2706,7 +2731,8 @@
             if (setEntry->itemId[i])
                 itemSetItems.insert(setEntry->itemId[i]);
     }
-
+    
+    //                                                  0        1            2
     QueryResult result = WorldDatabase.Query("SELECT `entry`, `name`, `InventoryType` FROM `item_set_names`");
 
     if (!result)
@@ -2733,7 +2759,7 @@
         ItemSetNameEntry &data = _itemSetNameStore[entry];
         data.name = fields[1].GetString();
 
-        uint32 invType = fields[2].GetUInt32();
+        uint32 invType = fields[2].GetUInt8();
         if (invType >= MAX_INVTYPE)
         {
             sLog->outErrorDb("Item set name (Entry: %u) has wrong InventoryType value (%u)", entry, invType);
@@ -2778,6 +2804,7 @@
 
     uint32 count = 0;
 
+    //                                                  0             1              2          3           4             5
     QueryResult result = WorldDatabase.Query("SELECT `entry`, `accessory_entry`, `seat_id`, `minion`, `summontype`, `summontimer` FROM `vehicle_template_accessory`");
 
     if (!result)
@@ -2793,7 +2820,7 @@
 
         uint32 uiEntry      = fields[0].GetUInt32();
         uint32 uiAccessory  = fields[1].GetUInt32();
-        int8   uiSeat       = int8(fields[2].GetInt16());
+        int8   uiSeat       = int8(fields[2].GetInt8());
         bool   bMinion      = fields[3].GetBool();
         uint8  uiSummonType = fields[4].GetUInt8();
         uint32 uiSummonTimer= fields[5].GetUInt32();
@@ -2834,6 +2861,7 @@
 
     uint32 count = 0;
 
+    //                                                  0             1             2          3           4             5
     QueryResult result = WorldDatabase.Query("SELECT `guid`, `accessory_entry`, `seat_id`, `minion`, `summontype`, `summontimer` FROM `vehicle_accessory`");
 
     if (!result)
@@ -2875,7 +2903,7 @@
     uint32 oldMSTime = getMSTime();
 
     //                                                 0               1      2   3     4    5    6    7     8    9
-    QueryResult result  = WorldDatabase.Query("SELECT creature_entry, level, hp, mana, str, agi, sta, inte, spi, armor FROM pet_levelstats");
+    QueryResult result = WorldDatabase.Query("SELECT creature_entry, level, hp, mana, str, agi, sta, inte, spi, armor FROM pet_levelstats");
 
     if (!result)
     {
@@ -2897,7 +2925,7 @@
             continue;
         }
 
-        uint32 current_level = fields[1].GetUInt32();
+        uint32 current_level = fields[1].GetUInt8();
         if (current_level > sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
         {
             if (current_level > STRONG_MAX_LEVEL)        // hardcoded level maximum
@@ -2918,14 +2946,14 @@
         PetLevelInfo*& pInfoMapEntry = _petInfoStore[creature_id];
 
         if (pInfoMapEntry == NULL)
-            pInfoMapEntry =  new PetLevelInfo[sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL)];
+            pInfoMapEntry = new PetLevelInfo[sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL)];
 
         // data for level 1 stored in [0] array element, ...
         PetLevelInfo* pLevelInfo = &pInfoMapEntry[current_level-1];
 
         pLevelInfo->health = fields[2].GetUInt16();
         pLevelInfo->mana   = fields[3].GetUInt16();
-        pLevelInfo->armor  = fields[9].GetUInt16();
+        pLevelInfo->armor  = fields[9].GetUInt32();
 
         for (int i = 0; i < MAX_STATS; i++)
         {
@@ -3021,7 +3049,7 @@
     // Load playercreate
     {
         uint32 oldMSTime = getMSTime();
-        //                                                0     1      2    3     4           5           6
+        //                                                0     1      2    3        4          5           6
         QueryResult result = WorldDatabase.Query("SELECT race, class, map, zone, position_x, position_y, position_z, orientation FROM playercreateinfo");
 
         if (!result)
@@ -3038,10 +3066,10 @@
             {
                 Field* fields = result->Fetch();
 
-                uint32 current_race  = fields[0].GetUInt32();
-                uint32 current_class = fields[1].GetUInt32();
-                uint32 mapId         = fields[2].GetUInt32();
-                uint32 areaId        = fields[3].GetUInt32();
+                uint32 current_race  = fields[0].GetUInt8();
+                uint32 current_class = fields[1].GetUInt8();
+                uint32 mapId         = fields[2].GetUInt16();
+                uint32 areaId        = fields[3].GetUInt32(); // zone
                 float  positionX     = fields[4].GetFloat();
                 float  positionY     = fields[5].GetFloat();
                 float  positionZ     = fields[6].GetFloat();
@@ -3126,14 +3154,14 @@
             {
                 Field* fields = result->Fetch();
 
-                uint32 current_race = fields[0].GetUInt32();
+                uint32 current_race = fields[0].GetUInt8();
                 if (current_race >= MAX_RACES)
                 {
                     sLog->outErrorDb("Wrong race %u in `playercreateinfo_item` table, ignoring.", current_race);
                     continue;
                 }
 
-                uint32 current_class = fields[1].GetUInt32();
+                uint32 current_class = fields[1].GetUInt8();
                 if (current_class >= MAX_CLASSES)
                 {
                     sLog->outErrorDb("Wrong class %u in `playercreateinfo_item` table, ignoring.", current_class);
@@ -3148,7 +3176,7 @@
                     continue;
                 }
 
-                int32 amount   = fields[3].GetInt32();
+                int32 amount   = fields[3].GetInt8();
 
                 if (!amount)
                 {
@@ -3183,11 +3211,8 @@
     {
         uint32 oldMSTime = getMSTime();
 
-        QueryResult result = QueryResult(NULL);
-        if (sWorld->getBoolConfig(CONFIG_START_ALL_SPELLS))
-            result = WorldDatabase.Query("SELECT race, class, Spell, Active FROM playercreateinfo_spell_custom");
-        else
-            result = WorldDatabase.Query("SELECT race, class, Spell FROM playercreateinfo_spell");
+        std::string tableName = sWorld->getBoolConfig(CONFIG_START_ALL_SPELLS) ? "playercreateinfo_spell_custom" : "playercreateinfo_spell";
+        QueryResult result = WorldDatabase.PQuery("SELECT race, class, Spell FROM %s", tableName.c_str());
 
         if (!result)
         {
@@ -3202,14 +3227,14 @@
             {
                 Field* fields = result->Fetch();
 
-                uint32 current_race = fields[0].GetUInt32();
+                uint32 current_race = fields[0].GetUInt8();
                 if (current_race >= MAX_RACES)
                 {
                     sLog->outErrorDb("Wrong race %u in `playercreateinfo_spell` table, ignoring.", current_race);
                     continue;
                 }
 
-                uint32 current_class = fields[1].GetUInt32();
+                uint32 current_class = fields[1].GetUInt8();
                 if (current_class >= MAX_CLASSES)
                 {
                     sLog->outErrorDb("Wrong class %u in `playercreateinfo_spell` table, ignoring.", current_class);
@@ -3259,14 +3284,14 @@
             {
                 Field* fields = result->Fetch();
 
-                uint32 current_race = fields[0].GetUInt32();
+                uint32 current_race = fields[0].GetUInt8();
                 if (current_race >= MAX_RACES)
                 {
                     sLog->outErrorDb("Wrong race %u in `playercreateinfo_action` table, ignoring.", current_race);
                     continue;
                 }
 
-                uint32 current_class = fields[1].GetUInt32();
+                uint32 current_class = fields[1].GetUInt8();
                 if (current_class >= MAX_CLASSES)
                 {
                     sLog->outErrorDb("Wrong class %u in `playercreateinfo_action` table, ignoring.", current_class);
@@ -3274,7 +3299,7 @@
                 }
 
                 PlayerInfo* pInfo = &_playerInfo[current_race][current_class];
-                pInfo->action.push_back(PlayerCreateInfoAction(fields[2].GetUInt8(), fields[3].GetUInt32(), fields[4].GetUInt8()));
+                pInfo->action.push_back(PlayerCreateInfoAction(fields[2].GetUInt16(), fields[3].GetUInt32(), fields[4].GetUInt16()));
 
                 ++count;
             }
@@ -3306,7 +3331,7 @@
         {
             Field* fields = result->Fetch();
 
-            uint32 current_class = fields[0].GetUInt32();
+            uint32 current_class = fields[0].GetUInt8();
             if (current_class >= MAX_CLASSES)
             {
                 sLog->outErrorDb("Wrong class %u in `player_classlevelstats` table, ignoring.", current_class);
@@ -3387,21 +3412,21 @@
         {
             Field* fields = result->Fetch();
 
-            uint32 current_race = fields[0].GetUInt32();
+            uint32 current_race = fields[0].GetUInt8();
             if (current_race >= MAX_RACES)
             {
                 sLog->outErrorDb("Wrong race %u in `player_levelstats` table, ignoring.", current_race);
                 continue;
             }
 
-            uint32 current_class = fields[1].GetUInt32();
+            uint32 current_class = fields[1].GetUInt8();
             if (current_class >= MAX_CLASSES)
             {
                 sLog->outErrorDb("Wrong class %u in `player_levelstats` table, ignoring.", current_class);
                 continue;
             }
 
-            uint32 current_level = fields[2].GetUInt32();
+            uint32 current_level = fields[2].GetUInt8();
             if (current_level > sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
             {
                 if (current_level > STRONG_MAX_LEVEL)        // hardcoded level maximum
@@ -3505,7 +3530,7 @@
         {
             Field* fields = result->Fetch();
 
-            uint32 current_level = fields[0].GetUInt32();
+            uint32 current_level = fields[0].GetUInt8();
             uint32 current_xp    = fields[1].GetUInt32();
 
             if (current_level >= sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
@@ -4395,9 +4420,8 @@
     scripts->clear();                                       // need for reload support
 
     bool isSpellScriptTable = (type == SCRIPTS_SPELL);
-    char buff[125];
-    sprintf(buff, "SELECT id, delay, command, datalong, datalong2, dataint, x, y, z, o%s FROM %s", isSpellScriptTable ? ", effIndex" : "", tableName.c_str());
-    QueryResult result = WorldDatabase.Query(buff);
+    //                                                 0    1       2         3         4          5    6  7  8  9
+    QueryResult result = WorldDatabase.PQuery("SELECT id, delay, command, datalong, datalong2, dataint, x, y, z, o%s FROM %s", isSpellScriptTable ? ", effIndex" : "", tableName.c_str());
 
     if (!result)
     {
@@ -4809,7 +4833,9 @@
     for (ScriptMapMap::const_iterator itr = sWaypointScripts.begin(); itr != sWaypointScripts.end(); ++itr)
         actionSet.insert(itr->first);
 
-    QueryResult result = WorldDatabase.PQuery("SELECT DISTINCT(`action`) FROM waypoint_data");
+    PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WOLRD_SEL_WAYPOINT_DATA_ACTION);
+    PreparedQueryResult result = WorldDatabase.Query(stmt);
+
     if (result)
     {
         do
@@ -4950,6 +4976,7 @@
 {
     uint32 oldMSTime = getMSTime();
 
+    //                                                 0      1       2
     QueryResult result = WorldDatabase.Query("SELECT entry, text, next_page FROM page_text");
 
     if (!result)
@@ -4964,10 +4991,10 @@
     {
         Field* fields = result->Fetch();
 
-        PageText& pageText =  _pageTextStore[fields[0].GetUInt32()];
+        PageText& pageText = _pageTextStore[fields[0].GetUInt32()];
 
         pageText.Text     = fields[1].GetString();
-        pageText.NextPage = fields[2].GetInt16();
+        pageText.NextPage = fields[2].GetUInt32();
 
         ++count;
     }
@@ -5028,6 +5055,7 @@
 {
     uint32 oldMSTime = getMSTime();
 
+    //                                                0     1       2        4
     QueryResult result = WorldDatabase.Query("SELECT map, parent, script, allowMount FROM instance_template");
 
     if (!result)
@@ -5079,6 +5107,7 @@
 {
     uint32 oldMSTime = getMSTime();
 
+    //                                                 0         1            2                3
     QueryResult result = WorldDatabase.Query("SELECT entry, creditType, creditEntry, lastEncounterDungeon FROM instance_encounters");
     if (!result)
     {
@@ -5095,7 +5124,7 @@
         uint32 entry = fields[0].GetUInt32();
         uint8 creditType = fields[1].GetUInt8();
         uint32 creditEntry = fields[2].GetUInt32();
-        uint32 lastEncounterDungeon = fields[3].GetUInt32();
+        uint32 lastEncounterDungeon = fields[3].GetUInt16();
         DungeonEncounterEntry const* dungeonEncounter = sDungeonEncounterStore.LookupEntry(entry);
         if (!dungeonEncounter)
         {
@@ -5201,13 +5230,13 @@
             gText.Options[i].Text_0           = fields[cic++].GetString();
             gText.Options[i].Text_1           = fields[cic++].GetString();
 
-            gText.Options[i].Language         = fields[cic++].GetUInt32();
+            gText.Options[i].Language         = fields[cic++].GetUInt8();
             gText.Options[i].Probability      = fields[cic++].GetFloat();
 
             for (uint8 j=0; j < MAX_GOSSIP_TEXT_EMOTES; ++j)
             {
-                gText.Options[i].Emotes[j]._Delay  = fields[cic++].GetUInt32();
-                gText.Options[i].Emotes[j]._Emote  = fields[cic++].GetUInt32();
+                gText.Options[i].Emotes[j]._Delay  = fields[cic++].GetUInt16();
+                gText.Options[i].Emotes[j]._Emote  = fields[cic++].GetUInt16();
             }
         }
     } while (result->NextRow());
@@ -5288,7 +5317,7 @@
 
     std::map<uint32 /*messageId*/, MailItemInfoVec> itemsCache;
     stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_EXPIRED_MAIL_ITEMS);
-    stmt->setUInt64(0, basetime);
+    stmt->setUInt32(0, (uint32)basetime);
     if (PreparedQueryResult items = CharacterDatabase.Query(stmt))
     {
         MailItemInfo item;
@@ -5308,15 +5337,15 @@
     {
         Field* fields = result->Fetch();
         Mail* m = new Mail;
-        m->messageID = fields[0].GetUInt32();
-        m->messageType = fields[1].GetUInt8();
-        m->sender = fields[2].GetUInt32();
-        m->receiver = fields[3].GetUInt32();
-        bool has_items = fields[4].GetBool();
-        m->expire_time = time_t(fields[5].GetUInt32());
-        m->deliver_time = 0;
-        m->COD = fields[6].GetUInt32();
-        m->checked = fields[7].GetUInt32();
+        m->messageID      = fields[0].GetUInt32();
+        m->messageType    = fields[1].GetUInt8();
+        m->sender         = fields[2].GetUInt32();
+        m->receiver       = fields[3].GetUInt32();
+        bool has_items    = fields[4].GetBool();
+        m->expire_time    = time_t(fields[5].GetUInt32());
+        m->deliver_time   = 0;
+        m->COD            = fields[6].GetUInt32();
+        m->checked        = fields[7].GetUInt8();
         m->mailTemplateId = fields[8].GetInt16();
 
         Player* player = NULL;
@@ -5353,8 +5382,8 @@
                 stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_MAIL_RETURNED);
                 stmt->setUInt32(0, m->receiver);
                 stmt->setUInt32(1, m->sender);
-                stmt->setUInt64(2, basetime + 30 * DAY);
-                stmt->setUInt64(3, basetime);
+                stmt->setUInt32(2, basetime + 30 * DAY);
+                stmt->setUInt32(3, basetime);
                 stmt->setUInt8 (4, uint8(MAIL_CHECK_MASK_RETURNED));
                 stmt->setUInt32(5, m->messageID);
                 CharacterDatabase.Execute(stmt);
@@ -5377,7 +5406,7 @@
             }
         }
 
-        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL);
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_BY_ID);
         stmt->setUInt32(0, m->messageID);
         CharacterDatabase.Execute(stmt);
         delete m;
@@ -5635,6 +5664,7 @@
 
     GraveYardStore.clear();                                  // need for reload case
 
+    //                                                0       1         2
     QueryResult result = WorldDatabase.Query("SELECT id, ghost_zone, faction FROM game_graveyard_zone");
 
     if (!result)
@@ -5654,7 +5684,7 @@
 
         uint32 safeLocId = fields[0].GetUInt32();
         uint32 zoneId = fields[1].GetUInt32();
-        uint32 team   = fields[2].GetUInt32();
+        uint32 team   = fields[2].GetUInt16();
 
         WorldSafeLocsEntry const* entry = sWorldSafeLocsStore.LookupEntry(safeLocId);
         if (!entry)
@@ -5949,7 +5979,7 @@
 
         AreaTrigger at;
 
-        at.target_mapId             = fields[1].GetUInt32();
+        at.target_mapId             = fields[1].GetUInt16();
         at.target_X                 = fields[2].GetFloat();
         at.target_Y                 = fields[3].GetFloat();
         at.target_Z                 = fields[4].GetFloat();
@@ -6423,7 +6453,7 @@
             got.questItems[i] = fields[10 + i].GetUInt32();
 
         for (uint8 i = 0; i < MAX_GAMEOBJECT_DATA; ++i)
-            got.raw.data[i] = fields[16 + i].GetUInt32();
+            got.raw.data[i] = fields[16 + i].GetInt32(); // data1 and data6 can be -1
 
         got.AIName = fields[40].GetString();
         got.ScriptId = GetScriptId(fields[41].GetCString());
@@ -6586,7 +6616,7 @@
     {
         Field* fields = result->Fetch();
         uint8 level  = fields[0].GetUInt8();
-        uint32 basexp = fields[1].GetUInt32();
+        uint32 basexp = fields[1].GetInt32();
         _baseXPTable[level] = basexp;
         ++count;
     }
@@ -6611,7 +6641,7 @@
 void ObjectMgr::LoadPetNames()
 {
     uint32 oldMSTime = getMSTime();
-
+    //                                                0     1      2
     QueryResult result = WorldDatabase.Query("SELECT word, entry, half FROM pet_name_generation");
 
     if (!result)
@@ -6725,7 +6755,7 @@
 
     _repRewardRateStore.clear();                             // for reload case
 
-    uint32 count = 0;
+    uint32 count = 0; //                                0          1            2             3
     QueryResult result = WorldDatabase.Query("SELECT faction, quest_rate, creature_rate, spell_rate FROM reputation_reward_rate");
 
     if (!result)
@@ -6811,13 +6841,13 @@
         uint32 creature_id = fields[0].GetUInt32();
 
         ReputationOnKillEntry repOnKill;
-        repOnKill.RepFaction1          = fields[1].GetUInt32();
-        repOnKill.RepFaction2          = fields[2].GetUInt32();
+        repOnKill.RepFaction1          = fields[1].GetInt16();
+        repOnKill.RepFaction2          = fields[2].GetInt16();
         repOnKill.IsTeamAward1        = fields[3].GetBool();
-        repOnKill.ReputationMaxCap1  = fields[4].GetUInt32();
+        repOnKill.ReputationMaxCap1  = fields[4].GetUInt8();
         repOnKill.RepValue1            = fields[5].GetInt32();
         repOnKill.IsTeamAward2        = fields[6].GetBool();
-        repOnKill.ReputationMaxCap2  = fields[7].GetUInt32();
+        repOnKill.ReputationMaxCap2  = fields[7].GetUInt8();
         repOnKill.RepValue2            = fields[8].GetInt32();
         repOnKill.TeamDependent       = fields[9].GetUInt8();
 
@@ -6862,7 +6892,7 @@
 
     _repSpilloverTemplateStore.clear();                      // for reload case
 
-    uint32 count = 0;
+    uint32 count = 0; //                                0         1        2       3        4       5       6         7        8      9        10       11     12
     QueryResult result = WorldDatabase.Query("SELECT faction, faction1, rate_1, rank_1, faction2, rate_2, rank_2, faction3, rate_3, rank_3, faction4, rate_4, rank_4 FROM reputation_spillover_template");
 
     if (!result)
@@ -6876,22 +6906,22 @@
     {
         Field* fields = result->Fetch();
 
-        uint32 factionId                = fields[0].GetUInt32();
+        uint32 factionId                = fields[0].GetUInt16();
 
         RepSpilloverTemplate repTemplate;
 
-        repTemplate.faction[0]          = fields[1].GetUInt32();
+        repTemplate.faction[0]          = fields[1].GetUInt16();
         repTemplate.faction_rate[0]     = fields[2].GetFloat();
-        repTemplate.faction_rank[0]     = fields[3].GetUInt32();
-        repTemplate.faction[1]          = fields[4].GetUInt32();
+        repTemplate.faction_rank[0]     = fields[3].GetUInt8();
+        repTemplate.faction[1]          = fields[4].GetUInt16();
         repTemplate.faction_rate[1]     = fields[5].GetFloat();
-        repTemplate.faction_rank[1]     = fields[6].GetUInt32();
-        repTemplate.faction[2]          = fields[7].GetUInt32();
+        repTemplate.faction_rank[1]     = fields[6].GetUInt8();
+        repTemplate.faction[2]          = fields[7].GetUInt16();
         repTemplate.faction_rate[2]     = fields[8].GetFloat();
-        repTemplate.faction_rank[2]     = fields[9].GetUInt32();
-        repTemplate.faction[3]          = fields[10].GetUInt32();
+        repTemplate.faction_rank[2]     = fields[9].GetUInt8();
+        repTemplate.faction[3]          = fields[10].GetUInt16();
         repTemplate.faction_rate[3]     = fields[11].GetFloat();
-        repTemplate.faction_rank[3]     = fields[12].GetUInt32();
+        repTemplate.faction_rank[3]     = fields[12].GetUInt8();
 
         FactionEntry const* factionEntry = sFactionStore.LookupEntry(factionId);
 
@@ -6976,7 +7006,7 @@
 
     uint32 count = 0;
 
-    //                                                0      1  2  3      4     5     6
+    //                                                  0   1  2   3      4     5       6
     QueryResult result = WorldDatabase.Query("SELECT entry, x, y, icon, flags, data, icon_name FROM points_of_interest");
 
     if (!result)
@@ -7033,8 +7063,8 @@
         return;
     }
 
-    //                                                0        1   2  3
-    QueryResult points = WorldDatabase.PQuery("SELECT questId, id, x, y FROM quest_poi_points ORDER BY questId DESC, idx");
+    //                                                0       1   2  3
+    QueryResult points = WorldDatabase.Query("SELECT questId, id, x, y FROM quest_poi_points ORDER BY questId DESC, idx");
 
     std::vector<std::vector<std::vector<QuestPOIPoint> > > POIs;
 
@@ -7124,7 +7154,7 @@
             continue;
         }
 
-        uint8 userType = fields[3].GetUInt8();
+        uint8 userType = fields[3].GetUInt16();
         if (userType >= SPELL_CLICK_USER_MAX)
             sLog->outErrorDb("Table npc_spellclick_spells references unknown user type %u. Skipping entry.", uint32(userType));
 
@@ -7173,7 +7203,7 @@
 
     PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_CREATURE_RESPAWN);
     stmt->setUInt32(0, loguid);
-    stmt->setUInt64(1, uint64(t));
+    stmt->setUInt32(1, uint32(t));
     stmt->setUInt32(2, instance);
     CharacterDatabase.Execute(stmt);
 }
@@ -7187,7 +7217,7 @@
         _creatureRespawnTimesMutex.release();
     }
 
-    PreparedStatement *stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CREATURE_RESPAWN);
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CREATURE_RESPAWN);
     stmt->setUInt32(0, loguid);
     stmt->setUInt32(1, instance);
     CharacterDatabase.Execute(stmt);
@@ -7778,7 +7808,7 @@
     {
         Field* fields = result->Fetch();
         uint32 entry  = fields[0].GetUInt32();
-        int32 skill   = fields[1].GetInt32();
+        int32 skill   = fields[1].GetInt16();
 
         AreaTableEntry const* fArea = GetAreaEntryByAreaID(entry);
         if (!fArea)
@@ -7871,6 +7901,7 @@
 
     _gameTeleStore.clear();                                  // for reload case
 
+    //                                                0       1           2           3           4        5     6
     QueryResult result = WorldDatabase.Query("SELECT id, position_x, position_y, position_z, orientation, map, name FROM game_tele");
 
     if (!result)
@@ -7894,7 +7925,7 @@
         gt.position_y     = fields[2].GetFloat();
         gt.position_z     = fields[3].GetFloat();
         gt.orientation    = fields[4].GetFloat();
-        gt.mapId          = fields[5].GetUInt32();
+        gt.mapId          = fields[5].GetUInt16();
         gt.name           = fields[6].GetString();
 
         if (!MapManager::IsValidMapCoord(gt.mapId, gt.position_x, gt.position_y, gt.position_z, gt.orientation))
@@ -8011,6 +8042,7 @@
 
     _mailLevelRewardStore.clear();                           // for reload case
 
+    //                                                 0        1             2            3
     QueryResult result = WorldDatabase.Query("SELECT level, raceMask, mailTemplateId, senderEntry FROM mail_level_reward");
 
     if (!result)
@@ -8172,9 +8204,9 @@
         uint32 entry         = fields[0].GetUInt32();
         uint32 spell         = fields[1].GetUInt32();
         uint32 spellCost     = fields[2].GetUInt32();
-        uint32 reqSkill      = fields[3].GetUInt32();
-        uint32 reqSkillValue = fields[4].GetUInt32();
-        uint32 reqLevel      = fields[5].GetUInt32();
+        uint32 reqSkill      = fields[3].GetUInt16();
+        uint32 reqSkillValue = fields[4].GetUInt16();
+        uint32 reqLevel      = fields[5].GetUInt8();
 
         AddSpellToTrainer(entry, spell, spellCost, reqSkill, reqSkillValue, reqLevel);
 
@@ -8189,7 +8221,10 @@
 int ObjectMgr::LoadReferenceVendor(int32 vendor, int32 item, std::set<uint32> *skip_vendors)
 {
     // find all items from the reference vendor
-    QueryResult result = WorldDatabase.PQuery("SELECT item, maxcount, incrtime, ExtendedCost FROM npc_vendor WHERE entry='%d' ORDER BY slot ASC", item);
+    PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_NPC_VENDOR_REF);
+    stmt->setUInt32(0, uint32(item));
+    PreparedQueryResult result = WorldDatabase.Query(stmt);
+
     if (!result)
         return 0;
 
@@ -8205,7 +8240,7 @@
             count += LoadReferenceVendor(vendor, -item_id, skip_vendors);
         else
         {
-            int32  maxcount     = fields[1].GetInt32();
+            int32  maxcount     = fields[1].GetUInt8();
             uint32 incrtime     = fields[2].GetUInt32();
             uint32 ExtendedCost = fields[3].GetUInt32();
 
@@ -8255,7 +8290,7 @@
             count += LoadReferenceVendor(entry, -item_id, &skip_vendors);
         else
         {
-            int32  maxcount     = fields[2].GetInt32();
+            uint32 maxcount     = fields[2].GetUInt8();
             uint32 incrtime     = fields[3].GetUInt32();
             uint32 ExtendedCost = fields[4].GetUInt32();
 
@@ -8297,7 +8332,7 @@
 
         GossipMenus gMenu;
 
-        gMenu.entry             = fields[0].GetUInt32();
+        gMenu.entry             = fields[0].GetUInt16();
         gMenu.text_id           = fields[1].GetUInt32();
 
         if (!GetGossipText(gMenu.text_id))
@@ -8323,7 +8358,9 @@
     _gossipMenuItemsStore.clear();
 
     QueryResult result = WorldDatabase.Query(
+        //          0              1            2           3              4
         "SELECT menu_id, id, option_icon, option_text, option_id, npc_option_npcflag, "
+        //       5              6           7          8         9
         "action_menu_id, action_poi_id, box_coded, box_money, box_text "
         "FROM gossip_menu_option ORDER BY menu_id, id");
 
@@ -8342,11 +8379,11 @@
 
         GossipMenuItems gMenuItem;
 
-        gMenuItem.MenuId                = fields[0].GetUInt32();
-        gMenuItem.OptionIndex           = fields[1].GetUInt32();
-        gMenuItem.OptionIcon            = fields[2].GetUInt8();
+        gMenuItem.MenuId                = fields[0].GetUInt16();
+        gMenuItem.OptionIndex           = fields[1].GetUInt16();
+        gMenuItem.OptionIcon            = fields[2].GetUInt32();
         gMenuItem.OptionText            = fields[3].GetString();
-        gMenuItem.OptionType            = fields[4].GetUInt32();
+        gMenuItem.OptionType            = fields[4].GetUInt8();
         gMenuItem.OptionNpcflag         = fields[5].GetUInt32();
         gMenuItem.ActionMenuId          = fields[6].GetUInt32();
         gMenuItem.ActionPoiId           = fields[7].GetUInt32();
@@ -8561,10 +8598,13 @@
 {
     // use binary search to find the script name in the sorted vector
     // assume "" is the first element
-    if (!name) return 0;
-    ScriptNameContainer::const_iterator itr =
-        std::lower_bound(_scriptNamesStore.begin(), _scriptNamesStore.end(), name);
-    if (itr == _scriptNamesStore.end() || *itr != name) return 0;
+    if (!name)
+        return 0;
+
+    ScriptNameContainer::const_iterator itr = std::lower_bound(_scriptNamesStore.begin(), _scriptNamesStore.end(), name);
+    if (itr == _scriptNamesStore.end() || *itr != name)
+        return 0;
+
     return uint32(itr - _scriptNamesStore.begin());
 }
 
@@ -8573,6 +8613,7 @@
     ScriptMapMap* scripts = GetScriptsMapByType(type);
     if (!scripts)
         return;
+
     for (ScriptMapMap::const_iterator itrMM = scripts->begin(); itrMM != scripts->end(); ++itrMM)
     {
         for (ScriptMap::const_iterator itrM = itrMM->second.begin(); itrM != itrMM->second.end(); ++itrM)
@@ -8663,16 +8704,16 @@
     {
         Field* fields = result->Fetch();
 
-        uint8 Level = fields[0].GetUInt8();
-        uint8 Class = fields[1].GetUInt8();
+        uint8 Level = fields[0].GetInt8();
+        uint8 Class = fields[1].GetInt8();
 
         CreatureBaseStats stats;
 
         for (uint8 i = 0; i < MAX_CREATURE_BASE_HP; ++i)
-            stats.BaseHealth[i] = fields[i + 2].GetUInt32();
-
-        stats.BaseMana = fields[5].GetUInt32();
-        stats.BaseArmor = fields[6].GetUInt32();
+            stats.BaseHealth[i] = fields[i + 2].GetInt16();
+
+        stats.BaseMana = fields[5].GetInt16();
+        stats.BaseArmor = fields[6].GetInt16();
 
         if (!Class || ((1 << (Class - 1)) & CLASSMASK_ALL_CREATURES) == 0)
             sLog->outErrorDb("Creature base stats for level %u has invalid class %u", Level, Class);
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Globals/ObjectMgr.h
--- a/src/server/game/Globals/ObjectMgr.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Globals/ObjectMgr.h	Mon Apr 16 14:29:17 2012 +0300
@@ -1025,15 +1025,6 @@
             return &itr->second;
         }
 
-        bool IsGoOfSpecificEntrySpawned(uint32 entry) const
-        {
-            for (GameObjectDataContainer::const_iterator it = _gameObjectDataStore.begin(); it != _gameObjectDataStore.end(); ++it)
-                if (it->second.id == entry)
-                    return true;
-
-            return false;
-        }
-
         GameObjectData const* GetGOData(uint32 guid) const
         {
             GameObjectDataContainer::const_iterator itr = _gameObjectDataStore.find(guid);
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Grids/Cells/CellImpl.h
--- a/src/server/game/Grids/Cells/CellImpl.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Grids/Cells/CellImpl.h	Mon Apr 16 14:29:17 2012 +0300
@@ -91,7 +91,7 @@
     //if radius is known to reach cell area more than 4x4 then we should call optimized VisitCircle
     //currently this technique works with MAX_NUMBER_OF_CELLS 16 and higher, with lower values
     //there are nothing to optimize because SIZE_OF_GRID_CELL is too big...
-    if (((area.high_bound.x_coord - area.low_bound.x_coord) > 4) && ((area.high_bound.y_coord - area.low_bound.y_coord) > 4))
+    if ((area.high_bound.x_coord > (area.low_bound.x_coord + 4)) && (area.high_bound.y_coord > (area.low_bound.y_coord + 4)))
     {
         VisitCircle(visitor, map, area.low_bound, area.high_bound);
         return;
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Grids/GridDefines.h
--- a/src/server/game/Grids/GridDefines.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Grids/GridDefines.h	Mon Apr 16 14:29:17 2012 +0300
@@ -215,7 +215,7 @@
 
     inline bool IsValidMapCoord(float c)
     {
-        return finite(c) && (std::fabs(c) <= MAP_HALFSIZE - CENTER_GRID_OFFSET - 0.5f);
+        return finite(c) && (std::fabs(c) <= MAP_HALFSIZE - 0.5f);
     }
 
     inline bool IsValidMapCoord(float x, float y)
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Grids/GridStates.h
--- a/src/server/game/Grids/GridStates.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Grids/GridStates.h	Mon Apr 16 14:29:17 2012 +0300
@@ -40,6 +40,7 @@
         void setMagic() { i_Magic = MAGIC_TESTVAL; }
         unsigned int i_Magic;
 #endif
+        virtual ~GridState() {};
         virtual void Update(Map &, NGridType&, GridInfo &, const uint32 t_diff) const = 0;
 };
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Grids/Notifiers/GridNotifiers.h
--- a/src/server/game/Grids/Notifiers/GridNotifiers.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Grids/Notifiers/GridNotifiers.h	Mon Apr 16 14:29:17 2012 +0300
@@ -797,7 +797,7 @@
                 if (u->GetTypeId() == TYPEID_UNIT && ((Creature*)u)->isTotem())
                     return false;
 
-                if(!u->isTargetableForAttack(false))
+                if (!u->isTargetableForAttack(false))
                     return false;
 
                 return i_obj->IsWithinDistInMap(u, i_range) && !i_funit->IsFriendlyTo(u);
@@ -927,13 +927,15 @@
     {
         public:
             AnyAoETargetUnitInObjectRangeCheck(WorldObject const* obj, Unit const* funit, float range)
-                : i_obj(obj), i_funit(funit), i_range(range)
+                : i_obj(obj), i_funit(funit), _spellInfo(NULL), i_range(range)
             {
                 Unit const* check = i_funit;
                 Unit const* owner = i_funit->GetOwner();
                 if (owner)
                     check = owner;
                 i_targetForPlayer = (check->GetTypeId() == TYPEID_PLAYER);
+                if (i_obj->GetTypeId() == TYPEID_DYNAMICOBJECT)
+                    _spellInfo = sSpellMgr->GetSpellInfo(((DynamicObject*)i_obj)->GetSpellId());
             }
             bool operator()(Unit* u)
             {
@@ -941,7 +943,7 @@
                 if (u->GetTypeId() == TYPEID_UNIT && ((Creature*)u)->isTotem())
                     return false;
 
-                if (i_funit->IsValidAttackTarget(u) && i_obj->IsWithinDistInMap(u, i_range))
+                if (i_funit->_IsValidAttackTarget(u, _spellInfo) && i_obj->IsWithinDistInMap(u, i_range))
                     return true;
 
                 return false;
@@ -950,6 +952,7 @@
             bool i_targetForPlayer;
             WorldObject const* i_obj;
             Unit const* i_funit;
+            SpellInfo const* _spellInfo;
             float i_range;
     };
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Groups/Group.cpp
--- a/src/server/game/Groups/Group.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Groups/Group.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -171,7 +171,7 @@
 
     m_lootMethod = LootMethod(fields[1].GetUInt8());
     m_looterGuid = MAKE_NEW_GUID(fields[2].GetUInt32(), 0, HIGHGUID_PLAYER);
-    m_lootThreshold = ItemQualities(fields[3].GetUInt16());
+    m_lootThreshold = ItemQualities(fields[3].GetUInt8());
 
     for (uint8 i = 0; i < TARGETICONCOUNT; ++i)
         m_targetIcons[i] = fields[4+i].GetUInt32();
@@ -698,13 +698,21 @@
     if (!isBGGroup())
     {
         SQLTransaction trans = CharacterDatabase.BeginTransaction();
-        trans->PAppend("DELETE FROM groups WHERE guid = %u", m_dbStoreId);
-        trans->PAppend("DELETE FROM group_member WHERE guid = %u", m_dbStoreId);
+
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GROUP);
+        stmt->setUInt32(0, m_dbStoreId);
+        trans->Append(stmt);
+
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GROUP_MEMBER_ALL);
+        stmt->setUInt32(0, m_dbStoreId);
+        trans->Append(stmt);
+
         CharacterDatabase.CommitTransaction(trans);
+
         ResetInstances(INSTANCE_RESET_GROUP_DISBAND, false, NULL);
         ResetInstances(INSTANCE_RESET_GROUP_DISBAND, true, NULL);
 
-        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_LFG_DATA);
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_LFG_DATA);
         stmt->setUInt32(0, m_dbStoreId);
         CharacterDatabase.Execute(stmt);
 
@@ -748,7 +756,7 @@
     if (!p || !p->GetSession())
         return;
 
-    WorldPacket data(SMSG_LOOT_START_ROLL, (8 + 4 + 4 + 4 + 4 + 4 + 4 + 1 ));
+    WorldPacket data(SMSG_LOOT_START_ROLL, (8 + 4 + 4 + 4 + 4 + 4 + 4 + 1));
     data << uint64(r.itemGUID);                             // guid of rolled item
     data << uint32(mapId);                                  // 3.3.3 mapid
     data << uint32(r.totalPlayersRolling);                  // maybe the number of players rolling for it???
@@ -812,28 +820,28 @@
     }
 }
 
-void Group::SendLootAllPassed(uint32 NumberOfPlayers, const Roll &r)
+void Group::SendLootAllPassed(uint32 numberOfPlayers, Roll const& roll)
 {
     WorldPacket data(SMSG_LOOT_ALL_PASSED, (8+4+4+4+4));
-    data << uint64(r.itemGUID);                             // Guid of the item rolled
-    data << uint32(NumberOfPlayers);                        // The number of players rolling for it???
-    data << uint32(r.itemid);                               // The itemEntryId for the item that shall be rolled for
-    data << uint32(r.itemRandomPropId);                     // Item random property ID
-    data << uint32(r.itemRandomSuffix);                     // Item random suffix ID
+    data << uint64(roll.itemGUID);                             // Guid of the item rolled
+    data << uint32(numberOfPlayers);                           // The number of players rolling for it
+    data << uint32(roll.itemid);                               // The itemEntryId for the item that shall be rolled for
+    data << uint32(roll.itemRandomPropId);                     // Item random property ID
+    data << uint32(roll.itemRandomSuffix);                     // Item random suffix ID
 
-    for (Roll::PlayerVote::const_iterator itr=r.playerVote.begin(); itr != r.playerVote.end(); ++itr)
+    for (Roll::PlayerVote::const_iterator itr = roll.playerVote.begin(); itr != roll.playerVote.end(); ++itr)
     {
-        Player* p = ObjectAccessor::FindPlayer(itr->first);
-        if (!p || !p->GetSession())
+        Player* player = ObjectAccessor::FindPlayer(itr->first);
+        if (!player || !player->GetSession())
             continue;
 
         if (itr->second != NOT_VALID)
-            p->GetSession()->SendPacket(&data);
+            player->GetSession()->SendPacket(&data);
     }
 }
 
 // notify group members which player is the allowed looter for the given creature
-void Group::SendLooter(Creature* creature, Player* pLooter)
+void Group::SendLooter(Creature* creature, Player* groupLooter)
 {
     ASSERT(creature);
 
@@ -841,8 +849,8 @@
     data << uint64(creature->GetGUID());
     data << uint8(0); // unk1
 
-    if (pLooter)
-        data.append(pLooter->GetPackGUID());
+    if (groupLooter)
+        data.append(groupLooter->GetPackGUID());
     else
         data << uint8(0);
 
@@ -2128,7 +2136,7 @@
     PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_GROUP_MEMBER_FLAG);
 
     stmt->setUInt8(0, slot->flags);
-    stmt->setUInt32(0, GUID_LOPART(guid));
+    stmt->setUInt32(1, GUID_LOPART(guid));
 
     CharacterDatabase.Execute(stmt);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Groups/GroupMgr.cpp
--- a/src/server/game/Groups/GroupMgr.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Groups/GroupMgr.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -120,7 +120,7 @@
         CharacterDatabase.DirectExecute("DELETE FROM groups WHERE guid NOT IN (SELECT guid FROM group_member GROUP BY guid HAVING COUNT(guid) > 1)");
 
         //                                                        0              1           2             3                 4      5          6      7         8       9
-        QueryResult result = CharacterDatabase.PQuery("SELECT g.leaderGuid, g.lootMethod, g.looterGuid, g.lootThreshold, g.icon1, g.icon2, g.icon3, g.icon4, g.icon5, g.icon6"
+        QueryResult result = CharacterDatabase.Query("SELECT g.leaderGuid, g.lootMethod, g.looterGuid, g.lootThreshold, g.icon1, g.icon2, g.icon3, g.icon4, g.icon5, g.icon6"
             //  10         11          12         13              14            15         16           17
             ", g.icon7, g.icon8, g.groupType, g.difficulty, g.raiddifficulty, g.guid, lfg.dungeon, lfg.state FROM groups g LEFT JOIN lfg_data lfg ON lfg.guid = g.guid ORDER BY g.guid ASC");
         if (!result)
@@ -215,10 +215,10 @@
             Group* group = GetGroupByDbStoreId(fields[0].GetUInt32());
             // group will never be NULL (we have run consistency sql's before loading)
 
-            MapEntry const* mapEntry = sMapStore.LookupEntry(fields[1].GetUInt32());
+            MapEntry const* mapEntry = sMapStore.LookupEntry(fields[1].GetUInt16());
             if (!mapEntry || !mapEntry->IsDungeon())
             {
-                sLog->outErrorDb("Incorrect entry in group_instance table : no dungeon map %d", fields[1].GetUInt32());
+                sLog->outErrorDb("Incorrect entry in group_instance table : no dungeon map %d", fields[1].GetUInt16());
                 continue;
             }
 
@@ -229,7 +229,7 @@
                 diff = 0;                                   // default for both difficaly types
             }
 
-            InstanceSave* save = sInstanceSaveMgr->AddInstanceSave(mapEntry->MapID, fields[2].GetUInt32(), Difficulty(diff), time_t(fields[5].GetUInt64()), fields[6].GetBool(), true);
+            InstanceSave* save = sInstanceSaveMgr->AddInstanceSave(mapEntry->MapID, fields[2].GetUInt32(), Difficulty(diff), time_t(fields[5].GetUInt32()), (bool)fields[6].GetUInt64(), true);
             group->BindToInstance(save, fields[3].GetBool(), true);
             ++count;
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Guilds/Guild.cpp
--- a/src/server/game/Guilds/Guild.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Guilds/Guild.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -588,11 +588,11 @@
     }
 
     SetStats(fields[19].GetString(),
-             fields[20].GetUInt8(),
-             fields[21].GetUInt8(),
-             fields[22].GetUInt32(),
-             fields[23].GetUInt32());
-    m_logoutTime    = fields[24].GetUInt32();
+             fields[20].GetUInt8(),                         // characters.level
+             fields[21].GetUInt8(),                         // characters.class
+             fields[22].GetUInt16(),                        // characters.zone
+             fields[23].GetUInt32());                       // characters.account
+    m_logoutTime    = fields[24].GetUInt32();               // characters.logout_time
 
     if (!CheckStats())
         return false;
@@ -1230,7 +1230,7 @@
     data << uint32(m_id);
     data << m_name;
 
-    for (uint8 i = 0 ; i < GUILD_RANKS_MAX_COUNT; ++i)              // Alwayse show 10 ranks
+    for (uint8 i = 0; i < GUILD_RANKS_MAX_COUNT; ++i)              // Alwayse show 10 ranks
     {
         if (i < _GetRanksSize())
             data << m_ranks[i].GetName();
@@ -1838,7 +1838,7 @@
     m_createdDate   = time_t(fields[10].GetUInt32());
     m_bankMoney     = fields[11].GetUInt64();
 
-    uint8 purchasedTabs = uint8(fields[12].GetUInt32());
+    uint8 purchasedTabs = uint8(fields[12].GetUInt64());
     if (purchasedTabs > GUILD_BANK_MAX_TABS)
         purchasedTabs = GUILD_BANK_MAX_TABS;
 
@@ -1940,7 +1940,7 @@
 
 bool Guild::LoadBankTabFromDB(Field* fields)
 {
-    uint32 tabId = fields[1].GetUInt8();
+    uint8 tabId = fields[1].GetUInt8();
     if (tabId >= _GetPurchasedTabsSize())
     {
         sLog->outError("Invalid tab (tabId: %u) in guild bank, skipped.", tabId);
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Handlers/AuctionHouseHandler.cpp
--- a/src/server/game/Handlers/AuctionHouseHandler.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Handlers/AuctionHouseHandler.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -439,7 +439,11 @@
         auction->bid = price;
         GetPlayer()->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_AUCTION_BID, price);
 
-        trans->PAppend("UPDATE auctionhouse SET buyguid = '%u', lastbid = '%u' WHERE id = '%u'", auction->bidder, auction->bid, auction->Id);
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_AUCTION_BID);
+        stmt->setUInt32(0, auction->bidder);
+        stmt->setUInt32(1, auction->bid);
+        stmt->setUInt32(2, auction->Id);
+        trans->Append(stmt);
 
         SendAuctionCommandResult(auction->Id, AUCTION_PLACE_BID, AUCTION_OK, 0);
     }
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Handlers/CharacterHandler.cpp
--- a/src/server/game/Handlers/CharacterHandler.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Handlers/CharacterHandler.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -465,7 +465,7 @@
             if (result)
             {
                 Field* fields = result->Fetch();
-                createInfo->CharCount = fields[0].GetUInt8();
+                createInfo->CharCount = uint8(fields[0].GetUInt64()); // SQL's COUNT() returns uint64 but it will always be less than uint8.Max
 
                 if (createInfo->CharCount >= sWorld->getIntConfig(CONFIG_CHARACTERS_PER_REALM))
                 {
@@ -644,7 +644,7 @@
 
             SQLTransaction trans = LoginDatabase.BeginTransaction();
 
-            PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_DEL_REALM_CHARACTERS);
+            PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_DEL_REALM_CHARACTERS_BY_REALM);
             stmt->setUInt32(0, GetAccountId());
             stmt->setUInt32(1, realmID);
             trans->Append(stmt);
@@ -657,8 +657,6 @@
 
             LoginDatabase.CommitTransaction(trans);
 
-            newChar.CleanupsBeforeDelete();
-
             WorldPacket data(SMSG_CHAR_CREATE, 1);
             data << uint8(CHAR_CREATE_SUCCESS);
             SendPacket(&data);
@@ -669,6 +667,7 @@
             sScriptMgr->OnPlayerCreate(&newChar);
             sWorld->AddCharacterNameData(newChar.GetGUIDLow(), std::string(newChar.GetName()), newChar.getGender(), newChar.getRace(), newChar.getClass());
 
+            newChar.CleanupsBeforeDelete();
             delete createInfo;
             _charCreateCallback.Reset();
         }
@@ -706,12 +705,17 @@
         return;
     }
 
-    QueryResult result = CharacterDatabase.PQuery("SELECT account, name FROM characters WHERE guid='%u'", GUID_LOPART(guid));
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_ACCOUNT_NAME_BY_GUID);
+
+    stmt->setUInt32(0, GUID_LOPART(guid));
+
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
     if (result)
     {
         Field* fields = result->Fetch();
-        accountId = fields[0].GetUInt32();
-        name = fields[1].GetString();
+        accountId     = fields[0].GetUInt32();
+        name          = fields[1].GetString();
     }
 
     // prevent deleting other players' characters using cheating tools
@@ -1137,8 +1141,10 @@
     uint8 res = ObjectMgr::CheckPlayerName(newName, true);
     if (res != CHAR_NAME_SUCCESS)
     {
-        WorldPacket data(SMSG_CHAR_RENAME, 1);
+        WorldPacket data(SMSG_CHAR_RENAME, 1+8+(newName.size()+1));
         data << uint8(res);
+        data << uint64(guid);
+        data << newName;
         SendPacket(&data);
         return;
     }
@@ -1287,9 +1293,19 @@
         CharacterDatabase.EscapeString(declinedname.name[i]);
 
     SQLTransaction trans = CharacterDatabase.BeginTransaction();
-    trans->PAppend("DELETE FROM character_declinedname WHERE guid = '%u'", GUID_LOPART(guid));
-    trans->PAppend("INSERT INTO character_declinedname (guid, genitive, dative, accusative, instrumental, prepositional) VALUES ('%u', '%s', '%s', '%s', '%s', '%s')",
-        GUID_LOPART(guid), declinedname.name[0].c_str(), declinedname.name[1].c_str(), declinedname.name[2].c_str(), declinedname.name[3].c_str(), declinedname.name[4].c_str());
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_DECLINED_NAME);
+    stmt->setUInt32(0, GUID_LOPART(guid));
+    trans->Append(stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_DECLINED_NAME);
+    stmt->setUInt32(0, GUID_LOPART(guid));
+
+    for (uint8 i = 0; i < 5; i++)
+        stmt->setString(i+1, declinedname.name[i]);
+
+    trans->Append(stmt);
+
     CharacterDatabase.CommitTransaction(trans);
 
     WorldPacket data(SMSG_SET_PLAYER_DECLINED_NAMES_RESULT, 4+8);
@@ -1386,7 +1402,12 @@
     uint8 gender, skin, face, hairStyle, hairColor, facialHair;
     recv_data >> gender >> skin >> hairColor >> hairStyle >> facialHair >> face;
 
-    QueryResult result = CharacterDatabase.PQuery("SELECT at_login FROM characters WHERE guid ='%u'", GUID_LOPART(guid));
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_AT_LOGIN);
+
+    stmt->setUInt32(0, GUID_LOPART(guid));
+
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
     if (!result)
     {
         WorldPacket data(SMSG_CHAR_CUSTOMIZE, 1);
@@ -1445,14 +1466,16 @@
         }
     }
 
-    if (QueryResult oldNameResult = CharacterDatabase.PQuery("SELECT name FROM characters WHERE guid ='%u'", GUID_LOPART(guid)))
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_NAME);
+    stmt->setUInt32(0, GUID_LOPART(guid));
+    result = CharacterDatabase.Query(stmt);
     {
-        std::string oldname = oldNameResult->Fetch()[0].GetString();
-        std::string IP_str = GetRemoteAddress();
-        sLog->outChar("Account: %d (IP: %s), Character[%s] (guid:%u) Customized to: %s", GetAccountId(), IP_str.c_str(), oldname.c_str(), GUID_LOPART(guid), newName.c_str());
+        std::string oldname = result->Fetch()[0].GetString();
+        sLog->outChar("Account: %d (IP: %s), Character[%s] (guid:%u) Customized to: %s", GetAccountId(), GetRemoteAddress().c_str(), oldname.c_str(), GUID_LOPART(guid), newName.c_str());
     }
+
     Player::Customize(guid, gender, skin, face, hairStyle, hairColor, facialHair);
-    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_NAME_AT_LOGIN);
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_NAME_AT_LOGIN);
 
     stmt->setString(0, newName);
     stmt->setUInt16(1, uint16(AT_LOGIN_CUSTOMIZE));
@@ -1597,7 +1620,13 @@
     recv_data >> gender >> skin >> hairColor >> hairStyle >> facialHair >> face >> race;
 
     uint32 lowGuid = GUID_LOPART(guid);
-    QueryResult result = CharacterDatabase.PQuery("SELECT class, level, at_login FROM characters WHERE guid ='%u'", lowGuid);
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_CLASS_LVL_AT_LOGIN);
+
+    stmt->setUInt32(0, lowGuid);
+
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
     if (!result)
     {
         WorldPacket data(SMSG_CHAR_FACTION_CHANGE, 1);
@@ -1607,8 +1636,8 @@
     }
 
     Field* fields = result->Fetch();
-    uint32 playerClass = fields[0].GetUInt32();
-    uint32 level = fields[1].GetUInt32();
+    uint32 playerClass = uint32(fields[0].GetUInt8());
+    uint32 level = uint32(fields[1].GetUInt8());
     uint32 at_loginFlags = fields[2].GetUInt16();
     uint32 used_loginFlag = ((recv_data.GetOpcode() == CMSG_CHAR_RACE_CHANGE) ? AT_LOGIN_CHANGE_RACE : AT_LOGIN_CHANGE_FACTION);
 
@@ -1663,7 +1692,7 @@
     {
         WorldPacket data(SMSG_CHAR_FACTION_CHANGE, 1);
         data << uint8(CHAR_NAME_RESERVED);
-        SendPacket (&data);
+        SendPacket(&data);
         return;
     }
 
@@ -1682,8 +1711,18 @@
     CharacterDatabase.EscapeString(newname);
     Player::Customize(guid, gender, skin, face, hairStyle, hairColor, facialHair);
     SQLTransaction trans = CharacterDatabase.BeginTransaction();
-    trans->PAppend("UPDATE `characters` SET name='%s', race='%u', at_login=at_login & ~ %u WHERE guid='%u'", newname.c_str(), race, used_loginFlag, lowGuid);
-    trans->PAppend("DELETE FROM character_declinedname WHERE guid ='%u'", lowGuid);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_FACTION_OR_RACE);
+    stmt->setString(0, newname);
+    stmt->setUInt8(1, race);
+    stmt->setUInt16(2, used_loginFlag);
+    stmt->setUInt32(3, lowGuid);
+    trans->Append(stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_DECLINED_NAME);
+    stmt->setUInt32(0, lowGuid);
+    trans->Append(stmt);
+
     sWorld->UpdateCharacterNameData(GUID_LOPART(guid), newname, gender, race);
 
     BattlegroundTeamId team = BG_TEAM_ALLIANCE;
@@ -1704,52 +1743,65 @@
 
     // Switch Languages
     // delete all languages first
-    trans->PAppend("DELETE FROM `character_skills` WHERE `skill` IN (98, 113, 759, 111, 313, 109, 115, 315, 673, 137) AND `guid`='%u'", lowGuid);
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SKILL_LANGUAGES);
+    stmt->setUInt32(0, lowGuid);
+    trans->Append(stmt);
 
-    // now add them back
-    if (team == BG_TEAM_ALLIANCE)
+    // Now add them back
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_SKILL_LANGUAGE);
+    stmt->setUInt32(0, lowGuid);
+
+    // Faction specific languages
+    if (team == BG_TEAM_HORDE)
+        stmt->setUInt16(1, 109);
+    else
+        stmt->setUInt16(1, 98);
+
+    trans->Append(stmt);
+
+    // Race specific languages
+    if (race != RACE_ORC && race != RACE_HUMAN)
     {
-        trans->PAppend("INSERT INTO `character_skills` (guid, skill, value, max) VALUES (%u, 98, 300, 300)", lowGuid);
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_SKILL_LANGUAGE);
+        stmt->setUInt32(0, lowGuid);
+
         switch (race)
         {
-        case RACE_DWARF:
-            trans->PAppend("INSERT INTO `character_skills` (guid, skill, value, max) VALUES (%u, 111, 300, 300)", lowGuid);
-            break;
-        case RACE_DRAENEI:
-            trans->PAppend("INSERT INTO `character_skills` (guid, skill, value, max) VALUES (%u, 759, 300, 300)", lowGuid);
-            break;
-        case RACE_GNOME:
-            trans->PAppend("INSERT INTO `character_skills` (guid, skill, value, max) VALUES (%u, 313, 300, 300)", lowGuid);
-            break;
-        case RACE_NIGHTELF:
-            trans->PAppend("INSERT INTO `character_skills` (guid, skill, value, max) VALUES (%u, 113, 300, 300)", lowGuid);
-            break;
+            case RACE_DWARF:
+                stmt->setUInt16(1, 111);
+                break;
+            case RACE_DRAENEI:
+                stmt->setUInt16(1, 759);
+                break;
+            case RACE_GNOME:
+                stmt->setUInt16(1, 313);
+                break;
+            case RACE_NIGHTELF:
+                stmt->setUInt16(1, 113);
+                break;
+            case RACE_UNDEAD_PLAYER:
+                stmt->setUInt16(1, 673);
+                break;
+            case RACE_TAUREN:
+                stmt->setUInt16(1, 115);
+                break;
+            case RACE_TROLL:
+                stmt->setUInt16(1, 315);
+                break;
+            case RACE_BLOODELF:
+                stmt->setUInt16(1, 137);
+                break;
         }
-    }
-    else if (team == BG_TEAM_HORDE)
-    {
-        trans->PAppend("INSERT INTO `character_skills` (guid, skill, value, max) VALUES (%u, 109, 300, 300)", lowGuid);
-        switch (race)
-        {
-        case RACE_UNDEAD_PLAYER:
-            trans->PAppend("INSERT INTO `character_skills` (guid, skill, value, max) VALUES (%u, 673, 300, 300)", lowGuid);
-            break;
-        case RACE_TAUREN:
-            trans->PAppend("INSERT INTO `character_skills` (guid, skill, value, max) VALUES (%u, 115, 300, 300)", lowGuid);
-            break;
-        case RACE_TROLL:
-            trans->PAppend("INSERT INTO `character_skills` (guid, skill, value, max) VALUES (%u, 315, 300, 300)", lowGuid);
-            break;
-        case RACE_BLOODELF:
-            trans->PAppend("INSERT INTO `character_skills` (guid, skill, value, max) VALUES (%u, 137, 300, 300)", lowGuid);
-            break;
-        }
+
+        trans->Append(stmt);
     }
 
     if (recv_data.GetOpcode() == CMSG_CHAR_FACTION_CHANGE)
     {
         // Delete all Flypaths
-        trans->PAppend("UPDATE `characters` SET taxi_path = '' WHERE guid ='%u'", lowGuid);
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_TAXI_PATH);
+        stmt->setUInt32(0, lowGuid);
+        trans->Append(stmt);
 
         if (level > 7)
         {
@@ -1791,11 +1843,17 @@
                 taximaskstream << "0 ";
             taximaskstream << '0';
             std::string taximask = taximaskstream.str();
-            trans->PAppend("UPDATE `characters` SET `taximask`= '%s' WHERE `guid` = '%u'", taximask.c_str(), lowGuid);
+
+            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_TAXIMASK);
+            stmt->setString(0, taximask);
+            stmt->setUInt32(1, lowGuid);
+            trans->Append(stmt);
         }
 
         // Delete all current quests
-        trans->PAppend("DELETE FROM `character_queststatus` WHERE guid ='%u'", GUID_LOPART(guid));
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS);
+        stmt->setUInt32(0, GUID_LOPART(guid));
+        trans->Append(stmt);
 
         // Delete record of the faction old completed quests
         {
@@ -1833,23 +1891,33 @@
         if (!sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_GUILD))
         {
             // Reset guild
-            if (QueryResult result2 = CharacterDatabase.PQuery("SELECT guildid FROM `guild_member` WHERE guid ='%u'", lowGuid))
-                if (Guild* guild = sGuildMgr->GetGuildById((result2->Fetch()[0]).GetUInt32()))
+            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GUILD_MEMBER);
+
+            stmt->setUInt32(0, lowGuid);
+
+            PreparedQueryResult result = CharacterDatabase.Query(stmt);
+            if (result)
+                if (Guild* guild = sGuildMgr->GetGuildById((result->Fetch()[0]).GetUInt32()))
                     guild->DeleteMember(MAKE_NEW_GUID(lowGuid, 0, HIGHGUID_PLAYER));
         }
 
         if (!sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_ADD_FRIEND))
         {
             // Delete Friend List
-            trans->PAppend("DELETE FROM `character_social` WHERE `guid`= '%u'", lowGuid);
-            trans->PAppend("DELETE FROM `character_social` WHERE `friend`= '%u'", lowGuid);
+            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SOCIAL_BY_GUID);
+            stmt->setUInt32(0, lowGuid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SOCIAL_BY_FRIEND);
+            stmt->setUInt32(0, lowGuid);
+            trans->Append(stmt);
         }
 
         // Leave Arena Teams
         Player::LeaveAllArenaTeams(guid);
 
         // Reset homebind and position
-        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_HOMEBIND);
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_HOMEBIND);
         stmt->setUInt32(0, lowGuid);
         trans->Append(stmt);
 
@@ -1880,10 +1948,17 @@
         {
             uint32 achiev_alliance = it->first;
             uint32 achiev_horde = it->second;
-            trans->PAppend("DELETE FROM `character_achievement` WHERE `achievement`=%u AND `guid`=%u",
-                            team == BG_TEAM_ALLIANCE ? achiev_alliance : achiev_horde, lowGuid);
-            trans->PAppend("UPDATE `character_achievement` SET achievement = '%u' where achievement = '%u' AND guid = '%u'",
-                team == BG_TEAM_ALLIANCE ? achiev_alliance : achiev_horde, team == BG_TEAM_ALLIANCE ? achiev_horde : achiev_alliance, lowGuid);
+
+            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACHIEVEMENT_BY_ACHIEVEMENT);
+            stmt->setUInt16(0, uint16(team == BG_TEAM_ALLIANCE ? achiev_alliance : achiev_horde));
+            stmt->setUInt32(1, lowGuid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_ACHIEVEMENT);
+            stmt->setUInt16(0, uint16(team == BG_TEAM_ALLIANCE ? achiev_alliance : achiev_horde));
+            stmt->setUInt16(1, uint16(team == BG_TEAM_ALLIANCE ? achiev_horde : achiev_alliance));
+            stmt->setUInt32(2, lowGuid);
+            trans->Append(stmt);
         }
 
         // Item conversion
@@ -1891,8 +1966,12 @@
         {
             uint32 item_alliance = it->first;
             uint32 item_horde = it->second;
-            trans->PAppend("UPDATE `item_instance` ii, `character_inventory` ci SET ii.itemEntry = '%u' WHERE ii.itemEntry = '%u' AND ci.guid = '%u' AND ci.item = ii.guid",
-                team == BG_TEAM_ALLIANCE ? item_alliance : item_horde, team == BG_TEAM_ALLIANCE ? item_horde : item_alliance, guid);
+
+            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_INVENTORY_FACTION_CHANGE);
+            stmt->setUInt32(0, (team == BG_TEAM_ALLIANCE ? item_alliance : item_horde));
+            stmt->setUInt32(1, (team == BG_TEAM_ALLIANCE ? item_horde : item_alliance));
+            stmt->setUInt32(2, guid);
+            trans->Append(stmt);
         }
 
         // Spell conversion
@@ -1900,10 +1979,17 @@
         {
             uint32 spell_alliance = it->first;
             uint32 spell_horde = it->second;
-            trans->PAppend("DELETE FROM `character_spell` WHERE `spell`=%u AND `guid`=%u",
-                            team == BG_TEAM_ALLIANCE ? spell_alliance : spell_horde, lowGuid);
-            trans->PAppend("UPDATE `character_spell` SET spell = '%u' where spell = '%u' AND guid = '%u'",
-                team == BG_TEAM_ALLIANCE ? spell_alliance : spell_horde, team == BG_TEAM_ALLIANCE ? spell_horde : spell_alliance, lowGuid);
+
+            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SPELL_BY_SPELL);
+            stmt->setUInt32(0, (team == BG_TEAM_ALLIANCE ? spell_alliance : spell_horde));
+            stmt->setUInt32(1, lowGuid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_SPELL_FACTION_CHANGE);
+            stmt->setUInt32(0, (team == BG_TEAM_ALLIANCE ? spell_alliance : spell_horde));
+            stmt->setUInt32(1, (team == BG_TEAM_ALLIANCE ? spell_horde : spell_alliance));
+            stmt->setUInt32(2, lowGuid);
+            trans->Append(stmt);
         }
 
         // Reputation conversion
@@ -1911,10 +1997,17 @@
         {
             uint32 reputation_alliance = it->first;
             uint32 reputation_horde = it->second;
-            trans->PAppend("DELETE FROM character_reputation WHERE faction = '%u' AND guid = '%u'",
-                team == BG_TEAM_ALLIANCE ? reputation_alliance : reputation_horde, lowGuid);
-            trans->PAppend("UPDATE `character_reputation` SET faction = '%u' where faction = '%u' AND guid = '%u'",
-                team == BG_TEAM_ALLIANCE ? reputation_alliance : reputation_horde, team == BG_TEAM_ALLIANCE ? reputation_horde : reputation_alliance, lowGuid);
+
+            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_REP_BY_FACTION);
+            stmt->setUInt32(0, uint16(team == BG_TEAM_ALLIANCE ? reputation_alliance : reputation_horde));
+            stmt->setUInt32(1, lowGuid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_REP_FACTION_CHANGE);
+            stmt->setUInt16(0, uint16(team == BG_TEAM_ALLIANCE ? reputation_alliance : reputation_horde));
+            stmt->setUInt16(1, uint16(team == BG_TEAM_ALLIANCE ? reputation_horde : reputation_alliance));
+            stmt->setUInt32(2, lowGuid);
+            trans->Append(stmt);
         }
     }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Handlers/GroupHandler.cpp
--- a/src/server/game/Handlers/GroupHandler.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Handlers/GroupHandler.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -248,8 +248,9 @@
 {
     sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Received CMSG_GROUP_DECLINE");
 
-    Group  *group  = GetPlayer()->GetGroupInvite();
-    if (!group) return;
+    Group* group = GetPlayer()->GetGroupInvite();
+    if (!group)
+        return;
 
     // Remember leader if online (group pointer will be invalid if group gets disbanded)
     Player* leader = ObjectAccessor::FindPlayer(group->GetLeaderGUID());
@@ -430,7 +431,8 @@
 
 void WorldSession::HandleLootRoll(WorldPacket &recv_data)
 {
-    if (!GetPlayer()->GetGroup())
+    Group* group = GetPlayer()->GetGroup();
+    if (!group)
     {
         recv_data.rfinish();
         return;
@@ -443,12 +445,6 @@
     recv_data >> NumberOfPlayers;
     recv_data >> rollType;                                    //0: pass, 1: need, 2: greed
 
-    //sLog->outDebug("WORLD RECIEVE CMSG_LOOT_ROLL, From:%u, Numberofplayers:%u, Choise:%u", (uint32)Guid, NumberOfPlayers, Choise);
-
-    Group* group = GetPlayer()->GetGroup();
-    if (!group)
-        return;
-
     // everything's fine, do it
     group->CountRollVote(GetPlayer()->GetGUID(), Guid, NumberOfPlayers, rollType);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Handlers/GuildHandler.cpp
--- a/src/server/game/Handlers/GuildHandler.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Handlers/GuildHandler.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -352,8 +352,8 @@
     uint64 GoGuid;
     recv_data >> GoGuid;
 
-    uint8 unk;
-    recv_data >> unk;
+    uint8 fullSlotList;
+    recv_data >> fullSlotList; // 0 = only slots updated in last operation are shown. 1 = all slots updated
 
     if (GetPlayer()->GetGameObjectIfCanInteractWith(GoGuid, GAMEOBJECT_TYPE_GUILD_BANK))
     {
@@ -375,8 +375,8 @@
     uint8 tabId;
     recv_data >> tabId;
 
-    uint8 unk1;
-    recv_data >> unk1;
+    uint8 fullSlotList;
+    recv_data >> fullSlotList; // 0 = only slots updated in last operation are shown. 1 = all slots updated
 
     if (GetPlayer()->GetGameObjectIfCanInteractWith(GoGuid, GAMEOBJECT_TYPE_GUILD_BANK))
         if (Guild* guild = _GetPlayerGuild(this))
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Handlers/ItemHandler.cpp
--- a/src/server/game/Handlers/ItemHandler.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Handlers/ItemHandler.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -115,7 +115,7 @@
     //sLog->outDebug(LOG_FILTER_PACKETIO, "WORLD: CMSG_SWAP_ITEM");
     uint8 dstbag, dstslot, srcbag, srcslot;
 
-    recv_data >> dstbag >> dstslot >> srcbag >> srcslot ;
+    recv_data >> dstbag >> dstslot >> srcbag >> srcslot;
     //sLog->outDebug("STORAGE: receive srcbag = %u, srcslot = %u, dstbag = %u, dstslot = %u", srcbag, srcslot, dstbag, dstslot);
 
     uint16 src = ((srcbag << 8) | srcslot);
@@ -1124,7 +1124,14 @@
     }
 
     SQLTransaction trans = CharacterDatabase.BeginTransaction();
-    trans->PAppend("INSERT INTO character_gifts VALUES ('%u', '%u', '%u', '%u')", GUID_LOPART(item->GetOwnerGUID()), item->GetGUIDLow(), item->GetEntry(), item->GetUInt32Value(ITEM_FIELD_FLAGS));
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_GIFT);
+    stmt->setUInt32(0, GUID_LOPART(item->GetOwnerGUID()));
+    stmt->setUInt32(1, item->GetGUIDLow());
+    stmt->setUInt32(2, item->GetEntry());
+    stmt->setUInt32(3, item->GetUInt32Value(ITEM_FIELD_FLAGS));
+    trans->Append(stmt);
+
     item->SetEntry(gift->GetEntry());
 
     switch (item->GetEntry())
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Handlers/LFGHandler.cpp
--- a/src/server/game/Handlers/LFGHandler.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Handlers/LFGHandler.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -70,7 +70,7 @@
     }
 
     LfgDungeonSet newDungeons;
-    for (int8 i = 0 ; i < numDungeons; ++i)
+    for (int8 i = 0; i < numDungeons; ++i)
     {
         recv_data >> dungeon;
         newDungeons.insert((dungeon & 0x00FFFFFF));       // remove the type from the dungeon entry
@@ -525,9 +525,9 @@
                 ++agreeNum;
         }
     }
-    sLog->outDebug(LOG_FILTER_NETWORKIO, "SMSG_LFG_BOOT_PLAYER [" UI64FMTD "] inProgress: %u - didVote: %u - agree: %u - victim: [" UI64FMTD "] votes: %u - agrees: %u - left: %u - needed: %u - reason %s",
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "SMSG_LFG_BOOT_PROPOSAL_UPDATE [" UI64FMTD "] inProgress: %u - didVote: %u - agree: %u - victim: [" UI64FMTD "] votes: %u - agrees: %u - left: %u - needed: %u - reason %s",
         guid, uint8(pBoot->inProgress), uint8(playerVote != LFG_ANSWER_PENDING), uint8(playerVote == LFG_ANSWER_AGREE), pBoot->victim, votesNum, agreeNum, secsleft, pBoot->votedNeeded, pBoot->reason.c_str());
-    WorldPacket data(SMSG_LFG_BOOT_PLAYER, 1 + 1 + 1 + 8 + 4 + 4 + 4 + 4 + pBoot->reason.length());
+    WorldPacket data(SMSG_LFG_BOOT_PROPOSAL_UPDATE, 1 + 1 + 1 + 8 + 4 + 4 + 4 + 4 + pBoot->reason.length());
     data << uint8(pBoot->inProgress);                      // Vote in progress
     data << uint8(playerVote != LFG_ANSWER_PENDING);       // Did Vote
     data << uint8(playerVote == LFG_ANSWER_AGREE);         // Agree
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Handlers/MailHandler.cpp
--- a/src/server/game/Handlers/MailHandler.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Handlers/MailHandler.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -128,12 +128,26 @@
     else
     {
         rc_team = sObjectMgr->GetPlayerTeamByGUID(rc);
-        if (QueryResult result = CharacterDatabase.PQuery("SELECT COUNT(*) FROM mail WHERE receiver = '%u'", GUID_LOPART(rc)))
+
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_MAIL_COUNT);
+
+        stmt->setUInt32(0, GUID_LOPART(rc));
+
+        PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+        if (result)
         {
             Field* fields = result->Fetch();
-            mails_count = fields[0].GetUInt32();
+            mails_count = fields[0].GetUInt64();
         }
-        if (QueryResult result = CharacterDatabase.PQuery("SELECT level FROM characters WHERE guid = '%u'", GUID_LOPART(rc)))
+
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_LEVEL);
+
+        stmt->setUInt32(0, GUID_LOPART(rc));
+
+        result = CharacterDatabase.Query(stmt);
+
+        if (result)
         {
             Field* fields = result->Fetch();
             receiveLevel = fields[0].GetUInt8();
@@ -360,8 +374,15 @@
     //we can return mail now
     //so firstly delete the old one
     SQLTransaction trans = CharacterDatabase.BeginTransaction();
-    trans->PAppend("DELETE FROM mail WHERE id = '%u'", mailId);             // needed?
-    trans->PAppend("DELETE FROM mail_items WHERE mail_id = '%u'", mailId);
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_BY_ID);
+    stmt->setUInt32(0, mailId);
+    trans->Append(stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM_BY_ID);
+    stmt->setUInt32(0, mailId);
+    trans->Append(stmt);
+
     player->RemoveMail(mailId);
 
     // only return mail if the player exists (and delete if not existing)
@@ -537,7 +558,7 @@
 
     //load players mails, and mailed items
     if (!player->m_mailsLoaded)
-        player ->_LoadMail();
+        player->_LoadMail();
 
     // client can't work with packets > max int16 value
     const uint32 maxPacketSize = 32767;
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Handlers/MiscHandler.cpp
--- a/src/server/game/Handlers/MiscHandler.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Handlers/MiscHandler.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -1303,7 +1303,12 @@
 
     uint32 accid = player->GetSession()->GetAccountId();
 
-    QueryResult result = LoginDatabase.PQuery("SELECT username, email, last_ip FROM account WHERE id=%u", accid);
+    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_ACCOUNT_WHOIS);
+
+    stmt->setUInt32(0, accid);
+
+    PreparedQueryResult result = LoginDatabase.Query(stmt);
+
     if (!result)
     {
         SendNotification(LANG_ACCOUNT_FOR_PLAYER_NOT_FOUND, charname.c_str());
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Handlers/NPCHandler.cpp
--- a/src/server/game/Handlers/NPCHandler.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Handlers/NPCHandler.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -169,7 +169,7 @@
 
         bool valid = true;
         bool primary_prof_first_rank = false;
-        for (uint8 i = 0; i < MAX_SPELL_EFFECTS ; ++i)
+        for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
         {
             if (!tSpell->learnedSpell[i])
                 continue;
@@ -199,7 +199,7 @@
         data << uint32(tSpell->reqSkillValue);
         //prev + req or req + 0
         uint8 maxReq = 0;
-        for (uint8 i = 0; i < MAX_SPELL_EFFECTS ; ++i)
+        for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
         {
             if (!tSpell->learnedSpell[i])
                 continue;
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Handlers/PetHandler.cpp
--- a/src/server/game/Handlers/PetHandler.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Handlers/PetHandler.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -153,8 +153,6 @@
             switch (spellid)
             {
                 case COMMAND_STAY:                          //flat=1792  //STAY
-                    pet->AttackStop();
-                    pet->InterruptNonMeleeSpells(false);
                     pet->StopMoving();
                     pet->GetMotionMaster()->Clear(false);
                     pet->GetMotionMaster()->MoveIdle();
@@ -647,15 +645,25 @@
     SQLTransaction trans = CharacterDatabase.BeginTransaction();
     if (isdeclined)
     {
-        for (uint8 i = 0; i < MAX_DECLINED_NAME_CASES; ++i)
-            CharacterDatabase.EscapeString(declinedname.name[i]);
-        trans->PAppend("DELETE FROM character_pet_declinedname WHERE owner = '%u' AND id = '%u'", _player->GetGUIDLow(), pet->GetCharmInfo()->GetPetNumber());
-        trans->PAppend("INSERT INTO character_pet_declinedname (id, owner, genitive, dative, accusative, instrumental, prepositional) VALUES ('%u', '%u', '%s', '%s', '%s', '%s', '%s')",
-            pet->GetCharmInfo()->GetPetNumber(), _player->GetGUIDLow(), declinedname.name[0].c_str(), declinedname.name[1].c_str(), declinedname.name[2].c_str(), declinedname.name[3].c_str(), declinedname.name[4].c_str());
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_PET_DECLINEDNAME);
+        stmt->setUInt32(0, pet->GetCharmInfo()->GetPetNumber());
+        trans->Append(stmt);
+
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_ADD_CHAR_PET_DECLINEDNAME);
+        stmt->setUInt32(0, _player->GetGUIDLow());
+
+        for (uint8 i = 0; i < 5; i++)
+            stmt->setString(i+1, declinedname.name[i]);
+
+        trans->Append(stmt);
     }
 
-    CharacterDatabase.EscapeString(name);
-    trans->PAppend("UPDATE character_pet SET name = '%s', renamed = '1' WHERE owner = '%u' AND id = '%u'", name.c_str(), _player->GetGUIDLow(), pet->GetCharmInfo()->GetPetNumber());
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_PET_NAME);
+    stmt->setString(0, name);
+    stmt->setUInt32(1, _player->GetGUIDLow());
+    stmt->setUInt32(2, pet->GetCharmInfo()->GetPetNumber());
+    trans->Append(stmt);
+
     CharacterDatabase.CommitTransaction(trans);
 
     pet->SetUInt32Value(UNIT_FIELD_PET_NAME_TIMESTAMP, uint32(time(NULL))); // cast can't be helped
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Handlers/PetitionsHandler.cpp
--- a/src/server/game/Handlers/PetitionsHandler.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Handlers/PetitionsHandler.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -215,7 +215,10 @@
     // a petition is invalid, if both the owner and the type matches
     // we checked above, if this player is in an arenateam, so this must be
     // datacorruption
-    QueryResult result = CharacterDatabase.PQuery("SELECT petitionguid FROM petition WHERE ownerguid = '%u'  AND type = '%u'", _player->GetGUIDLow(), type);
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_BY_OWNER);
+    stmt->setUInt32(0, _player->GetGUIDLow());
+    stmt->setUInt8(1, type);
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
 
     std::ostringstream ssInvalidPetitionGUIDs;
 
@@ -236,8 +239,14 @@
     SQLTransaction trans = CharacterDatabase.BeginTransaction();
     trans->PAppend("DELETE FROM petition WHERE petitionguid IN (%s)",  ssInvalidPetitionGUIDs.str().c_str());
     trans->PAppend("DELETE FROM petition_sign WHERE petitionguid IN (%s)", ssInvalidPetitionGUIDs.str().c_str());
-    trans->PAppend("INSERT INTO petition (ownerguid, petitionguid, name, type) VALUES ('%u', '%u', '%s', '%u')",
-        _player->GetGUIDLow(), charter->GetGUIDLow(), name.c_str(), type);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_PETITION);
+    stmt->setUInt32(0, _player->GetGUIDLow());
+    stmt->setUInt32(1, charter->GetGUIDLow());
+    stmt->setString(2, name);
+    stmt->setUInt8(3, uint8(type));
+    trans->Append(stmt);
+
     CharacterDatabase.CommitTransaction(trans);
 }
 
@@ -250,9 +259,14 @@
     recv_data >> petitionguid;                              // petition guid
 
     // solve (possible) some strange compile problems with explicit use GUID_LOPART(petitionguid) at some GCC versions (wrong code optimization in compiler?)
-    uint32 petitionguid_low = GUID_LOPART(petitionguid);
+    uint32 petitionGuidLow = GUID_LOPART(petitionguid);
 
-    QueryResult result = CharacterDatabase.PQuery("SELECT type FROM petition WHERE petitionguid = '%u'", petitionguid_low);
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_TYPE);
+
+    stmt->setUInt32(0, petitionGuidLow);
+
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
     if (!result)
     {
         sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "Petition %u is not found for player %u %s", GUID_LOPART(petitionguid), GetPlayer()->GetGUIDLow(), GetPlayer()->GetName());
@@ -265,26 +279,30 @@
     if (type == GUILD_CHARTER_TYPE && _player->GetGuildId())
         return;
 
-    result = CharacterDatabase.PQuery("SELECT playerguid FROM petition_sign WHERE petitionguid = '%u'", petitionguid_low);
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_SIGNATURE);
+
+    stmt->setUInt32(0, petitionGuidLow);
+
+    result = CharacterDatabase.Query(stmt);
 
     // result == NULL also correct in case no sign yet
     if (result)
         signs = uint8(result->GetRowCount());
 
-    sLog->outDebug(LOG_FILTER_NETWORKIO, "CMSG_PETITION_SHOW_SIGNATURES petition entry: '%u'", petitionguid_low);
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "CMSG_PETITION_SHOW_SIGNATURES petition entry: '%u'", petitionGuidLow);
 
     WorldPacket data(SMSG_PETITION_SHOW_SIGNATURES, (8+8+4+1+signs*12));
     data << uint64(petitionguid);                           // petition guid
     data << uint64(_player->GetGUID());                     // owner guid
-    data << uint32(petitionguid_low);                       // guild guid
+    data << uint32(petitionGuidLow);                        // guild guid
     data << uint8(signs);                                   // sign's count
 
     for (uint8 i = 1; i <= signs; ++i)
     {
         Field* fields2 = result->Fetch();
-        uint64 plguid = fields2[0].GetUInt64();
+        uint32 lowGuid = fields2[0].GetUInt32();
 
-        data << uint64(plguid);                             // Player GUID
+        data << uint64(MAKE_NEW_GUID(lowGuid, 0, HIGHGUID_PLAYER)); // Player GUID
         data << uint32(0);                                  // there 0 ...
 
         result->NextRow();
@@ -311,16 +329,18 @@
     uint32 type;
     std::string name = "NO_NAME_FOR_GUID";
 
-    // TODO: Use CHAR_LOAD_PETITION PS
-    QueryResult result = CharacterDatabase.PQuery("SELECT ownerguid, name, type "
-        "FROM petition WHERE petitionguid = '%u'", GUID_LOPART(petitionguid));
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION);
+
+    stmt->setUInt32(0, GUID_LOPART(petitionguid));
+
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
 
     if (result)
     {
         Field* fields = result->Fetch();
         ownerguid = MAKE_NEW_GUID(fields[0].GetUInt32(), 0, HIGHGUID_PLAYER);
         name      = fields[1].GetString();
-        type      = fields[2].GetUInt32();
+        type      = fields[2].GetUInt8();
     }
     else
     {
@@ -382,7 +402,11 @@
     if (!item)
         return;
 
-    QueryResult result = CharacterDatabase.PQuery("SELECT type FROM petition WHERE petitionguid = '%u'", GUID_LOPART(petitionGuid));
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_TYPE);
+
+    stmt->setUInt32(0, GUID_LOPART(petitionGuid));
+
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
 
     if (result)
     {
@@ -422,7 +446,7 @@
         }
     }
 
-    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_PETITION_NAME);
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_PETITION_NAME);
 
     stmt->setString(0, newName);
     stmt->setUInt32(1, GUID_LOPART(petitionGuid));
@@ -446,11 +470,12 @@
     recv_data >> petitionGuid;                              // petition guid
     recv_data >> unk;
 
-    QueryResult result = CharacterDatabase.PQuery(
-        "SELECT ownerguid, "
-        "  (SELECT COUNT(playerguid) FROM petition_sign WHERE petition_sign.petitionguid = '%u') AS signs, "
-        "  type "
-        "FROM petition WHERE petitionguid = '%u'", GUID_LOPART(petitionGuid), GUID_LOPART(petitionGuid));
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_SIGNATURES);
+
+    stmt->setUInt32(0, GUID_LOPART(petitionGuid));
+    stmt->setUInt32(1, GUID_LOPART(petitionGuid));
+
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
 
     if (!result)
     {
@@ -460,8 +485,8 @@
 
     fields = result->Fetch();
     uint64 ownerGuid = MAKE_NEW_GUID(fields[0].GetUInt32(), 0, HIGHGUID_PLAYER);
-    uint8 signs = fields[1].GetUInt8();
-    uint32 type = fields[2].GetUInt32();
+    uint64 signs = fields[1].GetUInt64();
+    uint8 type = fields[2].GetUInt8();
 
     uint32 playerGuid = _player->GetGUIDLow();
     if (GUID_LOPART(ownerGuid) == playerGuid)
@@ -518,9 +543,14 @@
     if (++signs > type)                                        // client signs maximum
         return;
 
-    //client doesn't allow to sign petition two times by one character, but not check sign by another character from same account
-    //not allow sign another player from already sign player account
-    result = CharacterDatabase.PQuery("SELECT playerguid FROM petition_sign WHERE player_account = '%u' AND petitionguid = '%u'", GetAccountId(), GUID_LOPART(petitionGuid));
+    // Client doesn't allow to sign petition two times by one character, but not check sign by another character from same account
+    // not allow sign another player from already sign player account
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_SIG_BY_ACCOUNT);
+
+    stmt->setUInt32(0, GetAccountId());
+    stmt->setUInt32(1, GUID_LOPART(petitionGuid));
+
+    result = CharacterDatabase.Query(stmt);
 
     if (result)
     {
@@ -538,7 +568,7 @@
         return;
     }
 
-    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_PETITION_SIGNATURE);
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_PETITION_SIGNATURE);
 
     stmt->setUInt32(0, GUID_LOPART(ownerGuid));
     stmt->setUInt32(1, GUID_LOPART(petitionGuid));
@@ -576,7 +606,12 @@
     recv_data >> petitionguid;                              // petition guid
     sLog->outDebug(LOG_FILTER_NETWORKIO, "Petition %u declined by %u", GUID_LOPART(petitionguid), _player->GetGUIDLow());
 
-    QueryResult result = CharacterDatabase.PQuery("SELECT ownerguid FROM petition WHERE petitionguid = '%u'", GUID_LOPART(petitionguid));
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_OWNER_BY_GUID);
+
+    stmt->setUInt32(0, GUID_LOPART(petitionguid));
+
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
     if (!result)
         return;
 
@@ -608,7 +643,12 @@
     if (!player)
         return;
 
-    QueryResult result = CharacterDatabase.PQuery("SELECT type FROM petition WHERE petitionguid = '%u'", GUID_LOPART(petitionguid));
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_TYPE);
+
+    stmt->setUInt32(0, GUID_LOPART(petitionguid));
+
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
     if (!result)
         return;
 
@@ -667,7 +707,13 @@
         }
     }
 
-    result = CharacterDatabase.PQuery("SELECT playerguid FROM petition_sign WHERE petitionguid = '%u'", GUID_LOPART(petitionguid));
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_SIGNATURE);
+
+    stmt->setUInt32(0, GUID_LOPART(petitionguid));
+
+    result = CharacterDatabase.Query(stmt);
+
     // result == NULL also correct charter without signs
     if (result)
         signs = uint8(result->GetRowCount());
@@ -681,9 +727,7 @@
     for (uint8 i = 1; i <= signs; ++i)
     {
         Field* fields2 = result->Fetch();
-        plguid = fields2[0].GetUInt64();
-
-        data << uint64(plguid);                             // Player GUID
+        data << uint64(MAKE_NEW_GUID(fields2[0].GetUInt32(), 0, HIGHGUID_PLAYER)); // Player GUID
         data << uint32(0);                                  // there 0 ...
 
         result->NextRow();
@@ -861,8 +905,15 @@
     }
 
     SQLTransaction trans = CharacterDatabase.BeginTransaction();
-    trans->PAppend("DELETE FROM petition WHERE petitionguid = '%u'", GUID_LOPART(petitionGuid));
-    trans->PAppend("DELETE FROM petition_sign WHERE petitionguid = '%u'", GUID_LOPART(petitionGuid));
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_BY_GUID);
+    stmt->setUInt32(0, GUID_LOPART(petitionGuid));
+    trans->Append(stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_SIGNATURE_BY_GUID);
+    stmt->setUInt32(0, GUID_LOPART(petitionGuid));
+    trans->Append(stmt);
+
     CharacterDatabase.CommitTransaction(trans);
 
     // created
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Handlers/QueryHandler.cpp
--- a/src/server/game/Handlers/QueryHandler.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Handlers/QueryHandler.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -33,42 +33,33 @@
 
 void WorldSession::SendNameQueryOpcode(uint64 guid)
 {
-    Player* player = NULL;
-    const CharacterNameData* nameData = sWorld->GetCharacterNameData(GUID_LOPART(guid));
-    if (nameData)
-        player = ObjectAccessor::FindPlayer(guid);
+    Player* player = ObjectAccessor::FindPlayer(guid);
+    CharacterNameData const* nameData = sWorld->GetCharacterNameData(GUID_LOPART(guid));
 
-                                                            // guess size
     WorldPacket data(SMSG_NAME_QUERY_RESPONSE, (8+1+1+1+1+1+10));
     data.appendPackGUID(guid);
-    data << uint8(0);                                       // added in 3.1
-    if (nameData)
+    if (!nameData)
     {
-        data << nameData->m_name;                                   // played name
-        data << uint8(0);                                       // realm name for cross realm BG usage
-        data << uint8(nameData->m_race);
-        data << uint8(nameData->m_gender);
-        data << uint8(nameData->m_class);
+        data << uint8(1);                           // name unknown
+        SendPacket(&data);
+        return;
+    }
+
+    data << uint8(0);                               // name known
+    data << nameData->m_name;                       // played name
+    data << uint8(0);                               // realm name - only set for cross realm interaction (such as Battlegrounds)
+    data << uint8(nameData->m_race);
+    data << uint8(nameData->m_gender);
+    data << uint8(nameData->m_class);
+
+    if (DeclinedName const* names = (player ? player->GetDeclinedNames() : NULL))
+    {
+        data << uint8(1);                           // Name is declined
+        for (uint8 i = 0; i < MAX_DECLINED_NAME_CASES; ++i)
+            data << names->name[i];
     }
     else
-    {
-        data << std::string(GetTrinityString(LANG_NON_EXIST_CHARACTER));
-        data << uint32(0);
-    }
-
-    if (player)
-    {
-        if (DeclinedName const* names = player->GetDeclinedNames())
-        {
-            data << uint8(1);                                   // is declined
-            for (int i = 0; i < MAX_DECLINED_NAME_CASES; ++i)
-                data << names->name[i];
-        }
-        else
-            data << uint8(0);                                   // is not declined
-    }
-    else //TODO: decline names may also need to be stored in char name data
-        data << uint8(0);
+        data << uint8(0);                           // Name is not declined
 
     SendPacket(&data);
 }
@@ -76,7 +67,6 @@
 void WorldSession::HandleNameQueryOpcode(WorldPacket& recv_data)
 {
     uint64 guid;
-
     recv_data >> guid;
 
     // This is disable by default to prevent lots of console spam
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Handlers/SpellHandler.cpp
--- a/src/server/game/Handlers/SpellHandler.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Handlers/SpellHandler.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -173,12 +173,6 @@
     }
 }
 
-#define OPEN_CHEST 11437
-#define OPEN_SAFE 11535
-#define OPEN_CAGE 11792
-#define OPEN_BOOTY_CHEST 5107
-#define OPEN_STRONGBOX 8517
-
 void WorldSession::HandleOpenItemOpcode(WorldPacket& recvPacket)
 {
     sLog->outDetail("WORLD: CMSG_OPEN_ITEM packet, data length = %i", (uint32)recvPacket.size());
@@ -241,7 +235,12 @@
 
     if (item->HasFlag(ITEM_FIELD_FLAGS, ITEM_FLAG_WRAPPED))// wrapped?
     {
-        QueryResult result = CharacterDatabase.PQuery("SELECT entry, flags FROM character_gifts WHERE item_guid = '%u'", item->GetGUIDLow());
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_GIFT_BY_ITEM);
+
+        stmt->setUInt32(0, item->GetGUIDLow());
+
+        PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
         if (result)
         {
             Field* fields = result->Fetch();
@@ -260,7 +259,7 @@
             return;
         }
 
-        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GIFT);
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GIFT);
 
         stmt->setUInt32(0, item->GetGUIDLow());
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Handlers/TicketHandler.cpp
--- a/src/server/game/Handlers/TicketHandler.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Handlers/TicketHandler.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -38,7 +38,7 @@
         return;
     }
 
-    GMTicketResponse response = GMTICKET_RESPONSE_FAILURE;
+    GMTicketResponse response = GMTICKET_RESPONSE_CREATE_ERROR;
     // Player must not have ticket
     if (!sTicketMgr->GetTicketByPlayer(GetPlayer()->GetGUID()))
     {
@@ -48,7 +48,7 @@
 
         sWorld->SendGMText(LANG_COMMAND_TICKETNEW, GetPlayer()->GetName(), ticket->GetId());
 
-        response = GMTICKET_RESPONSE_SUCCESS;
+        response = GMTICKET_RESPONSE_CREATE_SUCCESS;
     }
 
     WorldPacket data(SMSG_GMTICKET_CREATE, 4);
@@ -61,8 +61,8 @@
     std::string message;
     recv_data >> message;
 
-    GMTicketResponse response = GMTICKET_RESPONSE_FAILURE;
-    if (GmTicket *ticket = sTicketMgr->GetTicketByPlayer(GetPlayer()->GetGUID()))
+    GMTicketResponse response = GMTICKET_RESPONSE_UPDATE_ERROR;
+    if (GmTicket* ticket = sTicketMgr->GetTicketByPlayer(GetPlayer()->GetGUID()))
     {
         SQLTransaction trans = SQLTransaction(NULL);
         ticket->SetMessage(message);
@@ -70,7 +70,7 @@
 
         sWorld->SendGMText(LANG_COMMAND_TICKETUPDATED, GetPlayer()->GetName(), ticket->GetId());
 
-        response = GMTICKET_RESPONSE_SUCCESS;
+        response = GMTICKET_RESPONSE_UPDATE_SUCCESS;
     }
 
     WorldPacket data(SMSG_GMTICKET_UPDATETEXT, 4);
@@ -176,6 +176,8 @@
     stmt->setFloat (3, x);
     stmt->setFloat (4, y);
     stmt->setFloat (5, z);
+    stmt->setUInt32(6, GetLatency());
+    stmt->setUInt32(7, time(NULL));
     CharacterDatabase.Execute(stmt);
 }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Handlers/TradeHandler.cpp
--- a/src/server/game/Handlers/TradeHandler.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Handlers/TradeHandler.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -412,7 +412,7 @@
         trader->GetSession()->SendTradeStatus(TRADE_STATUS_TRADE_ACCEPT);
 
         // test if item will fit in each inventory
-        hisCanCompleteTrade =  (trader->CanStoreItems(myItems, TRADE_SLOT_TRADED_COUNT) == EQUIP_ERR_OK);
+        hisCanCompleteTrade = (trader->CanStoreItems(myItems, TRADE_SLOT_TRADED_COUNT) == EQUIP_ERR_OK);
         myCanCompleteTrade = (_player->CanStoreItems(hisItems, TRADE_SLOT_TRADED_COUNT) == EQUIP_ERR_OK);
 
         clearAcceptTradeMode(myItems, hisItems);
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Instances/InstanceSaveMgr.cpp
--- a/src/server/game/Instances/InstanceSaveMgr.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Instances/InstanceSaveMgr.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -124,11 +124,21 @@
 void InstanceSaveManager::DeleteInstanceFromDB(uint32 instanceid)
 {
     SQLTransaction trans = CharacterDatabase.BeginTransaction();
-    trans->PAppend("DELETE FROM instance WHERE id = '%u'", instanceid);
-    trans->PAppend("DELETE FROM character_instance WHERE instance = '%u'", instanceid);
-    trans->PAppend("DELETE FROM group_instance WHERE instance = '%u'", instanceid);
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_INSTANCE_BY_INSTANCE);
+    stmt->setUInt32(0, instanceid);
+    trans->Append(stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INSTANCE_BY_INSTANCE);
+    stmt->setUInt32(0, instanceid);
+    trans->Append(stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GROUP_INSTANCE_BY_INSTANCE);
+    stmt->setUInt32(0, instanceid);
+    trans->Append(stmt);
+
     CharacterDatabase.CommitTransaction(trans);
-    // respawn times should be deleted only when the map gets unloaded
+    // Respawn times should be deleted only when the map gets unloaded
 }
 
 void InstanceSaveManager::RemoveInstanceSave(uint32 InstanceId)
@@ -348,7 +358,7 @@
         {
             Field* fields = result->Fetch();
             uint32 mapid = fields[0].GetUInt16();
-            Difficulty difficulty = Difficulty(fields[1].GetUInt32());
+            Difficulty difficulty = Difficulty(fields[1].GetUInt8());
             uint64 oldresettime = fields[2].GetUInt32();
 
             MapDifficulty const* mapDiff = GetMapDifficultyData(mapid, difficulty);
@@ -568,9 +578,22 @@
 
         // delete them from the DB, even if not loaded
         SQLTransaction trans = CharacterDatabase.BeginTransaction();
-        trans->PAppend("DELETE FROM character_instance USING character_instance LEFT JOIN instance ON character_instance.instance = id WHERE map = '%u' and difficulty='%u'", mapid, difficulty);
-        trans->PAppend("DELETE FROM group_instance USING group_instance LEFT JOIN instance ON group_instance.instance = id WHERE map = '%u' and difficulty='%u'", mapid, difficulty);
-        trans->PAppend("DELETE FROM instance WHERE map = '%u' and difficulty='%u'", mapid, difficulty);
+
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INSTANCE_BY_MAP_DIFF);
+        stmt->setUInt16(0, uint16(mapid));
+        stmt->setUInt8(1, uint8(difficulty));
+        trans->Append(stmt);
+
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GROUP_INSTANCE_BY_MAP_DIFF);
+        stmt->setUInt16(0, uint16(mapid));
+        stmt->setUInt8(1, uint8(difficulty));
+        trans->Append(stmt);
+
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_INSTANCE_BY_MAP_DIFF);
+        stmt->setUInt16(0, uint16(mapid));
+        stmt->setUInt8(1, uint8(difficulty));
+        trans->Append(stmt);
+
         CharacterDatabase.CommitTransaction(trans);
 
         // calculate the next reset time
@@ -580,13 +603,13 @@
         if (period < DAY)
             period = DAY;
 
-        uint32 next_reset = ((resetTime + MINUTE) / DAY * DAY) + period + diff;
+        uint32 next_reset = uint32(((resetTime + MINUTE) / DAY * DAY) + period + diff);
 
         SetResetTimeFor(mapid, difficulty, next_reset);
         ScheduleReset(true, time_t(next_reset-3600), InstResetEvent(1, mapid, difficulty, 0));
 
         // Update it in the DB
-        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_GLOBAL_INSTANCE_RESETTIME);
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_GLOBAL_INSTANCE_RESETTIME);
 
         stmt->setUInt32(0, next_reset);
         stmt->setUInt16(1, uint16(mapid));
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Loot/LootMgr.cpp
--- a/src/server/game/Loot/LootMgr.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Loot/LootMgr.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -26,7 +26,8 @@
 #include "SpellInfo.h"
 #include "Group.h"
 
-static Rates const qualityToRate[MAX_ITEM_QUALITY] = {
+static Rates const qualityToRate[MAX_ITEM_QUALITY] =
+{
     RATE_DROP_ITEM_POOR,                                    // ITEM_QUALITY_POOR
     RATE_DROP_ITEM_NORMAL,                                  // ITEM_QUALITY_NORMAL
     RATE_DROP_ITEM_UNCOMMON,                                // ITEM_QUALITY_UNCOMMON
@@ -116,7 +117,7 @@
         uint16 lootmode            = fields[3].GetUInt16();
         uint8  group               = fields[4].GetUInt8();
         int32  mincountOrRef       = fields[5].GetInt32();
-        int32  maxcount            = fields[6].GetInt32();
+        int32  maxcount            = fields[6].GetUInt8();
 
         if (maxcount > std::numeric_limits<uint8>::max())
         {
@@ -512,7 +513,9 @@
 
 QuestItemList* Loot::FillQuestLoot(Player* player)
 {
-    if (items.size() == MAX_NR_LOOT_ITEMS) return NULL;
+    if (items.size() == MAX_NR_LOOT_ITEMS)
+        return NULL;
+
     QuestItemList* ql = new QuestItemList();
 
     for (uint8 i = 0; i < quest_items.size(); ++i)
@@ -734,7 +737,7 @@
     if (q_itr != lootPlayerQuestItems.end())
     {
         QuestItemList* q_list = q_itr->second;
-        for (QuestItemList::const_iterator qi = q_list->begin() ; qi != q_list->end(); ++qi)
+        for (QuestItemList::const_iterator qi = q_list->begin(); qi != q_list->end(); ++qi)
         {
             const LootItem &item = quest_items[qi->index];
             if (!qi->is_looted && !item.is_looted)
@@ -747,7 +750,7 @@
     if (ffa_itr != lootPlayerFFAItems.end())
     {
         QuestItemList* ffa_list = ffa_itr->second;
-        for (QuestItemList::const_iterator fi = ffa_list->begin() ; fi != ffa_list->end(); ++fi)
+        for (QuestItemList::const_iterator fi = ffa_list->begin(); fi != ffa_list->end(); ++fi)
         {
             const LootItem &item = items[fi->index];
             if (!fi->is_looted && !item.is_looted)
@@ -759,8 +762,8 @@
     QuestItemMap::const_iterator nn_itr = lootPlayerNonQuestNonFFAConditionalItems.find(player->GetGUIDLow());
     if (nn_itr != lootPlayerNonQuestNonFFAConditionalItems.end())
     {
-        QuestItemList* conditional_list =  nn_itr->second;
-        for (QuestItemList::const_iterator ci = conditional_list->begin() ; ci != conditional_list->end(); ++ci)
+        QuestItemList* conditional_list = nn_itr->second;
+        for (QuestItemList::const_iterator ci = conditional_list->begin(); ci != conditional_list->end(); ++ci)
         {
             const LootItem &item = items[ci->index];
             if (!ci->is_looted && !item.is_looted)
@@ -900,7 +903,7 @@
     if (q_itr != lootPlayerQuestItems.end())
     {
         QuestItemList* q_list = q_itr->second;
-        for (QuestItemList::const_iterator qi = q_list->begin() ; qi != q_list->end(); ++qi)
+        for (QuestItemList::const_iterator qi = q_list->begin(); qi != q_list->end(); ++qi)
         {
             LootItem &item = l.quest_items[qi->index];
             if (!qi->is_looted && !item.is_looted)
@@ -918,7 +921,7 @@
     if (ffa_itr != lootPlayerFFAItems.end())
     {
         QuestItemList* ffa_list = ffa_itr->second;
-        for (QuestItemList::const_iterator fi = ffa_list->begin() ; fi != ffa_list->end(); ++fi)
+        for (QuestItemList::const_iterator fi = ffa_list->begin(); fi != ffa_list->end(); ++fi)
         {
             LootItem &item = l.items[fi->index];
             if (!fi->is_looted && !item.is_looted)
@@ -935,8 +938,8 @@
     QuestItemMap::const_iterator nn_itr = lootPlayerNonQuestNonFFAConditionalItems.find(lv.viewer->GetGUIDLow());
     if (nn_itr != lootPlayerNonQuestNonFFAConditionalItems.end())
     {
-        QuestItemList* conditional_list =  nn_itr->second;
-        for (QuestItemList::const_iterator ci = conditional_list->begin() ; ci != conditional_list->end(); ++ci)
+        QuestItemList* conditional_list = nn_itr->second;
+        for (QuestItemList::const_iterator ci = conditional_list->begin(); ci != conditional_list->end(); ++ci)
         {
             LootItem &item = l.items[ci->index];
             if (!ci->is_looted && !item.is_looted)
@@ -1285,7 +1288,7 @@
     }
 
     // Now processing groups
-    for (LootGroups::const_iterator i = Groups.begin() ; i != Groups.end(); ++i)
+    for (LootGroups::const_iterator i = Groups.begin(); i != Groups.end(); ++i)
         if (i->HasQuestDrop())
             return true;
 
@@ -1303,7 +1306,7 @@
     }
 
     // Checking non-grouped entries
-    for (LootStoreItemList::const_iterator i = Entries.begin() ; i != Entries.end(); ++i)
+    for (LootStoreItemList::const_iterator i = Entries.begin(); i != Entries.end(); ++i)
     {
         if (i->mincountOrRef < 0)                           // References processing
         {
@@ -1523,7 +1526,7 @@
     {
         if (uint32 lootid = itr->second.GetLootId())
         {
-            if (sObjectMgr->IsGoOfSpecificEntrySpawned(itr->second.entry) && lootIdSet.find(lootid) == lootIdSet.end())
+            if (lootIdSet.find(lootid) == lootIdSet.end())
                 LootTemplates_Gameobject.ReportNotExistedId(lootid);
             else
                 lootIdSetUsed.insert(lootid);
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Maps/Map.cpp
--- a/src/server/game/Maps/Map.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Maps/Map.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -818,20 +818,20 @@
 void Map::MoveAllCreaturesInMoveList()
 {
     _creatureToMoveLock = true;
-    for(std::vector<Creature*>::iterator itr = _creaturesToMove.begin(); itr != _creaturesToMove.end(); ++itr)
+    for (std::vector<Creature*>::iterator itr = _creaturesToMove.begin(); itr != _creaturesToMove.end(); ++itr)
     {
         Creature* c = *itr;
-        if(c->FindMap() != this) //pet is teleported to another map
+        if (c->FindMap() != this) //pet is teleported to another map
             continue;
 
-        if(c->_moveState != CREATURE_CELL_MOVE_ACTIVE)
+        if (c->_moveState != CREATURE_CELL_MOVE_ACTIVE)
         {
             c->_moveState = CREATURE_CELL_MOVE_NONE;
             continue;
         }
 
         c->_moveState = CREATURE_CELL_MOVE_NONE;
-        if(!c->IsInWorld())
+        if (!c->IsInWorld())
             continue;
 
         // do move or do move to respawn or remove creature if previous all fail
@@ -1557,8 +1557,11 @@
                 {
                     uint32 overrideLiquid = area->LiquidTypeOverride[liquidEntry->Type];
                     if (!overrideLiquid && area->zone)
-                        if (area = GetAreaEntryByAreaID(area->zone))
+                    {
+                        area = GetAreaEntryByAreaID(area->zone);
+                        if (area)
                             overrideLiquid = area->LiquidTypeOverride[liquidEntry->Type];
+                    }
 
                     if (LiquidTypeEntry const* liq = sLiquidTypeStore.LookupEntry(overrideLiquid))
                     {
@@ -1851,8 +1854,11 @@
                     {
                         uint32 overrideLiquid = area->LiquidTypeOverride[liquidFlagType];
                         if (!overrideLiquid && area->zone)
-                            if (area = GetAreaEntryByAreaID(area->zone))
+                        {
+                            area = GetAreaEntryByAreaID(area->zone);
+                            if (area)
                                 overrideLiquid = area->LiquidTypeOverride[liquidFlagType];
+                        }
 
                         if (LiquidTypeEntry const* liq = sLiquidTypeStore.LookupEntry(overrideLiquid))
                         {
@@ -2401,7 +2407,7 @@
                     return false;
                 }
                 // player inside instance has no group or his groups is different to entering player's one, deny entry
-                if (!iPlayer->GetGroup() || iPlayer->GetGroup() != player->GetGroup() )
+                if (!iPlayer->GetGroup() || iPlayer->GetGroup() != player->GetGroup())
                 {
                     player->SendTransferAborted(GetId(), TRANSFER_ABORT_MAX_PLAYERS);
                     return false;
@@ -2579,7 +2585,11 @@
     if (load)
     {
         // TODO: make a global storage for this
-        QueryResult result = CharacterDatabase.PQuery("SELECT data, completedEncounters FROM instance WHERE map = '%u' AND id = '%u'", GetId(), i_InstanceId);
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_INSTANCE);
+        stmt->setUInt16(0, uint16(GetId()));
+        stmt->setUInt32(1, i_InstanceId);
+        PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
         if (result)
         {
             Field* fields = result->Fetch();
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Maps/Map.h
--- a/src/server/game/Maps/Map.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Maps/Map.h	Mon Apr 16 14:29:17 2012 +0300
@@ -245,8 +245,12 @@
         // currently unused for normal maps
         bool CanUnload(uint32 diff)
         {
-            if (!m_unloadTimer) return false;
-            if (m_unloadTimer <= diff) return true;
+            if (!m_unloadTimer)
+                return false;
+
+            if (m_unloadTimer <= diff)
+                return true;
+
             m_unloadTimer -= diff;
             return false;
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Maps/MapManager.cpp
--- a/src/server/game/Maps/MapManager.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Maps/MapManager.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -96,32 +96,32 @@
 
 Map* MapManager::CreateBaseMap(uint32 id)
 {
-    Map* m = FindBaseMap(id);
+    Map* map = FindBaseMap(id);
 
-    if (m == NULL)
+    if (map == NULL)
     {
         TRINITY_GUARD(ACE_Thread_Mutex, Lock);
 
         const MapEntry* entry = sMapStore.LookupEntry(id);
         if (entry && entry->Instanceable())
         {
-            m = new MapInstanced(id, i_gridCleanUpDelay);
+            map = new MapInstanced(id, i_gridCleanUpDelay);
         }
         else
         {
-            m = new Map(id, i_gridCleanUpDelay, 0, REGULAR_DIFFICULTY);
+            map = new Map(id, i_gridCleanUpDelay, 0, REGULAR_DIFFICULTY);
         }
-        i_maps[id] = m;
+        i_maps[id] = map;
     }
 
-    ASSERT(m != NULL);
-    return m;
+    ASSERT(map);
+    return map;
 }
 
 Map* MapManager::FindBaseNonInstanceMap(uint32 mapId) const
 {
     Map* map = FindBaseMap(mapId);
-    if(map && map->Instanceable())
+    if (map && map->Instanceable())
         return NULL;
     return map;
 }
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Maps/MapUpdater.cpp
--- a/src/server/game/Maps/MapUpdater.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Maps/MapUpdater.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -52,7 +52,7 @@
         virtual int call()
         {
             m_map.Update (m_diff);
-            m_updater.update_finished ();
+            m_updater.update_finished();
             return 0;
         }
 };
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Miscellaneous/Language.h
--- a/src/server/game/Miscellaneous/Language.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Miscellaneous/Language.h	Mon Apr 16 14:29:17 2012 +0300
@@ -522,8 +522,10 @@
     LANG_YOURS_EXPLORE_SET_ALL          = 553,
     LANG_YOURS_EXPLORE_SET_NOTHING      = 554,
 
-    LANG_HOVER_ENABLED                  = 555,
-    LANG_HOVER_DISABLED                 = 556,
+    //! Old ones now free:
+    // LANG_HOVER_ENABLED               = 555,
+    // LANG_HOVER_DISABLED              = 556,
+
     LANG_YOURS_LEVEL_UP                 = 557,
     LANG_YOURS_LEVEL_DOWN               = 558,
     LANG_YOURS_LEVEL_PROGRESS_RESET     = 559,
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Miscellaneous/SharedDefines.h
--- a/src/server/game/Miscellaneous/SharedDefines.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Miscellaneous/SharedDefines.h	Mon Apr 16 14:29:17 2012 +0300
@@ -248,7 +248,8 @@
     SPELL_CATEGORY_DRINK            = 59,
 };
 
-const uint32 ItemQualityColors[MAX_ITEM_QUALITY] = {
+const uint32 ItemQualityColors[MAX_ITEM_QUALITY] =
+{
     0xff9d9d9d,        //GREY
     0xffffffff,        //WHITE
     0xff1eff00,        //GREEN
@@ -268,7 +269,7 @@
     SPELL_ATTR0_UNK0                             = 0x00000001, //  0
     SPELL_ATTR0_REQ_AMMO                         = 0x00000002, //  1 on next ranged
     SPELL_ATTR0_ON_NEXT_SWING                    = 0x00000004, //  2
-    SPELL_ATTR0_UNK3                             = 0x00000008, //  3 not set in 3.0.3
+    SPELL_ATTR0_IS_REPLENISHMENT                 = 0x00000008, //  3 not set in 3.0.3
     SPELL_ATTR0_ABILITY                          = 0x00000010, //  4 client puts 'ability' instead of 'spell' in game strings for these spells
     SPELL_ATTR0_TRADESPELL                       = 0x00000020, //  5 trade spells (recipes), will be added by client to a sublist of profession spell
     SPELL_ATTR0_PASSIVE                          = 0x00000040, //  6 Passive spell
@@ -313,7 +314,7 @@
     SPELL_ATTR1_MELEE_COMBAT_START               = 0x00000200, //  9 player starts melee combat after this spell is cast
     SPELL_ATTR1_NO_THREAT                        = 0x00000400, // 10 no generates threat on cast 100% (old NO_INITIAL_AGGRO)
     SPELL_ATTR1_UNK11                            = 0x00000800, // 11 aura
-    SPELL_ATTR1_UNK12                            = 0x00001000, // 12 pickpoket
+    SPELL_ATTR1_IS_PICKPOCKET                    = 0x00001000, // 12 Pickpocket
     SPELL_ATTR1_FARSIGHT                         = 0x00002000, // 13 Client removes farsight on aura loss
     SPELL_ATTR1_CHANNEL_TRACK_TARGET             = 0x00004000, // 14 Client automatically forces player to face target when channeling
     SPELL_ATTR1_DISPEL_AURAS_ON_IMMUNITY         = 0x00008000, // 15 remove auras on immunity
@@ -325,7 +326,7 @@
     SPELL_ATTR1_UNK21                            = 0x00200000, // 21
     SPELL_ATTR1_REQ_COMBO_POINTS2                = 0x00400000, // 22 Req combo points on target
     SPELL_ATTR1_UNK23                            = 0x00800000, // 23
-    SPELL_ATTR1_UNK24                            = 0x01000000, // 24 only fishing spells
+    SPELL_ATTR1_IS_FISHING                       = 0x01000000, // 24 only fishing spells
     SPELL_ATTR1_UNK25                            = 0x02000000, // 25
     SPELL_ATTR1_UNK26                            = 0x04000000, // 26 works correctly with [target=focus] and [target=mouseover] macros?
     SPELL_ATTR1_UNK27                            = 0x08000000, // 27 melee spell?
@@ -350,17 +351,17 @@
     SPELL_ATTR2_UNK10                            = 0x00000400, // 10 related to tame
     SPELL_ATTR2_HEALTH_FUNNEL                    = 0x00000800, // 11
     SPELL_ATTR2_UNK12                            = 0x00001000, // 12 Cleave, Heart Strike, Maul, Sunder Armor, Swipe
-    SPELL_ATTR2_UNK13                            = 0x00002000, // 13 Items enchanted by spells with this flag preserve the enchant to arenas
+    SPELL_ATTR2_PRESERVE_ENCHANT_IN_ARENA        = 0x00002000, // 13 Items enchanted by spells with this flag preserve the enchant to arenas
     SPELL_ATTR2_UNK14                            = 0x00004000, // 14
     SPELL_ATTR2_UNK15                            = 0x00008000, // 15 not set in 3.0.3
     SPELL_ATTR2_TAME_BEAST                       = 0x00010000, // 16
     SPELL_ATTR2_NOT_RESET_AUTO_ACTIONS           = 0x00020000, // 17 don't reset timers for melee autoattacks (swings) or ranged autoattacks (autoshoots)
-    SPELL_ATTR2_UNK18                            = 0x00040000, // 18 Only Revive pet - possible req dead pet
+    SPELL_ATTR2_REQ_DEAD_PET                     = 0x00040000, // 18 Only Revive pet and Heart of the Pheonix
     SPELL_ATTR2_NOT_NEED_SHAPESHIFT              = 0x00080000, // 19 does not necessarly need shapeshift
     SPELL_ATTR2_UNK20                            = 0x00100000, // 20
     SPELL_ATTR2_DAMAGE_REDUCED_SHIELD            = 0x00200000, // 21 for ice blocks, pala immunity buffs, priest absorb shields, but used also for other spells -> not sure!
     SPELL_ATTR2_UNK22                            = 0x00400000, // 22 Ambush, Backstab, Cheap Shot, Death Grip, Garrote, Judgements, Mutilate, Pounce, Ravage, Shiv, Shred
-    SPELL_ATTR2_UNK23                            = 0x00800000, // 23 Only mage Arcane Concentration have this flag
+    SPELL_ATTR2_IS_ARCANE_CONCENTRATION          = 0x00800000, // 23 Only mage Arcane Concentration have this flag
     SPELL_ATTR2_UNK24                            = 0x01000000, // 24
     SPELL_ATTR2_UNK25                            = 0x02000000, // 25
     SPELL_ATTR2_UNK26                            = 0x04000000, // 26 unaffected by school immunity
@@ -387,7 +388,7 @@
     SPELL_ATTR3_BATTLEGROUND                     = 0x00000800, // 11 Can casted only on battleground
     SPELL_ATTR3_ONLY_TARGET_GHOSTS               = 0x00001000, // 12
     SPELL_ATTR3_UNK13                            = 0x00002000, // 13
-    SPELL_ATTR3_UNK14                            = 0x00004000, // 14 "Honorless Target" only this spells have this flag
+    SPELL_ATTR3_IS_HONORLESS_TARGET              = 0x00004000, // 14 "Honorless Target" only this spells have this flag
     SPELL_ATTR3_UNK15                            = 0x00008000, // 15 Auto Shoot, Shoot, Throw,  - this is autoshot flag
     SPELL_ATTR3_CANT_TRIGGER_PROC                = 0x00010000, // 16 confirmed with many patchnotes
     SPELL_ATTR3_NO_INITIAL_AGGRO                 = 0x00020000, // 17 Soothe Animal, 39758, Mind Soothe
@@ -409,8 +410,8 @@
 
 enum SpellAttr4
 {
-    SPELL_ATTR4_UNK0                             = 0x00000001, //  0
-    SPELL_ATTR4_PROC_ONLY_ON_DUMMY               = 0x00000002, //  1 proc only on SPELL_EFFECT_DUMMY?
+    SPELL_ATTR4_IGNORE_RESISTANCES               = 0x00000001, //  0 spells with this attribute will completely ignore the target's resistance (these spells can't be resisted)
+    SPELL_ATTR4_PROC_ONLY_ON_CASTER              = 0x00000002, //  1 proc only on effects with TARGET_UNIT_CASTER?
     SPELL_ATTR4_UNK2                             = 0x00000004, //  2
     SPELL_ATTR4_UNK3                             = 0x00000008, //  3
     SPELL_ATTR4_UNK4                             = 0x00000010, //  4 This will no longer cause guards to attack on use??
@@ -431,16 +432,16 @@
     SPELL_ATTR4_UNK19                            = 0x00080000, // 19 proc dalayed, after damage or don't proc on absorb?
     SPELL_ATTR4_NOT_CHECK_SELFCAST_POWER         = 0x00100000, // 20 supersedes message "More powerful spell applied" for self casts.
     SPELL_ATTR4_UNK21                            = 0x00200000, // 21 Pally aura, dk presence, dudu form, warrior stance, shadowform, hunter track
-    SPELL_ATTR4_UNK22                            = 0x00400000, // 22
+    SPELL_ATTR4_UNK22                            = 0x00400000, // 22 Seal of Command (42058,57770) and Gymer's Smash 55426
     SPELL_ATTR4_UNK23                            = 0x00800000, // 23
     SPELL_ATTR4_UNK24                            = 0x01000000, // 24 some shoot spell
-    SPELL_ATTR4_UNK25                            = 0x02000000, // 25 pet scaling auras
+    SPELL_ATTR4_IS_PET_SCALING                   = 0x02000000, // 25 pet scaling auras
     SPELL_ATTR4_CAST_ONLY_IN_OUTLAND             = 0x04000000, // 26 Can only be used in Outland.
     SPELL_ATTR4_UNK27                            = 0x08000000, // 27
     SPELL_ATTR4_UNK28                            = 0x10000000, // 28 Aimed Shot
     SPELL_ATTR4_UNK29                            = 0x20000000, // 29
     SPELL_ATTR4_UNK30                            = 0x40000000, // 30
-    SPELL_ATTR4_UNK31                            = 0x80000000  // 31
+    SPELL_ATTR4_UNK31                            = 0x80000000  // 31 Polymorph (chicken) 228 and Sonic Boom (38052,38488)
 };
 
 enum SpellAttr5
@@ -460,7 +461,7 @@
     SPELL_ATTR5_UNK12                            = 0x00001000, // 12 Cleave related?
     SPELL_ATTR5_HASTE_AFFECT_DURATION            = 0x00002000, // 13 haste effects decrease duration of this
     SPELL_ATTR5_UNK14                            = 0x00004000, // 14
-    SPELL_ATTR5_UNK15                            = 0x00008000, // 15
+    SPELL_ATTR5_UNK15                            = 0x00008000, // 15 Inflits on multiple targets?
     SPELL_ATTR5_SPECIAL_ITEM_CLASS_CHECK         = 0x00010000, // 16 this allows spells with EquippedItemClass to affect spells from other items if the required item is equipped
     SPELL_ATTR5_USABLE_WHILE_FEARED              = 0x00020000, // 17 usable while feared
     SPELL_ATTR5_USABLE_WHILE_CONFUSED            = 0x00040000, // 18 usable while confused
@@ -3293,20 +3294,20 @@
 // indexes of BattlemasterList.dbc
 enum BattlegroundTypeId
 {
-    BATTLEGROUND_TYPE_NONE     = 0,
-    BATTLEGROUND_AV            = 1,
-    BATTLEGROUND_WS            = 2,
-    BATTLEGROUND_AB            = 3,
-    BATTLEGROUND_NA            = 4,
-    BATTLEGROUND_BE            = 5,
-    BATTLEGROUND_AA            = 6,
-    BATTLEGROUND_EY            = 7,
-    BATTLEGROUND_RL            = 8,
-    BATTLEGROUND_SA            = 9,
-    BATTLEGROUND_DS            = 10,
-    BATTLEGROUND_RV            = 11,
-    BATTLEGROUND_IC            = 30,
-    BATTLEGROUND_RB            = 32
+    BATTLEGROUND_TYPE_NONE     = 0, // None
+    BATTLEGROUND_AV            = 1, // Alterac Valley
+    BATTLEGROUND_WS            = 2, // Warsong Gulch
+    BATTLEGROUND_AB            = 3, // Arathi Basin
+    BATTLEGROUND_NA            = 4, // Nagrand Arena
+    BATTLEGROUND_BE            = 5, // Blade's Edge Arena
+    BATTLEGROUND_AA            = 6, // All Arenas
+    BATTLEGROUND_EY            = 7, // Eye of the Storm
+    BATTLEGROUND_RL            = 8, // Ruins of Lordaernon
+    BATTLEGROUND_SA            = 9, // Strand of the Ancients
+    BATTLEGROUND_DS            = 10, // Dalaran Sewers
+    BATTLEGROUND_RV            = 11, // Ring of Valor
+    BATTLEGROUND_IC            = 30, // Isle of Conquest
+    BATTLEGROUND_RB            = 32 // Random Battleground
 };
 
 #define MAX_BATTLEGROUND_TYPE_ID 33
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Movement/MotionMaster.cpp
--- a/src/server/game/Movement/MotionMaster.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Movement/MotionMaster.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -202,11 +202,11 @@
     }
     else if (_owner->GetTypeId()==TYPEID_UNIT && ((Creature*)_owner)->GetCharmerOrOwnerGUID())
     {
-        sLog->outStaticDebug("Pet or controlled creature (Entry: %u GUID: %u) targeting home", _owner->GetEntry(), _owner->GetGUIDLow() );
+        sLog->outStaticDebug("Pet or controlled creature (Entry: %u GUID: %u) targeting home", _owner->GetEntry(), _owner->GetGUIDLow());
         Unit *target = ((Creature*)_owner)->GetCharmerOrOwner();
         if (target)
         {
-            sLog->outStaticDebug("Following %s (GUID: %u)", target->GetTypeId() == TYPEID_PLAYER ? "player" : "creature", target->GetTypeId() == TYPEID_PLAYER ? target->GetGUIDLow() : ((Creature*)target)->GetDBTableGUIDLow() );
+            sLog->outStaticDebug("Following %s (GUID: %u)", target->GetTypeId() == TYPEID_PLAYER ? "player" : "creature", target->GetTypeId() == TYPEID_PLAYER ? target->GetGUIDLow() : ((Creature*)target)->GetDBTableGUIDLow());
             Mutate(new FollowMovementGenerator<Creature>(*target,PET_FOLLOW_DIST,PET_FOLLOW_ANGLE), MOTION_SLOT_ACTIVE);
         }
     }
@@ -383,6 +383,12 @@
     if (fabs(_owner->GetPositionZ() - tz) < 0.1f)
         return;
 
+    if (_owner->GetTypeId() == TYPEID_PLAYER)
+    {
+        _owner->AddUnitMovementFlag(MOVEMENTFLAG_FALLING);
+        _owner->m_movementInfo.SetFallTime(0);
+    }
+
     Movement::MoveSplineInit init(*_owner);
     init.MoveTo(_owner->GetPositionX(), _owner->GetPositionY(), tz);
     init.SetFall();
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Movement/MovementGenerators/ConfusedMovementGenerator.cpp
--- a/src/server/game/Movement/MovementGenerators/ConfusedMovementGenerator.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Movement/MovementGenerators/ConfusedMovementGenerator.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -32,11 +32,10 @@
 template<class T>
 void ConfusedMovementGenerator<T>::Initialize(T &unit)
 {
-    const float wander_distance=4;
-    float x,y,z;
-    x = unit.GetPositionX();
-    y = unit.GetPositionY();
-    z = unit.GetPositionZ();
+    float const wander_distance = 4;
+    float x = unit.GetPositionX();
+    float y = unit.GetPositionY();
+    float z = unit.GetPositionZ();
 
     Map const* map = unit.GetBaseMap();
 
@@ -47,31 +46,42 @@
 
     for (uint8 idx = 0; idx < MAX_CONF_WAYPOINTS + 1; ++idx)
     {
-        const float wanderX=wander_distance*(float)rand_norm() - wander_distance/2;
-        const float wanderY=wander_distance*(float)rand_norm() - wander_distance/2;
-
-        i_waypoints[idx][0] = x + wanderX;
-        i_waypoints[idx][1] = y + wanderY;
+        float wanderX = x + (wander_distance * (float)rand_norm() - wander_distance/2);
+        float wanderY = y + (wander_distance * (float)rand_norm() - wander_distance/2);
 
         // prevent invalid coordinates generation
-        Trinity::NormalizeMapCoord(i_waypoints[idx][0]);
-        Trinity::NormalizeMapCoord(i_waypoints[idx][1]);
+        Trinity::NormalizeMapCoord(wanderX);
+        Trinity::NormalizeMapCoord(wanderY);
 
-        bool is_water = map->IsInWater(i_waypoints[idx][0],i_waypoints[idx][1],z);
-        // if generated wrong path just ignore
-        if ((is_water && !is_water_ok) || (!is_water && !is_land_ok))
+        if (unit.IsWithinLOS(wanderX, wanderY, z))
         {
-            i_waypoints[idx][0] = idx > 0 ? i_waypoints[idx-1][0] : x;
-            i_waypoints[idx][1] = idx > 0 ? i_waypoints[idx-1][1] : y;
+            bool is_water = map->IsInWater(wanderX, wanderY, z);
+
+            if ((is_water && !is_water_ok) || (!is_water && !is_land_ok))
+            {
+                //! Cannot use coordinates outside our InhabitType. Use the current or previous position.
+                wanderX = idx > 0 ? i_waypoints[idx-1][0] : x;
+                wanderY = idx > 0 ? i_waypoints[idx-1][1] : y;
+            }
+        }
+        else
+        {
+            //! Trying to access path outside line of sight. Skip this by using the current or previous position.
+            wanderX = idx > 0 ? i_waypoints[idx-1][0] : x;
+            wanderY = idx > 0 ? i_waypoints[idx-1][1] : y;
         }
 
-        unit.UpdateAllowedPositionZ(i_waypoints[idx][0], i_waypoints[idx][1], z);
-        i_waypoints[idx][2] =  z;
+        unit.UpdateAllowedPositionZ(wanderX, wanderY, z);
+
+        //! Positions are fine - apply them to this waypoint
+        i_waypoints[idx][0] = wanderX;
+        i_waypoints[idx][1] = wanderY;
+        i_waypoints[idx][2] = z;
     }
 
     unit.StopMoving();
     unit.SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_CONFUSED);
-    unit.AddUnitState(UNIT_STATE_CONFUSED|UNIT_STATE_CONFUSED_MOVE);
+    unit.AddUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_CONFUSED_MOVE);
 }
 
 template<>
@@ -94,7 +104,7 @@
     i_nextMove = 1;
     i_nextMoveTime.Reset(0);
     unit.StopMoving();
-    unit.AddUnitState(UNIT_STATE_CONFUSED|UNIT_STATE_CONFUSED_MOVE);
+    unit.AddUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_CONFUSED_MOVE);
 }
 
 template<class T>
@@ -110,20 +120,20 @@
 
         if (unit.movespline->Finalized())
         {
-            i_nextMove = urand(1,MAX_CONF_WAYPOINTS);
-            i_nextMoveTime.Reset(urand(0, 1500-1));     // TODO: check the minimum reset time, should be probably higher
+            i_nextMove = urand(1, MAX_CONF_WAYPOINTS);
+            i_nextMoveTime.Reset(urand(500, 1200)); // Guessed
         }
     }
     else
     {
         // waiting for next move
         i_nextMoveTime.Update(diff);
-        if(i_nextMoveTime.Passed() )
+        if (i_nextMoveTime.Passed())
         {
             // start moving
             unit.AddUnitState(UNIT_STATE_CONFUSED_MOVE);
 
-            ASSERT( i_nextMove <= MAX_CONF_WAYPOINTS );
+            ASSERT(i_nextMove <= MAX_CONF_WAYPOINTS);
             float x = i_waypoints[i_nextMove][0];
             float y = i_waypoints[i_nextMove][1];
             float z = i_waypoints[i_nextMove][2];
@@ -141,14 +151,14 @@
 void ConfusedMovementGenerator<Player>::Finalize(Player &unit)
 {
     unit.RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_CONFUSED);
-    unit.ClearUnitState(UNIT_STATE_CONFUSED|UNIT_STATE_CONFUSED_MOVE);
+    unit.ClearUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_CONFUSED_MOVE);
 }
 
 template<>
 void ConfusedMovementGenerator<Creature>::Finalize(Creature &unit)
 {
     unit.RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_CONFUSED);
-    unit.ClearUnitState(UNIT_STATE_CONFUSED|UNIT_STATE_CONFUSED_MOVE);
+    unit.ClearUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_CONFUSED_MOVE);
     if (unit.getVictim())
         unit.SetTarget(unit.getVictim()->GetGUID());
 }
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Movement/MovementGenerators/ConfusedMovementGenerator.h
--- a/src/server/game/Movement/MovementGenerators/ConfusedMovementGenerator.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Movement/MovementGenerators/ConfusedMovementGenerator.h	Mon Apr 16 14:29:17 2012 +0300
@@ -22,11 +22,10 @@
 #include "MovementGenerator.h"
 #include "Timer.h"
 
-#define MAX_CONF_WAYPOINTS 24
+#define MAX_CONF_WAYPOINTS 24 //! Allows a twelve second confusion if i_nextMove always is the absolute minimum timer.
 
 template<class T>
-class ConfusedMovementGenerator
-: public MovementGeneratorMedium< T, ConfusedMovementGenerator<T> >
+class ConfusedMovementGenerator : public MovementGeneratorMedium< T, ConfusedMovementGenerator<T> >
 {
     public:
         explicit ConfusedMovementGenerator() : i_nextMoveTime(0) {}
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Movement/MovementGenerators/FleeingMovementGenerator.cpp
--- a/src/server/game/Movement/MovementGenerators/FleeingMovementGenerator.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Movement/MovementGenerators/FleeingMovementGenerator.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -28,8 +28,7 @@
 #define MAX_QUIET_DISTANCE 43.0f
 
 template<class T>
-void
-FleeingMovementGenerator<T>::_setTargetLocation(T &owner)
+void FleeingMovementGenerator<T>::_setTargetLocation(T &owner)
 {
     if (!&owner)
         return;
@@ -53,8 +52,7 @@
 }
 
 template<class T>
-bool
-FleeingMovementGenerator<T>::_getPoint(T &owner, float &x, float &y, float &z)
+bool FleeingMovementGenerator<T>::_getPoint(T &owner, float &x, float &y, float &z)
 {
     if (!&owner)
         return false;
@@ -65,8 +63,8 @@
 
     float temp_x, temp_y, angle;
     const Map* _map = owner.GetBaseMap();
-    //primitive path-finding
-    for(uint8 i = 0; i < 18; ++i)
+    // primitive path-finding
+    for (uint8 i = 0; i < 18; ++i)
     {
         if (i_only_forward && i > 2)
             break;
@@ -182,13 +180,12 @@
         }
     }
     i_to_distance_from_caster = 0.0f;
-    i_nextCheckTime.Reset( urand(500,1000) );
+    i_nextCheckTime.Reset(urand(500,1000));
     return false;
 }
 
 template<class T>
-bool
-FleeingMovementGenerator<T>::_setMoveData(T &owner)
+bool FleeingMovementGenerator<T>::_setMoveData(T &owner)
 {
     float cur_dist_xyz = owner.GetDistance(i_caster_x, i_caster_y, i_caster_z);
 
@@ -201,12 +198,12 @@
            (i_last_distance_from_caster < i_to_distance_from_caster && cur_dist_xyz > i_to_distance_from_caster)   ||
                                                             // if we reach bigger distance
            (cur_dist_xyz > MAX_QUIET_DISTANCE) ||           // if we are too far
-           (i_last_distance_from_caster > MIN_QUIET_DISTANCE && cur_dist_xyz < MIN_QUIET_DISTANCE) )
+           (i_last_distance_from_caster > MIN_QUIET_DISTANCE && cur_dist_xyz < MIN_QUIET_DISTANCE))
                                                             // if we leave 'quiet zone'
         {
             // we are very far or too close, stopping
             i_to_distance_from_caster = 0.0f;
-            i_nextCheckTime.Reset( urand(500,1000) );
+            i_nextCheckTime.Reset(urand(500,1000));
             return false;
         }
         else
@@ -280,8 +277,7 @@
 }
 
 template<class T>
-void
-FleeingMovementGenerator<T>::Initialize(T &owner)
+void FleeingMovementGenerator<T>::Initialize(T &owner)
 {
     if (!&owner)
         return;
@@ -312,8 +308,7 @@
 }
 
 template<>
-void
-FleeingMovementGenerator<Creature>::_Init(Creature &owner)
+void FleeingMovementGenerator<Creature>::_Init(Creature &owner)
 {
     if (!&owner)
         return;
@@ -324,8 +319,7 @@
 }
 
 template<>
-void
-FleeingMovementGenerator<Player>::_Init(Player &)
+void FleeingMovementGenerator<Player>::_Init(Player &)
 {
     is_water_ok = true;
     is_land_ok  = true;
@@ -354,8 +348,7 @@
 }
 
 template<class T>
-bool
-FleeingMovementGenerator<T>::Update(T &owner, const uint32 &time_diff)
+bool FleeingMovementGenerator<T>::Update(T &owner, const uint32 &time_diff)
 {
     if (!&owner || !owner.isAlive())
         return false;
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Movement/MovementGenerators/FleeingMovementGenerator.h
--- a/src/server/game/Movement/MovementGenerators/FleeingMovementGenerator.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Movement/MovementGenerators/FleeingMovementGenerator.h	Mon Apr 16 14:29:17 2012 +0300
@@ -22,8 +22,7 @@
 #include "MovementGenerator.h"
 
 template<class T>
-class FleeingMovementGenerator
-: public MovementGeneratorMedium< T, FleeingMovementGenerator<T> >
+class FleeingMovementGenerator : public MovementGeneratorMedium< T, FleeingMovementGenerator<T> >
 {
     public:
         FleeingMovementGenerator(uint64 fright) : i_frightGUID(fright), i_nextCheckTime(0) {}
@@ -55,8 +54,7 @@
         TimeTracker i_nextCheckTime;
 };
 
-class TimedFleeingMovementGenerator
-: public FleeingMovementGenerator<Creature>
+class TimedFleeingMovementGenerator : public FleeingMovementGenerator<Creature>
 {
     public:
         TimedFleeingMovementGenerator(uint64 fright, uint32 time) :
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Movement/MovementGenerators/HomeMovementGenerator.h
--- a/src/server/game/Movement/MovementGenerators/HomeMovementGenerator.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Movement/MovementGenerators/HomeMovementGenerator.h	Mon Apr 16 14:29:17 2012 +0300
@@ -27,8 +27,7 @@
 class HomeMovementGenerator;
 
 template <>
-class HomeMovementGenerator<Creature>
-: public MovementGeneratorMedium< Creature, HomeMovementGenerator<Creature> >
+class HomeMovementGenerator<Creature> : public MovementGeneratorMedium< Creature, HomeMovementGenerator<Creature> >
 {
     public:
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Movement/MovementGenerators/PointMovementGenerator.cpp
--- a/src/server/game/Movement/MovementGenerators/PointMovementGenerator.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Movement/MovementGenerators/PointMovementGenerator.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -46,7 +46,7 @@
     if (!&unit)
         return false;
 
-    if(unit.HasUnitState(UNIT_STATE_ROOT | UNIT_STATE_STUNNED))
+    if (unit.HasUnitState(UNIT_STATE_ROOT | UNIT_STATE_STUNNED))
     {
         unit.ClearUnitState(UNIT_STATE_ROAMING_MOVE);
         return true;
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Movement/MovementGenerators/PointMovementGenerator.h
--- a/src/server/game/Movement/MovementGenerators/PointMovementGenerator.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Movement/MovementGenerators/PointMovementGenerator.h	Mon Apr 16 14:29:17 2012 +0300
@@ -23,8 +23,7 @@
 #include "FollowerReference.h"
 
 template<class T>
-class PointMovementGenerator
-: public MovementGeneratorMedium< T, PointMovementGenerator<T> >
+class PointMovementGenerator : public MovementGeneratorMedium< T, PointMovementGenerator<T> >
 {
     public:
         PointMovementGenerator(uint32 _id, float _x, float _y, float _z, float _speed = 0.0f) : id(_id),
@@ -46,8 +45,7 @@
         float speed;
 };
 
-class AssistanceMovementGenerator
-: public PointMovementGenerator<Creature>
+class AssistanceMovementGenerator : public PointMovementGenerator<Creature>
 {
     public:
         AssistanceMovementGenerator(float _x, float _y, float _z) :
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Movement/MovementGenerators/RandomMovementGenerator.cpp
--- a/src/server/game/Movement/MovementGenerators/RandomMovementGenerator.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Movement/MovementGenerators/RandomMovementGenerator.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -127,8 +127,7 @@
 }
 
 template<>
-void
-RandomMovementGenerator<Creature>::Reset(Creature &creature)
+void RandomMovementGenerator<Creature>::Reset(Creature &creature)
 {
     Initialize(creature);
 }
@@ -141,8 +140,7 @@
 }
 
 template<>
-bool
-RandomMovementGenerator<Creature>::Update(Creature &creature, const uint32 diff)
+bool RandomMovementGenerator<Creature>::Update(Creature &creature, const uint32 diff)
 {
     if (creature.HasUnitState(UNIT_STATE_ROOT | UNIT_STATE_STUNNED | UNIT_STATE_DISTRACTED))
     {
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Movement/MovementGenerators/RandomMovementGenerator.h
--- a/src/server/game/Movement/MovementGenerators/RandomMovementGenerator.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Movement/MovementGenerators/RandomMovementGenerator.h	Mon Apr 16 14:29:17 2012 +0300
@@ -22,8 +22,7 @@
 #include "MovementGenerator.h"
 
 template<class T>
-class RandomMovementGenerator
-: public MovementGeneratorMedium< T, RandomMovementGenerator<T> >
+class RandomMovementGenerator : public MovementGeneratorMedium< T, RandomMovementGenerator<T> >
 {
     public:
         RandomMovementGenerator(float spawn_dist = 0.0f) : i_nextMoveTime(0), wander_distance(spawn_dist) {}
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Movement/MovementGenerators/TargetedMovementGenerator.cpp
--- a/src/server/game/Movement/MovementGenerators/TargetedMovementGenerator.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Movement/MovementGenerators/TargetedMovementGenerator.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -78,7 +78,7 @@
 
         //We don't update Mob Movement, if the difference between New destination and last destination is < BothObjectSize
         float  bothObjectSize = i_target->GetObjectBoundingRadius() + owner.GetObjectBoundingRadius() + CONTACT_DISTANCE;
-        if( i_destinationHolder.HasDestination() && i_destinationHolder.GetDestinationDiff(x,y,z) < bothObjectSize )
+        if ( i_destinationHolder.HasDestination() && i_destinationHolder.GetDestinationDiff(x,y,z) < bothObjectSize )
             return;
     */
 
@@ -135,7 +135,7 @@
     }
 
     // prevent movement while casting spells with cast time or channel time
-    if (owner.IsNonMeleeSpellCasted(false, false,  true))
+    if (owner.HasUnitState(UNIT_STATE_CASTING))
     {
         if (!owner.IsStopped())
             owner.StopMoving();
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Movement/MovementGenerators/TargetedMovementGenerator.h
--- a/src/server/game/Movement/MovementGenerators/TargetedMovementGenerator.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Movement/MovementGenerators/TargetedMovementGenerator.h	Mon Apr 16 14:29:17 2012 +0300
@@ -34,8 +34,7 @@
 };
 
 template<class T, typename D>
-class TargetedMovementGeneratorMedium
-: public MovementGeneratorMedium< T, D >, public TargetedMovementGeneratorBase
+class TargetedMovementGeneratorMedium : public MovementGeneratorMedium< T, D >, public TargetedMovementGeneratorBase
 {
     protected:
         TargetedMovementGeneratorMedium(Unit &target, float offset, float angle) :
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Movement/MovementGenerators/WaypointMovementGenerator.cpp
--- a/src/server/game/Movement/MovementGenerators/WaypointMovementGenerator.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Movement/MovementGenerators/WaypointMovementGenerator.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -231,7 +231,7 @@
     uint32 end = GetPathAtMapEnd();
     for (uint32 i = GetCurrentNode(); i != end; ++i)
     {
-        G3D::Vector3 vertice((*i_path)[i].x,(*i_path)[i].y,(*i_path)[i].z);
+        G3D::Vector3 vertice((*i_path)[i].x, (*i_path)[i].y, (*i_path)[i].z);
         init.Path().push_back(vertice);
     }
     init.SetFirstPointId(GetCurrentNode());
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Movement/MovementGenerators/WaypointMovementGenerator.h
--- a/src/server/game/Movement/MovementGenerators/WaypointMovementGenerator.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Movement/MovementGenerators/WaypointMovementGenerator.h	Mon Apr 16 14:29:17 2012 +0300
@@ -58,9 +58,8 @@
 class WaypointMovementGenerator;
 
 template<>
-class WaypointMovementGenerator<Creature>
-: public MovementGeneratorMedium< Creature, WaypointMovementGenerator<Creature> >,
-public PathMovementBase<Creature, WaypointPath const*>
+class WaypointMovementGenerator<Creature> : public MovementGeneratorMedium< Creature, WaypointMovementGenerator<Creature> >,
+    public PathMovementBase<Creature, WaypointPath const*>
 {
     public:
         WaypointMovementGenerator(uint32 _path_id = 0, bool _repeating = true)
@@ -110,9 +109,8 @@
 /** FlightPathMovementGenerator generates movement of the player for the paths
  * and hence generates ground and activities for the player.
  */
-class FlightPathMovementGenerator
-: public MovementGeneratorMedium< Player, FlightPathMovementGenerator >,
-public PathMovementBase<Player, TaxiPathNodeList const*>
+class FlightPathMovementGenerator : public MovementGeneratorMedium< Player, FlightPathMovementGenerator >,
+    public PathMovementBase<Player, TaxiPathNodeList const*>
 {
     public:
         explicit FlightPathMovementGenerator(TaxiPathNodeList const& pathnodes, uint32 startNode = 0)
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Movement/Spline/MoveSpline.cpp
--- a/src/server/game/Movement/Spline/MoveSpline.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Movement/Spline/MoveSpline.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -288,7 +288,7 @@
         str << "facing  angle: " << facing.angle;
     else if (splineflags.final_target)
         str << "facing target: " << facing.target;
-    else if(splineflags.final_point)
+    else if (splineflags.final_point)
         str << "facing  point: " << facing.f.x << " " << facing.f.y << " " << facing.f.z;
     str << std::endl;
     str << "time passed: " << time_passed << std::endl;
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Movement/Spline/MovementPacketBuilder.cpp
--- a/src/server/game/Movement/Spline/MovementPacketBuilder.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Movement/Spline/MovementPacketBuilder.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -111,7 +111,7 @@
             Vector3 middle = (real_path[0] + real_path[last_idx]) / 2.f;
             Vector3 offset;
             // first and last points already appended
-            for(uint32 i = 1; i < last_idx; ++i)
+            for (uint32 i = 1; i < last_idx; ++i)
             {
                 offset = middle - real_path[i];
                 data.appendPackXYZ(offset.x, offset.y, offset.z);
@@ -169,7 +169,7 @@
             {
                 data << move_spline.facing.target;
             }
-            else if(splineFlags.final_point)
+            else if (splineFlags.final_point)
             {
                 data << move_spline.facing.f.x << move_spline.facing.f.y << move_spline.facing.f.z;
             }
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Movement/Waypoints/WaypointManager.cpp
--- a/src/server/game/Movement/Waypoints/WaypointManager.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Movement/Waypoints/WaypointManager.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -43,6 +43,7 @@
 {
     uint32 oldMSTime = getMSTime();
 
+    //                                                0    1         2           3          4            5           6        7      8           9
     QueryResult result = WorldDatabase.Query("SELECT id, point, position_x, position_y, position_z, orientation, move_flag, delay, action, action_chance FROM waypoint_data ORDER BY id, point");
 
     if (!result)
@@ -78,7 +79,7 @@
         wp->run = fields[6].GetBool();
         wp->delay = fields[7].GetUInt32();
         wp->event_id = fields[8].GetUInt32();
-        wp->event_chance = fields[9].GetUInt8();
+        wp->event_chance = fields[9].GetInt16();
 
         path.push_back(wp);
         ++count;
@@ -100,7 +101,12 @@
         _waypointStore.erase(itr);
     }
 
-    QueryResult result = WorldDatabase.PQuery("SELECT point, position_x, position_y, position_z, orientation, move_flag, delay, action, action_chance FROM waypoint_data WHERE id = %u ORDER BY point", id);
+    PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_WAYPOINT_DATA_BY_ID);
+
+    stmt->setUInt32(0, id);
+
+    PreparedQueryResult result = WorldDatabase.Query(stmt);
+
     if (!result)
         return;
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/OutdoorPvP/OutdoorPvPMgr.cpp
--- a/src/server/game/OutdoorPvP/OutdoorPvPMgr.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/OutdoorPvP/OutdoorPvPMgr.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -28,7 +28,7 @@
     //sLog->outDebug(LOG_FILTER_OUTDOORPVP, "Instantiating OutdoorPvPMgr");
 }
 
-OutdoorPvPMgr::~OutdoorPvPMgr()
+void OutdoorPvPMgr::Die()
 {
     //sLog->outDebug(LOG_FILTER_OUTDOORPVP, "Deleting OutdoorPvPMgr");
     for (OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
@@ -42,7 +42,7 @@
 {
     uint32 oldMSTime = getMSTime();
 
-    //                                                       0       1
+    //                                                 0       1
     QueryResult result = WorldDatabase.Query("SELECT TypeId, ScriptName FROM outdoorpvp_template");
 
     if (!result)
@@ -59,7 +59,7 @@
     {
         Field* fields = result->Fetch();
 
-        typeId = fields[0].GetUInt32();
+        typeId = fields[0].GetUInt8();
 
         if (DisableMgr::IsDisabledFor(DISABLE_TYPE_OUTDOORPVP, typeId, NULL))
             continue;
diff -r b4c056460923 -r da13f4f7a26c src/server/game/OutdoorPvP/OutdoorPvPMgr.h
--- a/src/server/game/OutdoorPvP/OutdoorPvPMgr.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/OutdoorPvP/OutdoorPvPMgr.h	Mon Apr 16 14:29:17 2012 +0300
@@ -42,12 +42,15 @@
 
     private:
         OutdoorPvPMgr();
-        ~OutdoorPvPMgr();
+        ~OutdoorPvPMgr() {};
 
     public:
         // create outdoor pvp events
         void InitOutdoorPvP();
 
+        // cleanup
+        void Die();
+
         // called when a player enters an outdoor pvp area
         void HandlePlayerEnterZone(Player* player, uint32 areaflag);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Pools/PoolMgr.cpp
--- a/src/server/game/Pools/PoolMgr.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Pools/PoolMgr.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -440,7 +440,12 @@
     // load state from db
     if (!triggerFrom)
     {
-        QueryResult result = CharacterDatabase.PQuery("SELECT quest_id FROM pool_quest_save WHERE pool_id = %u", poolId);
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_POOL_QUEST_SAVE);
+
+        stmt->setUInt32(0, poolId);
+
+        PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
         if (result)
         {
             do
@@ -474,7 +479,7 @@
     {
         do
         {
-            uint32 questId = SelectRandomContainerElement(currentQuests);
+            uint32 questId = Trinity::Containers::SelectRandomContainerElement(currentQuests);
             newQuests.insert(questId);
             currentQuests.erase(questId);
         } while (newQuests.size() < limit && !currentQuests.empty()); // failsafe
@@ -486,7 +491,7 @@
     // activate <limit> random quests
     do
     {
-        uint32 questId = SelectRandomContainerElement(newQuests);
+        uint32 questId = Trinity::Containers::SelectRandomContainerElement(newQuests);
         spawns.ActivateObject<Quest>(questId, poolId);
         PoolObject tempObj(questId, 0.0f);
         Spawn1Object(&tempObj);
@@ -595,7 +600,7 @@
     {
         uint32 oldMSTime = getMSTime();
 
-        //                                                 1     2           3
+        //                                                 1       2         3
         QueryResult result = WorldDatabase.Query("SELECT guid, pool_entry, chance FROM pool_creature");
 
         if (!result)
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Quests/QuestDef.cpp
--- a/src/server/game/Quests/QuestDef.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Quests/QuestDef.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -23,31 +23,31 @@
 Quest::Quest(Field* questRecord)
 {
     Id = questRecord[0].GetUInt32();
-    Method = questRecord[1].GetUInt32();
-    Level = questRecord[2].GetInt32();
-    MinLevel = questRecord[3].GetUInt32();
-    MaxLevel = questRecord[4].GetUInt32();
-    ZoneOrSort = questRecord[5].GetInt32();
-    Type = questRecord[6].GetUInt32();
-    SuggestedPlayers = questRecord[7].GetUInt32();
+    Method = questRecord[1].GetUInt8();
+    Level = questRecord[2].GetInt16();
+    MinLevel = questRecord[3].GetUInt8();
+    MaxLevel = questRecord[4].GetUInt8();
+    ZoneOrSort = questRecord[5].GetInt16();
+    Type = questRecord[6].GetUInt16();
+    SuggestedPlayers = questRecord[7].GetUInt8();
     LimitTime = questRecord[8].GetUInt32();
-    RequiredClasses = questRecord[9].GetUInt32();
-    RequiredRaces = questRecord[10].GetUInt32();
-    RequiredSkillId = questRecord[11].GetUInt32();
-    RequiredSkillPoints = questRecord[12].GetUInt32();
-    RequiredFactionId1 = questRecord[13].GetUInt32();
-    RequiredFactionId2 = questRecord[14].GetUInt32();
+    RequiredClasses = questRecord[9].GetUInt16();
+    RequiredRaces = questRecord[10].GetUInt16();
+    RequiredSkillId = questRecord[11].GetUInt16();
+    RequiredSkillPoints = questRecord[12].GetUInt16();
+    RequiredFactionId1 = questRecord[13].GetUInt16();
+    RequiredFactionId2 = questRecord[14].GetUInt16();
     RequiredFactionValue1 = questRecord[15].GetInt32();
     RequiredFactionValue2 = questRecord[16].GetInt32();
-    RequiredMinRepFaction = questRecord[17].GetUInt32();
-    RequiredMaxRepFaction = questRecord[18].GetUInt32();
+    RequiredMinRepFaction = questRecord[17].GetUInt16();
+    RequiredMaxRepFaction = questRecord[18].GetUInt16();
     RequiredMinRepValue = questRecord[19].GetInt32();
     RequiredMaxRepValue = questRecord[20].GetInt32();
     PrevQuestId = questRecord[21].GetInt32();
     NextQuestId = questRecord[22].GetInt32();
     ExclusiveGroup = questRecord[23].GetInt32();
     NextQuestIdChain = questRecord[24].GetUInt32();
-    RewardXPId = questRecord[25].GetUInt32();
+    RewardXPId = questRecord[25].GetUInt8();
     RewardOrRequiredMoney = questRecord[26].GetInt32();
     RewardMoneyMaxLevel = questRecord[27].GetUInt32();
     RewardSpell = questRecord[28].GetUInt32();
@@ -57,29 +57,29 @@
     RewardMailTemplateId = questRecord[32].GetUInt32();
     RewardMailDelay = questRecord[33].GetUInt32();
     SourceItemId = questRecord[34].GetUInt32();
-    SourceItemIdCount = questRecord[35].GetUInt32();
+    SourceItemIdCount = questRecord[35].GetUInt8();
     SourceSpellid = questRecord[36].GetUInt32();
     Flags = questRecord[37].GetUInt32();
-    uint32 SpecialFlags = questRecord[38].GetUInt16();
-    RewardTitleId = questRecord[39].GetUInt32();
-    RequiredPlayerKills = questRecord[40].GetUInt32();
-    RewardTalents = questRecord[41].GetUInt32();
-    RewardArenaPoints = questRecord[42].GetInt32();
+    uint32 SpecialFlags = questRecord[38].GetUInt8();
+    RewardTitleId = questRecord[39].GetUInt8();
+    RequiredPlayerKills = questRecord[40].GetUInt8();
+    RewardTalents = questRecord[41].GetUInt8();
+    RewardArenaPoints = questRecord[42].GetUInt16();
 
     for (int i = 0; i < QUEST_REWARDS_COUNT; ++i)
         RewardItemId[i] = questRecord[43+i].GetUInt32();
 
     for (int i = 0; i < QUEST_REWARDS_COUNT; ++i)
-        RewardItemIdCount[i] = questRecord[47+i].GetUInt32();
+        RewardItemIdCount[i] = questRecord[47+i].GetUInt16();
 
     for (int i = 0; i < QUEST_REWARD_CHOICES_COUNT; ++i)
         RewardChoiceItemId[i] = questRecord[51+i].GetUInt32();
 
     for (int i = 0; i < QUEST_REWARD_CHOICES_COUNT; ++i)
-        RewardChoiceItemCount[i] = questRecord[57+i].GetUInt32();
+        RewardChoiceItemCount[i] = questRecord[57+i].GetUInt16();
 
     for (int i = 0; i < QUEST_REPUTATIONS_COUNT; ++i)
-        RewardFactionId[i] = questRecord[63+i].GetUInt32();
+        RewardFactionId[i] = questRecord[63+i].GetUInt16();
 
     for (int i = 0; i < QUEST_REPUTATIONS_COUNT; ++i)
         RewardFactionValueId[i] = questRecord[68+i].GetInt32();
@@ -87,7 +87,7 @@
     for (int i = 0; i < QUEST_REPUTATIONS_COUNT; ++i)
         RewardFactionValueIdOverride[i] = questRecord[73+i].GetInt32();
 
-    PointMapId = questRecord[78].GetUInt32();
+    PointMapId = questRecord[78].GetUInt16();
     PointX = questRecord[79].GetFloat();
     PointY = questRecord[80].GetFloat();
     PointOption = questRecord[81].GetUInt32();
@@ -103,39 +103,39 @@
         RequiredNpcOrGo[i] = questRecord[89+i].GetInt32();
 
     for (int i = 0; i < QUEST_OBJECTIVES_COUNT; ++i)
-        RequiredNpcOrGoCount[i] = questRecord[93+i].GetUInt32();
+        RequiredNpcOrGoCount[i] = questRecord[93+i].GetUInt16();
 
     for (int i = 0; i < QUEST_SOURCE_ITEM_IDS_COUNT; ++i)
         RequiredSourceItemId[i] = questRecord[97+i].GetUInt32();
 
     for (int i = 0; i < QUEST_SOURCE_ITEM_IDS_COUNT; ++i)
-        RequiredSourceItemCount[i] = questRecord[101+i].GetUInt32();
+        RequiredSourceItemCount[i] = questRecord[101+i].GetUInt16();
 
     for (int i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; ++i)
         RequiredItemId[i] = questRecord[105+i].GetUInt32();
 
     for (int i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; ++i)
-        RequiredItemCount[i] = questRecord[111+i].GetUInt32();
+        RequiredItemCount[i] = questRecord[111+i].GetUInt16();
 
     for (int i = 0; i < QUEST_OBJECTIVES_COUNT; ++i)
         RequiredSpellCast[i] = questRecord[117+i].GetUInt32();
 
-    // int8 Unknown0 = questRecord[121].GetUInt32();
+    // int8 Unknown0 = questRecord[121].GetUInt8();
 
     for (int i = 0; i < QUEST_OBJECTIVES_COUNT; ++i)
         ObjectiveText[i] = questRecord[122+i].GetString();
 
     for (int i = 0; i < QUEST_EMOTE_COUNT; ++i)
-        DetailsEmote[i] = questRecord[126+i].GetUInt32();
+        DetailsEmote[i] = questRecord[126+i].GetUInt16();
 
     for (int i = 0; i < QUEST_EMOTE_COUNT; ++i)
         DetailsEmoteDelay[i] = questRecord[130+i].GetUInt32();
 
-    EmoteOnIncomplete = questRecord[134].GetUInt32();
-    EmoteOnComplete = questRecord[135].GetUInt32();
+    EmoteOnIncomplete = questRecord[134].GetUInt16();
+    EmoteOnComplete = questRecord[135].GetUInt16();
 
     for (int i = 0; i < QUEST_EMOTE_COUNT; ++i)
-        OfferRewardEmote[i] = questRecord[136+i].GetInt32();
+        OfferRewardEmote[i] = questRecord[136+i].GetInt16();
 
     for (int i = 0; i < QUEST_EMOTE_COUNT; ++i)
         OfferRewardEmoteDelay[i] = questRecord[140+i].GetInt32();
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Reputation/ReputationMgr.cpp
--- a/src/server/game/Reputation/ReputationMgr.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Reputation/ReputationMgr.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -525,7 +525,7 @@
                 FactionState* faction = &_factions[factionEntry->reputationListID];
 
                 // update standing to current
-                faction->Standing = int32(fields[1].GetUInt32());
+                faction->Standing = fields[1].GetInt32();
 
                 // update counters
                 int32 BaseRep = GetBaseReputation(factionEntry);
@@ -572,8 +572,18 @@
     {
         if (itr->second.needSave)
         {
-            trans->PAppend("DELETE FROM character_reputation WHERE guid = '%u' AND faction='%u'", _player->GetGUIDLow(), itr->second.ID);
-            trans->PAppend("INSERT INTO character_reputation (guid, faction, standing, flags) VALUES ('%u', '%u', '%i', '%u')", _player->GetGUIDLow(), itr->second.ID, itr->second.Standing, itr->second.Flags);
+            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_REPUTATION_BY_FACTION);
+            stmt->setUInt32(0, _player->GetGUIDLow());
+            stmt->setUInt16(1, uint16(itr->second.ID));
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_REPUTATION_BY_FACTION);
+            stmt->setUInt32(0, _player->GetGUIDLow());
+            stmt->setUInt16(1, uint16(itr->second.ID));
+            stmt->setInt32(2, itr->second.Standing);
+            stmt->setUInt16(3, uint16(itr->second.Flags));
+            trans->Append(stmt);
+
             itr->second.needSave = false;
         }
     }
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Reputation/ReputationMgr.h
--- a/src/server/game/Reputation/ReputationMgr.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Reputation/ReputationMgr.h	Mon Apr 16 14:29:17 2012 +0300
@@ -132,6 +132,9 @@
 
         void ApplyForceReaction(uint32 faction_id, ReputationRank rank, bool apply);
 
+        //! Public for chat command needs
+        bool SetOneFactionReputation(FactionEntry const* factionEntry, int32 standing, bool incremental);
+
     public:                                                 // senders
         void SendInitialReputations();
         void SendForceReactions();
@@ -142,7 +145,6 @@
         void Initialize();
         uint32 GetDefaultStateFlags(FactionEntry const* factionEntry) const;
         bool SetReputation(FactionEntry const* factionEntry, int32 standing, bool incremental);
-        bool SetOneFactionReputation(FactionEntry const* factionEntry, int32 standing, bool incremental);
         void SetVisible(FactionState* faction);
         void SetAtWar(FactionState* faction, bool atWar) const;
         void SetInactive(FactionState* faction, bool inactive) const;
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Scripting/MapScripts.cpp
--- a/src/server/game/Scripting/MapScripts.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Scripting/MapScripts.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -566,7 +566,7 @@
                                 step.script->GetDebugInfo().c_str(), target->GetTypeId(), target->GetEntry(), target->GetGUIDLow());
                             break;
                         }
-                        worldObject =  dynamic_cast<WorldObject*>(target);
+                        worldObject = dynamic_cast<WorldObject*>(target);
                     }
                     else
                     {
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Scripting/ScriptMgr.cpp
--- a/src/server/game/Scripting/ScriptMgr.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Scripting/ScriptMgr.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -260,7 +260,7 @@
 void ScriptMgr::Unload()
 {
     #define SCR_CLEAR(T) \
-        FOR_SCRIPTS(T, itr, end) \
+        for (SCR_REG_ITR(T) itr = SCR_REG_LST(T).begin(); itr != SCR_REG_LST(T).end(); ++itr) \
             delete itr->second; \
         SCR_REG_LST(T).clear();
 
@@ -583,7 +583,7 @@
 {
     ASSERT(map);
 
-    SCR_MAP_BGN(WorldMapScript, map, itr, end, entry, IsContinent);
+    SCR_MAP_BGN(WorldMapScript, map, itr, end, entry, IsWorldMap);
         itr->second->OnCreate(map);
     SCR_MAP_END;
 
@@ -600,7 +600,7 @@
 {
     ASSERT(map);
 
-    SCR_MAP_BGN(WorldMapScript, map, itr, end, entry, IsContinent);
+    SCR_MAP_BGN(WorldMapScript, map, itr, end, entry, IsWorldMap);
         itr->second->OnDestroy(map);
     SCR_MAP_END;
 
@@ -618,7 +618,7 @@
     ASSERT(map);
     ASSERT(gmap);
 
-    SCR_MAP_BGN(WorldMapScript, map, itr, end, entry, IsContinent);
+    SCR_MAP_BGN(WorldMapScript, map, itr, end, entry, IsWorldMap);
         itr->second->OnLoadGridMap(map, gmap, gx, gy);
     SCR_MAP_END;
 
@@ -636,7 +636,7 @@
     ASSERT(map);
     ASSERT(gmap);
 
-    SCR_MAP_BGN(WorldMapScript, map, itr, end, entry, IsContinent);
+    SCR_MAP_BGN(WorldMapScript, map, itr, end, entry, IsWorldMap);
         itr->second->OnUnloadGridMap(map, gmap, gx, gy);
     SCR_MAP_END;
 
@@ -654,7 +654,7 @@
     ASSERT(map);
     ASSERT(player);
 
-    SCR_MAP_BGN(WorldMapScript, map, itr, end, entry, IsContinent);
+    SCR_MAP_BGN(WorldMapScript, map, itr, end, entry, IsWorldMap);
         itr->second->OnPlayerEnter(map, player);
     SCR_MAP_END;
 
@@ -672,7 +672,7 @@
     ASSERT(map);
     ASSERT(player);
 
-    SCR_MAP_BGN(WorldMapScript, map, itr, end, entry, IsContinent);
+    SCR_MAP_BGN(WorldMapScript, map, itr, end, entry, IsWorldMap);
         itr->second->OnPlayerLeave(map, player);
     SCR_MAP_END;
 
@@ -689,7 +689,7 @@
 {
     ASSERT(map);
 
-    SCR_MAP_BGN(WorldMapScript, map, itr, end, entry, IsContinent);
+    SCR_MAP_BGN(WorldMapScript, map, itr, end, entry, IsWorldMap);
         itr->second->OnUpdate(map, diff);
     SCR_MAP_END;
 
@@ -960,6 +960,14 @@
     return tmpscript->OnDummyEffect(caster, spellId, effIndex, target);
 }
 
+GameObjectAI* ScriptMgr::GetGameObjectAI(GameObject* go)
+{
+    ASSERT(go);
+
+    GET_SCRIPT_RET(GameObjectScript, go->GetScriptId(), tmpscript, NULL);
+    return tmpscript->GetAI(go);
+}
+
 bool ScriptMgr::OnAreaTrigger(Player* player, AreaTriggerEntry const* trigger)
 {
     ASSERT(player);
@@ -1421,7 +1429,7 @@
 WorldMapScript::WorldMapScript(const char* name, uint32 mapId)
     : ScriptObject(name), MapScript<Map>(mapId)
 {
-    if (GetEntry() && !GetEntry()->IsContinent())
+    if (GetEntry() && !GetEntry()->IsWorldMap())
         sLog->outError("WorldMapScript for map %u is invalid.", mapId);
 
     ScriptRegistry<WorldMapScript>::AddScript(this);
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Scripting/ScriptMgr.h
--- a/src/server/game/Scripting/ScriptMgr.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Scripting/ScriptMgr.h	Mon Apr 16 14:29:17 2012 +0300
@@ -39,6 +39,7 @@
 class CreatureAI;
 class DynamicObject;
 class GameObject;
+class GameObjectAI;
 class Guild;
 class GridMap;
 class Group;
@@ -483,6 +484,9 @@
 
         // Called when the game object is damaged (destructible buildings only).
         virtual void OnDamaged(GameObject* /*go*/, Player* /*player*/) { }
+
+        // Called when a GameObjectAI object is needed for the gameobject.
+        virtual GameObjectAI* GetAI(GameObject* /*go*/) const { return NULL; }
 };
 
 class AreaTriggerScript : public ScriptObject
@@ -927,6 +931,7 @@
         void OnGameObjectDestroyed(GameObject* go, Player* player);
         void OnGameObjectDamaged(GameObject* go, Player* player);
         void OnGameObjectUpdate(GameObject* go, uint32 diff);
+        GameObjectAI* GetGameObjectAI(GameObject* go);
 
     public: /* AreaTriggerScript */
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Scripting/ScriptSystem.cpp
--- a/src/server/game/Scripting/ScriptSystem.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Scripting/ScriptSystem.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -30,7 +30,8 @@
 
     sLog->outString("TSCR: Loading Script Texts additional data...");
     uint32 oldMSTime = getMSTime();
-
+    
+    //                                                 0      1      2      3
     QueryResult result = WorldDatabase.Query("SELECT entry, sound, type, language, emote FROM script_texts");
 
     if (!result)
@@ -49,9 +50,9 @@
 
         int32 iId           = pFields[0].GetInt32();
         temp.uiSoundId     = pFields[1].GetUInt32();
-        temp.uiType        = pFields[2].GetUInt32();
-        temp.uiLanguage    = pFields[3].GetUInt32();
-        temp.uiEmote       = pFields[4].GetUInt32();
+        temp.uiType        = pFields[2].GetUInt8();
+        temp.uiLanguage    = pFields[3].GetUInt8();
+        temp.uiEmote       = pFields[4].GetUInt16();
 
         if (iId >= 0)
         {
@@ -109,11 +110,11 @@
         Field* pFields = result->Fetch();
         StringTextData temp;
 
-        int32 iId              = pFields[0].GetInt32();
+        int32 iId             = pFields[0].GetInt32();
         temp.uiSoundId        = pFields[1].GetUInt32();
-        temp.uiType           = pFields[2].GetUInt32();
-        temp.uiLanguage       = pFields[3].GetUInt32();
-        temp.uiEmote          = pFields[4].GetUInt32();
+        temp.uiType           = pFields[2].GetUInt8();
+        temp.uiLanguage       = pFields[3].GetUInt8();
+        temp.uiEmote          = pFields[4].GetUInt16();
 
         if (iId >= 0)
         {
@@ -164,6 +165,7 @@
 
     sLog->outString("TSCR: Loading Script Waypoints for " UI64FMTD " creature(s)...", uiCreatureCount);
 
+    //                                     0       1         2           3           4           5
     result = WorldDatabase.Query("SELECT entry, pointid, location_x, location_y, location_z, waittime FROM script_waypoint ORDER BY pointid");
 
     if (!result)
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Server/Protocol/Opcodes.h
--- a/src/server/game/Server/Protocol/Opcodes.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Server/Protocol/Opcodes.h	Mon Apr 16 14:29:17 2012 +0300
@@ -911,7 +911,7 @@
     CMSG_LFG_SET_ROLES                              = 0x36A,
     CMSG_LFG_SET_NEEDS                              = 0x36B,
     CMSG_LFG_SET_BOOT_VOTE                          = 0x36C,
-    SMSG_LFG_BOOT_PLAYER                            = 0x36D,    // uint8, uint8, uint8, uint64, uint32, uint32, uint32, uint32
+    SMSG_LFG_BOOT_PROPOSAL_UPDATE                   = 0x36D,    // uint8, uint8, uint8, uint64, uint32, uint32, uint32, uint32
     CMSG_LFD_PLAYER_LOCK_INFO_REQUEST               = 0x36E,
     SMSG_LFG_PLAYER_INFO                            = 0x36F,    // uint8, for (uint8) { uint32, uint8, uint32, uint32, uint32, uint32, uint8, for (uint8) {uint32, uint32, uint32}}, uint32, for (uint32) {uint32, uint32}
     CMSG_LFG_TELEPORT                               = 0x370,
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Server/Protocol/WorldLog.cpp
--- a/src/server/game/Server/Protocol/WorldLog.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Server/Protocol/WorldLog.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -34,6 +34,7 @@
 {
     if (i_file != NULL)
         fclose(i_file);
+
     i_file = NULL;
 }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Server/WorldSession.cpp
--- a/src/server/game/Server/WorldSession.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Server/WorldSession.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -121,8 +121,8 @@
     /// - If have unclosed socket, close it
     if (m_Socket)
     {
-        m_Socket->CloseSocket ();
-        m_Socket->RemoveReference ();
+        m_Socket->CloseSocket();
+        m_Socket->RemoveReference();
         m_Socket = NULL;
     }
 
@@ -195,8 +195,8 @@
     }
 #endif                                                      // !TRINITY_DEBUG
 
-    if (m_Socket->SendPacket (*packet) == -1)
-        m_Socket->CloseSocket ();
+    if (m_Socket->SendPacket(*packet) == -1)
+        m_Socket->CloseSocket();
 }
 
 /// Add an incoming packet to the queue
@@ -527,7 +527,7 @@
 
         ///- Broadcast a logout message to the player's friends
         sSocialMgr->SendFriendStatus(_player, FRIEND_OFFLINE, _player->GetGUIDLow(), true);
-        sSocialMgr->RemovePlayerSocial (_player->GetGUIDLow ());
+        sSocialMgr->RemovePlayerSocial(_player->GetGUIDLow());
 
         // Call script hook before deletion
         sScriptMgr->OnPlayerLogout(GetPlayer());
@@ -831,8 +831,8 @@
         in conjunction with any of the moving movement flags such as MOVEMENTFLAG_FORWARD.
         It will freeze clients that receive this player's movement info.
     */
-    REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_ROOT) && mi->HasMovementFlag(MOVEMENTFLAG_MASK_MOVING),
-        MOVEMENTFLAG_MASK_MOVING);
+    REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_ROOT),
+        MOVEMENTFLAG_ROOT);
 
     //! Cannot hover without SPELL_AURA_HOVER
     REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_HOVER) && !GetPlayer()->HasAuraType(SPELL_AURA_HOVER),
@@ -921,6 +921,7 @@
 {
     if (data.rpos() + 4 > data.size())
         return;
+
     uint32 size;
     data >> size;
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Server/WorldSocket.cpp
--- a/src/server/game/Server/WorldSocket.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Server/WorldSocket.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -152,7 +152,7 @@
     return m_Address;
 }
 
-int WorldSocket::SendPacket (const WorldPacket& pct)
+int WorldSocket::SendPacket(const WorldPacket& pct)
 {
     ACE_GUARD_RETURN (LockType, Guard, m_OutBufferLock, -1);
 
@@ -252,7 +252,7 @@
 
     if (peer().get_remote_addr(remote_addr) == -1)
     {
-        sLog->outError ("WorldSocket::open: peer().get_remote_addr errno = %s", ACE_OS::strerror (errno));
+        sLog->outError("WorldSocket::open: peer().get_remote_addr errno = %s", ACE_OS::strerror (errno));
         return -1;
     }
 
@@ -277,7 +277,7 @@
     // Register with ACE Reactor
     if (reactor()->register_handler(this, ACE_Event_Handler::READ_MASK | ACE_Event_Handler::WRITE_MASK) == -1)
     {
-        sLog->outError ("WorldSocket::open: unable to register client handler errno = %s", ACE_OS::strerror (errno));
+        sLog->outError("WorldSocket::open: unable to register client handler errno = %s", ACE_OS::strerror (errno));
         return -1;
     }
 
@@ -496,7 +496,7 @@
     if ((header.size < 4) || (header.size > 10240) || (header.cmd  > 10240))
     {
         Player* _player = m_Session ? m_Session->GetPlayer() : NULL;
-        sLog->outError ("WorldSocket::handle_input_header(): client (account: %u, char [GUID: %u, name: %s]) sent malformed packet (size: %d, cmd: %d)",
+        sLog->outError("WorldSocket::handle_input_header(): client (account: %u, char [GUID: %u, name: %s]) sent malformed packet (size: %d, cmd: %d)",
             m_Session ? m_Session->GetAccountId() : 0,
             _player ? _player->GetGUIDLow() : 0,
             _player ? _player->GetName() : "<none>",
@@ -602,7 +602,7 @@
         // hope this is not hack, as proper m_RecvWPct is asserted around
         if (!m_RecvWPct)
         {
-            sLog->outError ("Forcing close on input m_RecvWPct = NULL");
+            sLog->outError("Forcing close on input m_RecvWPct = NULL");
             errno = EINVAL;
             return -1;
         }
@@ -648,7 +648,7 @@
         (this, ACE_Event_Handler::WRITE_MASK) == -1)
     {
         // would be good to store errno from reactor with errno guard
-        sLog->outError ("WorldSocket::cancel_wakeup_output");
+        sLog->outError("WorldSocket::cancel_wakeup_output");
         return -1;
     }
 
@@ -667,7 +667,7 @@
     if (reactor()->schedule_wakeup
         (this, ACE_Event_Handler::WRITE_MASK) == -1)
     {
-        sLog->outError ("WorldSocket::schedule_wakeup_output");
+        sLog->outError("WorldSocket::schedule_wakeup_output");
         return -1;
     }
 
@@ -715,7 +715,7 @@
             case CMSG_AUTH_SESSION:
                 if (m_Session)
                 {
-                    sLog->outError ("WorldSocket::ProcessIncoming: Player send CMSG_AUTH_SESSION again");
+                    sLog->outError("WorldSocket::ProcessIncoming: Player send CMSG_AUTH_SESSION again");
                     return -1;
                 }
 
@@ -744,7 +744,7 @@
                 }
                 else
                 {
-                    sLog->outError ("WorldSocket::ProcessIncoming: Client not authed opcode = %u", uint32(opcode));
+                    sLog->outError("WorldSocket::ProcessIncoming: Client not authed opcode = %u", uint32(opcode));
                     return -1;
                 }
             }
@@ -789,9 +789,9 @@
     {
         packet.Initialize(SMSG_AUTH_RESPONSE, 1);
         packet << uint8(AUTH_REJECT);
-        SendPacket (packet);
+        SendPacket(packet);
 
-        sLog->outError ("WorldSocket::HandleAuthSession: World closed, denying client (%s).", GetRemoteAddress().c_str());
+        sLog->outError("WorldSocket::HandleAuthSession: World closed, denying client (%s).", GetRemoteAddress().c_str());
         return -1;
     }
 
@@ -813,13 +813,11 @@
                 clientSeed);
 
     // Get the account information from the realmd database
-    std::string safe_account = account; // Duplicate, else will screw the SHA hash verification below
-    LoginDatabase.EscapeString (safe_account);
-    // No SQL injection, username escaped.
+    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_ACCOUNT_INFO_BY_NAME);
 
-    //                                                 0       1          2       3     4  5      6          7       8         9      10
-    QueryResult result = LoginDatabase.PQuery ("SELECT id, sessionkey, last_ip, locked, v, s, expansion, mutetime, locale, recruiter, os FROM account "
-                                               "WHERE username = '%s'", safe_account.c_str());
+    stmt->setString(0, account);
+
+    PreparedQueryResult result = LoginDatabase.Query(stmt);
 
     // Stop if the account is not found
     if (!result)
@@ -827,9 +825,9 @@
         packet.Initialize (SMSG_AUTH_RESPONSE, 1);
         packet << uint8 (AUTH_UNKNOWN_ACCOUNT);
 
-        SendPacket (packet);
+        SendPacket(packet);
 
-        sLog->outError ("WorldSocket::HandleAuthSession: Sent Auth Response (unknown account).");
+        sLog->outError("WorldSocket::HandleAuthSession: Sent Auth Response (unknown account).");
         return -1;
     }
 
@@ -863,7 +861,7 @@
         {
             packet.Initialize (SMSG_AUTH_RESPONSE, 1);
             packet << uint8 (AUTH_FAILED);
-            SendPacket (packet);
+            SendPacket(packet);
 
             sLog->outBasic ("WorldSocket::HandleAuthSession: Sent Auth Response (Account IP differs).");
             return -1;
@@ -900,37 +898,36 @@
     std::string os = fields[10].GetString();
 
     // Checks gmlevel per Realm
-    result =
-        LoginDatabase.PQuery ("SELECT "
-                              "RealmID, "            //0
-                              "gmlevel "             //1
-                              "FROM account_access "
-                              "WHERE id = '%d'"
-                              " AND (RealmID = '%d'"
-                              " OR RealmID = '-1')",
-                              id, realmID);
+    stmt = LoginDatabase.GetPreparedStatement(LOGIN_GET_GMLEVEL_BY_REALMID);
+
+    stmt->setUInt32(0, id);
+    stmt->setInt32(1, int32(realmID));
+
+    result = LoginDatabase.Query(stmt);
+
     if (!result)
         security = 0;
     else
     {
         fields = result->Fetch();
-        security = fields[1].GetInt32();
+        security = fields[0].GetUInt8();
     }
 
     // Re-check account ban (same check as in realmd)
-    QueryResult banresult =
-          LoginDatabase.PQuery ("SELECT 1 FROM account_banned WHERE id = %u AND active = 1 "
-                                "UNION "
-                                "SELECT 1 FROM ip_banned WHERE ip = '%s'",
-                                id, GetRemoteAddress().c_str());
+    stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_BANS);
+
+    stmt->setUInt32(0, id);
+    stmt->setString(1, GetRemoteAddress());
+
+    PreparedQueryResult banresult = LoginDatabase.Query(stmt);
 
     if (banresult) // if account banned
     {
         packet.Initialize (SMSG_AUTH_RESPONSE, 1);
         packet << uint8 (AUTH_BANNED);
-        SendPacket (packet);
+        SendPacket(packet);
 
-        sLog->outError ("WorldSocket::HandleAuthSession: Sent Auth Response (Account banned).");
+        sLog->outError("WorldSocket::HandleAuthSession: Sent Auth Response (Account banned).");
         return -1;
     }
 
@@ -952,9 +949,9 @@
         WorldPacket Packet (SMSG_AUTH_RESPONSE, 1);
         Packet << uint8 (AUTH_UNAVAILABLE);
 
-        SendPacket (packet);
+        SendPacket(packet);
 
-        sLog->outDetail ("WorldSocket::HandleAuthSession: User tries to login but his security level is not enough");
+        sLog->outDetail("WorldSocket::HandleAuthSession: User tries to login but his security level is not enough");
         return -1;
     }
 
@@ -974,9 +971,9 @@
         packet.Initialize (SMSG_AUTH_RESPONSE, 1);
         packet << uint8 (AUTH_FAILED);
 
-        SendPacket (packet);
+        SendPacket(packet);
 
-        sLog->outError ("WorldSocket::HandleAuthSession: Sent Auth Response (authentification failed).");
+        sLog->outError("WorldSocket::HandleAuthSession: Sent Auth Response (authentification failed).");
         return -1;
     }
 
@@ -987,7 +984,11 @@
                 address.c_str());
 
     // Check if this user is by any chance a recruiter
-    result = LoginDatabase.PQuery ("SELECT 1  FROM account WHERE recruiter = %u", id);
+    stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_ACCOUNT_RECRUITER);
+
+    stmt->setUInt32(0, id);
+
+    result = LoginDatabase.Query(stmt);
 
     bool isRecruiter = false;
     if (result)
@@ -995,7 +996,7 @@
 
     // Update the last_ip in the database
 
-    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_UPD_LAST_IP);
+    stmt = LoginDatabase.GetPreparedStatement(LOGIN_UPD_LAST_IP);
 
     stmt->setString(0, address);
     stmt->setString(1, account);
@@ -1077,7 +1078,7 @@
             m_Session->SetLatency (latency);
         else
         {
-            sLog->outError ("WorldSocket::HandlePing: peer sent CMSG_PING, "
+            sLog->outError("WorldSocket::HandlePing: peer sent CMSG_PING, "
                             "but is not authenticated or got recently kicked, "
                             " address = %s",
                             GetRemoteAddress().c_str());
@@ -1087,5 +1088,5 @@
 
     WorldPacket packet (SMSG_PONG, 4);
     packet << ping;
-    return SendPacket (packet);
+    return SendPacket(packet);
 }
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Server/WorldSocket.h
--- a/src/server/game/Server/WorldSocket.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Server/WorldSocket.h	Mon Apr 16 14:29:17 2012 +0300
@@ -108,7 +108,7 @@
         /// Send A packet on the socket, this function is reentrant.
         /// @param pct packet to send
         /// @return -1 of failure
-        int SendPacket (const WorldPacket& pct);
+        int SendPacket(const WorldPacket& pct);
 
         /// Add reference to this object.
         long AddReference (void);
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Server/WorldSocketMgr.cpp
--- a/src/server/game/Server/WorldSocketMgr.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Server/WorldSocketMgr.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -236,7 +236,7 @@
 
     if (num_threads <= 0)
     {
-        sLog->outError ("Network.Threads is wrong in your config file");
+        sLog->outError("Network.Threads is wrong in your config file");
         return -1;
     }
 
@@ -253,7 +253,7 @@
 
     if (m_SockOutUBuff <= 0)
     {
-        sLog->outError ("Network.OutUBuff is wrong in your config file");
+        sLog->outError("Network.OutUBuff is wrong in your config file");
         return -1;
     }
 
@@ -263,7 +263,7 @@
 
     if (m_Acceptor->open(listen_addr, m_NetThreads[0].GetReactor(), ACE_NONBLOCK) == -1)
     {
-        sLog->outError ("Failed to open acceptor, check if the port is free");
+        sLog->outError("Failed to open acceptor, check if the port is free");
         return -1;
     }
 
@@ -327,7 +327,7 @@
             (void*) & m_SockOutKBuff,
             sizeof (int)) == -1 && errno != ENOTSUP)
         {
-            sLog->outError ("WorldSocketMgr::OnSocketOpen set_option SO_SNDBUF");
+            sLog->outError("WorldSocketMgr::OnSocketOpen set_option SO_SNDBUF");
             return -1;
         }
     }
@@ -342,7 +342,7 @@
             (void*)&ndoption,
             sizeof (int)) == -1)
         {
-            sLog->outError ("WorldSocketMgr::OnSocketOpen: peer().set_option TCP_NODELAY errno = %s", ACE_OS::strerror (errno));
+            sLog->outError("WorldSocketMgr::OnSocketOpen: peer().set_option TCP_NODELAY errno = %s", ACE_OS::strerror (errno));
             return -1;
         }
     }
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Skills/SkillDiscovery.cpp
--- a/src/server/game/Skills/SkillDiscovery.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Skills/SkillDiscovery.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -71,7 +71,7 @@
 
         uint32 spellId         = fields[0].GetUInt32();
         int32  reqSkillOrSpell = fields[1].GetInt32();
-        uint32 reqSkillValue   = fields[2].GetUInt32();
+        uint32 reqSkillValue   = fields[2].GetUInt16();
         float  chance          = fields[3].GetFloat();
 
         if (chance <= 0)                                    // chance
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Skills/SkillExtraItems.cpp
--- a/src/server/game/Skills/SkillExtraItems.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Skills/SkillExtraItems.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -55,7 +55,7 @@
 
     SkillExtraItemStore.clear();                            // need for reload
 
-    //                                                 0        1                       2                       3
+    //                                                  0               1                       2                    3
     QueryResult result = WorldDatabase.Query("SELECT spellId, requiredSpecialization, additionalCreateChance, additionalMaxNum FROM skill_extra_item_template");
 
     if (!result)
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Spells/Auras/SpellAuraEffects.cpp
--- a/src/server/game/Spells/Auras/SpellAuraEffects.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Spells/Auras/SpellAuraEffects.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -1236,12 +1236,11 @@
         if ((*itr)->IsAffectedOnSpell(m_spellInfo) && caster->isSpellCrit(target, m_spellInfo, m_spellInfo->GetSchoolMask()))
             return true;
     }
+
     // Rupture - since 3.3.3 can crit
-    if (target->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_ROGUE, 0x100000, 0x0, 0x0, caster->GetGUID()))
-    {
-        if (caster->isSpellCrit(target, m_spellInfo, m_spellInfo->GetSchoolMask()))
-            return true;
-    }
+    if (m_spellInfo->SpellIconID == 500 && m_spellInfo->SpellFamilyName == SPELLFAMILY_ROGUE)
+        return caster->isSpellCrit(target, m_spellInfo, m_spellInfo->GetSchoolMask());
+
     return false;
 }
 
@@ -1480,6 +1479,23 @@
                 if (spellInfo->Stances & (1<<(GetMiscValue()-1)))
                     target->CastSpell(target, itr->first, true, NULL, this);
             }
+
+            // Also do it for Glyphs
+            for (uint32 i = 0; i < MAX_GLYPH_SLOT_INDEX; ++i)
+            {
+                if (uint32 glyphId = target->ToPlayer()->GetGlyph(i))
+                {
+                    if (GlyphPropertiesEntry const* glyph = sGlyphPropertiesStore.LookupEntry(glyphId))
+                    {
+                        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(glyph->SpellId);
+                        if (!spellInfo || !(spellInfo->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)))
+                            continue;
+                        if (spellInfo->Stances & (1<<(GetMiscValue()-1)))
+                            target->CastSpell(target, glyph->SpellId, true, NULL, this);
+                    }
+                }
+            }
+
             // Leader of the Pack
             if (target->ToPlayer()->HasSpell(17007))
             {
@@ -1589,10 +1605,25 @@
             }
         }
 
+        const Unit::AuraEffectList& shapeshifts = target->GetAuraEffectsByType(SPELL_AURA_MOD_SHAPESHIFT);
+        AuraEffect* newAura = NULL;
+        // Iterate through all the shapeshift auras that the target has, if there is another aura with SPELL_AURA_MOD_SHAPESHIFT, then this aura is being removed due to that one being applied
+        for (Unit::AuraEffectList::const_iterator itr = shapeshifts.begin(); itr != shapeshifts.end(); ++itr)
+        {
+            if ((*itr) != this)
+            {
+                newAura = *itr;
+                break;
+            }
+        }
         Unit::AuraApplicationMap& tAuras = target->GetAppliedAuras();
         for (Unit::AuraApplicationMap::iterator itr = tAuras.begin(); itr != tAuras.end();)
         {
-            if (itr->second->GetBase()->IsRemovedOnShapeLost(target))
+            // Use the new aura to see on what stance the target will be
+            uint32 newStance = (1<<((newAura ? newAura->GetMiscValue() : 0)-1));
+            
+            // If the stances are not compatible with the spell, remove it
+            if (itr->second->GetBase()->IsRemovedOnShapeLost(target) && !(itr->second->GetBase()->GetSpellInfo()->Stances & newStance))
                 target->RemoveAura(itr);
             else
                 ++itr;
@@ -2861,9 +2892,8 @@
     target->SetCanFly(apply);
     if (!apply)
     {
-        target->RemoveUnitMovementFlag(MOVEMENTFLAG_FLYING);
-        target->AddUnitMovementFlag(MOVEMENTFLAG_FALLING);
-        target->m_movementInfo.SetFallTime(0);
+        target->RemoveUnitMovementFlag(MOVEMENTFLAG_MASK_MOVING_FLY);
+        target->GetMotionMaster()->MoveFall();
     }
 
     Player* player = target->ToPlayer();
@@ -2894,10 +2924,7 @@
     if (apply)
         target->AddUnitMovementFlag(MOVEMENTFLAG_WATERWALKING);
     else
-    {
         target->RemoveUnitMovementFlag(MOVEMENTFLAG_WATERWALKING);
-        target->AddUnitMovementFlag(MOVEMENTFLAG_FALLING);
-    }
 
     target->SendMovementWaterWalking();
 }
@@ -3486,7 +3513,7 @@
         {
             bool banishFound = false;
             Unit::AuraEffectList const& banishAuras = target->GetAuraEffectsByType(GetAuraType());
-            for (Unit::AuraEffectList::const_iterator i = banishAuras.begin(); i !=  banishAuras.end(); ++i)
+            for (Unit::AuraEffectList::const_iterator i = banishAuras.begin(); i != banishAuras.end(); ++i)
                 if ((*i)->GetSpellInfo()->Mechanic == MECHANIC_BANISH)
                 {
                     banishFound = true;
@@ -4599,7 +4626,7 @@
 
     flag96 mask;
     Unit::AuraEffectList const& noReagent = target->GetAuraEffectsByType(SPELL_AURA_NO_REAGENT_USE);
-        for (Unit::AuraEffectList::const_iterator i = noReagent.begin(); i !=  noReagent.end(); ++i)
+        for (Unit::AuraEffectList::const_iterator i = noReagent.begin(); i != noReagent.end(); ++i)
             mask |= (*i)->m_spellInfo->Effects[(*i)->m_effIndex].SpellClassMask;
 
     target->SetUInt32Value(PLAYER_NO_REAGENT_COST_1  , mask[0]);
@@ -4773,11 +4800,6 @@
                     if (target->GetTypeId() == TYPEID_PLAYER)
                         target->ToPlayer()->RemoveAmmo();      // not use ammo and not allow use
                     break;
-                case 49028:
-                    if (caster)
-                        if (AuraEffect* aurEff = caster->GetAuraEffect(63330, 0)) // glyph of Dancing Rune Weapon
-                            GetBase()->SetDuration(GetBase()->GetDuration() + aurEff->GetAmount());
-                    break;
                 case 52916: // Honor Among Thieves
                     if (target->GetTypeId() == TYPEID_PLAYER)
                         if (Unit* spellTarget = ObjectAccessor::GetUnit(*target, target->ToPlayer()->GetComboTarget()))
@@ -4964,7 +4986,10 @@
 
                         // final heal
                         int32 stack = GetBase()->GetStackAmount();
-                        target->CastCustomSpell(target, 33778, &m_amount, &stack, NULL, true, NULL, this, GetCasterGUID());
+                        int32 heal = m_amount;
+                        if (caster)
+                            heal = caster->SpellHealingBonus(target, GetSpellInfo(), heal, HEAL, stack);
+                        target->CastCustomSpell(target, 33778, &heal, &stack, NULL, true, NULL, this, GetCasterGUID());
 
                         // restore mana
                         if (caster)
@@ -4974,18 +4999,6 @@
                         }
                     }
                     break;
-                case SPELLFAMILY_HUNTER:
-                    switch (GetId())
-                    {
-                        case 34477: // Misdirection
-                            if (aurApp->GetRemoveMode() != AURA_REMOVE_BY_EXPIRE)
-                                target->SetReducedThreatPercent(0, 0);
-                            break;
-                        case 35079: // Misdirection proc
-                            target->SetReducedThreatPercent(0, 0);
-                            break;
-                    }
-                    break;
                 case SPELLFAMILY_DEATHKNIGHT:
                     // Summon Gargoyle (Dismiss Gargoyle at remove)
                     if (GetId() == 61777)
@@ -5213,7 +5226,7 @@
                         target->CastCustomSpell(target, 50322, &bp0, NULL, NULL, true);
                     }
                     else
-                        target-> RemoveAurasDueToSpell(50322);
+                        target->RemoveAurasDueToSpell(50322);
                     break;
                 }
             }
@@ -5647,21 +5660,6 @@
                     caster->CastCustomSpell(66153, SPELLVALUE_MAX_TARGETS, urand(1, 6), target, true);
                     break;
                 }
-                case 54798: // FLAMING Arrow Triggered Effect
-                {
-                    if (!caster || !target || !target->ToCreature() || !caster->GetVehicle() || target->HasAura(54683))
-                        break;
-
-                    target->CastSpell(target, 54683, true);
-
-                    // Credit Frostworgs
-                    if (target->GetEntry() == 29358)
-                        caster->CastSpell(caster, 54896, true);
-                    // Credit Frost Giants
-                    else if (target->GetEntry() == 29351)
-                        caster->CastSpell(caster, 54893, true);
-                    break;
-                }
                 case 62292: // Blaze (Pool of Tar)
                     // should we use custom damage?
                     target->CastSpell((Unit*)NULL, m_spellInfo->Effects[m_effIndex].TriggerSpell, true);
@@ -5742,7 +5740,7 @@
                     if (targets.empty())
                         return;
 
-                    Unit* spellTarget = SelectRandomContainerElement(targets);
+                    Unit* spellTarget = Trinity::Containers::SelectRandomContainerElement(targets);
 
                     target->CastSpell(spellTarget, 57840, true);
                     target->CastSpell(spellTarget, 57841, true);
@@ -6189,7 +6187,7 @@
 
     uint32 absorb = 0;
     uint32 resist = 0;
-    CleanDamage cleanDamage =  CleanDamage(0, 0, BASE_ATTACK, MELEE_HIT_NORMAL);
+    CleanDamage cleanDamage = CleanDamage(0, 0, BASE_ATTACK, MELEE_HIT_NORMAL);
 
     // ignore non positive values (can be result apply spellmods to aura damage
     uint32 damage = std::max(GetAmount(), 0);
@@ -6288,7 +6286,7 @@
 
 void AuraEffect::HandlePeriodicHealthLeechAuraTick(Unit* target, Unit* caster) const
 {
-    if (!caster || !caster->isAlive() || !target->isAlive())
+    if (!caster || !target->isAlive())
         return;
 
     if (target->HasUnitState(UNIT_STATE_ISOLATED) || target->IsImmunedToDamage(GetSpellInfo()))
@@ -6341,15 +6339,19 @@
     damage = (damage <= absorb+resist) ? 0 : (damage-absorb-resist);
     if (damage)
         procVictim |= PROC_FLAG_TAKEN_DAMAGE;
-    caster->ProcDamageAndSpell(target, procAttacker, procVictim, procEx, damage, BASE_ATTACK, GetSpellInfo());
+    if (caster->isAlive())
+        caster->ProcDamageAndSpell(target, procAttacker, procVictim, procEx, damage, BASE_ATTACK, GetSpellInfo());
     int32 new_damage = caster->DealDamage(target, damage, &cleanDamage, DOT, GetSpellInfo()->GetSchoolMask(), GetSpellInfo(), false);
 
-    float gainMultiplier = GetSpellInfo()->Effects[GetEffIndex()].CalcValueMultiplier(caster);
-
-    uint32 heal = uint32(caster->SpellHealingBonus(caster, GetSpellInfo(), uint32(new_damage * gainMultiplier), DOT, GetBase()->GetStackAmount()));
-
-    int32 gain = caster->HealBySpell(caster, GetSpellInfo(), heal);
-    caster->getHostileRefManager().threatAssist(caster, gain * 0.5f, GetSpellInfo());
+    if (caster->isAlive())
+    {
+        float gainMultiplier = GetSpellInfo()->Effects[GetEffIndex()].CalcValueMultiplier(caster);
+
+        uint32 heal = uint32(caster->SpellHealingBonus(caster, GetSpellInfo(), uint32(new_damage * gainMultiplier), DOT, GetBase()->GetStackAmount()));
+
+        int32 gain = caster->HealBySpell(caster, GetSpellInfo(), heal);
+        caster->getHostileRefManager().threatAssist(caster, gain * 0.5f, GetSpellInfo());
+    }
 }
 
 void AuraEffect::HandlePeriodicHealthFunnelAuraTick(Unit* target, Unit* caster) const
@@ -6464,7 +6466,7 @@
     caster->CalcHealAbsorb(target, GetSpellInfo(), heal, absorb);
     int32 gain = caster->DealHeal(target, heal);
 
-    SpellPeriodicAuraLogInfo pInfo(this, damage, damage - gain, absorb, 0, 0.0f, crit);
+    SpellPeriodicAuraLogInfo pInfo(this, heal, heal - gain, absorb, 0, 0.0f, crit);
     target->SendPeriodicAuraLog(&pInfo);
 
     target->getHostileRefManager().threatAssist(caster, float(gain) * 0.5f, GetSpellInfo());
@@ -6482,7 +6484,7 @@
         caster->DealDamageMods(caster, funnelDamage, &funnelAbsorb);
         caster->SendSpellNonMeleeDamageLog(caster, GetId(), funnelDamage, GetSpellInfo()->GetSchoolMask(), funnelAbsorb, 0, false, 0, false);
 
-        CleanDamage cleanDamage =  CleanDamage(0, 0, BASE_ATTACK, MELEE_HIT_NORMAL);
+        CleanDamage cleanDamage = CleanDamage(0, 0, BASE_ATTACK, MELEE_HIT_NORMAL);
         caster->DealDamage(caster, funnelDamage, &cleanDamage, NODAMAGE, GetSpellInfo()->GetSchoolMask(), GetSpellInfo(), true);
     }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Spells/Auras/SpellAuras.cpp
--- a/src/server/game/Spells/Auras/SpellAuras.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Spells/Auras/SpellAuras.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -350,7 +350,7 @@
 void Aura::_InitEffects(uint8 effMask, Unit* caster, int32 *baseAmount)
 {
     // shouldn't be in constructor - functions in AuraEffect::AuraEffect use polymorphism
-    for (uint8 i=0 ; i<MAX_SPELL_EFFECTS; ++i)
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
     {
         if (effMask & (uint8(1) << i))
             m_effects[i] = new AuraEffect(this, i, baseAmount ? baseAmount + i : NULL, caster);
@@ -371,7 +371,7 @@
     }
 
     // free effects memory
-    for (uint8 i = 0 ; i < MAX_SPELL_EFFECTS; ++i)
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
          delete m_effects[i];
 
     ASSERT(m_applications.empty());
@@ -453,7 +453,7 @@
     ApplicationMap::iterator appItr = m_applications.begin();
     for (appItr = m_applications.begin(); appItr != m_applications.end();)
     {
-        AuraApplication * aurApp =  appItr->second;
+        AuraApplication * aurApp = appItr->second;
         Unit* target = aurApp->GetTarget();
         target->_UnapplyAura(aurApp, removeMode);
         appItr = m_applications.begin();
@@ -719,7 +719,8 @@
     if (IsPassive() && !m_spellInfo->DurationEntry)
         maxDuration = -1;
 
-    if (!IsPermanent() && modOwner)
+    // IsPermanent() checks max duration (which we are supposed to calculate here)
+    if (maxDuration != -1 && modOwner)
         modOwner->ApplySpellMod(GetId(), SPELLMOD_DURATION, maxDuration);
     return maxDuration;
 }
@@ -2046,7 +2047,7 @@
 void Aura::LoadScripts()
 {
     sScriptMgr->CreateAuraScripts(m_spellInfo->Id, m_loadedScripts);
-    for (std::list<AuraScript*>::iterator itr = m_loadedScripts.begin(); itr != m_loadedScripts.end() ;)
+    for (std::list<AuraScript*>::iterator itr = m_loadedScripts.begin(); itr != m_loadedScripts.end();)
     {
         if (!(*itr)->_Load(this))
         {
@@ -2063,11 +2064,11 @@
 
 bool Aura::CallScriptCheckAreaTargetHandlers(Unit* target)
 {
-    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end(); ++scritr)
     {
         (*scritr)->_PrepareScriptCall(AURA_SCRIPT_HOOK_CHECK_AREA_TARGET);
         std::list<AuraScript::CheckAreaTargetHandler>::iterator hookItrEnd = (*scritr)->DoCheckAreaTarget.end(), hookItr = (*scritr)->DoCheckAreaTarget.begin();
-        for (; hookItr != hookItrEnd ; ++hookItr)
+        for (; hookItr != hookItrEnd; ++hookItr)
             if (!(*hookItr).Call(*scritr, target))
                 return false;
         (*scritr)->_FinishScriptCall();
@@ -2077,11 +2078,11 @@
 
 void Aura::CallScriptDispel(DispelInfo* dispelInfo)
 {
-    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end(); ++scritr)
     {
         (*scritr)->_PrepareScriptCall(AURA_SCRIPT_HOOK_DISPEL);
         std::list<AuraScript::AuraDispelHandler>::iterator hookItrEnd = (*scritr)->OnDispel.end(), hookItr = (*scritr)->OnDispel.begin();
-        for (; hookItr != hookItrEnd ; ++hookItr)
+        for (; hookItr != hookItrEnd; ++hookItr)
             (*hookItr).Call(*scritr, dispelInfo);
         (*scritr)->_FinishScriptCall();
     }
@@ -2089,11 +2090,11 @@
 
 void Aura::CallScriptAfterDispel(DispelInfo* dispelInfo)
 {
-    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end(); ++scritr)
     {
         (*scritr)->_PrepareScriptCall(AURA_SCRIPT_HOOK_AFTER_DISPEL);
         std::list<AuraScript::AuraDispelHandler>::iterator hookItrEnd = (*scritr)->AfterDispel.end(), hookItr = (*scritr)->AfterDispel.begin();
-        for (; hookItr != hookItrEnd ; ++hookItr)
+        for (; hookItr != hookItrEnd; ++hookItr)
             (*hookItr).Call(*scritr, dispelInfo);
         (*scritr)->_FinishScriptCall();
     }
@@ -2102,11 +2103,11 @@
 bool Aura::CallScriptEffectApplyHandlers(AuraEffect const* aurEff, AuraApplication const* aurApp, AuraEffectHandleModes mode)
 {
     bool preventDefault = false;
-    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end(); ++scritr)
     {
         (*scritr)->_PrepareScriptCall(AURA_SCRIPT_HOOK_EFFECT_APPLY, aurApp);
         std::list<AuraScript::EffectApplyHandler>::iterator effEndItr = (*scritr)->OnEffectApply.end(), effItr = (*scritr)->OnEffectApply.begin();
-        for (; effItr != effEndItr ; ++effItr)
+        for (; effItr != effEndItr; ++effItr)
         {
             if ((*effItr).IsEffectAffected(m_spellInfo, aurEff->GetEffIndex()))
                 (*effItr).Call(*scritr, aurEff, mode);
@@ -2121,11 +2122,11 @@
 bool Aura::CallScriptEffectRemoveHandlers(AuraEffect const* aurEff, AuraApplication const* aurApp, AuraEffectHandleModes mode)
 {
     bool preventDefault = false;
-    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end(); ++scritr)
     {
         (*scritr)->_PrepareScriptCall(AURA_SCRIPT_HOOK_EFFECT_REMOVE, aurApp);
         std::list<AuraScript::EffectApplyHandler>::iterator effEndItr = (*scritr)->OnEffectRemove.end(), effItr = (*scritr)->OnEffectRemove.begin();
-        for (; effItr != effEndItr ; ++effItr)
+        for (; effItr != effEndItr; ++effItr)
         {
             if ((*effItr).IsEffectAffected(m_spellInfo, aurEff->GetEffIndex()))
                 (*effItr).Call(*scritr, aurEff, mode);
@@ -2139,11 +2140,11 @@
 
 void Aura::CallScriptAfterEffectApplyHandlers(AuraEffect const* aurEff, AuraApplication const* aurApp, AuraEffectHandleModes mode)
 {
-    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end(); ++scritr)
     {
         (*scritr)->_PrepareScriptCall(AURA_SCRIPT_HOOK_EFFECT_AFTER_APPLY, aurApp);
         std::list<AuraScript::EffectApplyHandler>::iterator effEndItr = (*scritr)->AfterEffectApply.end(), effItr = (*scritr)->AfterEffectApply.begin();
-        for (; effItr != effEndItr ; ++effItr)
+        for (; effItr != effEndItr; ++effItr)
         {
             if ((*effItr).IsEffectAffected(m_spellInfo, aurEff->GetEffIndex()))
                 (*effItr).Call(*scritr, aurEff, mode);
@@ -2154,11 +2155,11 @@
 
 void Aura::CallScriptAfterEffectRemoveHandlers(AuraEffect const* aurEff, AuraApplication const* aurApp, AuraEffectHandleModes mode)
 {
-    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end(); ++scritr)
     {
         (*scritr)->_PrepareScriptCall(AURA_SCRIPT_HOOK_EFFECT_AFTER_REMOVE, aurApp);
         std::list<AuraScript::EffectApplyHandler>::iterator effEndItr = (*scritr)->AfterEffectRemove.end(), effItr = (*scritr)->AfterEffectRemove.begin();
-        for (; effItr != effEndItr ; ++effItr)
+        for (; effItr != effEndItr; ++effItr)
         {
             if ((*effItr).IsEffectAffected(m_spellInfo, aurEff->GetEffIndex()))
                 (*effItr).Call(*scritr, aurEff, mode);
@@ -2170,11 +2171,11 @@
 bool Aura::CallScriptEffectPeriodicHandlers(AuraEffect const* aurEff, AuraApplication const* aurApp)
 {
     bool preventDefault = false;
-    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end(); ++scritr)
     {
         (*scritr)->_PrepareScriptCall(AURA_SCRIPT_HOOK_EFFECT_PERIODIC, aurApp);
         std::list<AuraScript::EffectPeriodicHandler>::iterator effEndItr = (*scritr)->OnEffectPeriodic.end(), effItr = (*scritr)->OnEffectPeriodic.begin();
-        for (; effItr != effEndItr ; ++effItr)
+        for (; effItr != effEndItr; ++effItr)
         {
             if ((*effItr).IsEffectAffected(m_spellInfo, aurEff->GetEffIndex()))
                 (*effItr).Call(*scritr, aurEff);
@@ -2188,11 +2189,11 @@
 
 void Aura::CallScriptEffectUpdatePeriodicHandlers(AuraEffect* aurEff)
 {
-    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end(); ++scritr)
     {
         (*scritr)->_PrepareScriptCall(AURA_SCRIPT_HOOK_EFFECT_UPDATE_PERIODIC);
         std::list<AuraScript::EffectUpdatePeriodicHandler>::iterator effEndItr = (*scritr)->OnEffectUpdatePeriodic.end(), effItr = (*scritr)->OnEffectUpdatePeriodic.begin();
-        for (; effItr != effEndItr ; ++effItr)
+        for (; effItr != effEndItr; ++effItr)
         {
             if ((*effItr).IsEffectAffected(m_spellInfo, aurEff->GetEffIndex()))
                 (*effItr).Call(*scritr, aurEff);
@@ -2203,11 +2204,11 @@
 
 void Aura::CallScriptEffectCalcAmountHandlers(AuraEffect const* aurEff, int32 & amount, bool & canBeRecalculated)
 {
-    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end(); ++scritr)
     {
         (*scritr)->_PrepareScriptCall(AURA_SCRIPT_HOOK_EFFECT_CALC_AMOUNT);
         std::list<AuraScript::EffectCalcAmountHandler>::iterator effEndItr = (*scritr)->DoEffectCalcAmount.end(), effItr = (*scritr)->DoEffectCalcAmount.begin();
-        for (; effItr != effEndItr ; ++effItr)
+        for (; effItr != effEndItr; ++effItr)
         {
             if ((*effItr).IsEffectAffected(m_spellInfo, aurEff->GetEffIndex()))
                 (*effItr).Call(*scritr, aurEff, amount, canBeRecalculated);
@@ -2218,11 +2219,11 @@
 
 void Aura::CallScriptEffectCalcPeriodicHandlers(AuraEffect const* aurEff, bool & isPeriodic, int32 & amplitude)
 {
-    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end(); ++scritr)
     {
         (*scritr)->_PrepareScriptCall(AURA_SCRIPT_HOOK_EFFECT_CALC_PERIODIC);
         std::list<AuraScript::EffectCalcPeriodicHandler>::iterator effEndItr = (*scritr)->DoEffectCalcPeriodic.end(), effItr = (*scritr)->DoEffectCalcPeriodic.begin();
-        for (; effItr != effEndItr ; ++effItr)
+        for (; effItr != effEndItr; ++effItr)
         {
             if ((*effItr).IsEffectAffected(m_spellInfo, aurEff->GetEffIndex()))
                 (*effItr).Call(*scritr, aurEff, isPeriodic, amplitude);
@@ -2233,11 +2234,11 @@
 
 void Aura::CallScriptEffectCalcSpellModHandlers(AuraEffect const* aurEff, SpellModifier* & spellMod)
 {
-    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end(); ++scritr)
     {
         (*scritr)->_PrepareScriptCall(AURA_SCRIPT_HOOK_EFFECT_CALC_SPELLMOD);
         std::list<AuraScript::EffectCalcSpellModHandler>::iterator effEndItr = (*scritr)->DoEffectCalcSpellMod.end(), effItr = (*scritr)->DoEffectCalcSpellMod.begin();
-        for (; effItr != effEndItr ; ++effItr)
+        for (; effItr != effEndItr; ++effItr)
         {
             if ((*effItr).IsEffectAffected(m_spellInfo, aurEff->GetEffIndex()))
                 (*effItr).Call(*scritr, aurEff, spellMod);
@@ -2246,28 +2247,29 @@
     }
 }
 
-void Aura::CallScriptEffectAbsorbHandlers(AuraEffect* aurEff, AuraApplication const* aurApp, DamageInfo & dmgInfo, uint32 & absorbAmount, bool & /*defaultPrevented*/)
+void Aura::CallScriptEffectAbsorbHandlers(AuraEffect* aurEff, AuraApplication const* aurApp, DamageInfo & dmgInfo, uint32 & absorbAmount, bool& defaultPrevented)
 {
-    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end(); ++scritr)
     {
         (*scritr)->_PrepareScriptCall(AURA_SCRIPT_HOOK_EFFECT_ABSORB, aurApp);
         std::list<AuraScript::EffectAbsorbHandler>::iterator effEndItr = (*scritr)->OnEffectAbsorb.end(), effItr = (*scritr)->OnEffectAbsorb.begin();
-        for (; effItr != effEndItr ; ++effItr)
+        for (; effItr != effEndItr; ++effItr)
         {
             if ((*effItr).IsEffectAffected(m_spellInfo, aurEff->GetEffIndex()))
                 (*effItr).Call(*scritr, aurEff, dmgInfo, absorbAmount);
         }
+        defaultPrevented = (*scritr)->_IsDefaultActionPrevented();
         (*scritr)->_FinishScriptCall();
     }
 }
 
 void Aura::CallScriptEffectAfterAbsorbHandlers(AuraEffect* aurEff, AuraApplication const* aurApp, DamageInfo & dmgInfo, uint32 & absorbAmount)
 {
-    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end(); ++scritr)
     {
         (*scritr)->_PrepareScriptCall(AURA_SCRIPT_HOOK_EFFECT_AFTER_ABSORB, aurApp);
         std::list<AuraScript::EffectAbsorbHandler>::iterator effEndItr = (*scritr)->AfterEffectAbsorb.end(), effItr = (*scritr)->AfterEffectAbsorb.begin();
-        for (; effItr != effEndItr ; ++effItr)
+        for (; effItr != effEndItr; ++effItr)
         {
             if ((*effItr).IsEffectAffected(m_spellInfo, aurEff->GetEffIndex()))
                 (*effItr).Call(*scritr, aurEff, dmgInfo, absorbAmount);
@@ -2278,11 +2280,11 @@
 
 void Aura::CallScriptEffectManaShieldHandlers(AuraEffect* aurEff, AuraApplication const* aurApp, DamageInfo & dmgInfo, uint32 & absorbAmount, bool & /*defaultPrevented*/)
 {
-    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end(); ++scritr)
     {
         (*scritr)->_PrepareScriptCall(AURA_SCRIPT_HOOK_EFFECT_MANASHIELD, aurApp);
         std::list<AuraScript::EffectManaShieldHandler>::iterator effEndItr = (*scritr)->OnEffectManaShield.end(), effItr = (*scritr)->OnEffectManaShield.begin();
-        for (; effItr != effEndItr ; ++effItr)
+        for (; effItr != effEndItr; ++effItr)
         {
             if ((*effItr).IsEffectAffected(m_spellInfo, aurEff->GetEffIndex()))
                 (*effItr).Call(*scritr, aurEff, dmgInfo, absorbAmount);
@@ -2293,11 +2295,11 @@
 
 void Aura::CallScriptEffectAfterManaShieldHandlers(AuraEffect* aurEff, AuraApplication const* aurApp, DamageInfo & dmgInfo, uint32 & absorbAmount)
 {
-    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    for (std::list<AuraScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end(); ++scritr)
     {
         (*scritr)->_PrepareScriptCall(AURA_SCRIPT_HOOK_EFFECT_AFTER_MANASHIELD, aurApp);
         std::list<AuraScript::EffectManaShieldHandler>::iterator effEndItr = (*scritr)->AfterEffectManaShield.end(), effItr = (*scritr)->AfterEffectManaShield.begin();
-        for (; effItr != effEndItr ; ++effItr)
+        for (; effItr != effEndItr; ++effItr)
         {
             if ((*effItr).IsEffectAffected(m_spellInfo, aurEff->GetEffIndex()))
                 (*effItr).Call(*scritr, aurEff, dmgInfo, absorbAmount);
@@ -2342,7 +2344,7 @@
 
 void UnitAura::FillTargetMap(std::map<Unit*, uint8> & targets, Unit* caster)
 {
-    for (uint8 effIndex = 0; effIndex < MAX_SPELL_EFFECTS ; ++effIndex)
+    for (uint8 effIndex = 0; effIndex < MAX_SPELL_EFFECTS; ++effIndex)
     {
         if (!HasEffect(effIndex))
             continue;
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Spells/Spell.cpp
--- a/src/server/game/Spells/Spell.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Spells/Spell.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -1011,7 +1011,7 @@
     {
         case TARGET_OBJECT_TYPE_UNIT:
             if (Unit* unitTarget = target->ToUnit())
-                AddUnitTarget(unitTarget, effMask, false);
+                AddUnitTarget(unitTarget, effMask, true, false);
             break;
         case TARGET_OBJECT_TYPE_GOBJ:
             if (GameObject* gobjTarget = target->ToGameObject())
@@ -1058,7 +1058,7 @@
                     if ((*j)->IsAffectedOnSpell(m_spellInfo))
                         maxTargets += (*j)->GetAmount();
 
-                Trinity::RandomResizeList(targets, maxTargets);
+                Trinity::Containers::RandomResizeList(targets, maxTargets);
             }
 
             // for compability with older code - add only unit and go targets
@@ -1277,7 +1277,7 @@
                     break;
 
                 // Remove targets outside caster's raid
-                for (std::list<Unit*>::iterator itr = unitTargets.begin() ; itr != unitTargets.end();)
+                for (std::list<Unit*>::iterator itr = unitTargets.begin(); itr != unitTargets.end();)
                 {
                     if (!(*itr)->IsInRaidWith(m_caster))
                         itr = unitTargets.erase(itr);
@@ -1294,7 +1294,7 @@
                 else if (m_spellInfo->SpellFamilyFlags[2] == 0x0100) // Starfall
                 {
                     // Remove targets not in LoS or in stealth
-                    for (std::list<Unit*>::iterator itr = unitTargets.begin() ; itr != unitTargets.end();)
+                    for (std::list<Unit*>::iterator itr = unitTargets.begin(); itr != unitTargets.end();)
                     {
                         if ((*itr)->HasStealthAura() || (*itr)->HasInvisibilityAura() || !(*itr)->IsWithinLOSInMap(m_caster))
                             itr = unitTargets.erase(itr);
@@ -1307,7 +1307,7 @@
                     break;
 
                 // Remove targets outside caster's raid
-                for (std::list<Unit*>::iterator itr = unitTargets.begin() ; itr != unitTargets.end();)
+                for (std::list<Unit*>::iterator itr = unitTargets.begin(); itr != unitTargets.end();)
                     if (!(*itr)->IsInRaidWith(m_caster))
                         itr = unitTargets.erase(itr);
                     else
@@ -1329,7 +1329,7 @@
             }
             else
             {
-                for (std::list<Unit*>::iterator itr = unitTargets.begin() ; itr != unitTargets.end();)
+                for (std::list<Unit*>::iterator itr = unitTargets.begin(); itr != unitTargets.end();)
                     if ((*itr)->getPowerType() != (Powers)power)
                         itr = unitTargets.erase(itr);
                     else
@@ -1353,7 +1353,7 @@
 
             if (m_spellInfo->Id == 5246) //Intimidating Shout
                 unitTargets.remove(m_targets.GetUnitTarget());
-            Trinity::RandomResizeList(unitTargets, maxTargets);
+            Trinity::Containers::RandomResizeList(unitTargets, maxTargets);
         }
 
         CallScriptAfterUnitTargetSelectHandlers(unitTargets, effIndex);
@@ -1371,7 +1371,7 @@
                 if ((*j)->IsAffectedOnSpell(m_spellInfo))
                     maxTargets += (*j)->GetAmount();
 
-            Trinity::RandomResizeList(gObjTargets, maxTargets);
+            Trinity::Containers::RandomResizeList(gObjTargets, maxTargets);
         }
         for (std::list<GameObject*>::iterator itr = gObjTargets.begin(); itr != gObjTargets.end(); ++itr)
             AddGOTarget(*itr, effMask);
@@ -1547,7 +1547,7 @@
 {
     ASSERT((m_targets.GetObjectTarget() || m_targets.GetItemTarget()) && "Spell::SelectImplicitTargetObjectTargets - no explicit object or item target available!");
     if (Unit* unit = m_targets.GetUnitTarget())
-        AddUnitTarget(unit, 1 << effIndex);
+        AddUnitTarget(unit, 1 << effIndex, true, false);
     else if (GameObject* gobj = m_targets.GetGOTarget())
         AddGOTarget(gobj, 1 << effIndex);
     else
@@ -2080,7 +2080,7 @@
     m_delayMoment = 0;
 }
 
-void Spell::AddUnitTarget(Unit* target, uint32 effectMask, bool checkIfValid /*= true*/)
+void Spell::AddUnitTarget(Unit* target, uint32 effectMask, bool checkIfValid /*= true*/, bool implicit /*= true*/)
 {
     for (uint32 effIndex = 0; effIndex < MAX_SPELL_EFFECTS; ++effIndex)
         if (!m_spellInfo->Effects[effIndex].IsEffect() || !CheckEffectTarget(target, effIndex))
@@ -2091,7 +2091,7 @@
         return;
 
     if (checkIfValid)
-        if (m_spellInfo->CheckTarget(m_caster, target, true) != SPELL_CAST_OK)
+        if (m_spellInfo->CheckTarget(m_caster, target, implicit) != SPELL_CAST_OK)
             return;
 
     // Check for effect immune skip if immuned
@@ -2169,7 +2169,7 @@
     if (targetInfo.missCondition == SPELL_MISS_REFLECT)
     {
         // Calculate reflected spell result on caster
-        targetInfo.reflectResult =  m_caster->SpellHitResult(m_caster, m_spellInfo, m_canReflect);
+        targetInfo.reflectResult = m_caster->SpellHitResult(m_caster, m_spellInfo, m_canReflect);
 
         if (targetInfo.reflectResult == SPELL_MISS_REFLECT)     // Impossible reflect again, so simply deflect spell
             targetInfo.reflectResult = SPELL_MISS_PARRY;
@@ -2445,13 +2445,13 @@
         else
             procEx |= PROC_EX_NORMAL_HIT;
 
+        int32 gain = caster->HealBySpell(unitTarget, m_spellInfo, addhealth, crit);
+        unitTarget->getHostileRefManager().threatAssist(caster, float(gain) * 0.5f, m_spellInfo);
+        m_healing = gain;
+
         // Do triggers for unit (reflect triggers passed on hit phase for correct drop charge)
         if (canEffectTrigger && missInfo != SPELL_MISS_REFLECT)
             caster->ProcDamageAndSpell(unitTarget, procAttacker, procVictim, procEx, addhealth, m_attackType, m_spellInfo, m_triggeredByAuraSpell);
-
-        int32 gain = caster->HealBySpell(unitTarget, m_spellInfo, addhealth, crit);
-        unitTarget->getHostileRefManager().threatAssist(caster, float(gain) * 0.5f, m_spellInfo);
-        m_healing = gain;
     }
     // Do damage and triggers
     else if (m_damage > 0)
@@ -2748,18 +2748,18 @@
     if (!m_hitTriggerSpells.empty())
     {
         int _duration = 0;
-        for (HitTriggerSpells::const_iterator i = m_hitTriggerSpells.begin(); i != m_hitTriggerSpells.end(); ++i)
+        for (HitTriggerSpellList::const_iterator i = m_hitTriggerSpells.begin(); i != m_hitTriggerSpells.end(); ++i)
         {
-            if (CanExecuteTriggersOnHit(effMask, i->first) && roll_chance_i(i->second))
+            if (CanExecuteTriggersOnHit(effMask, i->triggeredByAura) && roll_chance_i(i->chance))
             {
-                m_caster->CastSpell(unit, i->first, true);
-                sLog->outDebug(LOG_FILTER_SPELLS_AURAS, "Spell %d triggered spell %d by SPELL_AURA_ADD_TARGET_TRIGGER aura", m_spellInfo->Id, i->first->Id);
+                m_caster->CastSpell(unit, i->triggeredSpell, true);
+                sLog->outDebug(LOG_FILTER_SPELLS_AURAS, "Spell %d triggered spell %d by SPELL_AURA_ADD_TARGET_TRIGGER aura", m_spellInfo->Id, i->triggeredSpell->Id);
 
                 // SPELL_AURA_ADD_TARGET_TRIGGER auras shouldn't trigger auras without duration
                 // set duration of current aura to the triggered spell
-                if (i->first->GetDuration() == -1)
+                if (i->triggeredSpell->GetDuration() == -1)
                 {
-                    if (Aura* triggeredAur = unit->GetAura(i->first->Id, m_caster->GetGUID()))
+                    if (Aura* triggeredAur = unit->GetAura(i->triggeredSpell->Id, m_caster->GetGUID()))
                     {
                         // get duration from aura-only once
                         if (!_duration)
@@ -3083,7 +3083,8 @@
         *m_selfContainer = NULL;
 
     m_caster->RemoveDynObject(m_spellInfo->Id);
-    m_caster->RemoveGameObject(m_spellInfo->Id, true);
+    if (m_spellInfo->IsChanneled()) // if not channeled then the object for the current cast wasn't summoned yet
+        m_caster->RemoveGameObject(m_spellInfo->Id, true);
 
     //set state back so finish will be processed
     m_spellState = oldState;
@@ -3103,11 +3104,20 @@
         return;
     }
 
-    // now that we've done the basic check, now run the scripts
-    // should be done before the spell is actually executed
     if (Player* playerCaster = m_caster->ToPlayer())
+    {
+        // now that we've done the basic check, now run the scripts
+        // should be done before the spell is actually executed
         sScriptMgr->OnPlayerSpellCast(playerCaster, this, skipCheck);
 
+        // Let any pets know we've attacked something. As of 3.0.2 pets begin
+        //  attacking their owner's target immediately
+        if (Pet* playerPet = playerCaster->GetPet())
+        {
+            if (playerPet->isAlive() && playerPet->isControlled() && (m_targets.GetTargetMask() & TARGET_FLAG_UNIT))
+                playerPet->AI()->OwnerAttacked(m_targets.GetObjectTarget()->ToUnit());
+        }
+    }
     SetExecutedCurrently(true);
 
     if (m_caster->GetTypeId() != TYPEID_PLAYER && m_targets.GetUnitTarget() && m_targets.GetUnitTarget() != m_caster)
@@ -3420,36 +3430,6 @@
     // process items
     for (std::list<ItemTargetInfo>::iterator ihit= m_UniqueItemInfo.begin(); ihit != m_UniqueItemInfo.end(); ++ihit)
         DoAllEffectOnTarget(&(*ihit));
-
-    if (!m_originalCaster)
-        return;
-    // Handle procs on cast
-    // TODO: finish new proc system:P
-    if (m_UniqueTargetInfo.empty())
-    {
-        uint32 procAttacker = m_procAttacker;
-        if (!procAttacker)
-        {
-            bool positive = m_spellInfo->IsPositive();
-            switch (m_spellInfo->DmgClass)
-            {
-                case SPELL_DAMAGE_CLASS_MAGIC:
-                    if (positive)
-                        procAttacker |= PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS;
-                    else
-                        procAttacker |= PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_NEG;
-                break;
-                case SPELL_DAMAGE_CLASS_NONE:
-                    if (positive)
-                        procAttacker |= PROC_FLAG_DONE_SPELL_NONE_DMG_CLASS_POS;
-                    else
-                        procAttacker |= PROC_FLAG_DONE_SPELL_NONE_DMG_CLASS_NEG;
-                break;
-            }
-        }
-        // Proc damage for spells which have only dest targets (2484 should proc 51486 for example)
-        m_originalCaster->ProcDamageAndSpell(NULL, procAttacker, 0, m_procEx | PROC_EX_NORMAL_HIT, 0, BASE_ATTACK, m_spellInfo, m_triggeredByAuraSpell);
-    }
 }
 
 void Spell::_handle_finish_phase()
@@ -4333,10 +4313,9 @@
                 for (std::list<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
                     if (ihit->targetGUID == targetGUID)
                     {
-                        if (ihit->missCondition != SPELL_MISS_NONE && ihit->missCondition != SPELL_MISS_MISS/* && ihit->targetGUID != m_caster->GetGUID()*/)
-                            hit = false;
                         if (ihit->missCondition != SPELL_MISS_NONE)
                         {
+                            hit = false;
                             //lower spell cost on fail (by talent aura)
                             if (Player* modOwner = m_caster->ToPlayer()->GetSpellModOwner())
                                 modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_SPELL_COST_REFUND_ON_FAIL, m_powerCost);
@@ -4986,7 +4965,7 @@
             break;
         }
 
-    if (!hasNonDispelEffect && !hasDispellableAura && m_spellInfo->HasEffect(SPELL_EFFECT_DISPEL))
+    if (!hasNonDispelEffect && !hasDispellableAura && m_spellInfo->HasEffect(SPELL_EFFECT_DISPEL) && !IsTriggered())
         return SPELL_FAILED_NOTHING_TO_DISPEL;
 
     for (int i = 0; i < MAX_SPELL_EFFECTS; i++)
@@ -5232,10 +5211,8 @@
             case SPELL_EFFECT_SUMMON_DEAD_PET:
             {
                 Creature* pet = m_caster->GetGuardianPet();
-                if (!pet)
-                    return SPELL_FAILED_NO_PET;
-
-                if (pet->isAlive())
+
+                if (pet && pet->isAlive())
                     return SPELL_FAILED_ALREADY_HAVE_SUMMON;
 
                 break;
@@ -5285,7 +5262,6 @@
 
                 if (m_caster->GetCharmGUID())
                     return SPELL_FAILED_ALREADY_HAVE_CHARM;
-
                 break;
             }
             case SPELL_EFFECT_SUMMON_PLAYER:
@@ -6055,7 +6031,7 @@
 
         // check totem-item requirements (items presence in inventory)
         uint32 totems = 2;
-        for (int i = 0; i < 2 ; ++i)
+        for (int i = 0; i < 2; ++i)
         {
             if (m_spellInfo->Totem[i] != 0)
             {
@@ -6278,9 +6254,12 @@
             case SPELL_EFFECT_WEAPON_DAMAGE:
             case SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
             {
-                if (m_caster->GetTypeId() != TYPEID_PLAYER) return SPELL_FAILED_TARGET_NOT_PLAYER;
+                if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                    return SPELL_FAILED_TARGET_NOT_PLAYER;
+
                 if (m_attackType != RANGED_ATTACK)
                     break;
+
                 Item* pItem = m_caster->ToPlayer()->GetWeaponForAttack(m_attackType);
                 if (!pItem || pItem->IsBroken())
                     return SPELL_FAILED_EQUIPPED_ITEM;
@@ -6292,7 +6271,8 @@
                         uint32 ammo = pItem->GetEntry();
                         if (!m_caster->ToPlayer()->HasItemCount(ammo, 1))
                             return SPELL_FAILED_NO_AMMO;
-                    };  break;
+                    };
+                    break;
                     case ITEM_SUBCLASS_WEAPON_GUN:
                     case ITEM_SUBCLASS_WEAPON_BOW:
                     case ITEM_SUBCLASS_WEAPON_CROSSBOW:
@@ -6682,7 +6662,7 @@
                 // no, we aren't, do the typical update
                 // check, if we have channeled spell on our hands
                 /*
-                if (IsChanneledSpell(m_Spell->m_spellInfo))
+                if (m_Spell->m_spellInfo->IsChanneled())
                 {
                     // evented channeled spell is processed separately, casted once after delay, and not destroyed till finish
                     // check, if we have casting anything else except this channeled spell and autorepeat
@@ -7003,7 +6983,7 @@
 void Spell::LoadScripts()
 {
     sScriptMgr->CreateSpellScripts(m_spellInfo->Id, m_loadedScripts);
-    for (std::list<SpellScript*>::iterator itr = m_loadedScripts.begin(); itr != m_loadedScripts.end() ;)
+    for (std::list<SpellScript*>::iterator itr = m_loadedScripts.begin(); itr != m_loadedScripts.end();)
     {
         if (!(*itr)->_Load(this))
         {
@@ -7020,11 +7000,11 @@
 
 void Spell::CallScriptBeforeCastHandlers()
 {
-    for (std::list<SpellScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    for (std::list<SpellScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end(); ++scritr)
     {
         (*scritr)->_PrepareScriptCall(SPELL_SCRIPT_HOOK_BEFORE_CAST);
         std::list<SpellScript::CastHandler>::iterator hookItrEnd = (*scritr)->BeforeCast.end(), hookItr = (*scritr)->BeforeCast.begin();
-        for (; hookItr != hookItrEnd ; ++hookItr)
+        for (; hookItr != hookItrEnd; ++hookItr)
             (*hookItr).Call(*scritr);
 
         (*scritr)->_FinishScriptCall();
@@ -7033,11 +7013,11 @@
 
 void Spell::CallScriptOnCastHandlers()
 {
-    for (std::list<SpellScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    for (std::list<SpellScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end(); ++scritr)
     {
         (*scritr)->_PrepareScriptCall(SPELL_SCRIPT_HOOK_ON_CAST);
         std::list<SpellScript::CastHandler>::iterator hookItrEnd = (*scritr)->OnCast.end(), hookItr = (*scritr)->OnCast.begin();
-        for (; hookItr != hookItrEnd ; ++hookItr)
+        for (; hookItr != hookItrEnd; ++hookItr)
             (*hookItr).Call(*scritr);
 
         (*scritr)->_FinishScriptCall();
@@ -7046,11 +7026,11 @@
 
 void Spell::CallScriptAfterCastHandlers()
 {
-    for (std::list<SpellScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    for (std::list<SpellScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end(); ++scritr)
     {
         (*scritr)->_PrepareScriptCall(SPELL_SCRIPT_HOOK_AFTER_CAST);
         std::list<SpellScript::CastHandler>::iterator hookItrEnd = (*scritr)->AfterCast.end(), hookItr = (*scritr)->AfterCast.begin();
-        for (; hookItr != hookItrEnd ; ++hookItr)
+        for (; hookItr != hookItrEnd; ++hookItr)
             (*hookItr).Call(*scritr);
 
         (*scritr)->_FinishScriptCall();
@@ -7060,7 +7040,7 @@
 SpellCastResult Spell::CallScriptCheckCastHandlers()
 {
     SpellCastResult retVal = SPELL_CAST_OK;
-    for (std::list<SpellScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    for (std::list<SpellScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end(); ++scritr)
     {
         (*scritr)->_PrepareScriptCall(SPELL_SCRIPT_HOOK_CHECK_CAST);
         std::list<SpellScript::CheckCastHandler>::iterator hookItrEnd = (*scritr)->OnCheckCast.end(), hookItr = (*scritr)->OnCheckCast.begin();
@@ -7078,7 +7058,7 @@
 
 void Spell::PrepareScriptHitHandlers()
 {
-    for (std::list<SpellScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    for (std::list<SpellScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end(); ++scritr)
         (*scritr)->_InitHit();
 }
 
@@ -7086,7 +7066,7 @@
 {
     // execute script effect handler hooks and check if effects was prevented
     bool preventDefault = false;
-    for (std::list<SpellScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    for (std::list<SpellScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end(); ++scritr)
     {
         std::list<SpellScript::EffectHandler>::iterator effItr, effEndItr;
         SpellScriptHookType hookType;
@@ -7117,7 +7097,7 @@
                 return false;
         }
         (*scritr)->_PrepareScriptCall(hookType);
-        for (; effItr != effEndItr ; ++effItr)
+        for (; effItr != effEndItr; ++effItr)
             // effect execution can be prevented
             if (!(*scritr)->_IsEffectPrevented(effIndex) && (*effItr).IsEffectAffected(m_spellInfo, effIndex))
                 (*effItr).Call(*scritr, effIndex);
@@ -7132,11 +7112,11 @@
 
 void Spell::CallScriptBeforeHitHandlers()
 {
-    for (std::list<SpellScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    for (std::list<SpellScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end(); ++scritr)
     {
         (*scritr)->_PrepareScriptCall(SPELL_SCRIPT_HOOK_BEFORE_HIT);
         std::list<SpellScript::HitHandler>::iterator hookItrEnd = (*scritr)->BeforeHit.end(), hookItr = (*scritr)->BeforeHit.begin();
-        for (; hookItr != hookItrEnd ; ++hookItr)
+        for (; hookItr != hookItrEnd; ++hookItr)
             (*hookItr).Call(*scritr);
 
         (*scritr)->_FinishScriptCall();
@@ -7145,11 +7125,11 @@
 
 void Spell::CallScriptOnHitHandlers()
 {
-    for (std::list<SpellScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    for (std::list<SpellScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end(); ++scritr)
     {
         (*scritr)->_PrepareScriptCall(SPELL_SCRIPT_HOOK_HIT);
         std::list<SpellScript::HitHandler>::iterator hookItrEnd = (*scritr)->OnHit.end(), hookItr = (*scritr)->OnHit.begin();
-        for (; hookItr != hookItrEnd ; ++hookItr)
+        for (; hookItr != hookItrEnd; ++hookItr)
             (*hookItr).Call(*scritr);
 
         (*scritr)->_FinishScriptCall();
@@ -7158,11 +7138,11 @@
 
 void Spell::CallScriptAfterHitHandlers()
 {
-    for (std::list<SpellScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    for (std::list<SpellScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end(); ++scritr)
     {
         (*scritr)->_PrepareScriptCall(SPELL_SCRIPT_HOOK_AFTER_HIT);
         std::list<SpellScript::HitHandler>::iterator hookItrEnd = (*scritr)->AfterHit.end(), hookItr = (*scritr)->AfterHit.begin();
-        for (; hookItr != hookItrEnd ; ++hookItr)
+        for (; hookItr != hookItrEnd; ++hookItr)
             (*hookItr).Call(*scritr);
 
         (*scritr)->_FinishScriptCall();
@@ -7171,11 +7151,11 @@
 
 void Spell::CallScriptAfterUnitTargetSelectHandlers(std::list<Unit*>& unitTargets, SpellEffIndex effIndex)
 {
-    for (std::list<SpellScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    for (std::list<SpellScript*>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end(); ++scritr)
     {
         (*scritr)->_PrepareScriptCall(SPELL_SCRIPT_HOOK_UNIT_TARGET_SELECT);
         std::list<SpellScript::UnitTargetHandler>::iterator hookItrEnd = (*scritr)->OnUnitTargetSelect.end(), hookItr = (*scritr)->OnUnitTargetSelect.begin();
-        for (; hookItr != hookItrEnd ; ++hookItr)
+        for (; hookItr != hookItrEnd; ++hookItr)
             if ((*hookItr).IsEffectAffected(m_spellInfo, effIndex))
                 (*hookItr).Call(*scritr, unitTargets);
 
@@ -7183,14 +7163,13 @@
     }
 }
 
-bool Spell::CanExecuteTriggersOnHit(uint8 effMask, SpellInfo const* spellInfo) const
-{
-    bool only_on_dummy = (spellInfo && (spellInfo->AttributesEx4 & SPELL_ATTR4_PROC_ONLY_ON_DUMMY));
-    // If triggered spell has SPELL_ATTR4_PROC_ONLY_ON_DUMMY then it can only proc on a casted spell with SPELL_EFFECT_DUMMY
-    // If triggered spell doesn't have SPELL_ATTR4_PROC_ONLY_ON_DUMMY then it can NOT proc on SPELL_EFFECT_DUMMY (needs confirmation)
+bool Spell::CanExecuteTriggersOnHit(uint8 effMask, SpellInfo const* triggeredByAura) const
+{
+    bool only_on_caster = (triggeredByAura && (triggeredByAura->AttributesEx4 & SPELL_ATTR4_PROC_ONLY_ON_CASTER));
+    // If triggeredByAura has SPELL_ATTR4_PROC_ONLY_ON_CASTER then it can only proc on a casted spell with TARGET_UNIT_CASTER
     for (uint8 i = 0;i < MAX_SPELL_EFFECTS; ++i)
     {
-        if ((effMask & (1 << i)) && (only_on_dummy == (m_spellInfo->Effects[i].Effect == SPELL_EFFECT_DUMMY)))
+        if ((effMask & (1 << i)) && (!only_on_caster || (m_spellInfo->Effects[i].TargetA.GetTarget() == TARGET_UNIT_CASTER)))
             return true;
     }
     return false;
@@ -7242,9 +7221,14 @@
             // calculate the chance using spell base amount, because aura amount is not updated on combo-points change
             // this possibly needs fixing
             int32 auraBaseAmount = (*i)->GetBaseAmount();
+            // proc chance is stored in effect amount
             int32 chance = m_caster->CalculateSpellDamage(NULL, auraSpellInfo, auraSpellIdx, &auraBaseAmount);
-            // proc chance is stored in effect amount
-            m_hitTriggerSpells.push_back(std::make_pair(spellInfo, chance * (*i)->GetBase()->GetStackAmount()));
+            // build trigger and add to the list
+            HitTriggerSpell spellTriggerInfo;
+            spellTriggerInfo.triggeredSpell = spellInfo;
+            spellTriggerInfo.triggeredByAura = auraSpellInfo;
+            spellTriggerInfo.chance = chance * (*i)->GetBase()->GetStackAmount();
+            m_hitTriggerSpells.push_back(spellTriggerInfo);
         }
     }
 }
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Spells/Spell.h
--- a/src/server/game/Spells/Spell.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Spells/Spell.h	Mon Apr 16 14:29:17 2012 +0300
@@ -455,7 +455,7 @@
         void SetAutoRepeat(bool rep) { m_autoRepeat = rep; }
         void ReSetTimer() { m_timer = m_casttime > 0 ? m_casttime : 0; }
         bool IsNextMeleeSwingSpell() const;
-        bool IsTriggered() const {return _triggeredCastFlags & TRIGGERED_FULL_MASK;};
+        bool IsTriggered() const { return _triggeredCastFlags & TRIGGERED_FULL_MASK; };
         bool IsChannelActive() const { return m_caster->GetUInt32Value(UNIT_CHANNEL_SPELL) != 0; }
         bool IsAutoActionResetSpell() const;
 
@@ -596,7 +596,7 @@
 
         SpellDestination m_destTargets[MAX_SPELL_EFFECTS];
 
-        void AddUnitTarget(Unit* target, uint32 effectMask, bool checkIfValid = true);
+        void AddUnitTarget(Unit* target, uint32 effectMask, bool checkIfValid = true, bool implicit = true);
         void AddGOTarget(GameObject* target, uint32 effectMask);
         void AddItemTarget(Item* item, uint32 effectMask);
         void AddDestTarget(SpellDestination const& dest, uint32 effIndex);
@@ -633,10 +633,18 @@
         void CallScriptAfterUnitTargetSelectHandlers(std::list<Unit*>& unitTargets, SpellEffIndex effIndex);
         std::list<SpellScript*> m_loadedScripts;
 
-        bool CanExecuteTriggersOnHit(uint8 effMask, SpellInfo const* spellInfo = NULL) const;
+        struct HitTriggerSpell
+        {
+            SpellInfo const* triggeredSpell;
+            SpellInfo const* triggeredByAura;
+            // uint8 triggeredByEffIdx          This might be needed at a later stage - No need known for now
+            int32 chance;
+        };
+
+        bool CanExecuteTriggersOnHit(uint8 effMask, SpellInfo const* triggeredByAura = NULL) const;
         void PrepareTriggersExecutedOnHit();
-        typedef std::list< std::pair<SpellInfo const*, int32> > HitTriggerSpells;
-        HitTriggerSpells m_hitTriggerSpells;
+        typedef std::list<HitTriggerSpell> HitTriggerSpellList;
+        HitTriggerSpellList m_hitTriggerSpells;
 
         // effect helpers
         void SummonGuardian(uint32 i, uint32 entry, SummonPropertiesEntry const* properties, uint32 numSummons);
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Spells/SpellEffects.cpp
--- a/src/server/game/Spells/SpellEffects.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Spells/SpellEffects.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -782,7 +782,7 @@
                     uint32 maxTargets = std::min<uint32>(3, attackers.size());
                     for (uint32 i = 0; i < maxTargets; ++i)
                     {
-                        Unit* attacker = SelectRandomContainerElement(attackers);
+                        Unit* attacker = Trinity::Containers::SelectRandomContainerElement(attackers);
                         AddUnitTarget(attacker, 1 << 1);
                         attackers.erase(attacker);
                     }
@@ -1621,20 +1621,6 @@
                 }
             }
         }
-        // Lifebloom - final heal coef multiplied by original DoT stack
-        else if (m_spellInfo->Id == 33778)
-            addhealth = caster->SpellHealingBonus(unitTarget, m_spellInfo, addhealth, HEAL, m_spellValue->EffectBasePoints[1]);
-        // Riptide - increase healing done by Chain Heal
-        else if (m_spellInfo->SpellFamilyName == SPELLFAMILY_SHAMAN && m_spellInfo->SpellFamilyFlags[0] & 0x100)
-        {
-            addhealth = caster->SpellHealingBonus(unitTarget, m_spellInfo, addhealth, HEAL);
-            if (AuraEffect* aurEff = unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_SHAMAN, 0, 0, 0x10, m_originalCasterGUID))
-            {
-                addhealth = int32(addhealth * 1.25f);
-                // consume aura
-                unitTarget->RemoveAura(aurEff->GetBase());
-            }
-        }
         // Death Pact - return pct of max health to caster
         else if (m_spellInfo->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT && m_spellInfo->SpellFamilyFlags[0] & 0x00080000)
             addhealth = caster->SpellHealingBonus(unitTarget, m_spellInfo, int32(caster->CountPctFromMaxHealth(damage)), HEAL);
@@ -2006,7 +1992,7 @@
             sSpellMgr->GetSetOfSpellsInSpellGroup(SPELL_GROUP_ELIXIR_GUARDIAN, avalibleElixirs);
         if (!battleFound)
             sSpellMgr->GetSetOfSpellsInSpellGroup(SPELL_GROUP_ELIXIR_BATTLE, avalibleElixirs);
-        for (std::set<uint32>::iterator itr = avalibleElixirs.begin(); itr != avalibleElixirs.end() ;)
+        for (std::set<uint32>::iterator itr = avalibleElixirs.begin(); itr != avalibleElixirs.end();)
         {
             SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(*itr);
             if (spellInfo->SpellLevel < m_spellInfo->SpellLevel || spellInfo->SpellLevel > unitTarget->getLevel())
@@ -2022,7 +2008,7 @@
         if (!avalibleElixirs.empty())
         {
             // cast random elixir on target
-            m_caster->CastSpell(unitTarget, SelectRandomContainerElement(avalibleElixirs), true, m_CastItem);
+            m_caster->CastSpell(unitTarget, Trinity::Containers::SelectRandomContainerElement(avalibleElixirs), true, m_CastItem);
         }
     }
 }
@@ -2775,7 +2761,7 @@
     if (damage < 0)
         return;
 
-    uint32 skillid =  m_spellInfo->Effects[effIndex].MiscValue;
+    uint32 skillid = m_spellInfo->Effects[effIndex].MiscValue;
     uint16 skillval = unitTarget->ToPlayer()->GetPureSkillValue(skillid);
     unitTarget->ToPlayer()->SetSkill(skillid, m_spellInfo->Effects[effIndex].CalcValue(), skillval?skillval:1, damage*75);
 }
@@ -4660,7 +4646,8 @@
                         45684                             // Polymorph
                     };
 
-                    static uint32 const spellTarget[5] = {
+                    static uint32 const spellTarget[5] =
+                    {
                         45673,                            // Bigger!
                         45672,                            // Shrunk
                         45677,                            // Yellow
@@ -5109,7 +5096,7 @@
         return;
 
     // must be equipped
-    if (!item ->IsEquipped())
+    if (!item->IsEquipped())
         return;
 
     if (m_spellInfo->Effects[effIndex].MiscValue)
@@ -5755,7 +5742,7 @@
         return;
 
     Pet* pet = player->GetPet();
-    if (!pet || pet->isAlive())
+    if (pet && pet->isAlive())
         return;
 
     if (damage < 0)
@@ -5763,8 +5750,16 @@
 
     float x, y, z;
     player->GetPosition(x, y, z);
+    if (!pet)
+    {
+        player->SummonPet(0, x, y, z, player->GetOrientation(), SUMMON_PET, 0);
+        pet = player->GetPet();
+    }
+    if (!pet)
+        return;
+    
     player->GetMap()->CreatureRelocation(pet, x, y, z, player->GetOrientation());
-
+    
     pet->SetUInt32Value(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_NONE);
     pet->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE);
     pet->setDeathState(ALIVE);
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Spells/SpellInfo.cpp
--- a/src/server/game/Spells/SpellInfo.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Spells/SpellInfo.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -2177,12 +2177,12 @@
             switch (Id)
             {
                 case 34700: // Allergic Reaction
-                case 61716: // Rabbit Costume
-                case 61734: // Noblegarden Bunny
                 case 61987: // Avenging Wrath Marker
                 case 61988: // Divine Shield exclude aura
                 case 62532: // Conservator's Grip
                     return false;
+                case 61716: // Rabbit Costume
+                case 61734: // Noblegarden Bunny
                 case 30877: // Tag Murloc
                 case 62344: // Fists of Stone
                     return true;
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Spells/SpellMgr.cpp
--- a/src/server/game/Spells/SpellMgr.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Spells/SpellMgr.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -113,24 +113,14 @@
         }
         case SPELLFAMILY_WARLOCK:
         {
-            // Death Coil
-            if (spellproto->SpellFamilyFlags[0] & 0x80000)
-                return DIMINISHING_HORROR;
             // Curses/etc
-            else if ((spellproto->SpellFamilyFlags[0] & 0x80000000) || (spellproto->SpellFamilyFlags[1] & 0x200))
+            if ((spellproto->SpellFamilyFlags[0] & 0x80000000) || (spellproto->SpellFamilyFlags[1] & 0x200))
                 return DIMINISHING_LIMITONLY;
             // Seduction
             else if (spellproto->SpellFamilyFlags[1] & 0x10000000)
                 return DIMINISHING_FEAR;
             break;
         }
-        case SPELLFAMILY_PRIEST:
-        {
-            // Psychic Horror
-            if (spellproto->SpellFamilyFlags[2] & 0x2000)
-                return DIMINISHING_HORROR;
-            break;
-        }
         case SPELLFAMILY_DRUID:
         {
             // Pounce
@@ -230,6 +220,8 @@
         return DIMINISHING_BANISH;
     if (mechanic & (1 << MECHANIC_ROOT))
         return triggered ? DIMINISHING_ROOT : DIMINISHING_CONTROLLED_ROOT;
+    if (mechanic & (1 << MECHANIC_HORROR))
+        return DIMINISHING_HORROR;
 
     return DIMINISHING_NONE;
 }
@@ -653,7 +645,7 @@
 uint32 SpellMgr::IsSpellMemberOfSpellGroup(uint32 spellid, SpellGroup groupid) const
 {
     SpellSpellGroupMapBounds spellGroup = GetSpellSpellGroupMapBounds(spellid);
-    for (SpellSpellGroupMap::const_iterator itr = spellGroup.first; itr != spellGroup.second ; ++itr)
+    for (SpellSpellGroupMap::const_iterator itr = spellGroup.first; itr != spellGroup.second; ++itr)
     {
         if (itr->second == groupid)
             return true;
@@ -679,7 +671,7 @@
     usedGroups.insert(group_id);
 
     SpellGroupSpellMapBounds groupSpell = GetSpellGroupSpellMapBounds(group_id);
-    for (SpellGroupSpellMap::const_iterator itr = groupSpell.first; itr != groupSpell.second ; ++itr)
+    for (SpellGroupSpellMap::const_iterator itr = groupSpell.first; itr != groupSpell.second; ++itr)
     {
         if (itr->second < 0)
         {
@@ -698,7 +690,7 @@
     uint32 spellId = spellInfo->GetFirstRankSpell()->Id;
     SpellSpellGroupMapBounds spellGroup = GetSpellSpellGroupMapBounds(spellId);
     // Find group with SPELL_GROUP_STACK_RULE_EXCLUSIVE_SAME_EFFECT if it belongs to one
-    for (SpellSpellGroupMap::const_iterator itr = spellGroup.first; itr != spellGroup.second ; ++itr)
+    for (SpellSpellGroupMap::const_iterator itr = spellGroup.first; itr != spellGroup.second; ++itr)
     {
         SpellGroup group = itr->second;
         SpellGroupStackMap::const_iterator found = mSpellGroupStack.find(group);
@@ -734,13 +726,13 @@
     // find SpellGroups which are common for both spells
     SpellSpellGroupMapBounds spellGroup1 = GetSpellSpellGroupMapBounds(spellid_1);
     std::set<SpellGroup> groups;
-    for (SpellSpellGroupMap::const_iterator itr = spellGroup1.first; itr != spellGroup1.second ; ++itr)
+    for (SpellSpellGroupMap::const_iterator itr = spellGroup1.first; itr != spellGroup1.second; ++itr)
     {
         if (IsSpellMemberOfSpellGroup(spellid_2, itr->second))
         {
             bool add = true;
             SpellGroupSpellMapBounds groupSpell = GetSpellGroupSpellMapBounds(itr->second);
-            for (SpellGroupSpellMap::const_iterator itr2 = groupSpell.first; itr2 != groupSpell.second ; ++itr2)
+            for (SpellGroupSpellMap::const_iterator itr2 = groupSpell.first; itr2 != groupSpell.second; ++itr2)
             {
                 if (itr2->second < 0)
                 {
@@ -759,7 +751,7 @@
 
     SpellGroupStackRule rule = SPELL_GROUP_STACK_RULE_DEFAULT;
 
-    for (std::set<SpellGroup>::iterator itr = groups.begin() ; itr!= groups.end() ; ++itr)
+    for (std::set<SpellGroup>::iterator itr = groups.begin(); itr!= groups.end(); ++itr)
     {
         SpellGroupStackMap::const_iterator found = mSpellGroupStack.find(*itr);
         if (found != mSpellGroupStack.end())
@@ -1170,11 +1162,6 @@
     return true;
 }
 
-void SpellMgr::LoadSpellInfos()
-{
-
-}
-
 void SpellMgr::LoadSpellRanks()
 {
     uint32 oldMSTime = getMSTime();
@@ -1185,18 +1172,17 @@
         mSpellInfoMap[itr->first]->ChainEntry = NULL;
     }
     mSpellChains.clear();
-
+    //                                                     0             1      2
     QueryResult result = WorldDatabase.Query("SELECT first_spell_id, spell_id, rank from spell_ranks ORDER BY first_spell_id, rank");
 
     if (!result)
     {
-        sLog->outString(">> Loaded 0 spell rank records");
+        sLog->outString(">> Loaded 0 spell rank records. DB table `spell_ranks` is empty.");
         sLog->outString();
-        sLog->outErrorDb("`spell_ranks` table is empty!");
         return;
     }
 
-    uint32 rows = 0;
+    uint32 count = 0;
     bool finished = false;
 
     do
@@ -1215,7 +1201,7 @@
             if (lastSpell == -1)
                 lastSpell = currentSpell;
             uint32 spell_id = fields[1].GetUInt32();
-            uint32 rank = fields[2].GetUInt32();
+            uint32 rank = fields[2].GetUInt8();
 
             // don't drop the row if we're moving to the next rank
             if (currentSpell == lastSpell)
@@ -1243,7 +1229,7 @@
         int32 curRank = 0;
         bool valid = true;
         // check spells in chain
-        for (std::list<std::pair<int32, int32> >::iterator itr = rankChain.begin() ; itr!= rankChain.end(); ++itr)
+        for (std::list<std::pair<int32, int32> >::iterator itr = rankChain.begin(); itr!= rankChain.end(); ++itr)
         {
             SpellInfo const* spell = GetSpellInfo(itr->first);
             if (!spell)
@@ -1267,7 +1253,7 @@
         std::list<std::pair<int32, int32> >::iterator itr = rankChain.begin();
         do
         {
-            ++rows;
+            ++count;
             int32 addedSpell = itr->first;
             mSpellChains[addedSpell].first = GetSpellInfo(lastSpell);
             mSpellChains[addedSpell].last = GetSpellInfo(rankChain.back().first);
@@ -1287,7 +1273,7 @@
         while (true);
     } while (!finished);
 
-    sLog->outString(">> Loaded %u spell rank records in %u ms", rows, GetMSTimeDiffToNow(oldMSTime));
+    sLog->outString(">> Loaded %u spell rank records in %u ms", count, GetMSTimeDiffToNow(oldMSTime));
     sLog->outString();
 }
 
@@ -1298,23 +1284,24 @@
     mSpellsReqSpell.clear();                                   // need for reload case
     mSpellReq.clear();                                         // need for reload case
 
+    //                                                   0        1
     QueryResult result = WorldDatabase.Query("SELECT spell_id, req_spell from spell_required");
 
     if (!result)
     {
-        sLog->outString(">> Loaded 0 spell required records");
+        sLog->outString(">> Loaded 0 spell required records. DB table `spell_required` is empty.");
         sLog->outString();
-        sLog->outErrorDb("`spell_required` table is empty!");
         return;
     }
-    uint32 rows = 0;
-
+
+    uint32 count = 0;
     do
     {
         Field* fields = result->Fetch();
 
-        uint32 spell_id =  fields[0].GetUInt32();
+        uint32 spell_id = fields[0].GetUInt32();
         uint32 spell_req = fields[1].GetUInt32();
+
         // check if chain is made with valid first spell
         SpellInfo const* spell = GetSpellInfo(spell_id);
         if (!spell)
@@ -1322,17 +1309,20 @@
             sLog->outErrorDb("spell_id %u in `spell_required` table is not found in dbcs, skipped", spell_id);
             continue;
         }
+
         SpellInfo const* req_spell = GetSpellInfo(spell_req);
         if (!req_spell)
         {
             sLog->outErrorDb("req_spell %u in `spell_required` table is not found in dbcs, skipped", spell_req);
             continue;
         }
+
         if (GetFirstSpellInChain(spell_id) == GetFirstSpellInChain(spell_req))
         {
             sLog->outErrorDb("req_spell %u and spell_id %u in `spell_required` table are ranks of the same spell, entry not needed, skipped", spell_req, spell_id);
             continue;
         }
+
         if (IsSpellRequiringSpell(spell_id, spell_req))
         {
             sLog->outErrorDb("duplicated entry of req_spell %u and spell_id %u in `spell_required`, skipped", spell_req, spell_id);
@@ -1341,10 +1331,10 @@
 
         mSpellReq.insert (std::pair<uint32, uint32>(spell_id, spell_req));
         mSpellsReqSpell.insert (std::pair<uint32, uint32>(spell_req, spell_id));
-        ++rows;
+        ++count;
     } while (result->NextRow());
 
-    sLog->outString(">> Loaded %u spell required records in %u ms", rows, GetMSTimeDiffToNow(oldMSTime));
+    sLog->outString(">> Loaded %u spell required records in %u ms", count, GetMSTimeDiffToNow(oldMSTime));
     sLog->outString();
 }
 
@@ -1396,24 +1386,22 @@
     QueryResult result = WorldDatabase.Query("SELECT entry, SpellID, Active FROM spell_learn_spell");
     if (!result)
     {
-        sLog->outString(">> Loaded 0 spell learn spells");
+        sLog->outString(">> Loaded 0 spell learn spells. DB table `spell_learn_spell` is empty.");
         sLog->outString();
-        sLog->outErrorDb("`spell_learn_spell` table is empty!");
         return;
     }
 
     uint32 count = 0;
-
     do
     {
         Field* fields = result->Fetch();
 
-        uint32 spell_id = fields[0].GetUInt32();
+        uint32 spell_id = fields[0].GetUInt16();
 
         SpellLearnSpellNode node;
-        node.spell      = fields[1].GetUInt32();
-        node.active     = fields[2].GetBool();
-        node.autoLearned= false;
+        node.spell       = fields[1].GetUInt16();
+        node.active      = fields[2].GetBool();
+        node.autoLearned = false;
 
         if (!GetSpellInfo(spell_id))
         {
@@ -1497,7 +1485,7 @@
 
     mSpellTargetPositions.clear();                                // need for reload case
 
-    //                                                0   1           2                  3                  4                  5
+    //                                                0      1              2                  3                  4                  5
     QueryResult result = WorldDatabase.Query("SELECT id, target_map, target_position_x, target_position_y, target_position_z, target_orientation FROM spell_target_position");
     if (!result)
     {
@@ -1507,7 +1495,6 @@
     }
 
     uint32 count = 0;
-
     do
     {
         Field* fields = result->Fetch();
@@ -1516,7 +1503,7 @@
 
         SpellTargetPosition st;
 
-        st.target_mapId       = fields[1].GetUInt32();
+        st.target_mapId       = fields[1].GetUInt16();
         st.target_X           = fields[2].GetFloat();
         st.target_Y           = fields[3].GetFloat();
         st.target_Z           = fields[4].GetFloat();
@@ -1619,19 +1606,17 @@
     mSpellSpellGroup.clear();                                  // need for reload case
     mSpellGroupSpell.clear();
 
-    uint32 count = 0;
-
-    //                                                       0   1
+    //                                                0     1
     QueryResult result = WorldDatabase.Query("SELECT id, spell_id FROM spell_group");
     if (!result)
     {
+        sLog->outString(">> Loaded 0 spell group definitions. DB table `spell_group` is empty.");
         sLog->outString();
-        sLog->outString(">> Loaded %u spell group definitions", count);
         return;
     }
 
     std::set<uint32> groups;
-
+    uint32 count = 0;
     do
     {
         Field* fields = result->Fetch();
@@ -1649,7 +1634,7 @@
 
     } while (result->NextRow());
 
-    for (SpellGroupSpellMap::iterator itr = mSpellGroupSpell.begin(); itr!= mSpellGroupSpell.end() ;)
+    for (SpellGroupSpellMap::iterator itr = mSpellGroupSpell.begin(); itr!= mSpellGroupSpell.end();)
     {
         if (itr->second < 0)
         {
@@ -1680,12 +1665,12 @@
         }
     }
 
-    for (std::set<uint32>::iterator groupItr = groups.begin() ; groupItr != groups.end() ; ++groupItr)
+    for (std::set<uint32>::iterator groupItr = groups.begin(); groupItr != groups.end(); ++groupItr)
     {
         std::set<uint32> spells;
         GetSetOfSpellsInSpellGroup(SpellGroup(*groupItr), spells);
 
-        for (std::set<uint32>::iterator spellItr = spells.begin() ; spellItr != spells.end() ; ++spellItr)
+        for (std::set<uint32>::iterator spellItr = spells.begin(); spellItr != spells.end(); ++spellItr)
         {
             ++count;
             mSpellSpellGroup.insert(SpellSpellGroupMap::value_type(*spellItr, SpellGroup(*groupItr)));
@@ -1702,23 +1687,22 @@
 
     mSpellGroupStack.clear();                                  // need for reload case
 
-    uint32 count = 0;
-
     //                                                       0         1
     QueryResult result = WorldDatabase.Query("SELECT group_id, stack_rule FROM spell_group_stack_rules");
     if (!result)
     {
-        sLog->outString(">> Loaded 0 spell group stack rules");
+        sLog->outString(">> Loaded 0 spell group stack rules. DB table `spell_group_stack_rules` is empty.");
         sLog->outString();
         return;
     }
 
+    uint32 count = 0;
     do
     {
         Field* fields = result->Fetch();
 
         uint32 group_id = fields[0].GetUInt32();
-        uint8 stack_rule = fields[1].GetUInt32();
+        uint8 stack_rule = fields[1].GetInt8();
         if (stack_rule >= SPELL_GROUP_STACK_RULE_MAX)
         {
             sLog->outErrorDb("SpellGroupStackRule %u listed in `spell_group_stack_rules` does not exist", stack_rule);
@@ -1748,17 +1732,16 @@
 
     mSpellProcEventMap.clear();                             // need for reload case
 
-    uint32 count = 0;
-
     //                                                0      1           2                3                 4                 5                 6          7       8        9             10
     QueryResult result = WorldDatabase.Query("SELECT entry, SchoolMask, SpellFamilyName, SpellFamilyMask0, SpellFamilyMask1, SpellFamilyMask2, procFlags, procEx, ppmRate, CustomChance, Cooldown FROM spell_proc_event");
     if (!result)
     {
-        sLog->outString(">> Loaded %u spell proc event conditions", count);
+        sLog->outString(">> Loaded 0 spell proc event conditions. DB table `spell_proc_event` is empty.");
         sLog->outString();
         return;
     }
 
+    uint32 count = 0;
     uint32 customProc = 0;
     do
     {
@@ -1775,8 +1758,8 @@
 
         SpellProcEventEntry spe;
 
-        spe.schoolMask      = fields[1].GetUInt32();
-        spe.spellFamilyName = fields[2].GetUInt32();
+        spe.schoolMask      = fields[1].GetInt8();
+        spe.spellFamilyName = fields[2].GetUInt16();
         spe.spellFamilyMask[0] = fields[3].GetUInt32();
         spe.spellFamilyMask[1] = fields[4].GetUInt32();
         spe.spellFamilyMask[2] = fields[5].GetUInt32();
@@ -1813,17 +1796,16 @@
 
     mSpellProcMap.clear();                             // need for reload case
 
-    uint32 count = 0;
-
-    //                                               0        1           2                3                 4                 5                 6         7              8               9        10              11             12      13        14
+    //                                                 0        1           2                3                 4                 5                 6         7              8               9        10              11             12      13        14
     QueryResult result = WorldDatabase.Query("SELECT spellId, schoolMask, spellFamilyName, spellFamilyMask0, spellFamilyMask1, spellFamilyMask2, typeMask, spellTypeMask, spellPhaseMask, hitMask, attributesMask, ratePerMinute, chance, cooldown, charges FROM spell_proc");
     if (!result)
     {
-        sLog->outString(">> Loaded %u spell proc conditions and data", count);
+        sLog->outString(">> Loaded 0 spell proc conditions and data. DB table `spell_proc` is empty.");
         sLog->outString();
         return;
     }
 
+    uint32 count = 0;
     do
     {
         Field* fields = result->Fetch();
@@ -1855,8 +1837,8 @@
 
         SpellProcEntry baseProcEntry;
 
-        baseProcEntry.schoolMask      = fields[1].GetUInt32();
-        baseProcEntry.spellFamilyName = fields[2].GetUInt32();
+        baseProcEntry.schoolMask      = fields[1].GetInt8();
+        baseProcEntry.spellFamilyName = fields[2].GetUInt16();
         baseProcEntry.spellFamilyMask[0] = fields[3].GetUInt32();
         baseProcEntry.spellFamilyMask[1] = fields[4].GetUInt32();
         baseProcEntry.spellFamilyMask[2] = fields[5].GetUInt32();
@@ -1954,16 +1936,17 @@
     uint32 oldMSTime = getMSTime();
 
     mSpellBonusMap.clear();                             // need for reload case
-    uint32 count = 0;
+
     //                                                0      1             2          3         4
     QueryResult result = WorldDatabase.Query("SELECT entry, direct_bonus, dot_bonus, ap_bonus, ap_dot_bonus FROM spell_bonus_data");
     if (!result)
     {
-        sLog->outString(">> Loaded %u spell bonus data", count);
+        sLog->outString(">> Loaded 0 spell bonus data. DB table `spell_bonus_data` is empty.");
         sLog->outString();
         return;
     }
 
+    uint32 count = 0;
     do
     {
         Field* fields = result->Fetch();
@@ -1995,17 +1978,16 @@
 
     mSpellThreatMap.clear();                                // need for reload case
 
-    uint32 count = 0;
-
     //                                                0      1        2       3
     QueryResult result = WorldDatabase.Query("SELECT entry, flatMod, pctMod, apPctMod FROM spell_threat");
     if (!result)
     {
-        sLog->outString(">> Loaded 0 aggro generating spells");
+        sLog->outString(">> Loaded 0 aggro generating spells. DB table `spell_threat` is empty.");
         sLog->outString();
         return;
     }
 
+    uint32 count = 0;
     do
     {
         Field* fields = result->Fetch();
@@ -2019,7 +2001,7 @@
         }
 
         SpellThreatEntry ste;
-        ste.flatMod  = fields[1].GetInt16();
+        ste.flatMod  = fields[1].GetInt32();
         ste.pctMod   = fields[2].GetFloat();
         ste.apPctMod = fields[3].GetFloat();
 
@@ -2069,7 +2051,6 @@
     }
 
     uint32 count = 0;
-
     do
     {
         Field* fields = result->Fetch();
@@ -2124,11 +2105,10 @@
     uint32 size = sSpellItemEnchantmentStore.GetNumRows();
     mEnchantCustomAttr.resize(size);
 
-    uint32 count = 0;
-
     for (uint32 i = 0; i < size; ++i)
        mEnchantCustomAttr[i] = 0;
 
+    uint32 count = 0;
     for (uint32 i = 0; i < GetSpellInfoStoreSize(); ++i)
     {
         SpellInfo const* spellInfo = GetSpellInfo(i);
@@ -2136,7 +2116,7 @@
             continue;
 
         // TODO: find a better check
-        if (!(spellInfo->AttributesEx2 & SPELL_ATTR2_UNK13) || !(spellInfo->Attributes & SPELL_ATTR0_NOT_SHAPESHIFT))
+        if (!(spellInfo->AttributesEx2 & SPELL_ATTR2_PRESERVE_ENCHANT_IN_ARENA) || !(spellInfo->Attributes & SPELL_ATTR0_NOT_SHAPESHIFT))
             continue;
 
         for (uint32 j = 0; j < MAX_SPELL_EFFECTS; ++j)
@@ -2164,17 +2144,16 @@
 
     mSpellEnchantProcEventMap.clear();                             // need for reload case
 
-    uint32 count = 0;
-
     //                                                  0         1           2         3
     QueryResult result = WorldDatabase.Query("SELECT entry, customChance, PPMChance, procEx FROM spell_enchant_proc_data");
     if (!result)
     {
-        sLog->outString(">> Loaded %u spell enchant proc event conditions", count);
+        sLog->outString(">> Loaded 0 spell enchant proc event conditions. DB table `spell_enchant_proc_data` is empty.");
         sLog->outString();
         return;
     }
 
+    uint32 count = 0;
     do
     {
         Field* fields = result->Fetch();
@@ -2219,14 +2198,13 @@
     }
 
     uint32 count = 0;
-
     do
     {
         Field* fields = result->Fetch();
 
         int32 trigger = fields[0].GetInt32();
-        int32 effect =  fields[1].GetInt32();
-        int32 type =    fields[2].GetInt32();
+        int32 effect = fields[1].GetInt32();
+        int32 type = fields[2].GetUInt8();
 
         SpellInfo const* spellInfo = GetSpellInfo(abs(trigger));
         if (!spellInfo)
@@ -2464,7 +2442,6 @@
     }
 
     uint32 count = 0;
-
     do
     {
         Field* fields = result->Fetch();
@@ -2990,6 +2967,7 @@
             case 40166: // Introspection
             case 40167: // Introspection
                 spellInfo->Attributes |= SPELL_ATTR0_NEGATIVE_1;
+                break;
             default:
                 break;
         }
@@ -3342,6 +3320,10 @@
                 spellInfo->EffectDieSides[0] = 0; // was 1, that should probably mean seat 0, but instead it's treated as spell 1
                 spellInfo->EffectBasePoints[0] = 52391; // Ride Vehicle (forces seat 0)
                 break;
+            case 64745: // Item - Death Knight T8 Tank 4P Bonus
+            case 64936: // Item - Warrior T8 Protection 4P Bonus
+                spellInfo->EffectBasePoints[0] = 100; // 100% chance of procc'ing, not -10% (chance calculated in PrepareTriggersExecutedOnHit)
+                break;
             case 19970: // Entangling Roots (Rank 6) -- Nature's Grasp Proc
             case 19971: // Entangling Roots (Rank 5) -- Nature's Grasp Proc
             case 19972: // Entangling Roots (Rank 4) -- Nature's Grasp Proc
@@ -3540,9 +3522,9 @@
         case 70460: // Coldflame Jets (Traps after Saurfang)
             spellInfo->DurationIndex = 1;   // 10 seconds
             break;
-        case 71413: // Green Ooze Summon (Professor Putricide)
-        case 71414: // Orange Ooze Summon (Professor Putricide)
-            spellInfo->EffectImplicitTargetA[0] = TARGET_DEST_DEST;
+            case 71412: // Green Ooze Summon (Professor Putricide)
+            case 71415: // Orange Ooze Summon (Professor Putricide)
+                spellInfo->EffectImplicitTargetA[0] = TARGET_UNIT_TARGET_ANY;
             break;
             case 71159: // Awaken Plagued Zombies
                 spellInfo->DurationIndex = 21;
@@ -3602,10 +3584,7 @@
             spellInfo->EffectImplicitTargetA[0] = TARGET_DEST_CASTER;
             break;
         case 69846: // Frost Bomb
-            spellInfo->speed = 10;
-            spellInfo->EffectImplicitTargetA[0] = TARGET_DEST_TARGET_ANY;
-            spellInfo->EffectImplicitTargetB[0] = TARGET_UNIT_TARGET_ANY;
-            spellInfo->Effect[1] = 0;
+            spellInfo->speed = 0.0f;    // This spell's summon happens instantly
             break;
         case 51678: //WintergraspSiegeEngine Ram set damage radius to 5 yards
             spellInfo->EffectRadiusIndex[0] = EFFECT_RADIUS_5_YARDS;
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Spells/SpellMgr.h
--- a/src/server/game/Spells/SpellMgr.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Spells/SpellMgr.h	Mon Apr 16 14:29:17 2012 +0300
@@ -693,7 +693,6 @@
     public:
 
         // Loading data at server startup
-        void LoadSpellInfos();
         void LoadSpellRanks();
         void LoadSpellRequired();
         void LoadSpellLearnSkills();
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Spells/SpellScript.cpp
--- a/src/server/game/Spells/SpellScript.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Spells/SpellScript.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -774,6 +774,7 @@
         case AURA_SCRIPT_HOOK_EFFECT_APPLY:
         case AURA_SCRIPT_HOOK_EFFECT_REMOVE:
         case AURA_SCRIPT_HOOK_EFFECT_PERIODIC:
+        case AURA_SCRIPT_HOOK_EFFECT_ABSORB:
             return m_defaultActionPrevented;
         default:
             ASSERT(false && "AuraScript::_IsDefaultActionPrevented is called in a wrong place");
@@ -788,6 +789,7 @@
         case AURA_SCRIPT_HOOK_EFFECT_APPLY:
         case AURA_SCRIPT_HOOK_EFFECT_REMOVE:
         case AURA_SCRIPT_HOOK_EFFECT_PERIODIC:
+        case AURA_SCRIPT_HOOK_EFFECT_ABSORB:
             m_defaultActionPrevented = true;
             break;
         default:
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Tickets/TicketMgr.cpp
--- a/src/server/game/Tickets/TicketMgr.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Tickets/TicketMgr.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -1,366 +1,387 @@
-/*
- * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
- * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "Common.h"
-#include "TicketMgr.h"
-#include "DatabaseEnv.h"
-#include "Log.h"
-#include "WorldPacket.h"
-#include "WorldSession.h"
-#include "Chat.h"
-#include "World.h"
-
-inline float GetAge(uint64 t) { return float(time(NULL) - t) / DAY; }
-
-///////////////////////////////////////////////////////////////////////////////////////////////////
-// GM ticket
-GmTicket::GmTicket() { }
-
-GmTicket::GmTicket(Player* player, WorldPacket& recv_data) : _createTime(time(NULL)), _lastModifiedTime(time(NULL)), _closedBy(0), _assignedTo(0), _completed(false), _escalatedStatus(TICKET_UNASSIGNED)
-{
-    _id = sTicketMgr->GenerateTicketId();
-    _playerName = player->GetName();
-    _playerGuid = player->GetGUID();
-
-    uint32 mapId;
-    recv_data >> mapId;
-    _mapId = mapId;
-
-    recv_data >> _posX;
-    recv_data >> _posY;
-    recv_data >> _posZ;
-    recv_data >> _message;
-
-    uint32 unk1;
-    recv_data >> unk1;          // not sure what this is... replyTo?
-    uint8 needResponse;
-    recv_data >> needResponse;  // always 1/0 -- not sure what retail does with this
-}
-
-GmTicket::~GmTicket() { }
-
-bool GmTicket::LoadFromDB(Field* fields)
-{
-    uint8 index = 0;
-    _id                 = fields[  index].GetUInt32();
-    _playerGuid         = MAKE_NEW_GUID(fields[++index].GetUInt32(), 0, HIGHGUID_PLAYER);
-    _playerName         = fields[++index].GetString();
-    _message            = fields[++index].GetString();
-    _createTime         = fields[++index].GetUInt32();
-    _mapId              = fields[++index].GetUInt16();
-    _posX               = fields[++index].GetFloat();
-    _posY               = fields[++index].GetFloat();
-    _posZ               = fields[++index].GetFloat();
-    _lastModifiedTime   = fields[++index].GetUInt32();
-    _closedBy           = fields[++index].GetInt32();
-    _assignedTo         = MAKE_NEW_GUID(fields[++index].GetUInt32(), 0, HIGHGUID_PLAYER);
-    _comment            = fields[++index].GetString();
-    _completed          = fields[++index].GetBool();
-    _escalatedStatus    = GMTicketEscalationStatus(fields[++index].GetUInt8());
-    _viewed             = fields[++index].GetBool();
-    return true;
-}
-
-void GmTicket::SaveToDB(SQLTransaction& trans) const
-{
-    uint8 index = 0;
-    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_GM_TICKET);
-    stmt->setUInt32(  index, _id);
-    stmt->setUInt32(++index, GUID_LOPART(_playerGuid));
-    stmt->setString(++index, _playerName);
-    stmt->setString(++index, _message);
-    stmt->setUInt32(++index, uint32(_createTime));
-    stmt->setUInt16(++index, _mapId);
-    stmt->setFloat (++index, _posX);
-    stmt->setFloat (++index, _posY);
-    stmt->setFloat (++index, _posZ);
-    stmt->setUInt32(++index, uint32(_lastModifiedTime));
-    stmt->setInt32 (++index, GUID_LOPART(_closedBy));
-    stmt->setUInt32(++index, GUID_LOPART(_assignedTo));
-    stmt->setString(++index, _comment);
-    stmt->setBool  (++index, _completed);
-    stmt->setUInt8 (++index, uint8(_escalatedStatus));
-    stmt->setBool  (++index, _viewed);
-
-    CharacterDatabase.ExecuteOrAppend(trans, stmt);
-}
-
-void GmTicket::DeleteFromDB()
-{
-    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GM_TICKET);
-    stmt->setUInt32(0, _id);
-    CharacterDatabase.Execute(stmt);
-}
-
-void GmTicket::WritePacket(WorldPacket& data) const
-{
-    data << GetAge(_lastModifiedTime);
-    if (GmTicket* ticket = sTicketMgr->GetOldestOpenTicket())
-        data << GetAge(ticket->GetLastModifiedTime());
-    else
-        data << float(0);
-
-    // I am not sure how blizzlike this is, and we don't really have a way to find out
-    data << GetAge(sTicketMgr->GetLastChange());
-
-    data << uint8(std::min(_escalatedStatus, TICKET_IN_ESCALATION_QUEUE));                              // escalated data
-    data << uint8(_viewed ? GMTICKET_OPENEDBYGM_STATUS_OPENED : GMTICKET_OPENEDBYGM_STATUS_NOT_OPENED); // whether or not it has been viewed
-}
-
-void GmTicket::SendResponse(WorldSession* session) const
-{
-    WorldPacket data(SMSG_GMRESPONSE_RECEIVED);
-    data << uint32(1); // unk? Zor says "hasActiveTicket"
-    data << uint32(0); // can-edit - always 1 or 0, not flags
-    data << _message.c_str();
-    data << _response.c_str();
-    // 3 null strings
-    data << uint8(0);
-    data << uint8(0);
-    data << uint8(0);
-    session->SendPacket(&data);
-}
-
-std::string GmTicket::FormatMessageString(ChatHandler& handler, bool detailed) const
-{
-    time_t curTime = time(NULL);
-
-    std::stringstream ss;
-    ss << handler.PGetParseString(LANG_COMMAND_TICKETLISTGUID, _id);
-    ss << handler.PGetParseString(LANG_COMMAND_TICKETLISTNAME, _playerName.c_str());
-    ss << handler.PGetParseString(LANG_COMMAND_TICKETLISTAGECREATE, (secsToTimeString(curTime - _createTime, true, false)).c_str());
-    ss << handler.PGetParseString(LANG_COMMAND_TICKETLISTAGE, (secsToTimeString(curTime - _lastModifiedTime, true, false)).c_str());
-
-    std::string name;
-    if (sObjectMgr->GetPlayerNameByGUID(_assignedTo, name))
-        ss << handler.PGetParseString(LANG_COMMAND_TICKETLISTASSIGNEDTO, name.c_str());
-
-    if (detailed)
-    {
-        ss << handler.PGetParseString(LANG_COMMAND_TICKETLISTMESSAGE, _message.c_str());
-        if (!_comment.empty())
-            ss << handler.PGetParseString(LANG_COMMAND_TICKETLISTCOMMENT, _comment.c_str());
-    }
-    return ss.str();
-}
-
-std::string GmTicket::FormatMessageString(ChatHandler& handler, const char* szClosedName, const char* szAssignedToName, const char* szUnassignedName, const char* szDeletedName) const
-{
-    std::stringstream ss;
-    ss << handler.PGetParseString(LANG_COMMAND_TICKETLISTGUID, _id);
-    ss << handler.PGetParseString(LANG_COMMAND_TICKETLISTNAME, _playerName.c_str());
-    if (szClosedName)
-        ss << handler.PGetParseString(LANG_COMMAND_TICKETCLOSED, szClosedName);
-    if (szAssignedToName)
-        ss << handler.PGetParseString(LANG_COMMAND_TICKETLISTASSIGNEDTO, szAssignedToName);
-    if (szUnassignedName)
-        ss << handler.PGetParseString(LANG_COMMAND_TICKETLISTUNASSIGNED, szUnassignedName);
-    if (szDeletedName)
-        ss << handler.PGetParseString(LANG_COMMAND_TICKETDELETED, szDeletedName);
-    return ss.str();
-}
-
-void GmTicket::SetUnassigned()
-{
-    _assignedTo = 0;
-    switch (_escalatedStatus)
-    {
-        case TICKET_ASSIGNED: _escalatedStatus = TICKET_UNASSIGNED; break;
-        case TICKET_ESCALATED_ASSIGNED: _escalatedStatus = TICKET_IN_ESCALATION_QUEUE; break;
-        case TICKET_UNASSIGNED:
-        case TICKET_IN_ESCALATION_QUEUE:
-        default:
-            break;
-    }
-}
-
-void GmTicket::TeleportTo(Player* player) const
-{
-    player->TeleportTo(_mapId, _posX, _posY, _posZ, 1, 0);
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////////////
-// Ticket manager
-TicketMgr::TicketMgr() : _status(true), _lastTicketId(0), _lastSurveyId(0), _openTicketCount(0), _lastChange(time(NULL)) { }
-
-void TicketMgr::Initialize() { SetStatus(sWorld->getBoolConfig(CONFIG_ALLOW_TICKETS)); }
-
-void TicketMgr::ResetTickets()
-{
-    for (GmTicketList::const_iterator itr = _ticketList.begin(); itr != _ticketList.end(); ++itr)
-        if (itr->second->IsClosed())
-            sTicketMgr->RemoveTicket(itr->second->GetId());
-
-    _lastTicketId = 0;
-
-    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ALL_GM_TICKETS);
-
-    CharacterDatabase.Execute(stmt);
-}
-
-void TicketMgr::LoadTickets()
-{
-    uint32 oldMSTime = getMSTime();
-
-    if (!_ticketList.empty())
-        for (GmTicketList::const_iterator itr = _ticketList.begin(); itr != _ticketList.end(); ++itr)
-            if (itr->second)
-                delete itr->second;
-    _ticketList.clear();
-
-    _lastTicketId = 0;
-    _openTicketCount = 0;
-
-    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GM_TICKETS);
-    PreparedQueryResult result = CharacterDatabase.Query(stmt);
-    if (!result)
-    {
-        sLog->outString(">> Loaded 0 GM tickets. DB table `gm_tickets` is empty!");
-        sLog->outString();
-        return;
-    }
-
-    uint32 count = 0;
-    do
-    {
-        Field* fields = result->Fetch();
-        GmTicket* ticket = new GmTicket();
-        if (!ticket->LoadFromDB(fields))
-        {
-            delete ticket;
-            continue;
-        }
-        if (!ticket->IsClosed())
-            ++_openTicketCount;
-
-        // Update max ticket id if necessary
-        uint32 id = ticket->GetId();
-        if (_lastTicketId < id)
-            _lastTicketId = id;
-
-        _ticketList[id] = ticket;
-        ++count;
-    } while (result->NextRow());
-
-    sLog->outString(">> Loaded %u GM tickets in %u ms", count, GetMSTimeDiffToNow(oldMSTime));
-    sLog->outString();
-}
-
-void TicketMgr::LoadSurveys()
-{
-    // we don't actually load anything into memory here as there's no reason to
-    _lastSurveyId = 0;
-
-    uint32 oldMSTime = getMSTime();
-    if (QueryResult result = CharacterDatabase.Query("SELECT MAX(surveyId) FROM gm_surveys"))
-        _lastSurveyId = (*result)[0].GetUInt32();
-
-    sLog->outString(">> Loaded GM Survey count from database in %u ms", GetMSTimeDiffToNow(oldMSTime));
-    sLog->outString();
-}
-
-void TicketMgr::AddTicket(GmTicket* ticket)
-{
-    _ticketList[ticket->GetId()] = ticket;
-    if (!ticket->IsClosed())
-        ++_openTicketCount;
-    SQLTransaction trans = SQLTransaction(NULL);
-    ticket->SaveToDB(trans);
-}
-
-void TicketMgr::CloseTicket(uint32 ticketId, int64 source)
-{
-    if (GmTicket* ticket = GetTicket(ticketId))
-    {
-        SQLTransaction trans = SQLTransaction(NULL);
-        ticket->SetClosedBy(source);
-        if (source)
-            --_openTicketCount;
-        ticket->SaveToDB(trans);
-    }
-}
-
-void TicketMgr::RemoveTicket(uint32 ticketId)
-{
-    if (GmTicket* ticket = GetTicket(ticketId))
-    {
-        ticket->DeleteFromDB();
-        _ticketList.erase(ticketId);
-    }
-}
-
-void TicketMgr::ShowList(ChatHandler& handler, bool onlineOnly) const
-{
-    handler.SendSysMessage(onlineOnly ? LANG_COMMAND_TICKETSHOWONLINELIST : LANG_COMMAND_TICKETSHOWLIST);
-    for (GmTicketList::const_iterator itr = _ticketList.begin(); itr != _ticketList.end(); ++itr)
-        if (!itr->second->IsClosed() && !itr->second->IsCompleted())
-            if (!onlineOnly || itr->second->GetPlayer())
-                handler.SendSysMessage(itr->second->FormatMessageString(handler).c_str());
-}
-
-void TicketMgr::ShowClosedList(ChatHandler& handler) const
-{
-    handler.SendSysMessage(LANG_COMMAND_TICKETSHOWCLOSEDLIST);
-    for (GmTicketList::const_iterator itr = _ticketList.begin(); itr != _ticketList.end(); ++itr)
-        if (itr->second->IsClosed())
-            handler.SendSysMessage(itr->second->FormatMessageString(handler).c_str());
-}
-
-void TicketMgr::ShowEscalatedList(ChatHandler& handler) const
-{
-    handler.SendSysMessage(LANG_COMMAND_TICKETSHOWESCALATEDLIST);
-    for (GmTicketList::const_iterator itr = _ticketList.begin(); itr != _ticketList.end(); ++itr)
-        if (!itr->second->IsClosed() && itr->second->GetEscalatedStatus() == TICKET_IN_ESCALATION_QUEUE)
-            handler.SendSysMessage(itr->second->FormatMessageString(handler).c_str());
-}
-
-void TicketMgr::SendTicket(WorldSession* session, GmTicket* ticket) const
-{
-    uint32 status = GMTICKET_STATUS_DEFAULT;
-    std::string message;
-    if (ticket)
-    {
-        message = ticket->GetMessage();
-        status = GMTICKET_STATUS_HASTEXT;
-    }
-
-    WorldPacket data(SMSG_GMTICKET_GETTICKET, (4 + 4 + (ticket ? message.length() + 1 + 4 + 4 + 4 + 1 + 1 : 0)));
-    data << uint32(status);         // standard 0x0A, 0x06 if text present
-    data << uint32(1);              // g_HasActiveGMTicket -- not a flag
-
-    if (ticket)
-    {
-        data << message.c_str();    // ticket text
-        data << uint8(0x7);         // ticket category; why is this hardcoded? does it make a diff re: client?
-
-        // we've got the easy stuff done by now.
-        // Now we need to go through the client logic for displaying various levels of ticket load
-        if (ticket)
-            ticket->WritePacket(data);
-        else
-        {
-            // we can't actually get any numbers here...
-            data << float(0);
-            data << float(0);
-            data << float(1);
-            data << uint8(0);
-            data << uint8(0);
-        }
-    }
-    session->SendPacket(&data);
-}
+/*
+ * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "Common.h"
+#include "TicketMgr.h"
+#include "DatabaseEnv.h"
+#include "Log.h"
+#include "WorldPacket.h"
+#include "WorldSession.h"
+#include "Chat.h"
+#include "World.h"
+
+inline float GetAge(uint64 t) { return float(time(NULL) - t) / DAY; }
+
+///////////////////////////////////////////////////////////////////////////////////////////////////
+// GM ticket
+GmTicket::GmTicket() { }
+
+GmTicket::GmTicket(Player* player, WorldPacket& recv_data) : _createTime(time(NULL)), _lastModifiedTime(time(NULL)), _closedBy(0), _assignedTo(0), _completed(false), _escalatedStatus(TICKET_UNASSIGNED)
+{
+    _id = sTicketMgr->GenerateTicketId();
+    _playerName = player->GetName();
+    _playerGuid = player->GetGUID();
+
+    uint32 mapId;
+    recv_data >> mapId; // Map is sent as UInt32!
+    _mapId = mapId;
+
+    recv_data >> _posX;
+    recv_data >> _posY;
+    recv_data >> _posZ;
+    recv_data >> _message;
+    uint32 needResponse;
+    recv_data >> needResponse;
+    _needResponse = (needResponse == 17); // Requires GM response. 17 = true, 1 = false (17 is default)
+    uint8 unk1;
+    recv_data >> unk1; // Requests further GM interaction on a ticket to which a GM has already responded
+
+    recv_data.rfinish();
+    /*
+    recv_data >> uint32(count); // text lines
+    for (int i = 0; i < count; i++)
+        recv_data >> uint32();
+
+    if (something)
+        recv_data >> uint32();
+    else
+        compressed uint32 + string;
+    */
+}
+
+GmTicket::~GmTicket() { }
+
+bool GmTicket::LoadFromDB(Field* fields)
+{
+    //     0       1     2      3          4        5      6     7     8           9            10         11         12        13        14        15
+    // ticketId, guid, name, message, createTime, mapId, posX, posY, posZ, lastModifiedTime, closedBy, assignedTo, comment, completed, escalated, viewed
+    uint8 index = 0;
+    _id                 = fields[  index].GetUInt32();
+    _playerGuid         = MAKE_NEW_GUID(fields[++index].GetUInt32(), 0, HIGHGUID_PLAYER);
+    _playerName         = fields[++index].GetString();
+    _message            = fields[++index].GetString();
+    _createTime         = fields[++index].GetUInt32();
+    _mapId              = fields[++index].GetUInt16();
+    _posX               = fields[++index].GetFloat();
+    _posY               = fields[++index].GetFloat();
+    _posZ               = fields[++index].GetFloat();
+    _lastModifiedTime   = fields[++index].GetUInt32();
+    _closedBy           = fields[++index].GetInt32();
+    _assignedTo         = MAKE_NEW_GUID(fields[++index].GetUInt32(), 0, HIGHGUID_PLAYER);
+    _comment            = fields[++index].GetString();
+    _completed          = fields[++index].GetBool();
+    _escalatedStatus    = GMTicketEscalationStatus(fields[++index].GetUInt8());
+    _viewed             = fields[++index].GetBool();
+    return true;
+}
+
+void GmTicket::SaveToDB(SQLTransaction& trans) const
+{
+    //     0       1     2      3          4        5      6     7     8           9            10         11         12        13        14        15
+    // ticketId, guid, name, message, createTime, mapId, posX, posY, posZ, lastModifiedTime, closedBy, assignedTo, comment, completed, escalated, viewed
+    uint8 index = 0;
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_GM_TICKET);
+    stmt->setUInt32(  index, _id);
+    stmt->setUInt32(++index, GUID_LOPART(_playerGuid));
+    stmt->setString(++index, _playerName);
+    stmt->setString(++index, _message);
+    stmt->setUInt32(++index, uint32(_createTime));
+    stmt->setUInt16(++index, _mapId);
+    stmt->setFloat (++index, _posX);
+    stmt->setFloat (++index, _posY);
+    stmt->setFloat (++index, _posZ);
+    stmt->setUInt32(++index, uint32(_lastModifiedTime));
+    stmt->setInt32 (++index, GUID_LOPART(_closedBy));
+    stmt->setUInt32(++index, GUID_LOPART(_assignedTo));
+    stmt->setString(++index, _comment);
+    stmt->setBool  (++index, _completed);
+    stmt->setUInt8 (++index, uint8(_escalatedStatus));
+    stmt->setBool  (++index, _viewed);
+
+    CharacterDatabase.ExecuteOrAppend(trans, stmt);
+}
+
+void GmTicket::DeleteFromDB()
+{
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GM_TICKET);
+    stmt->setUInt32(0, _id);
+    CharacterDatabase.Execute(stmt);
+}
+
+void GmTicket::WritePacket(WorldPacket& data) const
+{
+    data << GetAge(_lastModifiedTime);
+    if (GmTicket* ticket = sTicketMgr->GetOldestOpenTicket())
+        data << GetAge(ticket->GetLastModifiedTime());
+    else
+        data << float(0);
+
+    // I am not sure how blizzlike this is, and we don't really have a way to find out
+    data << GetAge(sTicketMgr->GetLastChange());
+
+    data << uint8(std::min(_escalatedStatus, TICKET_IN_ESCALATION_QUEUE));                              // escalated data
+    data << uint8(_viewed ? GMTICKET_OPENEDBYGM_STATUS_OPENED : GMTICKET_OPENEDBYGM_STATUS_NOT_OPENED); // whether or not it has been viewed
+}
+
+void GmTicket::SendResponse(WorldSession* session) const
+{
+    WorldPacket data(SMSG_GMRESPONSE_RECEIVED);
+    data << uint32(1);          // responseID
+    data << uint32(_id);        // ticketID
+    data << _message.c_str();
+    data << _response.c_str();
+    // 3 null strings (unused)
+    data << uint8(0);
+    data << uint8(0);
+    data << uint8(0);
+    session->SendPacket(&data);
+}
+
+std::string GmTicket::FormatMessageString(ChatHandler& handler, bool detailed) const
+{
+    time_t curTime = time(NULL);
+
+    std::stringstream ss;
+    ss << handler.PGetParseString(LANG_COMMAND_TICKETLISTGUID, _id);
+    ss << handler.PGetParseString(LANG_COMMAND_TICKETLISTNAME, _playerName.c_str());
+    ss << handler.PGetParseString(LANG_COMMAND_TICKETLISTAGECREATE, (secsToTimeString(curTime - _createTime, true, false)).c_str());
+    ss << handler.PGetParseString(LANG_COMMAND_TICKETLISTAGE, (secsToTimeString(curTime - _lastModifiedTime, true, false)).c_str());
+
+    std::string name;
+    if (sObjectMgr->GetPlayerNameByGUID(_assignedTo, name))
+        ss << handler.PGetParseString(LANG_COMMAND_TICKETLISTASSIGNEDTO, name.c_str());
+
+    if (detailed)
+    {
+        ss << handler.PGetParseString(LANG_COMMAND_TICKETLISTMESSAGE, _message.c_str());
+        if (!_comment.empty())
+            ss << handler.PGetParseString(LANG_COMMAND_TICKETLISTCOMMENT, _comment.c_str());
+    }
+    return ss.str();
+}
+
+std::string GmTicket::FormatMessageString(ChatHandler& handler, const char* szClosedName, const char* szAssignedToName, const char* szUnassignedName, const char* szDeletedName) const
+{
+    std::stringstream ss;
+    ss << handler.PGetParseString(LANG_COMMAND_TICKETLISTGUID, _id);
+    ss << handler.PGetParseString(LANG_COMMAND_TICKETLISTNAME, _playerName.c_str());
+    if (szClosedName)
+        ss << handler.PGetParseString(LANG_COMMAND_TICKETCLOSED, szClosedName);
+    if (szAssignedToName)
+        ss << handler.PGetParseString(LANG_COMMAND_TICKETLISTASSIGNEDTO, szAssignedToName);
+    if (szUnassignedName)
+        ss << handler.PGetParseString(LANG_COMMAND_TICKETLISTUNASSIGNED, szUnassignedName);
+    if (szDeletedName)
+        ss << handler.PGetParseString(LANG_COMMAND_TICKETDELETED, szDeletedName);
+    return ss.str();
+}
+
+void GmTicket::SetUnassigned()
+{
+    _assignedTo = 0;
+    switch (_escalatedStatus)
+    {
+        case TICKET_ASSIGNED: _escalatedStatus = TICKET_UNASSIGNED; break;
+        case TICKET_ESCALATED_ASSIGNED: _escalatedStatus = TICKET_IN_ESCALATION_QUEUE; break;
+        case TICKET_UNASSIGNED:
+        case TICKET_IN_ESCALATION_QUEUE:
+        default:
+            break;
+    }
+}
+
+void GmTicket::TeleportTo(Player* player) const
+{
+    player->TeleportTo(_mapId, _posX, _posY, _posZ, 0.0f, 0);
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////////////
+// Ticket manager
+TicketMgr::TicketMgr() : _status(true), _lastTicketId(0), _lastSurveyId(0), _openTicketCount(0), _lastChange(time(NULL)) { }
+
+TicketMgr::~TicketMgr()
+{
+    for (GmTicketList::const_iterator itr = _ticketList.begin(); itr != _ticketList.end(); ++itr)
+        delete itr->second;
+}
+
+void TicketMgr::Initialize() { SetStatus(sWorld->getBoolConfig(CONFIG_ALLOW_TICKETS)); }
+
+void TicketMgr::ResetTickets()
+{
+    for (GmTicketList::const_iterator itr = _ticketList.begin(); itr != _ticketList.end(); ++itr)
+        if (itr->second->IsClosed())
+            sTicketMgr->RemoveTicket(itr->second->GetId());
+
+    _lastTicketId = 0;
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ALL_GM_TICKETS);
+
+    CharacterDatabase.Execute(stmt);
+}
+
+void TicketMgr::LoadTickets()
+{
+    uint32 oldMSTime = getMSTime();
+
+    for (GmTicketList::const_iterator itr = _ticketList.begin(); itr != _ticketList.end(); ++itr)
+        delete itr->second;
+    _ticketList.clear();
+
+    _lastTicketId = 0;
+    _openTicketCount = 0;
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GM_TICKETS);
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+    if (!result)
+    {
+        sLog->outString(">> Loaded 0 GM tickets. DB table `gm_tickets` is empty!");
+        sLog->outString();
+        return;
+    }
+
+    uint32 count = 0;
+    do
+    {
+        Field* fields = result->Fetch();
+        GmTicket* ticket = new GmTicket();
+        if (!ticket->LoadFromDB(fields))
+        {
+            delete ticket;
+            continue;
+        }
+        if (!ticket->IsClosed())
+            ++_openTicketCount;
+
+        // Update max ticket id if necessary
+        uint32 id = ticket->GetId();
+        if (_lastTicketId < id)
+            _lastTicketId = id;
+
+        _ticketList[id] = ticket;
+        ++count;
+    } while (result->NextRow());
+
+    sLog->outString(">> Loaded %u GM tickets in %u ms", count, GetMSTimeDiffToNow(oldMSTime));
+    sLog->outString();
+}
+
+void TicketMgr::LoadSurveys()
+{
+    // we don't actually load anything into memory here as there's no reason to
+    _lastSurveyId = 0;
+
+    uint32 oldMSTime = getMSTime();
+    if (QueryResult result = CharacterDatabase.Query("SELECT MAX(surveyId) FROM gm_surveys"))
+        _lastSurveyId = (*result)[0].GetUInt32();
+
+    sLog->outString(">> Loaded GM Survey count from database in %u ms", GetMSTimeDiffToNow(oldMSTime));
+    sLog->outString();
+}
+
+void TicketMgr::AddTicket(GmTicket* ticket)
+{
+    _ticketList[ticket->GetId()] = ticket;
+    if (!ticket->IsClosed())
+        ++_openTicketCount;
+    SQLTransaction trans = SQLTransaction(NULL);
+    ticket->SaveToDB(trans);
+}
+
+void TicketMgr::CloseTicket(uint32 ticketId, int64 source)
+{
+    if (GmTicket* ticket = GetTicket(ticketId))
+    {
+        SQLTransaction trans = SQLTransaction(NULL);
+        ticket->SetClosedBy(source);
+        if (source)
+            --_openTicketCount;
+        ticket->SaveToDB(trans);
+    }
+}
+
+void TicketMgr::RemoveTicket(uint32 ticketId)
+{
+    if (GmTicket* ticket = GetTicket(ticketId))
+    {
+        ticket->DeleteFromDB();
+        _ticketList.erase(ticketId);
+        delete ticket;
+    }
+}
+
+void TicketMgr::ShowList(ChatHandler& handler, bool onlineOnly) const
+{
+    handler.SendSysMessage(onlineOnly ? LANG_COMMAND_TICKETSHOWONLINELIST : LANG_COMMAND_TICKETSHOWLIST);
+    for (GmTicketList::const_iterator itr = _ticketList.begin(); itr != _ticketList.end(); ++itr)
+        if (!itr->second->IsClosed() && !itr->second->IsCompleted())
+            if (!onlineOnly || itr->second->GetPlayer())
+                handler.SendSysMessage(itr->second->FormatMessageString(handler).c_str());
+}
+
+void TicketMgr::ShowClosedList(ChatHandler& handler) const
+{
+    handler.SendSysMessage(LANG_COMMAND_TICKETSHOWCLOSEDLIST);
+    for (GmTicketList::const_iterator itr = _ticketList.begin(); itr != _ticketList.end(); ++itr)
+        if (itr->second->IsClosed())
+            handler.SendSysMessage(itr->second->FormatMessageString(handler).c_str());
+}
+
+void TicketMgr::ShowEscalatedList(ChatHandler& handler) const
+{
+    handler.SendSysMessage(LANG_COMMAND_TICKETSHOWESCALATEDLIST);
+    for (GmTicketList::const_iterator itr = _ticketList.begin(); itr != _ticketList.end(); ++itr)
+        if (!itr->second->IsClosed() && itr->second->GetEscalatedStatus() == TICKET_IN_ESCALATION_QUEUE)
+            handler.SendSysMessage(itr->second->FormatMessageString(handler).c_str());
+}
+
+void TicketMgr::SendTicket(WorldSession* session, GmTicket* ticket) const
+{
+    uint32 status = GMTICKET_STATUS_DEFAULT;
+    std::string message;
+    if (ticket)
+    {
+        message = ticket->GetMessage();
+        status = GMTICKET_STATUS_HASTEXT;
+    }
+
+    WorldPacket data(SMSG_GMTICKET_GETTICKET, (4 + 4 + (ticket ? message.length() + 1 + 4 + 4 + 4 + 1 + 1 : 0)));
+    data << uint32(status);                         // standard 0x0A, 0x06 if text present
+    data << uint32(ticket ? ticket->GetId() : 0);   // ticketID
+
+    if (ticket)
+    {
+        data << message.c_str();                    // ticket text
+        data << uint8(0x7);                         // ticket category; why is this hardcoded? does it make a diff re: client?
+
+        // we've got the easy stuff done by now.
+        // Now we need to go through the client logic for displaying various levels of ticket load
+        if (ticket)
+            ticket->WritePacket(data);
+        else
+        {
+            // we can't actually get any numbers here...
+            data << float(0);
+            data << float(0);
+            data << float(1);
+            data << uint8(0);
+            data << uint8(0);
+        }
+    }
+    session->SendPacket(&data);
+}
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Tickets/TicketMgr.h
--- a/src/server/game/Tickets/TicketMgr.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Tickets/TicketMgr.h	Mon Apr 16 14:29:17 2012 +0300
@@ -40,8 +40,11 @@
 
 enum GMTicketResponse
 {
-    GMTICKET_RESPONSE_FAILURE                     = 1,
-    GMTICKET_RESPONSE_SUCCESS                     = 2,
+    GMTICKET_RESPONSE_ALREADY_EXIST               = 1,
+    GMTICKET_RESPONSE_CREATE_SUCCESS              = 2,
+    GMTICKET_RESPONSE_CREATE_ERROR                = 3,
+    GMTICKET_RESPONSE_UPDATE_SUCCESS              = 4,
+    GMTICKET_RESPONSE_UPDATE_ERROR                = 5,
     GMTICKET_RESPONSE_TICKET_DELETED              = 9,
 };
 
@@ -156,6 +159,7 @@
     bool _completed;
     GMTicketEscalationStatus _escalatedStatus;
     bool _viewed;
+    bool _needResponse; // TODO: find out the use of this, and then store it in DB
     std::string _response;
 };
 typedef std::map<uint32, GmTicket*> GmTicketList;
@@ -166,6 +170,7 @@
 
 private:
     TicketMgr();
+    ~TicketMgr();
 
 public:
     void LoadTickets();
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Tools/PlayerDump.cpp
--- a/src/server/game/Tools/PlayerDump.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Tools/PlayerDump.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -306,22 +306,28 @@
             switch (type)
             {
                 case DTT_INVENTORY:
-                    StoreGUID(result, 3, items); break;       // item guid collection (character_inventory.item)
+                    StoreGUID(result, 3, items);                // item guid collection (character_inventory.item)
+                    break;
                 case DTT_PET:
-                    StoreGUID(result, 0, pets);  break;       // pet petnumber collection (character_pet.id)
+                    StoreGUID(result, 0, pets);                 // pet petnumber collection (character_pet.id)
+                    break;
                 case DTT_MAIL:
-                    StoreGUID(result, 0, mails);              // mail id collection (mail.id)
+                    StoreGUID(result, 0, mails);                // mail id collection (mail.id)
+                    break;
                 case DTT_MAIL_ITEM:
-                    StoreGUID(result, 1, items); break;       // item guid collection (mail_items.item_guid)
+                    StoreGUID(result, 1, items);                // item guid collection (mail_items.item_guid)
+                    break;
                 case DTT_CHARACTER:
                 {
-                    if (result->GetFieldCount() <= 67)      // avoid crashes on next check
-                        return true;
-                    if (result->Fetch()[67].GetUInt32())    // characters.deleteInfos_Account - if filled error
+                    if (result->GetFieldCount() <= 68)          // avoid crashes on next check
+                        sLog->outCrash("PlayerDumpWriter::DumpTable - Trying to access non-existing or wrong positioned field (`deleteInfos_Account`) in `characters` table.");
+
+                    if (result->Fetch()[68].GetUInt32())        // characters.deleteInfos_Account - if filled error
                         return false;
                     break;
                 }
-                default:                       break;
+                default:
+                    break;
             }
 
             dump += CreateDumpString(tableTo, result);
@@ -406,7 +412,10 @@
     bool incHighest = true;
     if (guid != 0 && guid < sObjectMgr->_hiCharGuid)
     {
-        result = CharacterDatabase.PQuery("SELECT 1 FROM characters WHERE guid = '%d'", guid);
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHECK_GUID);
+        stmt->setUInt32(0, guid);
+        PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
         if (result)
             guid = sObjectMgr->_hiCharGuid;                     // use first free if exists
         else incHighest = false;
@@ -420,8 +429,10 @@
 
     if (ObjectMgr::CheckPlayerName(name, true) == CHAR_NAME_SUCCESS)
     {
-        CharacterDatabase.EscapeString(name);              // for safe, we use name only for sql quearies anyway
-        result = CharacterDatabase.PQuery("SELECT 1 FROM characters WHERE name = '%s'", name.c_str());
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHECK_NAME);
+        stmt->setString(0, name);
+        PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
         if (result)
             name = "";                                      // use the one from the dump
     }
@@ -524,9 +535,11 @@
                 {
                     // check if the original name already exists
                     name = getnth(line, 3);
-                    CharacterDatabase.EscapeString(name);
 
-                    result = CharacterDatabase.PQuery("SELECT 1 FROM characters WHERE name = '%s'", name.c_str());
+                    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHECK_NAME);
+                    stmt->setString(0, name);
+                    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
                     if (result)
                         if (!changenth(line, 37, "1"))       // characters.at_login set to "rename on login"
                             ROLLBACK(DUMP_FILE_BROKEN);
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Warden/Warden.cpp
--- a/src/server/game/Warden/Warden.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Warden/Warden.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -193,9 +193,9 @@
             break;
         }
     default:
-        return "Undefined";
         break;
     }
+    return "Undefined";
 }
 
 void WorldSession::HandleWardenDataOpcode(WorldPacket& recvData)
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Warden/Warden.h
--- a/src/server/game/Warden/Warden.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Warden/Warden.h	Mon Apr 16 14:29:17 2012 +0300
@@ -107,7 +107,7 @@
 
     public:
         Warden();
-        ~Warden();
+        virtual ~Warden();
 
         virtual void Init(WorldSession* session, BigNumber* k) = 0;
         virtual ClientWardenModule* GetModuleForClient() = 0;
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Warden/WardenCheckMgr.cpp
--- a/src/server/game/Warden/WardenCheckMgr.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Warden/WardenCheckMgr.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -59,7 +59,7 @@
 
     Field* fields = result->Fetch();
 
-    uint32 maxCheckId = fields[0].GetUInt32();
+    uint16 maxCheckId = fields[0].GetUInt16();
 
     CheckStore.resize(maxCheckId + 1);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Warden/WardenMac.cpp
--- a/src/server/game/Warden/WardenMac.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Warden/WardenMac.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -122,7 +122,7 @@
 
     uint8 mod_seed[16] = { 0x4D, 0x80, 0x8D, 0x2C, 0x77, 0xD9, 0x05, 0xC4, 0x1A, 0x63, 0x80, 0xEC, 0x08, 0x58, 0x6A, 0xFE };
 
-    for(int i = 0; i < 4; ++i)
+    for (int i = 0; i < 4; ++i)
     {
         keyIn[i] = *(int*)(&mod_seed[0] + i * 4);
     }
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Weather/Weather.cpp
--- a/src/server/game/Weather/Weather.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Weather/Weather.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -147,7 +147,7 @@
     }
 
     // At this point, only weather that isn't doing anything remains but that have weather data
-    uint32 chance1 =          m_weatherChances->data[season].rainChance;
+    uint32 chance1 = m_weatherChances->data[season].rainChance;
     uint32 chance2 = chance1+ m_weatherChances->data[season].snowChance;
     uint32 chance3 = chance2+ m_weatherChances->data[season].stormChance;
 
diff -r b4c056460923 -r da13f4f7a26c src/server/game/Weather/WeatherMgr.cpp
--- a/src/server/game/Weather/WeatherMgr.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/Weather/WeatherMgr.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -24,14 +24,14 @@
 #include "Weather.h"
 #include "Log.h"
 #include "ObjectMgr.h"
-#include <ace/Refcounted_Auto_Ptr.h>
+#include "AutoPtr.h"
 
 namespace WeatherMgr
 {
 
 namespace
 {
-    typedef UNORDERED_MAP<uint32, ACE_Refcounted_Auto_Ptr<Weather, ACE_Null_Mutex> > WeatherMap;
+    typedef UNORDERED_MAP<uint32, Trinity::AutoPtr<Weather, ACE_Null_Mutex> > WeatherMap;
     typedef UNORDERED_MAP<uint32, WeatherData> WeatherZoneMap;
 
     WeatherMap m_weathers;
@@ -108,9 +108,9 @@
 
         for (uint8 season = 0; season < WEATHER_SEASONS; ++season)
         {
-            wzc.data[season].rainChance  = fields[season * (MAX_WEATHER_TYPE-1) + 1].GetUInt32();
-            wzc.data[season].snowChance  = fields[season * (MAX_WEATHER_TYPE-1) + 2].GetUInt32();
-            wzc.data[season].stormChance = fields[season * (MAX_WEATHER_TYPE-1) + 3].GetUInt32();
+            wzc.data[season].rainChance  = fields[season * (MAX_WEATHER_TYPE-1) + 1].GetUInt8();
+            wzc.data[season].snowChance  = fields[season * (MAX_WEATHER_TYPE-1) + 2].GetUInt8();
+            wzc.data[season].stormChance = fields[season * (MAX_WEATHER_TYPE-1) + 3].GetUInt8();
 
             if (wzc.data[season].rainChance > 100)
             {
diff -r b4c056460923 -r da13f4f7a26c src/server/game/World/World.cpp
--- a/src/server/game/World/World.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/World/World.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -81,7 +81,7 @@
 #include "Warden.h"
 #include "CalendarMgr.h"
 
-volatile bool World::m_stopEvent = false;
+ACE_Atomic_Op<ACE_Thread_Mutex, bool> World::m_stopEvent = false;
 uint8 World::m_ExitCode = SHUTDOWN_EXIT_CODE;
 volatile uint32 World::m_worldLoopCounter = 0;
 
@@ -210,6 +210,7 @@
     {
         if (itr->second->PlayerLoading())
             return false;
+
         itr->second->KickPlayer();
     }
 
@@ -221,8 +222,7 @@
     addSessQueue.add(s);
 }
 
-void
-World::AddSession_(WorldSession* s)
+void World::AddSession_(WorldSession* s)
 {
     ASSERT (s);
 
@@ -270,16 +270,13 @@
     {
         AddQueuedPlayer (s);
         UpdateMaxSessionCounters();
-        sLog->outDetail ("PlayerQueue: Account id %u is in Queue Position (%u).", s->GetAccountId(), ++QueueSize);
+        sLog->outDetail("PlayerQueue: Account id %u is in Queue Position (%u).", s->GetAccountId(), ++QueueSize);
         return;
     }
 
     s->SendAuthResponse(AUTH_OK, true);
-
     s->SendAddonsInfo();
-
     s->SendClientCacheVersion(sWorld->getIntConfig(CONFIG_CLIENTCACHE_VERSION));
-
     s->SendTutorialsData();
 
     UpdateMaxSessionCounters();
@@ -290,7 +287,7 @@
         float popu = (float)GetActiveSessionCount();              // updated number of users on the server
         popu /= pLimit;
         popu *= 2;
-        sLog->outDetail ("Server Population (%f).", popu);
+        sLog->outDetail("Server Population (%f).", popu);
     }
 }
 
@@ -1288,7 +1285,9 @@
     m_int_configs[CONFIG_BOSS_KILL_HISTORY_GUILD_GROUP_10_COUNT] = ConfigMgr::GetIntDefault("Boss.Kill.History.Guild.Group.10",8);
     m_int_configs[CONFIG_BOSS_KILL_HISTORY_GUILD_GROUP_25_COUNT] = ConfigMgr::GetIntDefault("Boss.Kill.History.Guild.Group.25",20);
 
-    sScriptMgr->OnConfigLoad(reload);
+    // call ScriptMgr if we're reloading the configuration
+    if (reload)
+        sScriptMgr->OnConfigLoad(reload);
 }
 
 extern void LoadGameObjectModelList();
@@ -1368,6 +1367,9 @@
     sLog->outString("Loading SpellInfo store...");
     sSpellMgr->LoadSpellInfoStore();
 
+    sLog->outString("Loading SkillLineAbilityMultiMap Data...");
+    sSpellMgr->LoadSkillLineAbilityMap();
+
     sLog->outString("Loading spell custom attributes...");
     sSpellMgr->LoadSpellCustomAttr();
 
@@ -1380,9 +1382,6 @@
     sLog->outString("Loading Instance Template...");
     sObjectMgr->LoadInstanceTemplate();
 
-    sLog->outString("Loading SkillLineAbilityMultiMap Data...");
-    sSpellMgr->LoadSkillLineAbilityMap();
-
     // Must be called before `creature_respawn`/`gameobject_respawn` tables
     sLog->outString("Loading instances...");
     sInstanceSaveMgr->LoadInstances();
@@ -1674,7 +1673,7 @@
     sSmartWaypointMgr->LoadFromDB();
 
     sLog->outString("Loading Creature Formations...");
-    FormationMgr::LoadCreatureFormations();
+    sFormationMgr->LoadCreatureFormations();
 
     sLog->outString("Loading World States...");              // must be loaded before battleground, outdoor PvP and conditions
     LoadWorldStates();
@@ -1741,6 +1740,7 @@
 
     sLog->outString("Initializing Scripts...");
     sScriptMgr->Initialize();
+    sScriptMgr->OnConfigLoad(false);                                // must be done after the ScriptMgr has been properly initialized
 
     sLog->outString("Validating spell scripts...");
     sObjectMgr->ValidateSpellScripts();
@@ -1754,18 +1754,10 @@
     ///- Initialize game time and timers
     sLog->outString("Initialize game time and timers");
     m_gameTime = time(NULL);
-    m_startTime=m_gameTime;
-
-    tm local;
-    time_t curr;
-    time(&curr);
-    local=*(localtime(&curr));                              // dereference and assign
-    char isoDate[128];
-    sprintf(isoDate, "%04d-%02d-%02d %02d:%02d:%02d",
-        local.tm_year+1900, local.tm_mon+1, local.tm_mday, local.tm_hour, local.tm_min, local.tm_sec);
-
-    LoginDatabase.PExecute("INSERT INTO uptime (realmid, starttime, startstring, uptime, revision) VALUES('%u', " UI64FMTD ", '%s', 0, '%s')",
-                            realmID, uint64(m_startTime), isoDate, _FULLVERSION);       // One-time query
+    m_startTime = m_gameTime;
+
+    LoginDatabase.PExecute("INSERT INTO uptime (realmid, starttime, uptime, revision) VALUES(%u, %u, 0, '%s')",
+                            realmID, uint32(m_startTime), _FULLVERSION);       // One-time query
 
     m_timers[WUPDATE_WEATHERS].SetInterval(1*IN_MILLISECONDS);
     m_timers[WUPDATE_AUCTIONS].SetInterval(MINUTE*IN_MILLISECONDS);
@@ -1864,7 +1856,7 @@
 
     uint32 startupDuration = GetMSTimeDiffToNow(startupBegin);
     sLog->outString();
-    sLog->outString("WORLD: World initialized in %u minutes %u seconds", (startupDuration / 60000), ((startupDuration % 60000) / 1000) );
+    sLog->outString("WORLD: World initialized in %u minutes %u seconds", (startupDuration / 60000), ((startupDuration % 60000) / 1000));
     sLog->outString();
 }
 
@@ -2070,11 +2062,11 @@
         Field* fields = result->Fetch();
         uint32 maxOnlinePlayersBase = fields[0].GetUInt32();
 
-        stmt->setUInt64(0, uint64(tmpDiff));
+        stmt->setUInt32(0, tmpDiff);
         if (maxOnlinePlayers > maxOnlinePlayersBase)
             stmt->setUInt16(1, uint16(maxOnlinePlayers));
         stmt->setUInt32(2, realmID);
-        stmt->setUInt64(3, uint64(m_startTime));
+        stmt->setUInt32(3, uint32(m_startTime));
 
         LoginDatabase.Execute(stmt);
     }
@@ -2420,7 +2412,7 @@
     do
     {
         Field* fieldsAccount = resultAccounts->Fetch();
-        uint32 account = fieldsAccount->GetUInt32();
+        uint32 account = fieldsAccount[0].GetUInt32();
 
         if (mode != BAN_IP)
         {
@@ -2556,7 +2548,7 @@
     m_gameTime = thisTime;
 
     ///- if there is a shutdown timer
-    if (!m_stopEvent && m_ShutdownTimer > 0 && elapsed > 0)
+    if (!IsStopped() && m_ShutdownTimer > 0 && elapsed > 0)
     {
         ///- ... and it is overdue, stop the world (set m_stopEvent)
         if (m_ShutdownTimer <= elapsed)
@@ -2580,7 +2572,7 @@
 void World::ShutdownServ(uint32 time, uint32 options, uint8 exitcode)
 {
     // ignore if server shutdown at next tick
-    if (m_stopEvent)
+    if (IsStopped())
         return;
 
     m_ShutdownMask = options;
@@ -2632,7 +2624,7 @@
 void World::ShutdownCancel()
 {
     // nothing cancel or too later
-    if (!m_ShutdownTimer || m_stopEvent)
+    if (!m_ShutdownTimer || m_stopEvent.value())
         return;
 
     ServerMessageType msgid = (m_ShutdownMask & SHUTDOWN_MASK_RESTART) ? SERVER_MSG_RESTART_CANCELLED : SERVER_MSG_SHUTDOWN_CANCELLED;
@@ -2716,7 +2708,7 @@
 
     std::string msg;
 
-    msg = SelectRandomContainerElement(m_Autobroadcasts);
+    msg = Trinity::Containers::SelectRandomContainerElement(m_Autobroadcasts);
 
     uint32 abcenter = sWorld->getIntConfig(CONFIG_AUTOBROADCAST_CENTER);
 
@@ -2756,15 +2748,15 @@
     {
         Field* fields = resultCharCount->Fetch();
         uint32 accountId = fields[0].GetUInt32();
-        uint32 charCount = fields[1].GetUInt32();
-
-        PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_DEL_REALM_CHARACTERS);
+        uint8 charCount = uint8(fields[1].GetUInt64());
+
+        PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_DEL_REALM_CHARACTERS_BY_REALM);
         stmt->setUInt32(0, accountId);
         stmt->setUInt32(1, realmID);
         LoginDatabase.Execute(stmt);
 
         stmt = LoginDatabase.GetPreparedStatement(LOGIN_INS_REALM_CHARACTERS);
-        stmt->setUInt32(0, charCount);
+        stmt->setUInt8(0, charCount);
         stmt->setUInt32(1, accountId);
         stmt->setUInt32(2, realmID);
         LoginDatabase.Execute(stmt);
@@ -2858,9 +2850,12 @@
 
 void World::LoadDBAllowedSecurityLevel()
 {
-    QueryResult result = LoginDatabase.PQuery("SELECT allowedSecurityLevel from realmlist WHERE id = '%d'", realmID);
+    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_REALMLIST_SECURITY_LEVEL);
+    stmt->setInt32(0, int32(realmID));
+    PreparedQueryResult result = LoginDatabase.Query(stmt);
+
     if (result)
-        SetPlayerSecurityLimit(AccountTypes(result->Fetch()->GetUInt16()));
+        SetPlayerSecurityLimit(AccountTypes(result->Fetch()->GetUInt8()));
 }
 
 void World::SetPlayerSecurityLimit(AccountTypes _sec)
@@ -3039,7 +3034,7 @@
 {
     sLog->outString("Loading character name data");
 
-    QueryResult result = CharacterDatabase.Query("SELECT guid, name, race, gender, class FROM characters");
+    QueryResult result = CharacterDatabase.Query("SELECT guid, name, race, gender, class FROM characters WHERE deleteDate IS NULL");
     if (!result)
     {
         sLog->outError("No character name data loaded, empty query");
@@ -3050,7 +3045,7 @@
 
     do
     {
-        Field *fields = result->Fetch();
+        Field* fields = result->Fetch();
         AddCharacterNameData(fields[0].GetUInt32(), fields[1].GetString(),
             fields[3].GetUInt8() /*gender*/, fields[2].GetUInt8() /*race*/, fields[4].GetUInt8() /*class*/);
         ++count;
diff -r b4c056460923 -r da13f4f7a26c src/server/game/World/World.h
--- a/src/server/game/World/World.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/game/World/World.h	Mon Apr 16 14:29:17 2012 +0300
@@ -26,6 +26,7 @@
 #include "Common.h"
 #include "Timer.h"
 #include <ace/Singleton.h>
+#include <ace/Atomic_Op.h>
 #include "SharedDefines.h"
 #include "QueryResult.h"
 #include "Callback.h"
@@ -725,7 +726,7 @@
         void ShutdownMsg(bool show = false, Player* player = NULL);
         static uint8 GetExitCode() { return m_ExitCode; }
         static void StopNow(uint8 exitcode) { m_stopEvent = true; m_ExitCode = exitcode; }
-        static bool IsStopped() { return m_stopEvent; }
+        static bool IsStopped() { return m_stopEvent.value(); }
 
         void Update(uint32 diff);
 
@@ -855,7 +856,7 @@
         void ResetWeeklyQuests();
         void ResetRandomBG();
     private:
-        static volatile bool m_stopEvent;
+        static ACE_Atomic_Op<ACE_Thread_Mutex, bool> m_stopEvent;
         static uint8 m_ExitCode;
         uint32 m_ShutdownTimer;
         uint32 m_ShutdownMask;
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/CMakeLists.txt
--- a/src/server/scripts/CMakeLists.txt	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/CMakeLists.txt	Mon Apr 16 14:29:17 2012 +0300
@@ -53,7 +53,6 @@
   ${CMAKE_BINARY_DIR}
   ${CMAKE_SOURCE_DIR}/dep/g3dlite/include
   ${CMAKE_SOURCE_DIR}/dep/SFMT
-  ${CMAKE_SOURCE_DIR}/dep/mersennetwister
   ${CMAKE_SOURCE_DIR}/dep/zlib
   ${CMAKE_SOURCE_DIR}/src/server/shared
   ${CMAKE_SOURCE_DIR}/src/server/shared/Configuration
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Commands/cs_account.cpp
--- a/src/server/scripts/Commands/cs_account.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Commands/cs_account.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -194,8 +194,11 @@
     static bool HandleAccountOnlineListCommand(ChatHandler* handler, char const* /*args*/)
     {
         ///- Get the list of accounts ID logged to the realm
-        QueryResult resultDB = CharacterDatabase.Query("SELECT name, account, map, zone FROM characters WHERE online > 0");
-        if (!resultDB)
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_ONLINE);
+
+        PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+        if (!result)
         {
             handler->SendSysMessage(LANG_ACCOUNT_LIST_EMPTY);
             return true;
@@ -209,31 +212,28 @@
         ///- Cycle through accounts
         do
         {
-            Field* fieldsDB = resultDB->Fetch();
+            Field* fieldsDB = result->Fetch();
             std::string name = fieldsDB[0].GetString();
             uint32 account = fieldsDB[1].GetUInt32();
 
             ///- Get the username, last IP and GM level of each account
             // No SQL injection. account is uint32.
-            QueryResult resultLogin =
-                LoginDatabase.PQuery("SELECT a.username, a.last_ip, aa.gmlevel, a.expansion "
-                "FROM account a "
-                "LEFT JOIN account_access aa "
-                "ON (a.id = aa.id) "
-                "WHERE a.id = '%u'", account);
+            stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_ACCOUNT_INFO);
+            stmt->setUInt32(0, account);
+            PreparedQueryResult resultLogin = LoginDatabase.Query(stmt);
 
             if (resultLogin)
             {
                 Field* fieldsLogin = resultLogin->Fetch();
                 handler->PSendSysMessage(LANG_ACCOUNT_LIST_LINE,
                     fieldsLogin[0].GetCString(), name.c_str(), fieldsLogin[1].GetCString(),
-                    fieldsDB[2].GetUInt16(), fieldsDB[3].GetUInt16(), fieldsLogin[3].GetUInt32(),
-                    fieldsLogin[2].GetUInt32());
+                    fieldsDB[2].GetUInt16(), fieldsDB[3].GetUInt16(), fieldsLogin[3].GetUInt8(),
+                    fieldsLogin[2].GetUInt8());
             }
             else
                 handler->PSendSysMessage(LANG_ACCOUNT_LIST_ERROR, name.c_str());
 
-        } while (resultDB->NextRow());
+        } while (result->NextRow());
 
         handler->SendSysMessage(LANG_ACCOUNT_LIST_BAR);
         return true;
@@ -469,7 +469,13 @@
         // Check and abort if the target gm has a higher rank on one of the realms and the new realm is -1
         if (gmRealmID == -1 && !AccountMgr::IsConsoleAccount(playerSecurity))
         {
-            QueryResult result = LoginDatabase.PQuery("SELECT * FROM account_access WHERE id = '%u' AND gmlevel > '%d'", targetAccountId, gm);
+            PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_ACCOUNT_ACCESS_GMLEVEL_TEST);
+
+            stmt->setUInt32(0, targetAccountId);
+            stmt->setUInt8(1, uint8(gm));
+
+            PreparedQueryResult result = LoginDatabase.Query(stmt);
+
             if (result)
             {
                 handler->SendSysMessage(LANG_YOURS_SECURITY_IS_LOW);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Commands/cs_gm.cpp
--- a/src/server/scripts/Commands/cs_gm.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Commands/cs_gm.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -156,7 +156,11 @@
     static bool HandleGMListFullCommand(ChatHandler* handler, char const* /*args*/)
     {
         ///- Get the accounts with GM Level >0
-        QueryResult result = LoginDatabase.PQuery("SELECT a.username, aa.gmlevel FROM account a, account_access aa WHERE a.id=aa.id AND aa.gmlevel >= %u AND (aa.realmid = -1 OR aa.realmid = %u)", SEC_MODERATOR, realmID);
+        PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_GM_ACCOUNTS);
+        stmt->setUInt8(0, uint8(SEC_MODERATOR));
+        stmt->setInt32(1, int32(realmID));
+        PreparedQueryResult result = LoginDatabase.Query(stmt);
+
         if (result)
         {
             handler->SendSysMessage(LANG_GMLIST);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Commands/cs_gobject.cpp
--- a/src/server/scripts/Commands/cs_gobject.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Commands/cs_gobject.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -535,11 +535,17 @@
         uint32 count = 0;
 
         Player* player = handler->GetSession()->GetPlayer();
-        QueryResult result = WorldDatabase.PQuery("SELECT guid, id, position_x, position_y, position_z, map, "
-            "(POW(position_x - '%f', 2) + POW(position_y - '%f', 2) + POW(position_z - '%f', 2)) AS order_ "
-            "FROM gameobject WHERE map='%u' AND (POW(position_x - '%f', 2) + POW(position_y - '%f', 2) + POW(position_z - '%f', 2)) <= '%f' ORDER BY order_",
-            player->GetPositionX(), player->GetPositionY(), player->GetPositionZ(),
-            player->GetMapId(), player->GetPositionX(), player->GetPositionY(), player->GetPositionZ(), distance * distance);
+
+        PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_GAMEOBJECT_NEAREST);
+        stmt->setFloat(0, player->GetPositionX());
+        stmt->setFloat(1, player->GetPositionY());
+        stmt->setFloat(2, player->GetPositionZ());
+        stmt->setUInt32(3, player->GetMapId());
+        stmt->setFloat(4, player->GetPositionX());
+        stmt->setFloat(5, player->GetPositionY());
+        stmt->setFloat(6, player->GetPositionZ());
+        stmt->setFloat(7, distance * distance);
+        PreparedQueryResult result = WorldDatabase.Query(stmt);
 
         if (result)
         {
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Commands/cs_modify.cpp
--- a/src/server/scripts/Commands/cs_modify.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Commands/cs_modify.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -1234,7 +1234,7 @@
             return false;
         }
 
-        target->GetReputationMgr().SetReputation(factionEntry, amount);
+        target->GetReputationMgr().SetOneFactionReputation(factionEntry, amount, false);
         handler->PSendSysMessage(LANG_COMMAND_MODIFY_REP, factionEntry->name[handler->GetSessionDbcLocale()], factionId,
             handler->GetNameLink(target).c_str(), target->GetReputationMgr().GetReputation(factionEntry));
         return true;
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Commands/cs_npc.cpp
--- a/src/server/scripts/Commands/cs_npc.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Commands/cs_npc.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -676,7 +676,7 @@
         {
             PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_UPD_CREATURE_TRANSPORT_EMOTE);
 
-            stmt->setInt16(0, int16(emote));
+            stmt->setInt32(0, int32(emote));
             stmt->setInt32(1, target->GetTransport()->GetEntry());
             stmt->setInt32(2, target->GetGUIDTransport());
 
@@ -1218,7 +1218,7 @@
         group_member->leaderGUID     = leaderGUID;
         group_member->groupAI        = 0;
 
-        CreatureGroupMap[lowguid] = group_member;
+        sFormationMgr->CreatureGroupMap[lowguid] = group_member;
         creature->SearchFormation();
 
         WorldDatabase.PExecute("INSERT INTO creature_formations (leaderGUID, memberGUID, dist, angle, groupAI) VALUES ('%u', '%u', '%f', '%f', '%u')",
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Commands/cs_reload.cpp
--- a/src/server/scripts/Commands/cs_reload.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Commands/cs_reload.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -413,14 +413,18 @@
         for (Tokens::const_iterator itr = entries.begin(); itr != entries.end(); ++itr)
         {
             uint32 entry = uint32(atoi(*itr));
-            QueryResult result = WorldDatabase.PQuery("SELECT difficulty_entry_1, difficulty_entry_2, difficulty_entry_3, KillCredit1, KillCredit2, modelid1, modelid2, modelid3, modelid4, name, subname, IconName, gossip_menu_id, minlevel, maxlevel, exp, faction_A, faction_H, npcflag, speed_walk, speed_run, scale, rank, mindmg, maxdmg, dmgschool, attackpower, dmg_multiplier, baseattacktime, rangeattacktime, unit_class, unit_flags, dynamicflags, family, trainer_type, trainer_spell, trainer_class, trainer_race, minrangedmg, maxrangedmg, rangedattackpower, type, type_flags, lootid, pickpocketloot, skinloot, resistance1, resistance2, resistance3, resistance4, resistance5, resistance6, spell1, spell2, spell3, spell4, spell5, spell6, spell7, spell8, PetSpellDataId, VehicleId, mingold, maxgold, AIName, MovementType, InhabitType, HoverHeight, Health_mod, Mana_mod, Armor_mod, RacialLeader, questItem1, questItem2, questItem3, questItem4, questItem5, questItem6, movementId, RegenHealth, equipment_id, mechanic_immune_mask, flags_extra, ScriptName FROM creature_template WHERE entry = %u", entry);
+
+            PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_CREATURE_TEMPLATE);
+            stmt->setUInt32(0, entry);
+            PreparedQueryResult result = WorldDatabase.Query(stmt);
+
             if (!result)
             {
                 handler->PSendSysMessage(LANG_COMMAND_CREATURETEMPLATE_NOTFOUND, entry);
                 continue;
             }
 
-            CreatureTemplate const* cInfo = sObjectMgr->GetCreatureTemplate(entry);
+            CreatureTemplate* cInfo = const_cast<CreatureTemplate*>(sObjectMgr->GetCreatureTemplate(entry));
             if (!cInfo)
             {
                 handler->PSendSysMessage(LANG_COMMAND_CREATURESTORAGE_NOTFOUND, entry);
@@ -431,90 +435,88 @@
 
             Field* fields = result->Fetch();
 
-            const_cast<CreatureTemplate*>(cInfo)->DifficultyEntry[0] = fields[0].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->DifficultyEntry[1] = fields[1].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->DifficultyEntry[2] = fields[2].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->KillCredit[0] = fields[3].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->KillCredit[1] = fields[4].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->Modelid1 = fields[5].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->Modelid2 = fields[6].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->Modelid3 = fields[7].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->Modelid4 = fields[8].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->Name = fields[9].GetString();
-            const_cast<CreatureTemplate*>(cInfo)->SubName = fields[10].GetString();
-            const_cast<CreatureTemplate*>(cInfo)->IconName = fields[11].GetString();
-            const_cast<CreatureTemplate*>(cInfo)->GossipMenuId = fields[12].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->minlevel = fields[13].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->maxlevel = fields[14].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->expansion = fields[15].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->faction_A = fields[16].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->faction_H = fields[17].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->npcflag = fields[18].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->speed_walk = fields[19].GetFloat();
-            const_cast<CreatureTemplate*>(cInfo)->speed_run = fields[20].GetFloat();
-            const_cast<CreatureTemplate*>(cInfo)->scale = fields[21].GetFloat();
-            const_cast<CreatureTemplate*>(cInfo)->rank = fields[22].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->mindmg = fields[23].GetFloat();
-            const_cast<CreatureTemplate*>(cInfo)->maxdmg = fields[24].GetFloat();
-            const_cast<CreatureTemplate*>(cInfo)->dmgschool = fields[25].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->attackpower = fields[26].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->dmg_multiplier = fields[27].GetFloat();
-            const_cast<CreatureTemplate*>(cInfo)->baseattacktime = fields[28].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->rangeattacktime = fields[29].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->unit_class = fields[30].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->unit_flags = fields[31].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->dynamicflags = fields[32].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->family = fields[33].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->trainer_type = fields[34].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->trainer_spell = fields[35].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->trainer_class = fields[36].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->trainer_race = fields[37].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->minrangedmg = fields[38].GetFloat();
-            const_cast<CreatureTemplate*>(cInfo)->maxrangedmg = fields[39].GetFloat();
-            const_cast<CreatureTemplate*>(cInfo)->rangedattackpower = fields[40].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->type = fields[41].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->type_flags = fields[42].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->lootid = fields[43].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->pickpocketLootId = fields[44].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->SkinLootId = fields[45].GetUInt32();
+            cInfo->DifficultyEntry[0] = fields[0].GetUInt32();
+            cInfo->DifficultyEntry[1] = fields[1].GetUInt32();
+            cInfo->DifficultyEntry[2] = fields[2].GetUInt32();
+            cInfo->KillCredit[0]      = fields[3].GetUInt32();
+            cInfo->KillCredit[1]      = fields[4].GetUInt32();
+            cInfo->Modelid1           = fields[5].GetUInt32();
+            cInfo->Modelid2           = fields[6].GetUInt32();
+            cInfo->Modelid3           = fields[7].GetUInt32();
+            cInfo->Modelid4           = fields[8].GetUInt32();
+            cInfo->Name               = fields[9].GetString();
+            cInfo->SubName            = fields[10].GetString();
+            cInfo->IconName           = fields[11].GetString();
+            cInfo->GossipMenuId       = fields[12].GetUInt32();
+            cInfo->minlevel           = fields[13].GetUInt8();
+            cInfo->maxlevel           = fields[14].GetUInt8();
+            cInfo->expansion          = fields[15].GetUInt16();
+            cInfo->faction_A          = fields[16].GetUInt16();
+            cInfo->faction_H          = fields[17].GetUInt16();
+            cInfo->npcflag            = fields[18].GetUInt32();
+            cInfo->speed_walk         = fields[19].GetFloat();
+            cInfo->speed_run          = fields[20].GetFloat();
+            cInfo->scale              = fields[21].GetFloat();
+            cInfo->rank               = fields[22].GetUInt8();
+            cInfo->mindmg             = fields[23].GetFloat();
+            cInfo->maxdmg             = fields[24].GetFloat();
+            cInfo->dmgschool          = fields[25].GetUInt8();
+            cInfo->attackpower        = fields[26].GetUInt32();
+            cInfo->dmg_multiplier     = fields[27].GetFloat();
+            cInfo->baseattacktime     = fields[28].GetUInt32();
+            cInfo->rangeattacktime    = fields[29].GetUInt32();
+            cInfo->unit_class         = fields[30].GetUInt8();
+            cInfo->unit_flags         = fields[31].GetUInt32();
+            cInfo->dynamicflags       = fields[32].GetUInt32();
+            cInfo->family             = fields[33].GetUInt8();
+            cInfo->trainer_type       = fields[34].GetUInt8();
+            cInfo->trainer_spell      = fields[35].GetUInt32();
+            cInfo->trainer_class      = fields[36].GetUInt8();
+            cInfo->trainer_race       = fields[37].GetUInt8();
+            cInfo->minrangedmg        = fields[38].GetFloat();
+            cInfo->maxrangedmg        = fields[39].GetFloat();
+            cInfo->rangedattackpower  = fields[40].GetUInt16();
+            cInfo->type               = fields[41].GetUInt8();
+            cInfo->type_flags         = fields[42].GetUInt32();
+            cInfo->lootid             = fields[43].GetUInt32();
+            cInfo->pickpocketLootId   = fields[44].GetUInt32();
+            cInfo->SkinLootId         = fields[45].GetUInt32();
 
             for (uint8 i = SPELL_SCHOOL_HOLY; i < MAX_SPELL_SCHOOL; ++i)
-            {
-                const_cast<CreatureTemplate*>(cInfo)->resistance[i] = fields[46 + i -1].GetUInt32();
-            }
+                cInfo->resistance[i] = fields[46 + i -1].GetUInt16();
 
-            const_cast<CreatureTemplate*>(cInfo)->spells[0] = fields[52].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->spells[1] = fields[53].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->spells[2] = fields[54].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->spells[3] = fields[55].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->spells[4] = fields[56].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->spells[5] = fields[57].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->spells[6] = fields[58].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->spells[7] = fields[59].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->PetSpellDataId = fields[60].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->VehicleId = fields[61].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->mingold = fields[62].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->maxgold = fields[63].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->AIName = fields[64].GetString();
-            const_cast<CreatureTemplate*>(cInfo)->MovementType = fields[65].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->InhabitType = fields[66].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->HoverHeight = fields[67].GetFloat();
-            const_cast<CreatureTemplate*>(cInfo)->ModHealth = fields[68].GetFloat();
-            const_cast<CreatureTemplate*>(cInfo)->ModMana = fields[69].GetFloat();
-            const_cast<CreatureTemplate*>(cInfo)->ModArmor = fields[70].GetFloat();
-            const_cast<CreatureTemplate*>(cInfo)->RacialLeader = fields[71].GetBool();
-            const_cast<CreatureTemplate*>(cInfo)->questItems[0] = fields[72].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->questItems[1] = fields[73].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->questItems[2] = fields[74].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->questItems[3] = fields[75].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->questItems[4] = fields[76].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->questItems[5] = fields[77].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->movementId = fields[78].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->RegenHealth = fields[79].GetBool();
-            const_cast<CreatureTemplate*>(cInfo)->equipmentId = fields[80].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->MechanicImmuneMask = fields[81].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->flags_extra = fields[82].GetUInt32();
-            const_cast<CreatureTemplate*>(cInfo)->ScriptID = sObjectMgr->GetScriptId(fields[83].GetCString());
+            cInfo->spells[0]          = fields[52].GetUInt32();
+            cInfo->spells[1]          = fields[53].GetUInt32();
+            cInfo->spells[2]          = fields[54].GetUInt32();
+            cInfo->spells[3]          = fields[55].GetUInt32();
+            cInfo->spells[4]          = fields[56].GetUInt32();
+            cInfo->spells[5]          = fields[57].GetUInt32();
+            cInfo->spells[6]          = fields[58].GetUInt32();
+            cInfo->spells[7]          = fields[59].GetUInt32();
+            cInfo->PetSpellDataId     = fields[60].GetUInt32();
+            cInfo->VehicleId          = fields[61].GetUInt32();
+            cInfo->mingold            = fields[62].GetUInt32();
+            cInfo->maxgold            = fields[63].GetUInt32();
+            cInfo->AIName             = fields[64].GetString();
+            cInfo->MovementType       = fields[65].GetUInt8();
+            cInfo->InhabitType        = fields[66].GetUInt8();
+            cInfo->HoverHeight        = fields[67].GetFloat();
+            cInfo->ModHealth          = fields[68].GetFloat();
+            cInfo->ModMana            = fields[69].GetFloat();
+            cInfo->ModArmor           = fields[70].GetFloat();
+            cInfo->RacialLeader       = fields[71].GetBool();
+            cInfo->questItems[0]      = fields[72].GetUInt32();
+            cInfo->questItems[1]      = fields[73].GetUInt32();
+            cInfo->questItems[2]      = fields[74].GetUInt32();
+            cInfo->questItems[3]      = fields[75].GetUInt32();
+            cInfo->questItems[4]      = fields[76].GetUInt32();
+            cInfo->questItems[5]      = fields[77].GetUInt32();
+            cInfo->movementId         = fields[78].GetUInt32();
+            cInfo->RegenHealth        = fields[79].GetBool();
+            cInfo->equipmentId        = fields[80].GetUInt32();
+            cInfo->MechanicImmuneMask = fields[81].GetUInt32();
+            cInfo->flags_extra        = fields[82].GetUInt32();
+            cInfo->ScriptID           = sObjectMgr->GetScriptId(fields[83].GetCString());
 
             sObjectMgr->CheckCreatureTemplate(cInfo);
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Commands/cs_tele.cpp
--- a/src/server/scripts/Commands/cs_tele.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Commands/cs_tele.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -131,12 +131,15 @@
                 target->TeleportTo(target->m_homebindMapId, target->m_homebindX, target->m_homebindY, target->m_homebindZ, target->GetOrientation());
             else
             {
-                QueryResult resultDB = CharacterDatabase.PQuery("SELECT mapId, zoneId, posX, posY, posZ FROM character_homebind WHERE guid = %u", target_guid);
+                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_HOMEBIND);
+                stmt->setUInt32(0, target_guid);
+                PreparedQueryResult resultDB = CharacterDatabase.Query(stmt);
+
                 if (resultDB)
                 {
                     Field* fieldsDB = resultDB->Fetch();
-                    uint32 mapId = fieldsDB[0].GetUInt32();
-                    uint32 zoneId = fieldsDB[1].GetUInt32();
+                    uint32 mapId = fieldsDB[0].GetUInt16();
+                    uint32 zoneId = fieldsDB[1].GetUInt16();
                     float posX = fieldsDB[2].GetFloat();
                     float posY = fieldsDB[3].GetFloat();
                     float posZ = fieldsDB[4].GetFloat();
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Commands/cs_wp.cpp
--- a/src/server/scripts/Commands/cs_wp.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Commands/cs_wp.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -91,7 +91,10 @@
                 pathid = target->GetWaypointPath();
             else
             {
-                QueryResult result = WorldDatabase.Query("SELECT MAX(id) FROM waypoint_data");
+                PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_WAYPOINT_DATA_MAX_ID);
+
+                PreparedQueryResult result = WorldDatabase.Query(stmt);
+
                 uint32 maxpathid = result->Fetch()->GetInt32();
                 pathid = maxpathid+1;
                 handler->PSendSysMessage("%s%s|r", "|cff00ff00", "New path started.");
@@ -109,7 +112,9 @@
             return true;
         }
 
-        QueryResult result = WorldDatabase.PQuery("SELECT MAX(point) FROM waypoint_data WHERE id = '%u'", pathid);
+        PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_WAYPOINT_DATA_MAX_POINT);
+        stmt->setUInt32(0, pathid);
+        PreparedQueryResult result = WorldDatabase.Query(stmt);
 
         if (result)
             point = (*result)[0].GetUInt32();
@@ -117,7 +122,7 @@
         Player* player = handler->GetSession()->GetPlayer();
         //Map* map = player->GetMap();
 
-        PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_INS_WAYPOINT_DATA);
+        stmt = WorldDatabase.GetPreparedStatement(WORLD_INS_WAYPOINT_DATA);
 
         stmt->setUInt32(0, pathid);
         stmt->setUInt32(1, point + 1);
@@ -173,9 +178,12 @@
         }
 
         guidLow = target->GetDBTableGUIDLow();
-        QueryResult result = WorldDatabase.PQuery("SELECT guid FROM creature_addon WHERE guid = '%u'", guidLow);
 
-        PreparedStatement* stmt;
+        PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_CREATURE_ADDON_BY_GUID);
+
+        stmt->setUInt32(0, guidLow);
+
+        PreparedQueryResult result = WorldDatabase.Query(stmt);
 
         if (result)
         {
@@ -290,7 +298,9 @@
 
             if (id)
             {
-                QueryResult result = WorldDatabase.PQuery("SELECT id FROM waypoint_scripts WHERE guid = %u", id);
+                PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_WAYPOINT_SCRIPT_ID_BY_GUID);
+                stmt->setUInt32(0, id);
+                PreparedQueryResult result = WorldDatabase.Query(stmt);
 
                 if (!result)
                 {
@@ -307,10 +317,13 @@
             }
             else
             {
-                QueryResult result = WorldDatabase.Query("SELECT MAX(guid) FROM waypoint_scripts");
+                PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_WAYPOINT_SCRIPTS_MAX_ID);
+
+                PreparedQueryResult result = WorldDatabase.Query(stmt);
+
                 id = result->Fetch()->GetUInt32();
 
-                PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_INS_WAYPOINT_SCRIPT);
+                stmt = WorldDatabase.GetPreparedStatement(WORLD_INS_WAYPOINT_SCRIPT);
 
                 stmt->setUInt32(0, id + 1);
 
@@ -336,7 +349,9 @@
             float a8, a9, a10, a11;
             char const* a7;
 
-            QueryResult result = WorldDatabase.PQuery("SELECT guid, delay, command, datalong, datalong2, dataint, x, y, z, o FROM waypoint_scripts WHERE id = %u", id);
+            PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_WAYPOINT_SCRIPT_BY_ID);
+            stmt->setUInt32(0, id);
+            PreparedQueryResult result = WorldDatabase.Query(stmt);
 
             if (!result)
             {
@@ -369,7 +384,11 @@
         {
             id = atoi(arg_id);
 
-            QueryResult result = WorldDatabase.PQuery("SELECT guid FROM waypoint_scripts WHERE guid = %u", id);
+            PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_WAYPOINT_SCRIPT_ID_BY_GUID);
+
+            stmt->setUInt32(0, id);
+
+            PreparedQueryResult result = WorldDatabase.Query(stmt);
 
             if (result)
             {
@@ -447,7 +466,9 @@
             }
             else
             {
-                QueryResult result = WorldDatabase.PQuery("SELECT id FROM waypoint_scripts WHERE guid='%u'", id);
+                PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_WAYPOINT_SCRIPT_ID_BY_GUID);
+                stmt->setUInt32(0, id);
+                PreparedQueryResult result = WorldDatabase.Query(stmt);
 
                 if (!result)
                 {
@@ -567,7 +588,9 @@
         // User did select a visual waypoint?
 
         // Check the creature
-        QueryResult result = WorldDatabase.PQuery("SELECT id, point FROM waypoint_data WHERE wpguid = %u", wpGuid);
+        PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_WAYPOINT_DATA_BY_WPGUID);
+        stmt->setUInt32(0, wpGuid);
+        PreparedQueryResult result = WorldDatabase.Query(stmt);
 
         if (!result)
         {
@@ -578,9 +601,17 @@
             // Here we search for all waypoints that only differ in one from 1 thousand
             // (0.001) - There is no other way to compare C++ floats with mySQL floats
             // See also: http://dev.mysql.com/doc/refman/5.0/en/problems-with-float.html
-            const char* maxDIFF = "0.01";
-            result = WorldDatabase.PQuery("SELECT id, point FROM waypoint_data WHERE (abs(position_x - %f) <= %s) and (abs(position_y - %f) <= %s) and (abs(position_z - %f) <= %s)",
-                target->GetPositionX(), maxDIFF, target->GetPositionY(), maxDIFF, target->GetPositionZ(), maxDIFF);
+            std::string maxDiff = "0.01";
+
+            PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_WAYPOINT_DATA_BY_POS);
+            stmt->setFloat(0, target->GetPositionX());
+            stmt->setString(1, maxDiff);
+            stmt->setFloat(2, target->GetPositionY());
+            stmt->setString(3, maxDiff);
+            stmt->setFloat(4, target->GetPositionZ());
+            stmt->setString(5, maxDiff);
+            PreparedQueryResult result = WorldDatabase.Query(stmt);
+
             if (!result)
             {
                 handler->PSendSysMessage(LANG_WAYPOINT_NOTFOUNDDBPROBLEM, wpGuid);
@@ -765,7 +796,6 @@
         }
 
         std::string show = show_str;
-        uint32 Maxpoint;
 
         //handler->PSendSysMessage("wpshow - show: %s", show);
 
@@ -780,7 +810,11 @@
                 return false;
             }
 
-            QueryResult result = WorldDatabase.PQuery("SELECT id, point, delay, move_flag, action, action_chance FROM waypoint_data WHERE wpguid = %u", target->GetGUIDLow());
+            PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_WAYPOINT_DATA_ALL_BY_WPGUID);
+
+            stmt->setUInt32(0, target->GetGUIDLow());
+
+            PreparedQueryResult result = WorldDatabase.Query(stmt);
 
             if (!result)
             {
@@ -812,7 +846,11 @@
 
         if (show == "on")
         {
-            QueryResult result = WorldDatabase.PQuery("SELECT point, position_x, position_y, position_z FROM waypoint_data WHERE id = '%u'", pathid);
+            PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_WAYPOINT_DATA_POS_BY_ID);
+
+            stmt->setUInt32(0, pathid);
+
+            PreparedQueryResult result = WorldDatabase.Query(stmt);
 
             if (!result)
             {
@@ -824,7 +862,11 @@
             handler->PSendSysMessage("|cff00ff00DEBUG: wp on, PathID: |cff00ffff%u|r", pathid);
 
             // Delete all visuals for this NPC
-            QueryResult result2 = WorldDatabase.PQuery("SELECT wpguid FROM waypoint_data WHERE id = '%u' and wpguid <> 0", pathid);
+            stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_WAYPOINT_DATA_WPGUID_BY_ID);
+
+            stmt->setUInt32(0, pathid);
+
+            PreparedQueryResult result2 = WorldDatabase.Query(stmt);
 
             if (result2)
             {
@@ -921,7 +963,10 @@
         {
             handler->PSendSysMessage("|cff00ff00DEBUG: wp first, GUID: %u|r", pathid);
 
-            QueryResult result = WorldDatabase.PQuery("SELECT position_x, position_y, position_z FROM waypoint_data WHERE point='1' AND id = '%u'", pathid);
+            PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_WAYPOINT_DATA_POS_FIRST_BY_ID);
+            stmt->setUInt32(0, pathid);
+            PreparedQueryResult result = WorldDatabase.Query(stmt);
+
             if (!result)
             {
                 handler->PSendSysMessage(LANG_WAYPOINT_NOTFOUND, pathid);
@@ -968,13 +1013,10 @@
         {
             handler->PSendSysMessage("|cff00ff00DEBUG: wp last, PathID: |r|cff00ffff%u|r", pathid);
 
-            QueryResult result = WorldDatabase.PQuery("SELECT MAX(point) FROM waypoint_data WHERE id = '%u'", pathid);
-            if (result)
-                Maxpoint = (*result)[0].GetUInt32();
-            else
-                Maxpoint = 0;
+            PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_WAYPOINT_DATA_POS_LAST_BY_ID);
+            stmt->setUInt32(0, pathid);
+            PreparedQueryResult result = WorldDatabase.Query(stmt);
 
-            result = WorldDatabase.PQuery("SELECT position_x, position_y, position_z, orientation FROM waypoint_data WHERE point ='%u' AND id = '%u'", Maxpoint, pathid);
             if (!result)
             {
                 handler->PSendSysMessage(LANG_WAYPOINT_NOTFOUNDLAST, pathid);
@@ -1018,7 +1060,10 @@
 
         if (show == "off")
         {
-            QueryResult result = WorldDatabase.PQuery("SELECT guid FROM creature WHERE id = '%u'", 1);
+            PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_CREATURE_BY_ID);
+            stmt->setUInt32(0, 1);
+            PreparedQueryResult result = WorldDatabase.Query(stmt);
+
             if (!result)
             {
                 handler->SendSysMessage(LANG_WAYPOINT_VP_NOTFOUND);
@@ -1051,7 +1096,7 @@
             }
             while (result->NextRow());
             // set "wpguid" column to "empty" - no visual waypoint spawned
-            PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_UPD_ALL_WAYPOINT_DATA_WPGUID);
+            stmt = WorldDatabase.GetPreparedStatement(WORLD_UPD_WAYPOINT_DATA_ALL_WPGUID);
 
             WorldDatabase.Execute(stmt);
             //WorldDatabase.PExecute("UPDATE creature_movement SET wpguid = '0' WHERE wpguid <> '0'");
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/AlteracValley/boss_balinda.cpp
--- a/src/server/scripts/EasternKingdoms/AlteracValley/boss_balinda.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/AlteracValley/boss_balinda.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -139,7 +139,7 @@
             summons.Summon(summoned);
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             summons.DespawnAll();
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/BlackrockDepths/blackrock_depths.cpp
--- a/src/server/scripts/EasternKingdoms/BlackrockDepths/blackrock_depths.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/BlackrockDepths/blackrock_depths.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -177,39 +177,39 @@
             MobDeath_Timer = 2500;
         }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
-            switch (i)
+            switch (waypointId)
             {
-            case 0:
-                DoScriptText(SCRIPT_TEXT1, me);//2
-                CanWalk = false;
-                Event_Timer = 5000;
-                break;
-            case 1:
-                DoScriptText(SCRIPT_TEXT2, me);//4
-                CanWalk = false;
-                Event_Timer = 5000;
-                break;
-            case 2:
-                CanWalk = false;
-                break;
-            case 3:
-                DoScriptText(SCRIPT_TEXT3, me);//5
-                break;
-            case 4:
-                DoScriptText(SCRIPT_TEXT4, me);//6
-                CanWalk = false;
-                Event_Timer = 5000;
-                break;
-            case 5:
-                if (instance)
-                {
-                    instance->UpdateEncounterState(ENCOUNTER_CREDIT_KILL_CREATURE, NPC_GRIMSTONE, me);
-                    instance->SetData(TYPE_RING_OF_LAW, DONE);
-                    sLog->outDebug(LOG_FILTER_TSCR, "TSCR: npc_grimstone: event reached end and set complete.");
-                }
-                break;
+                case 0:
+                    DoScriptText(SCRIPT_TEXT1, me);//2
+                    CanWalk = false;
+                    Event_Timer = 5000;
+                    break;
+                case 1:
+                    DoScriptText(SCRIPT_TEXT2, me);//4
+                    CanWalk = false;
+                    Event_Timer = 5000;
+                    break;
+                case 2:
+                    CanWalk = false;
+                    break;
+                case 3:
+                    DoScriptText(SCRIPT_TEXT3, me);//5
+                    break;
+                case 4:
+                    DoScriptText(SCRIPT_TEXT4, me);//6
+                    CanWalk = false;
+                    Event_Timer = 5000;
+                    break;
+                case 5:
+                    if (instance)
+                    {
+                        instance->UpdateEncounterState(ENCOUNTER_CREDIT_KILL_CREATURE, NPC_GRIMSTONE, me);
+                        instance->SetData(TYPE_RING_OF_LAW, DONE);
+                        sLog->outDebug(LOG_FILTER_TSCR, "TSCR: npc_grimstone: event reached end and set complete.");
+                    }
+                    break;
             }
         }
 
@@ -611,18 +611,22 @@
     {
         npc_dughal_stormwingAI(Creature* creature) : npc_escortAI(creature) {}
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
-        switch (i)
+            switch (waypointId)
             {
-            case 0:me->Say(SAY_DUGHAL_FREE, LANG_UNIVERSAL, PlayerGUID); break;
-            case 1:instance->SetData(DATA_DUGHAL, ENCOUNTER_STATE_OBJECTIVE_COMPLETED);break;
-            case 2:
-                me->SetVisible(false);
-                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
-                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-                instance->SetData(DATA_DUGHAL, ENCOUNTER_STATE_ENDED);
-                break;
+                case 0:
+                    me->Say(SAY_DUGHAL_FREE, LANG_UNIVERSAL, PlayerGUID);
+                    break;
+                case 1:
+                    instance->SetData(DATA_DUGHAL, ENCOUNTER_STATE_OBJECTIVE_COMPLETED);
+                    break;
+                case 2:
+                    me->SetVisible(false);
+                    me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                    me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                    instance->SetData(DATA_DUGHAL, ENCOUNTER_STATE_ENDED);
+                    break;
             }
         }
 
@@ -712,14 +716,15 @@
     bool OnQuestAccept(Player* player, Creature* creature, Quest const* quest)
     {
         if (quest->GetQuestId() == 4322)
-            {PlayerStart = player;
+        {
+            PlayerStart = player;
             if (instance->GetData(DATA_QUEST_JAIL_BREAK) == ENCOUNTER_STATE_NOT_STARTED)
             {
-                    CAST_AI(npc_escort::npc_escortAI, (creature->AI()))->Start(true, false, player->GetGUID());
-                    instance->SetData(DATA_QUEST_JAIL_BREAK, ENCOUNTER_STATE_IN_PROGRESS);
-                    creature->setFaction(11);
+                CAST_AI(npc_escort::npc_escortAI, (creature->AI()))->Start(true, false, player->GetGUID());
+                instance->SetData(DATA_QUEST_JAIL_BREAK, ENCOUNTER_STATE_IN_PROGRESS);
+                creature->setFaction(11);
             }
-            }
+        }
         return false;
     }
 
@@ -730,60 +735,66 @@
             instance = creature->GetInstanceScript();
         }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
-        switch (i)
+            switch (waypointId)
             {
-            case 1:
-                me->Say(SAY_WINDSOR_1, LANG_UNIVERSAL, PlayerGUID);
-                break;
-            case 7:
-                me->HandleEmoteCommand(EMOTE_STATE_POINT);
-                me->Say(SAY_WINDSOR_4_1, LANG_UNIVERSAL, PlayerGUID);
-                IsOnHold=true;
-                break;
-            case 10:
-                me->setFaction(534);
-                break;
-            case 12:
-                me->Say(SAY_WINDSOR_6, LANG_UNIVERSAL, PlayerGUID);
-                instance->SetData(DATA_SUPPLY_ROOM, ENCOUNTER_STATE_IN_PROGRESS);
-                break;
-            case 13:
-                me->HandleEmoteCommand(EMOTE_STATE_USESTANDING);//EMOTE_STATE_WORK
-                break;
-            case 14:
-                instance->SetData(DATA_GATE_SR, 0);
-                me->setFaction(11);
-                break;
-            case 16:
-                me->Say(SAY_WINDSOR_9, LANG_UNIVERSAL, PlayerGUID);
-                break;
-            case 17:
-                me->HandleEmoteCommand(EMOTE_STATE_USESTANDING);//EMOTE_STATE_WORK
-                break;
-            case 18:
-                instance->SetData(DATA_GATE_SC, 0);
-                break;
-            case 19:
-                me->SetVisible(false);
-                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
-                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-                me->SummonCreature(MOB_ENTRY_REGINALD_WINDSOR, 403.61f, -51.71f, -63.92f, 3.600434f, TEMPSUMMON_DEAD_DESPAWN, 0);
-                instance->SetData(DATA_SUPPLY_ROOM, ENCOUNTER_STATE_ENDED);
-                break;
+                case 1:
+                    me->Say(SAY_WINDSOR_1, LANG_UNIVERSAL, PlayerGUID);
+                    break;
+                case 7:
+                    me->HandleEmoteCommand(EMOTE_STATE_POINT);
+                    me->Say(SAY_WINDSOR_4_1, LANG_UNIVERSAL, PlayerGUID);
+                    IsOnHold = true;
+                    break;
+                case 10:
+                    me->setFaction(534);
+                    break;
+                case 12:
+                    me->Say(SAY_WINDSOR_6, LANG_UNIVERSAL, PlayerGUID);
+                    instance->SetData(DATA_SUPPLY_ROOM, ENCOUNTER_STATE_IN_PROGRESS);
+                    break;
+                case 13:
+                    me->HandleEmoteCommand(EMOTE_STATE_USESTANDING);//EMOTE_STATE_WORK
+                    break;
+                case 14:
+                    instance->SetData(DATA_GATE_SR, 0);
+                    me->setFaction(11);
+                    break;
+                case 16:
+                    me->Say(SAY_WINDSOR_9, LANG_UNIVERSAL, PlayerGUID);
+                    break;
+                case 17:
+                    me->HandleEmoteCommand(EMOTE_STATE_USESTANDING);//EMOTE_STATE_WORK
+                    break;
+                case 18:
+                    instance->SetData(DATA_GATE_SC, 0);
+                    break;
+                case 19:
+                    me->SetVisible(false);
+                    me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                    me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                    me->SummonCreature(MOB_ENTRY_REGINALD_WINDSOR, 403.61f, -51.71f, -63.92f, 3.600434f, TEMPSUMMON_DEAD_DESPAWN, 0);
+                    instance->SetData(DATA_SUPPLY_ROOM, ENCOUNTER_STATE_ENDED);
+                    break;
             }
         }
 
         void EnterCombat(Unit* who)
-            {
+        {
             switch (urand(0, 2))
             {
-                case 0: me->Say(SAY_WINDSOR_AGGRO1, LANG_UNIVERSAL, PlayerGUID); break;
-                case 1: me->Say(SAY_WINDSOR_AGGRO2, LANG_UNIVERSAL, PlayerGUID); break;
-                case 2: me->Say(SAY_WINDSOR_AGGRO3, LANG_UNIVERSAL, PlayerGUID); break;
+                case 0:
+                    me->Say(SAY_WINDSOR_AGGRO1, LANG_UNIVERSAL, PlayerGUID);
+                    break;
+                case 1:
+                    me->Say(SAY_WINDSOR_AGGRO2, LANG_UNIVERSAL, PlayerGUID);
+                    break;
+                case 2:
+                    me->Say(SAY_WINDSOR_AGGRO3, LANG_UNIVERSAL, PlayerGUID);
+                    break;
             }
-            }
+        }
 
         void Reset() {}
 
@@ -794,19 +805,22 @@
 
         void UpdateAI(const uint32 diff)
         {
-            if (instance->GetData(DATA_QUEST_JAIL_BREAK) == ENCOUNTER_STATE_NOT_STARTED) return;
+            if (instance->GetData(DATA_QUEST_JAIL_BREAK) == ENCOUNTER_STATE_NOT_STARTED)
+                return;
+
             if (instance->GetData(DATA_DUGHAL) == ENCOUNTER_STATE_OBJECTIVE_COMPLETED)
                 SetEscortPaused(false);
+
             if (!instance->GetData(DATA_GATE_D) && instance->GetData(DATA_DUGHAL) == ENCOUNTER_STATE_NOT_STARTED)
-                {
+            {
                 me->Say(SAY_WINDSOR_4_2, LANG_UNIVERSAL, PlayerGUID);
                 instance->SetData(DATA_DUGHAL, ENCOUNTER_STATE_BEFORE_START);
-                }
+            }
             if (instance->GetData(DATA_DUGHAL) == ENCOUNTER_STATE_OBJECTIVE_COMPLETED)
-                {
+            {
                 me->Say(SAY_WINDSOR_4_3, LANG_UNIVERSAL, PlayerGUID);
                 instance->SetData(DATA_DUGHAL, ENCOUNTER_STATE_ENDED);
-                }
+            }
             if ((instance->GetData(DATA_QUEST_JAIL_BREAK) == ENCOUNTER_STATE_IN_PROGRESS || instance->GetData(DATA_QUEST_JAIL_BREAK) == ENCOUNTER_STATE_FAILED || instance->GetData(DATA_QUEST_JAIL_BREAK) == ENCOUNTER_STATE_ENDED)&& instance->GetData(DATA_SUPPLY_ROOM) == ENCOUNTER_STATE_ENDED)
             {
                 me->SetVisible(false);
@@ -900,61 +914,61 @@
         {
         }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
-        wp=i;
-        switch (i)
+            wp = waypointId;
+            switch (waypointId)
             {
-            case 0:
-                me->setFaction(11);
-                me->Say(SAY_REGINALD_WINDSOR_0_1, LANG_UNIVERSAL, PlayerGUID);
-                break;
-            case 1:
-                me->Say(SAY_REGINALD_WINDSOR_0_2, LANG_UNIVERSAL, PlayerGUID);
-                break;
-            case 7:
-                me->HandleEmoteCommand(EMOTE_STATE_POINT);
-                me->Say(SAY_REGINALD_WINDSOR_5_1, LANG_UNIVERSAL, PlayerGUID);
-                IsOnHold=true;
-                break;
-            case 8:
-                me->Say(SAY_REGINALD_WINDSOR_5_2, LANG_UNIVERSAL, PlayerGUID);
-                break;
-            case 11:
-                me->HandleEmoteCommand(EMOTE_STATE_POINT);
-                me->Say(SAY_REGINALD_WINDSOR_7_1, LANG_UNIVERSAL, PlayerGUID);
-                IsOnHold=true;
-                break;
-            case 12:
-                me->Say(SAY_REGINALD_WINDSOR_7_2, LANG_UNIVERSAL, PlayerGUID);
-                break;
-            case 13:
-                me->Say(SAY_REGINALD_WINDSOR_7_3, LANG_UNIVERSAL, PlayerGUID);
-                break;
-            case 20:
-                me->HandleEmoteCommand(EMOTE_STATE_POINT);
-                me->Say(SAY_REGINALD_WINDSOR_13_1, LANG_UNIVERSAL, PlayerGUID);
-                IsOnHold=true;
-                break;
-            case 21:
-                me->Say(SAY_REGINALD_WINDSOR_13_3, LANG_UNIVERSAL, PlayerGUID);
-                break;
-            case 23:
-                me->HandleEmoteCommand(EMOTE_STATE_POINT);
-                me->Say(SAY_REGINALD_WINDSOR_14_1, LANG_UNIVERSAL, PlayerGUID);
-                IsOnHold=true;
-                break;
-            case 24:
-                me->Say(SAY_REGINALD_WINDSOR_14_2, LANG_UNIVERSAL, PlayerGUID);
-                break;
-            case 31:
-                me->Say(SAY_REGINALD_WINDSOR_20_1, LANG_UNIVERSAL, PlayerGUID);
-                break;
-            case 32:
-                me->Say(SAY_REGINALD_WINDSOR_20_2, LANG_UNIVERSAL, PlayerGUID);
-                PlayerStart->GroupEventHappens(QUEST_JAIL_BREAK, me);
-                instance->SetData(DATA_SHILL, ENCOUNTER_STATE_ENDED);
-                break;
+                case 0:
+                    me->setFaction(11);
+                    me->Say(SAY_REGINALD_WINDSOR_0_1, LANG_UNIVERSAL, PlayerGUID);
+                    break;
+                case 1:
+                    me->Say(SAY_REGINALD_WINDSOR_0_2, LANG_UNIVERSAL, PlayerGUID);
+                    break;
+                case 7:
+                    me->HandleEmoteCommand(EMOTE_STATE_POINT);
+                    me->Say(SAY_REGINALD_WINDSOR_5_1, LANG_UNIVERSAL, PlayerGUID);
+                    IsOnHold=true;
+                    break;
+                case 8:
+                    me->Say(SAY_REGINALD_WINDSOR_5_2, LANG_UNIVERSAL, PlayerGUID);
+                    break;
+                case 11:
+                    me->HandleEmoteCommand(EMOTE_STATE_POINT);
+                    me->Say(SAY_REGINALD_WINDSOR_7_1, LANG_UNIVERSAL, PlayerGUID);
+                    IsOnHold=true;
+                    break;
+                case 12:
+                    me->Say(SAY_REGINALD_WINDSOR_7_2, LANG_UNIVERSAL, PlayerGUID);
+                    break;
+                case 13:
+                    me->Say(SAY_REGINALD_WINDSOR_7_3, LANG_UNIVERSAL, PlayerGUID);
+                    break;
+                case 20:
+                    me->HandleEmoteCommand(EMOTE_STATE_POINT);
+                    me->Say(SAY_REGINALD_WINDSOR_13_1, LANG_UNIVERSAL, PlayerGUID);
+                    IsOnHold=true;
+                    break;
+                case 21:
+                    me->Say(SAY_REGINALD_WINDSOR_13_3, LANG_UNIVERSAL, PlayerGUID);
+                    break;
+                case 23:
+                    me->HandleEmoteCommand(EMOTE_STATE_POINT);
+                    me->Say(SAY_REGINALD_WINDSOR_14_1, LANG_UNIVERSAL, PlayerGUID);
+                    IsOnHold=true;
+                    break;
+                case 24:
+                    me->Say(SAY_REGINALD_WINDSOR_14_2, LANG_UNIVERSAL, PlayerGUID);
+                    break;
+                case 31:
+                    me->Say(SAY_REGINALD_WINDSOR_20_1, LANG_UNIVERSAL, PlayerGUID);
+                    break;
+                case 32:
+                    me->Say(SAY_REGINALD_WINDSOR_20_2, LANG_UNIVERSAL, PlayerGUID);
+                    PlayerStart->GroupEventHappens(QUEST_JAIL_BREAK, me);
+                    instance->SetData(DATA_SHILL, ENCOUNTER_STATE_ENDED);
+                    break;
             }
         }
 
@@ -978,14 +992,20 @@
         }
 
         void EnterCombat(Unit* who)
-            {
+        {
             switch (urand(0, 2))
             {
-                case 0: me->Say(SAY_WINDSOR_AGGRO1, LANG_UNIVERSAL, PlayerGUID); break;
-                case 1: me->Say(SAY_WINDSOR_AGGRO2, LANG_UNIVERSAL, PlayerGUID); break;
-                case 2: me->Say(SAY_WINDSOR_AGGRO3, LANG_UNIVERSAL, PlayerGUID); break;
+                case 0:
+                    me->Say(SAY_WINDSOR_AGGRO1, LANG_UNIVERSAL, PlayerGUID);
+                    break;
+                case 1:
+                    me->Say(SAY_WINDSOR_AGGRO2, LANG_UNIVERSAL, PlayerGUID);
+                    break;
+                case 2:
+                    me->Say(SAY_WINDSOR_AGGRO3, LANG_UNIVERSAL, PlayerGUID);
+                    break;
             }
-            }
+        }
         void Reset() {}
 
         void JustDied(Unit* slayer)
@@ -995,47 +1015,49 @@
 
         void UpdateAI(const uint32 diff)
         {
-            if (instance->GetData(DATA_QUEST_JAIL_BREAK) == ENCOUNTER_STATE_NOT_STARTED) return;
+            if (instance->GetData(DATA_QUEST_JAIL_BREAK) == ENCOUNTER_STATE_NOT_STARTED)
+                return;
+
             if (wp == 7)
+            {
+                if (!instance->GetData(DATA_GATE_J) && instance->GetData(DATA_JAZ) == ENCOUNTER_STATE_NOT_STARTED)
                 {
-                if (!instance->GetData(DATA_GATE_J) && instance->GetData(DATA_JAZ) == ENCOUNTER_STATE_NOT_STARTED)
-                    {
-                        instance->SetData(DATA_CREATURE_JAZ, 1);
-                        instance->SetData(DATA_JAZ, ENCOUNTER_STATE_IN_PROGRESS);
-                    }
+                    instance->SetData(DATA_CREATURE_JAZ, 1);
+                    instance->SetData(DATA_JAZ, ENCOUNTER_STATE_IN_PROGRESS);
+                }
                 if (instance->GetData(DATA_CREATURE_JAZ) && instance->GetData(DATA_CREATURE_OGRABISI) && instance->GetData(DATA_JAZ) == ENCOUNTER_STATE_IN_PROGRESS)
-                    {
-                        SetEscortPaused(false);
-                        instance->SetData(DATA_JAZ, ENCOUNTER_STATE_ENDED);
-                    }
+                {
+                    SetEscortPaused(false);
+                    instance->SetData(DATA_JAZ, ENCOUNTER_STATE_ENDED);
                 }
+            }
             else if (wp == 11)
+            {
+                if (!instance->GetData(DATA_GATE_S) && instance->GetData(DATA_SHILL) == ENCOUNTER_STATE_NOT_STARTED)
                 {
-                if (!instance->GetData(DATA_GATE_S) && instance->GetData(DATA_SHILL) == ENCOUNTER_STATE_NOT_STARTED)
-                    {
-                        instance->SetData(DATA_CREATURE_SHILL, 1);
-                        instance->SetData(DATA_SHILL, ENCOUNTER_STATE_IN_PROGRESS);
-                    }
+                    instance->SetData(DATA_CREATURE_SHILL, 1);
+                    instance->SetData(DATA_SHILL, ENCOUNTER_STATE_IN_PROGRESS);
+                }
                 if (instance->GetData(DATA_CREATURE_SHILL) && instance->GetData(DATA_SHILL) == ENCOUNTER_STATE_IN_PROGRESS)
-                    {
-                        instance->SetData(DATA_SHILL, ENCOUNTER_STATE_ENDED);
-                        SetEscortPaused(false);
-                    }
+                {
+                    instance->SetData(DATA_SHILL, ENCOUNTER_STATE_ENDED);
+                    SetEscortPaused(false);
                 }
+            }
             else if (wp == 20)
+            {
+                if (!instance->GetData(DATA_GATE_C) && instance->GetData(DATA_CREST) == ENCOUNTER_STATE_NOT_STARTED)
                 {
-                if (!instance->GetData(DATA_GATE_C) && instance->GetData(DATA_CREST) == ENCOUNTER_STATE_NOT_STARTED)
-                    {
-                        instance->SetData(DATA_CREATURE_CREST, 1);
-                        me->Say(SAY_REGINALD_WINDSOR_13_2, LANG_UNIVERSAL, PlayerGUID);
-                        instance->SetData(DATA_CREST, ENCOUNTER_STATE_IN_PROGRESS);
-                    }
+                    instance->SetData(DATA_CREATURE_CREST, 1);
+                    me->Say(SAY_REGINALD_WINDSOR_13_2, LANG_UNIVERSAL, PlayerGUID);
+                    instance->SetData(DATA_CREST, ENCOUNTER_STATE_IN_PROGRESS);
+                }
                 if (instance->GetData(DATA_CREATURE_CREST) && instance->GetData(DATA_CREST) == ENCOUNTER_STATE_IN_PROGRESS)
-                    {
-                        SetEscortPaused(false);
-                        instance->SetData(DATA_CREST, ENCOUNTER_STATE_ENDED);
-                    }
+                {
+                    SetEscortPaused(false);
+                    instance->SetData(DATA_CREST, ENCOUNTER_STATE_ENDED);
                 }
+            }
             if (instance->GetData(DATA_TOBIAS) == ENCOUNTER_STATE_OBJECTIVE_COMPLETED) SetEscortPaused(false);
             npc_escortAI::UpdateAI(diff);
         }
@@ -1045,6 +1067,7 @@
 
 // npc_tobias_seecher
 #define SAY_TOBIAS_FREE         "Thank you! I will run for safety immediately!"
+
 /*
 class npc_tobias_seecher : public CreatureScript
 {
@@ -1105,25 +1128,30 @@
             }
         }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
-        switch (i)
+            switch (waypointId)
             {
-            case 0:me->Say(SAY_TOBIAS_FREE, LANG_UNIVERSAL, PlayerGUID); break;
-            case 2:
-                instance->SetData(DATA_TOBIAS, ENCOUNTER_STATE_OBJECTIVE_COMPLETED);break;
-            case 4:
-                me->SetVisible(false);
-                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
-                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-                instance->SetData(DATA_TOBIAS, ENCOUNTER_STATE_ENDED);
-                break;
+                case 0:
+                    me->Say(SAY_TOBIAS_FREE, LANG_UNIVERSAL, PlayerGUID);
+                    break;
+                case 2:
+                    instance->SetData(DATA_TOBIAS, ENCOUNTER_STATE_OBJECTIVE_COMPLETED);
+                    break;
+                case 4:
+                    me->SetVisible(false);
+                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                    instance->SetData(DATA_TOBIAS, ENCOUNTER_STATE_ENDED);
+                    break;
             }
         }
 
         void UpdateAI(const uint32 diff)
         {
-            if (instance->GetData(DATA_QUEST_JAIL_BREAK) == ENCOUNTER_STATE_NOT_STARTED) return;
+            if (instance->GetData(DATA_QUEST_JAIL_BREAK) == ENCOUNTER_STATE_NOT_STARTED)
+                return;
+
             if ((instance->GetData(DATA_QUEST_JAIL_BREAK) == ENCOUNTER_STATE_IN_PROGRESS || instance->GetData(DATA_QUEST_JAIL_BREAK) == ENCOUNTER_STATE_FAILED || instance->GetData(DATA_QUEST_JAIL_BREAK) == ENCOUNTER_STATE_ENDED)&& instance->GetData(DATA_TOBIAS) == ENCOUNTER_STATE_ENDED)
             {
                 me->SetVisible(false);
@@ -1226,29 +1254,29 @@
                 go->SetGoState((GOState)state);
         }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             if (!instance)
                 return;
 
-            switch (i)
+            switch (waypointId)
             {
-            case 1:
-                me->HandleEmoteCommand(EMOTE_ONESHOT_KICK);
-                break;
-            case 2:
-                me->HandleEmoteCommand(EMOTE_ONESHOT_ATTACK_UNARMED);
-                break;
-            case 3:
-                me->HandleEmoteCommand(EMOTE_ONESHOT_ATTACK_UNARMED);
-                break;
-            case 4:
-                me->HandleEmoteCommand(EMOTE_ONESHOT_KICK);
-                break;
-            case 5:
-                me->HandleEmoteCommand(EMOTE_ONESHOT_KICK);
-                BreakKeg_Timer = 2000;
-                break;
+                case 1:
+                    me->HandleEmoteCommand(EMOTE_ONESHOT_KICK);
+                    break;
+                case 2:
+                    me->HandleEmoteCommand(EMOTE_ONESHOT_ATTACK_UNARMED);
+                    break;
+                case 3:
+                    me->HandleEmoteCommand(EMOTE_ONESHOT_ATTACK_UNARMED);
+                    break;
+                case 4:
+                    me->HandleEmoteCommand(EMOTE_ONESHOT_KICK);
+                    break;
+                case 5:
+                    me->HandleEmoteCommand(EMOTE_ONESHOT_KICK);
+                    BreakKeg_Timer = 2000;
+                    break;
             }
         }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/BlackrockDepths/boss_emperor_dagran_thaurissan.cpp
--- a/src/server/scripts/EasternKingdoms/BlackrockDepths/boss_emperor_dagran_thaurissan.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/BlackrockDepths/boss_emperor_dagran_thaurissan.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -71,7 +71,7 @@
             DoScriptText(SAY_SLAY, me);
         }
 
-        void JustDied(Unit* /*who*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (Creature* Moira = ObjectAccessor::GetCreature(*me, instance ? instance->GetData64(DATA_MOIRA) : 0))
             {
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/BlackrockDepths/boss_magmus.cpp
--- a/src/server/scripts/EasternKingdoms/BlackrockDepths/boss_magmus.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/BlackrockDepths/boss_magmus.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -80,9 +80,9 @@
             DoMeleeAttackIfReady();
         }
         // When he die open door to last chamber
-        void JustDied(Unit* who)
+        void JustDied(Unit* killer)
         {
-            if (InstanceScript* instance = who->GetInstanceScript())
+            if (InstanceScript* instance = killer->GetInstanceScript())
                 instance->HandleGameObject(instance->GetData64(DATA_THRONE_DOOR), true);
         }
     };
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/BlackrockDepths/boss_tomb_of_seven.cpp
--- a/src/server/scripts/EasternKingdoms/BlackrockDepths/boss_tomb_of_seven.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/BlackrockDepths/boss_tomb_of_seven.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -193,7 +193,7 @@
                 instance->SetData64(DATA_EVENSTARTER, 0);
         }
 
-        void JustDied(Unit* /*who*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (instance)
                 instance->SetData(DATA_GHOSTKILL, 1);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/BlackrockSpire/boss_drakkisath.cpp
--- a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_drakkisath.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_drakkisath.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -64,7 +64,7 @@
             events.ScheduleEvent(EVENT_THUNDERCLAP,    17 * IN_MILLISECONDS);
         }
 
-        void JustDied(Unit* /*who*/)
+        void JustDied(Unit* /*killer*/)
         {
             _JustDied();
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/BlackrockSpire/boss_gyth.cpp
--- a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_gyth.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_gyth.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -79,7 +79,7 @@
             events.ScheduleEvent(EVENT_AGGRO, 60 * IN_MILLISECONDS);
         }
 
-        void JustDied(Unit* /*who*/)
+        void JustDied(Unit* /*killer*/)
         {
             _JustDied();
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/BlackrockSpire/boss_halycon.cpp
--- a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_halycon.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_halycon.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -63,7 +63,7 @@
             events.ScheduleEvent(EVENT_MIGHTY_BLOW, 14 * IN_MILLISECONDS);
         }
 
-        void JustDied(Unit* /*who*/)
+        void JustDied(Unit* /*killer*/)
         {
             _JustDied();
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/BlackrockSpire/boss_highlord_omokk.cpp
--- a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_highlord_omokk.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_highlord_omokk.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -73,7 +73,7 @@
             events.ScheduleEvent(EVENT_SLOW, 24 * IN_MILLISECONDS);
         }
 
-        void JustDied(Unit* /*who*/)
+        void JustDied(Unit* /*killer*/)
         {
             _JustDied();
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/BlackrockSpire/boss_mother_smolderweb.cpp
--- a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_mother_smolderweb.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_mother_smolderweb.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -59,7 +59,7 @@
             events.ScheduleEvent(EVENT_MOTHERS_MILK, 10 * IN_MILLISECONDS);
         }
 
-        void JustDied(Unit* /*who*/)
+        void JustDied(Unit* /*killer*/)
         {
             _JustDied();
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/BlackrockSpire/boss_overlord_wyrmthalak.cpp
--- a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_overlord_wyrmthalak.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_overlord_wyrmthalak.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -77,7 +77,7 @@
             events.ScheduleEvent(EVENT_KNOCK_AWAY, 12 * IN_MILLISECONDS);
         }
 
-        void JustDied(Unit* /*who*/)
+        void JustDied(Unit* /*killer*/)
         {
             _JustDied();
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/BlackrockSpire/boss_pyroguard_emberseer.cpp
--- a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_pyroguard_emberseer.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_pyroguard_emberseer.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -62,7 +62,7 @@
             events.ScheduleEvent(EVENT_PYROBLAST,  14 * IN_MILLISECONDS);
         }
 
-        void JustDied(Unit* /*who*/)
+        void JustDied(Unit* /*killer*/)
         {
             _JustDied();
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/BlackrockSpire/boss_quartermaster_zigris.cpp
--- a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_quartermaster_zigris.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_quartermaster_zigris.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -60,7 +60,7 @@
             events.ScheduleEvent(EVENT_STUN_BOMB, 16 * IN_MILLISECONDS);
         }
 
-        void JustDied(Unit* /*who*/)
+        void JustDied(Unit* /*killer*/)
         {
             _JustDied();
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/BlackrockSpire/boss_rend_blackhand.cpp
--- a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_rend_blackhand.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_rend_blackhand.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -61,7 +61,7 @@
             events.ScheduleEvent(EVENT_THUNDERCLAP, 9 * IN_MILLISECONDS);
         }
 
-        void JustDied(Unit* /*who*/)
+        void JustDied(Unit* /*killer*/)
         {
             _JustDied();
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/BlackrockSpire/boss_shadow_hunter_voshgajin.cpp
--- a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_shadow_hunter_voshgajin.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_shadow_hunter_voshgajin.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -62,7 +62,7 @@
             events.ScheduleEvent(EVENT_CLEAVE, 14 * IN_MILLISECONDS);
         }
 
-        void JustDied(Unit* /*who*/)
+        void JustDied(Unit* /*killer*/)
         {
             _JustDied();
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/BlackrockSpire/boss_the_beast.cpp
--- a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_the_beast.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_the_beast.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -61,7 +61,7 @@
             events.ScheduleEvent(EVENT_TERRIFYING_ROAR, 23 * IN_MILLISECONDS);
         }
 
-        void JustDied(Unit* /*who*/)
+        void JustDied(Unit* /*killer*/)
         {
             _JustDied();
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/BlackrockSpire/boss_warmaster_voone.cpp
--- a/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_warmaster_voone.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/BlackrockSpire/boss_warmaster_voone.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -70,7 +70,7 @@
             events.ScheduleEvent(EVENT_THROW_AXE, 1 * IN_MILLISECONDS);
         }
 
-        void JustDied(Unit* /*who*/)
+        void JustDied(Unit* /*killer*/)
         {
             _JustDied();
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/BlackwingLair/boss_chromaggus.cpp
--- a/src/server/scripts/EasternKingdoms/BlackwingLair/boss_chromaggus.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/BlackwingLair/boss_chromaggus.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -245,7 +245,7 @@
                     Unit* unit;
                     if ((*i) && (*i)->getSource())
                     {
-                        unit = Unit::GetUnit((*me), (*i)->getUnitGuid());
+                        unit = Unit::GetUnit(*me, (*i)->getUnitGuid());
                         if (unit)
                         {
                             //Cast affliction
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/BlackwingLair/boss_nefarian.cpp
--- a/src/server/scripts/EasternKingdoms/BlackwingLair/boss_nefarian.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/BlackwingLair/boss_nefarian.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -111,7 +111,7 @@
             DoScriptText(SAY_SLAY, me, Victim);
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEATH, me);
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/BlackwingLair/boss_razorgore.cpp
--- a/src/server/scripts/EasternKingdoms/BlackwingLair/boss_razorgore.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/BlackwingLair/boss_razorgore.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -75,7 +75,7 @@
             DoZoneInCombat();
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEATH, me);
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/BlackwingLair/boss_vaelastrasz.cpp
--- a/src/server/scripts/EasternKingdoms/BlackwingLair/boss_vaelastrasz.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/BlackwingLair/boss_vaelastrasz.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -176,9 +176,9 @@
                             break;
                         case 2:
                             me->setFaction(103);
-                            if (PlayerGUID && Unit::GetUnit((*me), PlayerGUID))
+                            if (PlayerGUID && Unit::GetUnit(*me, PlayerGUID))
                             {
-                                AttackStart(Unit::GetUnit((*me), PlayerGUID));
+                                AttackStart(Unit::GetUnit(*me, PlayerGUID));
                                 DoCast(me, SPELL_ESSENCEOFTHERED);
                             }
                             SpeechTimer = 0;
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/Deadmines/boss_mr_smite.cpp
--- a/src/server/scripts/EasternKingdoms/Deadmines/boss_mr_smite.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/Deadmines/boss_mr_smite.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -127,7 +127,7 @@
                 DoCastAOE(SPELL_SMITE_STOMP, false);
                 SetCombatMovement(false);
                 if (instance)
-                    if (GameObject* go = GameObject::GetGameObject((*me), instance->GetData64(DATA_SMITE_CHEST)))
+                    if (GameObject* go = GameObject::GetGameObject(*me, instance->GetData64(DATA_SMITE_CHEST)))
                     {
                         me->GetMotionMaster()->Clear();
                         me->GetMotionMaster()->MovePoint(1, go->GetPositionX() - 3.0f, go->GetPositionY(), go->GetPositionZ());
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/Gnomeregan/gnomeregan.cpp
--- a/src/server/scripts/EasternKingdoms/Gnomeregan/gnomeregan.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/Gnomeregan/gnomeregan.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -189,11 +189,11 @@
            if (bBool)
            {
                 if (instance)
-                    if (GameObject* go = GameObject::GetGameObject((*me), instance->GetData64(DATA_GO_CAVE_IN_RIGHT)))
+                    if (GameObject* go = GameObject::GetGameObject(*me, instance->GetData64(DATA_GO_CAVE_IN_RIGHT)))
                         instance->HandleGameObject(0, false, go);
            }else
                 if (instance)
-                    if (GameObject* go = GameObject::GetGameObject((*me), instance->GetData64(DATA_GO_CAVE_IN_LEFT)))
+                    if (GameObject* go = GameObject::GetGameObject(*me, instance->GetData64(DATA_GO_CAVE_IN_LEFT)))
                         instance->HandleGameObject(0, false, go);
         }
 
@@ -204,10 +204,10 @@
 
             if (bBool)
             {
-                if (GameObject* go = GameObject::GetGameObject((*me), instance->GetData64(DATA_GO_CAVE_IN_RIGHT)))
+                if (GameObject* go = GameObject::GetGameObject(*me, instance->GetData64(DATA_GO_CAVE_IN_RIGHT)))
                     me->SetFacingToObject(go);
             }else
-                if (GameObject* go = GameObject::GetGameObject((*me), instance->GetData64(DATA_GO_CAVE_IN_LEFT)))
+                if (GameObject* go = GameObject::GetGameObject(*me, instance->GetData64(DATA_GO_CAVE_IN_LEFT)))
                     me->SetFacingToObject(go);
         }
 
@@ -216,10 +216,10 @@
             if (!instance)
                 return;
 
-            if (GameObject* go = GameObject::GetGameObject((*me), instance->GetData64(DATA_GO_CAVE_IN_RIGHT)))
+            if (GameObject* go = GameObject::GetGameObject(*me, instance->GetData64(DATA_GO_CAVE_IN_RIGHT)))
                 instance->HandleGameObject(0, false, go);
 
-            if (GameObject* go = GameObject::GetGameObject((*me), instance->GetData64(DATA_GO_CAVE_IN_LEFT)))
+            if (GameObject* go = GameObject::GetGameObject(*me, instance->GetData64(DATA_GO_CAVE_IN_LEFT)))
                 instance->HandleGameObject(0, false, go);
 
             if (!GoSummonList.empty())
@@ -266,14 +266,14 @@
             }
         }
 
-        void WaypointReached(uint32 uiPoint)
+        void WaypointReached(uint32 waypointId)
         {
             //just in case
             if (GetPlayerForEscort())
                 if (me->getFaction() != GetPlayerForEscort()->getFaction())
                     me->setFaction(GetPlayerForEscort()->getFaction());
 
-            switch (uiPoint)
+            switch (waypointId)
             {
                 case 3:
                     SetEscortPaused(true);
@@ -445,7 +445,7 @@
                             DoScriptText(SAY_BLASTMASTER_5, me);
                             Summon(1);
                             if (instance)
-                                if (GameObject* go = GameObject::GetGameObject((*me), instance->GetData64(DATA_GO_CAVE_IN_RIGHT)))
+                                if (GameObject* go = GameObject::GetGameObject(*me, instance->GetData64(DATA_GO_CAVE_IN_RIGHT)))
                                     instance->HandleGameObject(0, true, go);
                             NextStep(3000, true);
                             break;
@@ -491,7 +491,7 @@
                             DoScriptText(SAY_BLASTMASTER_23, me);
                             SetInFace(false);
                             if (instance)
-                                if (GameObject* go = GameObject::GetGameObject((*me), instance->GetData64(DATA_GO_CAVE_IN_LEFT)))
+                                if (GameObject* go = GameObject::GetGameObject(*me, instance->GetData64(DATA_GO_CAVE_IN_LEFT)))
                                     instance->HandleGameObject(0, true, go);
                             NextStep(2000, true);
                             break;
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/Karazhan/boss_curator.cpp
--- a/src/server/scripts/EasternKingdoms/Karazhan/boss_curator.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/Karazhan/boss_curator.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -80,7 +80,7 @@
             DoScriptText(RAND(SAY_KILL1, SAY_KILL2), me);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEATH, me);
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/Karazhan/boss_maiden_of_virtue.cpp
--- a/src/server/scripts/EasternKingdoms/Karazhan/boss_maiden_of_virtue.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/Karazhan/boss_maiden_of_virtue.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -78,7 +78,7 @@
                 DoScriptText(RAND(SAY_SLAY1, SAY_SLAY2, SAY_SLAY3), me);
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEATH, me);
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/Karazhan/boss_midnight.cpp
--- a/src/server/scripts/EasternKingdoms/Karazhan/boss_midnight.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/Karazhan/boss_midnight.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -89,7 +89,7 @@
             DoScriptText(RAND(SAY_KILL1, SAY_KILL2), me);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEATH, me);
             if (Unit* pMidnight = Unit::GetUnit(*me, Midnight))
@@ -203,16 +203,16 @@
             pAttumen->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
             float angle = me->GetAngle(pAttumen);
             float distance = me->GetDistance2d(pAttumen);
-            float newX = me->GetPositionX() + cos(angle)*(distance/2) ;
-            float newY = me->GetPositionY() + sin(angle)*(distance/2) ;
+            float newX = me->GetPositionX() + cos(angle)*(distance/2);
+            float newY = me->GetPositionY() + sin(angle)*(distance/2);
             float newZ = 50;
             //me->Relocate(newX, newY, newZ, angle);
             //me->SendMonsterMove(newX, newY, newZ, 0, true, 1000);
             me->GetMotionMaster()->Clear();
             me->GetMotionMaster()->MovePoint(0, newX, newY, newZ);
             distance += 10;
-            newX = me->GetPositionX() + cos(angle)*(distance/2) ;
-            newY = me->GetPositionY() + sin(angle)*(distance/2) ;
+            newX = me->GetPositionX() + cos(angle)*(distance/2);
+            newY = me->GetPositionY() + sin(angle)*(distance/2);
             pAttumen->GetMotionMaster()->Clear();
             pAttumen->GetMotionMaster()->MovePoint(0, newX, newY, newZ);
             //pAttumen->Relocate(newX, newY, newZ, -angle);
@@ -244,8 +244,8 @@
             Midnight = 0;
             me->SetVisible(false);
             me->Kill(me);
-        }
-    } else ResetTimer -= diff;
+        } else ResetTimer -= diff;
+    }
 
     //Return since we have no target
     if (!UpdateVictim())
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/Karazhan/boss_moroes.cpp
--- a/src/server/scripts/EasternKingdoms/Karazhan/boss_moroes.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/Karazhan/boss_moroes.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -135,7 +135,7 @@
             DoScriptText(RAND(SAY_KILL_1, SAY_KILL_2, SAY_KILL_3), me);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEATH, me);
 
@@ -201,7 +201,7 @@
 
         void DeSpawnAdds()
         {
-            for (uint8 i = 0; i < 4 ; ++i)
+            for (uint8 i = 0; i < 4; ++i)
             {
                 Creature* Temp = NULL;
                 if (AddGUID[i])
@@ -358,7 +358,7 @@
         uint64 TempGUID = GuestGUID[rand()%4];
         if (TempGUID)
         {
-            Unit* unit = Unit::GetUnit((*me), TempGUID);
+            Unit* unit = Unit::GetUnit(*me, TempGUID);
             if (unit && unit->isAlive())
                 return unit;
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/Karazhan/boss_prince_malchezaar.cpp
--- a/src/server/scripts/EasternKingdoms/Karazhan/boss_prince_malchezaar.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/Karazhan/boss_prince_malchezaar.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -243,7 +243,7 @@
             DoScriptText(RAND(SAY_SLAY1, SAY_SLAY2, SAY_SLAY3), me);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEATH, me);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/Karazhan/boss_shade_of_aran.cpp
--- a/src/server/scripts/EasternKingdoms/Karazhan/boss_shade_of_aran.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/Karazhan/boss_shade_of_aran.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -161,7 +161,7 @@
             DoScriptText(RAND(SAY_KILL1, SAY_KILL2), me);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEATH, me);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/Karazhan/boss_terestian_illhoof.cpp
--- a/src/server/scripts/EasternKingdoms/Karazhan/boss_terestian_illhoof.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/Karazhan/boss_terestian_illhoof.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -94,14 +94,14 @@
             }
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (instance)
             {
                 uint64 TerestianGUID = instance->GetData64(DATA_TERESTIAN);
                 if (TerestianGUID)
                 {
-                    Unit* Terestian = Unit::GetUnit((*me), TerestianGUID);
+                    Unit* Terestian = Unit::GetUnit(*me, TerestianGUID);
                     if (Terestian && Terestian->isAlive())
                         DoCast(Terestian, SPELL_BROKEN_PACT, true);
                 }
@@ -157,7 +157,7 @@
         {
             if (SacrificeGUID)
             {
-                Unit* Sacrifice = Unit::GetUnit((*me), SacrificeGUID);
+                Unit* Sacrifice = Unit::GetUnit(*me, SacrificeGUID);
                 if (Sacrifice)
                     Sacrifice->RemoveAurasDueToSpell(SPELL_SACRIFICE);
             }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/Karazhan/bosses_opera.cpp
--- a/src/server/scripts/EasternKingdoms/Karazhan/bosses_opera.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/Karazhan/bosses_opera.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -886,7 +886,7 @@
                 {
                     IsChasing = false;
 
-                    if (Unit* target = Unit::GetUnit((*me), HoodGUID))
+                    if (Unit* target = Unit::GetUnit(*me, HoodGUID))
                     {
                         HoodGUID = 0;
                         if (DoGetThreat(target))
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/Karazhan/karazhan.cpp
--- a/src/server/scripts/EasternKingdoms/Karazhan/karazhan.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/Karazhan/karazhan.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -158,12 +158,12 @@
 
         void EnterCombat(Unit* /*who*/) {}
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             if (!instance)
                 return;
 
-            switch (i)
+            switch (waypointId)
             {
                 case 0:
                     DoCast(me, SPELL_TUXEDO, false);
@@ -536,7 +536,7 @@
 
         uint32 NextStep(uint32 Step)
         {
-            Unit* arca = Unit::GetUnit((*me), ArcanagosGUID);
+            Unit* arca = Unit::GetUnit(*me, ArcanagosGUID);
             Map* map = me->GetMap();
             switch (Step)
             {
@@ -625,7 +625,7 @@
 
             if (Step >= 7 && Step <= 12)
             {
-                Unit* arca = Unit::GetUnit((*me), ArcanagosGUID);
+                Unit* arca = Unit::GetUnit(*me, ArcanagosGUID);
 
                 if (FireArcanagosTimer <= diff)
                 {
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/MagistersTerrace/boss_felblood_kaelthas.cpp
--- a/src/server/scripts/EasternKingdoms/MagistersTerrace/boss_felblood_kaelthas.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/MagistersTerrace/boss_felblood_kaelthas.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -197,7 +197,7 @@
             std::list<HostileReference*>::const_iterator i = m_threatlist.begin();
             for (i = m_threatlist.begin(); i != m_threatlist.end(); ++i)
             {
-                Unit* unit = Unit::GetUnit((*me), (*i)->getUnitGuid());
+                Unit* unit = Unit::GetUnit(*me, (*i)->getUnitGuid());
                 if (unit && unit->isAlive())
                 {
                     float threat = me->getThreatManager().getThreat(unit);
@@ -215,7 +215,7 @@
             std::list<HostileReference*>::const_iterator i = me->getThreatManager().getThreatList().begin();
             for (i = me->getThreatManager().getThreatList().begin(); i!= me->getThreatManager().getThreatList().end(); ++i)
             {
-                Unit* unit = Unit::GetUnit((*me), (*i)->getUnitGuid());
+                Unit* unit = Unit::GetUnit(*me, (*i)->getUnitGuid());
                 if (unit && (unit->GetTypeId() == TYPEID_PLAYER))
                     unit->CastSpell(unit, SPELL_TELEPORT_CENTER, true);
             }
@@ -227,7 +227,7 @@
             std::list<HostileReference*>::const_iterator i = me->getThreatManager().getThreatList().begin();
             for (i = me->getThreatManager().getThreatList().begin(); i!= me->getThreatManager().getThreatList().end(); ++i)
             {
-                Unit* unit = Unit::GetUnit((*me), (*i)->getUnitGuid());
+                Unit* unit = Unit::GetUnit(*me, (*i)->getUnitGuid());
                 if (unit && (unit->GetTypeId() == TYPEID_PLAYER))
                     // Knockback into the air
                     unit->CastSpell(unit, SPELL_GRAVITY_LAPSE_DOT, true, 0, 0, me->GetGUID());
@@ -239,7 +239,7 @@
             std::list<HostileReference*>::const_iterator i = me->getThreatManager().getThreatList().begin();
             for (i = me->getThreatManager().getThreatList().begin(); i!= me->getThreatManager().getThreatList().end(); ++i)
             {
-                Unit* unit = Unit::GetUnit((*me), (*i)->getUnitGuid());
+                Unit* unit = Unit::GetUnit(*me, (*i)->getUnitGuid());
                 if (unit && (unit->GetTypeId() == TYPEID_PLAYER))
                 {
                     // Also needs an exception in spell system.
@@ -259,7 +259,7 @@
             std::list<HostileReference*>::const_iterator i = me->getThreatManager().getThreatList().begin();
             for (i = me->getThreatManager().getThreatList().begin(); i!= me->getThreatManager().getThreatList().end(); ++i)
             {
-                Unit* unit = Unit::GetUnit((*me), (*i)->getUnitGuid());
+                Unit* unit = Unit::GetUnit(*me, (*i)->getUnitGuid());
                 if (unit && (unit->GetTypeId() == TYPEID_PLAYER))
                 {
                     unit->RemoveAurasDueToSpell(SPELL_GRAVITY_LAPSE_FLY);
@@ -548,7 +548,7 @@
 
         }
 
-        void JustDied(Unit* /*slayer*/)
+        void JustDied(Unit* /*killer*/)
         {
             me->SummonCreature(CREATURE_PHOENIX_EGG, 0.0f, 0.0f, 0.0f, 0.0f, TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN, 45000);
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/MagistersTerrace/boss_vexallus.cpp
--- a/src/server/scripts/EasternKingdoms/MagistersTerrace/boss_vexallus.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/MagistersTerrace/boss_vexallus.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -101,7 +101,7 @@
             DoScriptText(SAY_KILL, me);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (instance)
                 instance->SetData(DATA_VEXALLUS_EVENT, DONE);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/MoltenCore/boss_ragnaros.cpp
--- a/src/server/scripts/EasternKingdoms/MoltenCore/boss_ragnaros.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/MoltenCore/boss_ragnaros.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -321,7 +321,7 @@
                 instance = me->GetInstanceScript();
             }
 
-            void JustDied(Unit* /*victim*/)
+            void JustDied(Unit* /*killer*/)
             {
                 if (instance)
                     instance->SetData(DATA_RAGNAROS_ADDS, 1);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/MoltenCore/boss_sulfuron_harbinger.cpp
--- a/src/server/scripts/EasternKingdoms/MoltenCore/boss_sulfuron_harbinger.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/MoltenCore/boss_sulfuron_harbinger.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -103,7 +103,7 @@
                         {
                             std::list<Creature*> healers = DoFindFriendlyMissingBuff(45.0f, SPELL_INSPIRE);
                             if (!healers.empty())
-                                DoCast(SelectRandomContainerElement(healers), SPELL_INSPIRE);
+                                DoCast(Trinity::Containers::SelectRandomContainerElement(healers), SPELL_INSPIRE);
 
                             DoCast(me, SPELL_INSPIRE);
                             events.ScheduleEvent(EVENT_INSPIRE, urand(20000, 26000));
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/ScarletEnclave/chapter1.cpp
--- a/src/server/scripts/EasternKingdoms/ScarletEnclave/chapter1.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/ScarletEnclave/chapter1.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -809,11 +809,11 @@
             {
                 for (std::list<Creature*>::const_iterator itr = MinionList.begin(); itr != MinionList.end(); ++itr)
                 {
-                    if (CAST_CRE(*itr)->GetOwner()->GetGUID() == me->GetOwner()->GetGUID())
+                    if ((*itr)->GetOwner()->GetGUID() == me->GetOwner()->GetGUID())
                     {
-                        if (CAST_CRE(*itr)->isInCombat() && CAST_CRE(*itr)->getAttackerForHelper())
+                        if ((*itr)->isInCombat() && (*itr)->getAttackerForHelper())
                         {
-                            AttackStart(CAST_CRE(*itr)->getAttackerForHelper());
+                            AttackStart((*itr)->getAttackerForHelper());
                         }
                     }
                 }
@@ -826,16 +826,13 @@
             {
                 if (Unit* owner = me->GetOwner())
                 {
-                    if (owner->GetTypeId() == TYPEID_PLAYER && CAST_PLR(owner)->isInCombat())
+                    Player* plrOwner = owner->ToPlayer();
+                    if (plrOwner && plrOwner->isInCombat())
                     {
-                        if (CAST_PLR(owner)->getAttackerForHelper() && CAST_PLR(owner)->getAttackerForHelper()->GetEntry() == GHOSTS)
-                        {
-                            AttackStart(CAST_PLR(owner)->getAttackerForHelper());
-                        }
+                        if (plrOwner->getAttackerForHelper() && plrOwner->getAttackerForHelper()->GetEntry() == GHOSTS)
+                            AttackStart(plrOwner->getAttackerForHelper());
                         else
-                        {
                             FindMinions(owner);
-                        }
                     }
                 }
             }
@@ -994,9 +991,9 @@
             SetDespawnAtFar(false);
         }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
-            switch (i)
+            switch (waypointId)
             {
                 case 1:
                     if (Unit* car = Unit::GetCreature(*me, carGUID))
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/ScarletEnclave/chapter2.cpp
--- a/src/server/scripts/EasternKingdoms/ScarletEnclave/chapter2.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/ScarletEnclave/chapter2.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -239,9 +239,9 @@
             }
         }
 
-        void WaypointReached(uint32 uiPointId)
+        void WaypointReached(uint32 waypointId)
         {
-            switch (uiPointId)
+            switch (waypointId)
             {
                 case 0:
                     DoScriptText(SAY_BREAKOUT1, me);
@@ -277,9 +277,7 @@
         void JustSummoned(Creature* summoned)
         {
             if (Player* player = GetPlayerForEscort())
-            {
                 summoned->AI()->AttackStart(player);
-            }
 
             if (summoned->GetEntry() == NPC_HIGH_INQUISITOR_VALROTH)
                 m_uiValrothGUID = summoned->GetGUID();
@@ -629,48 +627,48 @@
             me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
         }
 
-        bool MeetQuestCondition(Unit* player)
+        bool MeetQuestCondition(Player* player)
         {
             switch (me->GetEntry())
             {
                 case 29061:                                     // Ellen Stanbridge
-                    if (CAST_PLR(player)->GetQuestStatus(12742) == QUEST_STATUS_INCOMPLETE)
+                    if (player->GetQuestStatus(12742) == QUEST_STATUS_INCOMPLETE)
                         return true;
                     break;
                 case 29072:                                     // Kug Ironjaw
-                    if (CAST_PLR(player)->GetQuestStatus(12748) == QUEST_STATUS_INCOMPLETE)
+                    if (player->GetQuestStatus(12748) == QUEST_STATUS_INCOMPLETE)
                         return true;
                     break;
                 case 29067:                                     // Donovan Pulfrost
-                    if (CAST_PLR(player)->GetQuestStatus(12744) == QUEST_STATUS_INCOMPLETE)
+                    if (player->GetQuestStatus(12744) == QUEST_STATUS_INCOMPLETE)
                         return true;
                     break;
                 case 29065:                                     // Yazmina Oakenthorn
-                    if (CAST_PLR(player)->GetQuestStatus(12743) == QUEST_STATUS_INCOMPLETE)
+                    if (player->GetQuestStatus(12743) == QUEST_STATUS_INCOMPLETE)
                         return true;
                     break;
                 case 29071:                                     // Antoine Brack
-                    if (CAST_PLR(player)->GetQuestStatus(12750) == QUEST_STATUS_INCOMPLETE)
+                    if (player->GetQuestStatus(12750) == QUEST_STATUS_INCOMPLETE)
                         return true;
                     break;
                 case 29032:                                     // Malar Bravehorn
-                    if (CAST_PLR(player)->GetQuestStatus(12739) == QUEST_STATUS_INCOMPLETE)
+                    if (player->GetQuestStatus(12739) == QUEST_STATUS_INCOMPLETE)
                         return true;
                     break;
                 case 29068:                                     // Goby Blastenheimer
-                    if (CAST_PLR(player)->GetQuestStatus(12745) == QUEST_STATUS_INCOMPLETE)
+                    if (player->GetQuestStatus(12745) == QUEST_STATUS_INCOMPLETE)
                         return true;
                     break;
                 case 29073:                                     // Iggy Darktusk
-                    if (CAST_PLR(player)->GetQuestStatus(12749) == QUEST_STATUS_INCOMPLETE)
+                    if (player->GetQuestStatus(12749) == QUEST_STATUS_INCOMPLETE)
                         return true;
                     break;
                 case 29074:                                     // Lady Eonys
-                    if (CAST_PLR(player)->GetQuestStatus(12747) == QUEST_STATUS_INCOMPLETE)
+                    if (player->GetQuestStatus(12747) == QUEST_STATUS_INCOMPLETE)
                         return true;
                     break;
                 case 29070:                                     // Valok the Righteous
-                    if (CAST_PLR(player)->GetQuestStatus(12746) == QUEST_STATUS_INCOMPLETE)
+                    if (player->GetQuestStatus(12746) == QUEST_STATUS_INCOMPLETE)
                         return true;
                     break;
             }
@@ -683,7 +681,7 @@
             if (PlayerGUID || who->GetTypeId() != TYPEID_PLAYER || !who->IsWithinDist(me, INTERACTION_DISTANCE))
                 return;
 
-            if (MeetQuestCondition(who))
+            if (MeetQuestCondition(who->ToPlayer()))
                 PlayerGUID = who->GetGUID();
         }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/ScarletEnclave/chapter5.cpp
--- a/src/server/scripts/EasternKingdoms/ScarletEnclave/chapter5.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/ScarletEnclave/chapter5.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -497,9 +497,9 @@
             SetEscortPaused(bOnHold);
         }
 
-        void WaypointReached(uint32 wpId)
+        void WaypointReached(uint32 waypointId)
         {
-            switch (wpId)
+            switch (waypointId)
             {
                 case 0:
                     me->SetWalk(false);
@@ -507,7 +507,6 @@
                     break;
                 case 1:
                     SetHoldState(true);
-
                     SpawnNPC();
                     if (Creature* temp = Unit::GetCreature(*me, uiKorfaxGUID))
                         DoScriptText(SAY_LIGHT_OF_DAWN07, temp);
@@ -1011,8 +1010,7 @@
 
                                 if (fLichPositionX && fLichPositionY)
                                 {
-                                    Unit* temp;
-                                    temp = me->SummonCreature(NPC_DEFENDER_OF_THE_LIGHT, LightofDawnLoc[0].x+rand()%10, LightofDawnLoc[0].y+rand()%10, LightofDawnLoc[0].z, 0, TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN, 10000);
+                                    Unit* temp = me->SummonCreature(NPC_DEFENDER_OF_THE_LIGHT, LightofDawnLoc[0].x+rand()%10, LightofDawnLoc[0].y+rand()%10, LightofDawnLoc[0].z, 0, TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN, 10000);
                                     temp->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_STATE_ATTACK_UNARMED);
                                     temp->SetWalk(false);
                                     temp->SetSpeed(MOVE_RUN, 2.0f);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/ScarletMonastery/boss_headless_horseman.cpp
--- a/src/server/scripts/EasternKingdoms/ScarletMonastery/boss_headless_horseman.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/ScarletMonastery/boss_headless_horseman.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -348,7 +348,7 @@
                     if (wait <= diff)
                     {
                         die = false;
-                        if (Unit* body = Unit::GetUnit((*me), bodyGUID))
+                        if (Unit* body = Unit::GetUnit(*me, bodyGUID))
                             body->Kill(body);
                         me->Kill(me);
                     }
@@ -475,7 +475,7 @@
                     wp_reached = false;
                     me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
                     SaySound(SAY_ENTRANCE);
-                    if (Unit* player = Unit::GetUnit((*me), PlayerGUID))
+                    if (Unit* player = Unit::GetUnit(*me, PlayerGUID))
                         DoStartMovement(player);
                     break;
                 }
@@ -586,7 +586,7 @@
                 std::list<HostileReference*>::const_iterator itr;
                 for (itr = caster->getThreatManager().getThreatList().begin(); itr != caster->getThreatManager().getThreatList().end(); ++itr)
                 {
-                    Unit* unit = Unit::GetUnit((*me), (*itr)->getUnitGuid());
+                    Unit* unit = Unit::GetUnit(*me, (*itr)->getUnitGuid());
                     if (unit && unit->isAlive() && unit != caster)
                         me->AddThreat(unit, caster->getThreatManager().getThreat(unit));
                 }
@@ -606,7 +606,7 @@
                 if (!headGUID)
                     headGUID = DoSpawnCreature(HEAD, float(rand()%6), float(rand()%6), 0, 0, TEMPSUMMON_DEAD_DESPAWN, 0)->GetGUID();
 
-                Unit* Head = Unit::GetUnit((*me), headGUID);
+                Unit* Head = Unit::GetUnit(*me, headGUID);
                 if (Head && Head->isAlive())
                 {
                     Head->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
@@ -817,7 +817,7 @@
             if (!debuffGUID)
                 return;
 
-            Unit* debuff = Unit::GetUnit((*me), debuffGUID);
+            Unit* debuff = Unit::GetUnit(*me, debuffGUID);
             if (debuff)
             {
                 debuff->SetVisible(false);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/ScarletMonastery/boss_herod.cpp
--- a/src/server/scripts/EasternKingdoms/ScarletMonastery/boss_herod.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/ScarletMonastery/boss_herod.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -152,7 +152,12 @@
         uint32 Start_Timer;
 
         void Reset() {}
-        void WaypointReached(uint32 /*point*/) {}
+
+        void WaypointReached(uint32 /*waypointId*/)
+        {
+
+        }
+
         void EnterCombat(Unit* /*who*/) {}
 
         void UpdateAI(const uint32 diff)
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/ScarletMonastery/boss_high_inquisitor_fairbanks.cpp
--- a/src/server/scripts/EasternKingdoms/ScarletMonastery/boss_high_inquisitor_fairbanks.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/ScarletMonastery/boss_high_inquisitor_fairbanks.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -66,9 +66,15 @@
             Sleep_Timer = 30000;
             Dispel_Timer = 20000;
             PowerWordShield = false;
+            me->SetStandState(UNIT_STAND_STATE_DEAD);
+            me->SetUInt32Value(UNIT_FIELD_BYTES_1, 7);
         }
 
-        void EnterCombat(Unit* /*who*/) {}
+        void EnterCombat(Unit* /*who*/)
+        {
+            me->SetStandState(UNIT_STAND_STATE_STAND);
+            me->SetUInt32Value(UNIT_FIELD_BYTES_1, 0);
+        }
 
         void UpdateAI(const uint32 diff)
         {
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/ScarletMonastery/boss_interrogator_vishas.cpp
--- a/src/server/scripts/EasternKingdoms/ScarletMonastery/boss_interrogator_vishas.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/ScarletMonastery/boss_interrogator_vishas.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -78,7 +78,7 @@
             DoScriptText(SAY_KILL, me);
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (!instance)
                 return;
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/ScarletMonastery/boss_mograine_and_whitemane.cpp
--- a/src/server/scripts/EasternKingdoms/ScarletMonastery/boss_mograine_and_whitemane.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/ScarletMonastery/boss_mograine_and_whitemane.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -132,7 +132,7 @@
                 return;
 
             //On first death, fake death and open door, as well as initiate whitemane if exist
-            if (Unit* Whitemane = Unit::GetUnit((*me), instance->GetData64(DATA_WHITEMANE)))
+            if (Unit* Whitemane = Unit::GetUnit(*me, instance->GetData64(DATA_WHITEMANE)))
             {
                 instance->SetData(TYPE_MOGRAINE_AND_WHITE_EVENT, IN_PROGRESS);
 
@@ -181,7 +181,7 @@
             if (_bHasDied && !_bHeal && instance && instance->GetData(TYPE_MOGRAINE_AND_WHITE_EVENT) == SPECIAL)
             {
                 //On ressurection, stop fake death and heal whitemane and resume fight
-                if (Unit* Whitemane = Unit::GetUnit((*me), instance->GetData64(DATA_WHITEMANE)))
+                if (Unit* Whitemane = Unit::GetUnit(*me, instance->GetData64(DATA_WHITEMANE)))
                 {
                     me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
                     me->SetStandState(UNIT_STAND_STATE_STAND);
@@ -292,7 +292,7 @@
                 //When casting resuruction make sure to delay so on rez when reinstate battle deepsleep runs out
                 if (instance && Wait_Timer <= diff)
                 {
-                    if (Unit* Mograine = Unit::GetUnit((*me), instance->GetData64(DATA_MOGRAINE)))
+                    if (Unit* Mograine = Unit::GetUnit(*me, instance->GetData64(DATA_MOGRAINE)))
                     {
                         DoCast(Mograine, SPELL_SCARLETRESURRECTION);
                         DoScriptText(SAY_WH_RESSURECT, me);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/ShadowfangKeep/shadowfang_keep.cpp
--- a/src/server/scripts/EasternKingdoms/ShadowfangKeep/shadowfang_keep.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/ShadowfangKeep/shadowfang_keep.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -99,9 +99,9 @@
         InstanceScript* instance;
         uint32 uiNpcEntry;
 
-        void WaypointReached(uint32 uiPoint)
+        void WaypointReached(uint32 waypointId)
         {
-            switch (uiPoint)
+            switch (waypointId)
             {
                 case 0:
                     if (uiNpcEntry == NPC_ASH)
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/Stratholme/boss_baron_rivendare.cpp
--- a/src/server/scripts/EasternKingdoms/Stratholme/boss_baron_rivendare.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/Stratholme/boss_baron_rivendare.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -126,7 +126,7 @@
                 summoned->AI()->AttackStart(target);
         }
 
-         void JustDied(Unit* /*Killer*/)
+         void JustDied(Unit* /*killer*/)
          {
              if (instance)
                  instance->SetData(TYPE_BARON, DONE);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/Stratholme/boss_baroness_anastari.cpp
--- a/src/server/scripts/EasternKingdoms/Stratholme/boss_baroness_anastari.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/Stratholme/boss_baroness_anastari.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -67,7 +67,7 @@
         {
         }
 
-         void JustDied(Unit* /*Killer*/)
+         void JustDied(Unit* /*killer*/)
          {
              if (instance)
                  instance->SetData(TYPE_BARONESS, IN_PROGRESS);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/Stratholme/boss_cannon_master_willey.cpp
--- a/src/server/scripts/EasternKingdoms/Stratholme/boss_cannon_master_willey.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/Stratholme/boss_cannon_master_willey.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -103,7 +103,7 @@
             SummonRifleman_Timer = 15000;
         }
 
-        void JustDied(Unit* /*Victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             me->SummonCreature(11054, ADD_1X, ADD_1Y, ADD_1Z, ADD_1O, TEMPSUMMON_TIMED_DESPAWN, 240000);
             me->SummonCreature(11054, ADD_2X, ADD_2Y, ADD_2Z, ADD_2O, TEMPSUMMON_TIMED_DESPAWN, 240000);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/Stratholme/boss_dathrohan_balnazzar.cpp
--- a/src/server/scripts/EasternKingdoms/Stratholme/boss_dathrohan_balnazzar.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/Stratholme/boss_dathrohan_balnazzar.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -105,7 +105,7 @@
                 me->UpdateEntry(NPC_DATHROHAN);
         }
 
-        void JustDied(Unit* /*Victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             static uint32 uiCount = sizeof(m_aSummonPoint)/sizeof(SummonDef);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/Stratholme/boss_magistrate_barthilas.cpp
--- a/src/server/scripts/EasternKingdoms/Stratholme/boss_magistrate_barthilas.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/Stratholme/boss_magistrate_barthilas.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -75,7 +75,7 @@
             ScriptedAI::MoveInLineOfSight(who);
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             me->SetDisplayId(MODEL_HUMAN);
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/Stratholme/boss_maleki_the_pallid.cpp
--- a/src/server/scripts/EasternKingdoms/Stratholme/boss_maleki_the_pallid.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/Stratholme/boss_maleki_the_pallid.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -65,7 +65,7 @@
         {
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (instance)
                 instance->SetData(TYPE_PALLID, IN_PROGRESS);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/Stratholme/boss_nerubenkan.cpp
--- a/src/server/scripts/EasternKingdoms/Stratholme/boss_nerubenkan.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/Stratholme/boss_nerubenkan.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -67,7 +67,7 @@
         {
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (instance)
                 instance->SetData(TYPE_NERUB, IN_PROGRESS);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/Stratholme/boss_order_of_silver_hand.cpp
--- a/src/server/scripts/EasternKingdoms/Stratholme/boss_order_of_silver_hand.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/Stratholme/boss_order_of_silver_hand.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -96,30 +96,34 @@
         {
         }
 
-        void JustDied(Unit* Killer)
+        void JustDied(Unit* killer)
         {
-            if (instance)
+            if (!instance)
+                return;
+
+            switch (me->GetEntry())
             {
-                switch (me->GetEntry())
-                {
-                    case SH_AELMAR:
-                        instance->SetData(TYPE_SH_AELMAR, 2);
-                        break;
-                    case SH_CATHELA:
-                        instance->SetData(TYPE_SH_CATHELA, 2);
-                        break;
-                    case SH_GREGOR:
-                        instance->SetData(TYPE_SH_GREGOR, 2);
-                        break;
-                    case SH_NEMAS:
-                        instance->SetData(TYPE_SH_NEMAS, 2);
-                        break;
-                    case SH_VICAR:
-                        instance->SetData(TYPE_SH_VICAR, 2);
-                        break;
-                }
-                if (instance->GetData(TYPE_SH_QUEST) && Killer->GetTypeId() == TYPEID_PLAYER)
-                    CAST_PLR(Killer)->KilledMonsterCredit(SH_QUEST_CREDIT, 0);
+                case SH_AELMAR:
+                    instance->SetData(TYPE_SH_AELMAR, 2);
+                    break;
+                case SH_CATHELA:
+                    instance->SetData(TYPE_SH_CATHELA, 2);
+                    break;
+                case SH_GREGOR:
+                    instance->SetData(TYPE_SH_GREGOR, 2);
+                    break;
+                case SH_NEMAS:
+                    instance->SetData(TYPE_SH_NEMAS, 2);
+                    break;
+                case SH_VICAR:
+                    instance->SetData(TYPE_SH_VICAR, 2);
+                    break;
+            }
+
+            if (instance->GetData(TYPE_SH_QUEST))
+            {
+                if (Player* player = killer->ToPlayer())
+                    player->KilledMonsterCredit(SH_QUEST_CREDIT, 0);
             }
         }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/Stratholme/boss_ramstein_the_gorger.cpp
--- a/src/server/scripts/EasternKingdoms/Stratholme/boss_ramstein_the_gorger.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/Stratholme/boss_ramstein_the_gorger.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -63,7 +63,7 @@
         {
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             for (uint8 i = 0; i < 30; ++i)
             {
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/Stratholme/stratholme.cpp
--- a/src/server/scripts/EasternKingdoms/Stratholme/stratholme.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/Stratholme/stratholme.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -165,7 +165,7 @@
             summoned->CastSpell(summoned, SPELL_SOUL_FREED, false);
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (Tagged)
                 me->SummonCreature(ENTRY_FREED, me->GetPositionX(), me->GetPositionY(), me->GetPositionZ(), me->GetOrientation(), TEMPSUMMON_TIMED_DESPAWN, 300000);
@@ -230,7 +230,7 @@
                 Tagged = true;
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (Tagged)
             {
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/SunwellPlateau/boss_brutallus.cpp
--- a/src/server/scripts/EasternKingdoms/SunwellPlateau/boss_brutallus.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/SunwellPlateau/boss_brutallus.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -132,7 +132,7 @@
             DoScriptText(RAND(YELL_KILL1, YELL_KILL2, YELL_KILL3), me);
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(YELL_DEATH, me);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/SunwellPlateau/boss_eredar_twins.cpp
--- a/src/server/scripts/EasternKingdoms/SunwellPlateau/boss_eredar_twins.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/SunwellPlateau/boss_eredar_twins.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -120,7 +120,7 @@
 
             if (instance)
             {
-                Unit* Temp =  Unit::GetUnit((*me), instance->GetData64(DATA_ALYTHESS));
+                Unit* Temp =  Unit::GetUnit(*me, instance->GetData64(DATA_ALYTHESS));
                 if (Temp)
                 {
                     if (Temp->isDead())
@@ -152,7 +152,7 @@
 
             if (instance)
             {
-                Unit* Temp =  Unit::GetUnit((*me), instance->GetData64(DATA_ALYTHESS));
+                Unit* Temp =  Unit::GetUnit(*me, instance->GetData64(DATA_ALYTHESS));
                 if (Temp && Temp->isAlive() && !(Temp->getVictim()))
                     CAST_CRE(Temp)->AI()->AttackStart(who);
             }
@@ -167,7 +167,7 @@
                 DoScriptText(RAND(YELL_SAC_KILL_1, YELL_SAC_KILL_2), me);
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             // only if ALY death
             if (SisterDeath)
@@ -231,7 +231,7 @@
                 if (instance)
                 {
                     Unit* Temp = NULL;
-                    Temp = Unit::GetUnit((*me), instance->GetData64(DATA_ALYTHESS));
+                    Temp = Unit::GetUnit(*me, instance->GetData64(DATA_ALYTHESS));
                     if (Temp && Temp->isDead())
                     {
                         DoScriptText(YELL_SISTER_ALYTHESS_DEAD, me);
@@ -382,7 +382,7 @@
 
             if (instance)
             {
-                Unit* Temp =  Unit::GetUnit((*me), instance->GetData64(DATA_SACROLASH));
+                Unit* Temp =  Unit::GetUnit(*me, instance->GetData64(DATA_SACROLASH));
                 if (Temp)
                 {
                     if (Temp->isDead())
@@ -415,7 +415,7 @@
 
             if (instance)
             {
-                Unit* Temp =  Unit::GetUnit((*me), instance->GetData64(DATA_SACROLASH));
+                Unit* Temp =  Unit::GetUnit(*me, instance->GetData64(DATA_SACROLASH));
                 if (Temp && Temp->isAlive() && !(Temp->getVictim()))
                     CAST_CRE(Temp)->AI()->AttackStart(who);
             }
@@ -462,7 +462,7 @@
             }
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (SisterDeath)
             {
@@ -567,7 +567,7 @@
                 if (instance)
                 {
                     Unit* Temp = NULL;
-                    Temp = Unit::GetUnit((*me), instance->GetData64(DATA_SACROLASH));
+                    Temp = Unit::GetUnit(*me, instance->GetData64(DATA_SACROLASH));
                     if (Temp && Temp->isDead())
                     {
                         DoScriptText(YELL_SISTER_SACROLASH_DEAD, me);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/SunwellPlateau/boss_felmyst.cpp
--- a/src/server/scripts/EasternKingdoms/SunwellPlateau/boss_felmyst.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/SunwellPlateau/boss_felmyst.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -184,7 +184,7 @@
             DoScriptText(YELL_BIRTH, me);
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(YELL_DEATH, me);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/SunwellPlateau/boss_kiljaeden.cpp
--- a/src/server/scripts/EasternKingdoms/SunwellPlateau/boss_kiljaeden.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/SunwellPlateau/boss_kiljaeden.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -434,8 +434,9 @@
         {
             phase = PHASE_DECEIVERS;
 
-            if (Creature* pKalecKJ = Unit::GetCreature((*me), instance->GetData64(DATA_KALECGOS_KJ)))
-                CAST_AI(boss_kalecgos_kj::boss_kalecgos_kjAI, pKalecKJ->AI())->ResetOrbs();
+            if (instance)
+                if (Creature* pKalecKJ = Unit::GetCreature((*me), instance->GetData64(DATA_KALECGOS_KJ)))
+                    CAST_AI(boss_kalecgos_kj::boss_kalecgos_kjAI, pKalecKJ->AI())->ResetOrbs();
             deceiverDeathCount = 0;
             bSummonedDeceivers = false;
             bKiljaedenDeath = false;
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/ZulAman/boss_akilzon.cpp
--- a/src/server/scripts/EasternKingdoms/ZulAman/boss_akilzon.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/ZulAman/boss_akilzon.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -131,7 +131,7 @@
                     instance->SetData(DATA_AKILZONEVENT, IN_PROGRESS);
             }
 
-            void JustDied(Unit* /*Killer*/)
+            void JustDied(Unit* /*killer*/)
             {
                 me->MonsterYell(SAY_ONDEATH, LANG_UNIVERSAL, 0);
                 DoPlaySoundToSet(me, SOUND_ONDEATH);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/ZulAman/boss_halazzi.cpp
--- a/src/server/scripts/EasternKingdoms/ZulAman/boss_halazzi.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/ZulAman/boss_halazzi.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -324,7 +324,7 @@
                 }
             }
 
-            void JustDied(Unit* /*Killer*/)
+            void JustDied(Unit* /*killer*/)
             {
                 if (instance)
                     instance->SetData(DATA_HALAZZIEVENT, DONE);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/ZulAman/boss_hexlord.cpp
--- a/src/server/scripts/EasternKingdoms/ZulAman/boss_hexlord.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/ZulAman/boss_hexlord.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -267,7 +267,7 @@
 
                 for (uint8 i = 0; i < 4; ++i)
                 {
-                    Unit* Temp = Unit::GetUnit((*me), AddGUID[i]);
+                    Unit* Temp = Unit::GetUnit(*me, AddGUID[i]);
                     if (Temp && Temp->isAlive())
                         CAST_CRE(Temp)->AI()->AttackStart(me->getVictim());
                     else
@@ -293,7 +293,7 @@
                 }
             }
 
-            void JustDied(Unit* /*victim*/)
+            void JustDied(Unit* /*killer*/)
             {
                 if (instance)
                     instance->SetData(DATA_HEXLORDEVENT, DONE);
@@ -301,9 +301,9 @@
                 me->MonsterYell(YELL_DEATH, LANG_UNIVERSAL, 0);
                 DoPlaySoundToSet(me, SOUND_YELL_DEATH);
 
-                for (uint8 i = 0; i < 4 ; ++i)
+                for (uint8 i = 0; i < 4; ++i)
                 {
-                    Unit* Temp = Unit::GetUnit((*me), AddGUID[i]);
+                    Unit* Temp = Unit::GetUnit(*me, AddGUID[i]);
                     if (Temp && Temp->isAlive())
                         Temp->DealDamage(Temp, Temp->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
                 }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/ZulAman/boss_janalai.cpp
--- a/src/server/scripts/EasternKingdoms/ZulAman/boss_janalai.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/ZulAman/boss_janalai.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -159,7 +159,7 @@
                 HatchAllEggs(1);
             }
 
-            void JustDied(Unit* /*Killer*/)
+            void JustDied(Unit* /*killer*/)
             {
                 DoScriptText(SAY_DEATH, me);
 
@@ -289,7 +289,7 @@
             {
                 if (BombCount < 40)
                 {
-                    if (Unit* FireBomb = Unit::GetUnit((*me), FireBombGUIDs[BombCount]))
+                    if (Unit* FireBomb = Unit::GetUnit(*me, FireBombGUIDs[BombCount]))
                     {
                         FireBomb->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
                         DoCast(FireBomb, SPELL_FIRE_BOMB_THROW, true);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/ZulAman/boss_nalorakk.cpp
--- a/src/server/scripts/EasternKingdoms/ZulAman/boss_nalorakk.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/ZulAman/boss_nalorakk.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -276,7 +276,7 @@
                 DoZoneInCombat();
             }
 
-            void JustDied(Unit* /*Killer*/)
+            void JustDied(Unit* /*killer*/)
             {
                 if (instance)
                     instance->SetData(DATA_NALORAKKEVENT, DONE);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/ZulAman/boss_zuljin.cpp
--- a/src/server/scripts/EasternKingdoms/ZulAman/boss_zuljin.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/ZulAman/boss_zuljin.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -252,7 +252,7 @@
                 }
             }
 
-            void JustDied(Unit* /*Killer*/)
+            void JustDied(Unit* /*killer*/)
             {
                 if (instance)
                     instance->SetData(DATA_ZULJINEVENT, DONE);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/ZulAman/zulaman.cpp
--- a/src/server/scripts/EasternKingdoms/ZulAman/zulaman.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/ZulAman/zulaman.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -136,7 +136,7 @@
 
             void EnterCombat(Unit* /*who*/) {}
 
-            void JustDied(Unit* /*who*/)
+            void JustDied(Unit* /*killer*/)
             {
                 Player* player = Unit::GetPlayer(*me, PlayerGUID);
                 if (player)
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/ZulGurub/boss_gahzranka.cpp
--- a/src/server/scripts/EasternKingdoms/ZulGurub/boss_gahzranka.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/ZulGurub/boss_gahzranka.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -32,15 +32,11 @@
 class boss_gahzranka : public CreatureScript
 {
     public:
-
-        boss_gahzranka()
-            : CreatureScript("boss_gahzranka")
-        {
-        }
+        boss_gahzranka() : CreatureScript("boss_gahzranka") { }
 
         struct boss_gahzrankaAI : public ScriptedAI
         {
-            boss_gahzrankaAI(Creature* creature) : ScriptedAI(creature) {}
+            boss_gahzrankaAI(Creature* creature) : ScriptedAI(creature) { }
             uint32 Frostbreath_Timer;
             uint32 MassiveGeyser_Timer;
             uint32 Slam_Timer;
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/ZulGurub/boss_grilek.cpp
--- a/src/server/scripts/EasternKingdoms/ZulGurub/boss_grilek.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/ZulGurub/boss_grilek.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -32,15 +32,11 @@
 class boss_grilek : public CreatureScript
 {
     public:
-
-        boss_grilek()
-            : CreatureScript("boss_grilek")
-        {
-        }
+        boss_grilek() : CreatureScript("boss_grilek") { }
 
         struct boss_grilekAI : public ScriptedAI
         {
-            boss_grilekAI(Creature* creature) : ScriptedAI(creature) {}
+            boss_grilekAI(Creature* creature) : ScriptedAI(creature) { }
 
             uint32 Avartar_Timer;
             uint32 GroundTremor_Timer;
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/ZulGurub/boss_jeklik.cpp
--- a/src/server/scripts/EasternKingdoms/ZulGurub/boss_jeklik.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/ZulGurub/boss_jeklik.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -94,7 +94,7 @@
                 DoCast(me, SPELL_BAT_FORM);
             }
 
-            void JustDied(Unit* /*Killer*/)
+            void JustDied(Unit* /*killer*/)
             {
                 DoScriptText(SAY_DEATH, me);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/ZulGurub/boss_jindo.cpp
--- a/src/server/scripts/EasternKingdoms/ZulGurub/boss_jindo.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/ZulGurub/boss_jindo.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -212,7 +212,7 @@
                 {
                     if (instance)
                     {
-                        Unit* pJindo = Unit::GetUnit((*me), instance->GetData64(DATA_JINDO));
+                        Unit* pJindo = Unit::GetUnit(*me, instance->GetData64(DATA_JINDO));
                         if (pJindo)
                             DoCast(pJindo, SPELL_HEAL);
                     }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/ZulGurub/boss_mandokir.cpp
--- a/src/server/scripts/EasternKingdoms/ZulGurub/boss_mandokir.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/ZulGurub/boss_mandokir.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -309,7 +309,7 @@
 
             void EnterCombat(Unit* /*who*/) {}
 
-            void JustDied(Unit* /*Killer*/)
+            void JustDied(Unit* /*killer*/)
             {
                 if (instance)
                     instance->SetData(DATA_OHGAN, DONE);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/ZulGurub/boss_marli.cpp
--- a/src/server/scripts/EasternKingdoms/ZulGurub/boss_marli.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/ZulGurub/boss_marli.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -88,7 +88,7 @@
                 DoScriptText(SAY_AGGRO, me);
             }
 
-            void JustDied(Unit* /*Killer*/)
+            void JustDied(Unit* /*killer*/)
             {
                 DoScriptText(SAY_DEATH, me);
                 if (instance)
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/ZulGurub/boss_thekal.cpp
--- a/src/server/scripts/EasternKingdoms/ZulGurub/boss_thekal.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/ZulGurub/boss_thekal.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -108,7 +108,7 @@
                 DoScriptText(SAY_AGGRO, me);
             }
 
-            void JustDied(Unit* /*Killer*/)
+            void JustDied(Unit* /*killer*/)
             {
                 DoScriptText(SAY_DEATH, me);
                 if (instance)
@@ -134,7 +134,7 @@
                             if (instance->GetData(DATA_LORKHAN) == SPECIAL)
                             {
                                 //Resurrect LorKhan
-                                if (Unit* pLorKhan = Unit::GetUnit((*me), instance->GetData64(DATA_LORKHAN)))
+                                if (Unit* pLorKhan = Unit::GetUnit(*me, instance->GetData64(DATA_LORKHAN)))
                                 {
                                     pLorKhan->SetUInt32Value(UNIT_FIELD_BYTES_1, 0);
                                     pLorKhan->setFaction(14);
@@ -148,7 +148,7 @@
                             if (instance->GetData(DATA_ZATH) == SPECIAL)
                             {
                                 //Resurrect Zath
-                                Unit* pZath = Unit::GetUnit((*me), instance->GetData64(DATA_ZATH));
+                                Unit* pZath = Unit::GetUnit(*me, instance->GetData64(DATA_ZATH));
                                 if (pZath)
                                 {
                                     pZath->SetUInt32Value(UNIT_FIELD_BYTES_1, 0);
@@ -337,8 +337,8 @@
                 {
                     if (instance)
                     {
-                        Unit* pThekal = Unit::GetUnit((*me), instance->GetData64(DATA_THEKAL));
-                        Unit* pZath = Unit::GetUnit((*me), instance->GetData64(DATA_ZATH));
+                        Unit* pThekal = Unit::GetUnit(*me, instance->GetData64(DATA_THEKAL));
+                        Unit* pZath = Unit::GetUnit(*me, instance->GetData64(DATA_ZATH));
 
                         if (!pThekal || !pZath)
                             return;
@@ -374,7 +374,7 @@
                         if (instance->GetData(DATA_THEKAL) == SPECIAL)
                         {
                             //Resurrect Thekal
-                            if (Unit* pThekal = Unit::GetUnit((*me), instance->GetData64(DATA_THEKAL)))
+                            if (Unit* pThekal = Unit::GetUnit(*me, instance->GetData64(DATA_THEKAL)))
                             {
                                 pThekal->SetUInt32Value(UNIT_FIELD_BYTES_1, 0);
                                 pThekal->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
@@ -386,7 +386,7 @@
                         if (instance->GetData(DATA_ZATH) == SPECIAL)
                         {
                             //Resurrect Zath
-                            if (Unit* pZath = Unit::GetUnit((*me), instance->GetData64(DATA_ZATH)))
+                            if (Unit* pZath = Unit::GetUnit(*me, instance->GetData64(DATA_ZATH)))
                             {
                                 pZath->SetUInt32Value(UNIT_FIELD_BYTES_1, 0);
                                 pZath->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
@@ -527,7 +527,7 @@
                         if (instance->GetData(DATA_LORKHAN) == SPECIAL)
                         {
                             //Resurrect LorKhan
-                            if (Unit* pLorKhan = Unit::GetUnit((*me), instance->GetData64(DATA_LORKHAN)))
+                            if (Unit* pLorKhan = Unit::GetUnit(*me, instance->GetData64(DATA_LORKHAN)))
                             {
                                 pLorKhan->SetUInt32Value(UNIT_FIELD_BYTES_1, 0);
                                 pLorKhan->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
@@ -539,7 +539,7 @@
                         if (instance->GetData(DATA_THEKAL) == SPECIAL)
                         {
                             //Resurrect Thekal
-                            if (Unit* pThekal = Unit::GetUnit((*me), instance->GetData64(DATA_THEKAL)))
+                            if (Unit* pThekal = Unit::GetUnit(*me, instance->GetData64(DATA_THEKAL)))
                             {
                                 pThekal->SetUInt32Value(UNIT_FIELD_BYTES_1, 0);
                                 pThekal->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/ZulGurub/boss_venoxis.cpp
--- a/src/server/scripts/EasternKingdoms/ZulGurub/boss_venoxis.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/ZulGurub/boss_venoxis.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -198,7 +198,7 @@
                         case EVENT_HOLY_NOVA:
                             _inMeleeRange = 0;
 
-                            for (uint8 i = 0; i < 10 ; ++i)
+                            for (uint8 i = 0; i < 10; ++i)
                             {
                                 if (Unit* target = SelectTarget(SELECT_TARGET_TOPAGGRO, i))
                                     // check if target is within melee-distance
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/arathi_highlands.cpp
--- a/src/server/scripts/EasternKingdoms/arathi_highlands.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/arathi_highlands.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -64,44 +64,42 @@
         {
             npc_professor_phizzlethorpeAI(Creature* creature) : npc_escortAI(creature) {}
 
-            void WaypointReached(uint32 uiPointId)
+            void WaypointReached(uint32 waypointId)
             {
                 Player* player = GetPlayerForEscort();
-
                 if (!player)
                     return;
 
-                switch (uiPointId)
+                switch (waypointId)
                 {
-                case 4:
-                    Talk(SAY_PROGRESS_2, player->GetGUID());
-                    break;
-                case 5:
-                    Talk(SAY_PROGRESS_3, player->GetGUID());
-                    break;
-                case 8:
-                    Talk(EMOTE_PROGRESS_4);
-                    break;
-               case 9:
-                    me->SummonCreature(MOB_VENGEFUL_SURGE, -2052.96f, -2142.49f, 20.15f, 1.0f, TEMPSUMMON_CORPSE_DESPAWN, 0);
-                    me->SummonCreature(MOB_VENGEFUL_SURGE, -2052.96f, -2142.49f, 20.15f, 1.0f, TEMPSUMMON_CORPSE_DESPAWN, 0);
-                    break;
-                case 10:
-                    Talk(SAY_PROGRESS_5, player->GetGUID());
-                    break;
-                case 11:
-                    Talk(SAY_PROGRESS_6, player->GetGUID());
-                    SetRun();
-                    break;
-                case 19:
-                    Talk(SAY_PROGRESS_7, player->GetGUID());
-                    break;
-                case 20:
-                    Talk(EMOTE_PROGRESS_8);
-                    Talk(SAY_PROGRESS_9, player->GetGUID());
-                    if (player)
-                        CAST_PLR(player)->GroupEventHappens(QUEST_SUNKEN_TREASURE, me);
-                    break;
+                    case 4:
+                        Talk(SAY_PROGRESS_2, player->GetGUID());
+                        break;
+                    case 5:
+                        Talk(SAY_PROGRESS_3, player->GetGUID());
+                        break;
+                    case 8:
+                        Talk(EMOTE_PROGRESS_4);
+                        break;
+                    case 9:
+                        me->SummonCreature(MOB_VENGEFUL_SURGE, -2052.96f, -2142.49f, 20.15f, 1.0f, TEMPSUMMON_CORPSE_DESPAWN, 0);
+                        me->SummonCreature(MOB_VENGEFUL_SURGE, -2052.96f, -2142.49f, 20.15f, 1.0f, TEMPSUMMON_CORPSE_DESPAWN, 0);
+                        break;
+                    case 10:
+                        Talk(SAY_PROGRESS_5, player->GetGUID());
+                        break;
+                    case 11:
+                        Talk(SAY_PROGRESS_6, player->GetGUID());
+                        SetRun();
+                        break;
+                    case 19:
+                        Talk(SAY_PROGRESS_7, player->GetGUID());
+                        break;
+                    case 20:
+                        Talk(EMOTE_PROGRESS_8);
+                        Talk(SAY_PROGRESS_9, player->GetGUID());
+                        player->GroupEventHappens(QUEST_SUNKEN_TREASURE, me);
+                        break;
                 }
             }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/eastern_plaguelands.cpp
--- a/src/server/scripts/EasternKingdoms/eastern_plaguelands.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/eastern_plaguelands.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -32,34 +32,30 @@
 
 #include "ScriptPCH.h"
 
-//id8530 - cannibal ghoul
-//id8531 - gibbering ghoul
-//id8532 - diseased flayer
-
 class mobs_ghoul_flayer : public CreatureScript
 {
 public:
     mobs_ghoul_flayer() : CreatureScript("mobs_ghoul_flayer") { }
 
-    CreatureAI* GetAI(Creature* creature) const
-    {
-        return new mobs_ghoul_flayerAI (creature);
-    }
-
     struct mobs_ghoul_flayerAI : public ScriptedAI
     {
-        mobs_ghoul_flayerAI(Creature* creature) : ScriptedAI(creature) {}
+        mobs_ghoul_flayerAI(Creature* creature) : ScriptedAI(creature) { }
 
         void Reset() {}
 
         void EnterCombat(Unit* /*who*/) {}
 
-        void JustDied(Unit* Killer)
+        void JustDied(Unit* killer)
         {
-            if (Killer->GetTypeId() == TYPEID_PLAYER)
+            if (killer->GetTypeId() == TYPEID_PLAYER)
                 me->SummonCreature(11064, 0.0f, 0.0f, 0.0f, 0.0f, TEMPSUMMON_TIMED_DESPAWN, 60000);
         }
     };
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new mobs_ghoul_flayerAI (creature);
+    }
 };
 
 /*######
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/eversong_woods.cpp
--- a/src/server/scripts/EasternKingdoms/eversong_woods.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/eversong_woods.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -247,7 +247,7 @@
                     CAST_PLR(Killed)->FailQuest(QUEST_SECOND_TRIAL);
         }
 
-        void JustDied(Unit* Killer);
+        void JustDied(Unit* killer);
     };
 };
 
@@ -490,14 +490,14 @@
         {
             if (PlayerGUID)
                 if (Player* player = Unit::GetPlayer(*me, PlayerGUID))
-                    CAST_PLR(player)->FailQuest(QUEST_UNEXPECTED_RESULT);
+                    player->FailQuest(QUEST_UNEXPECTED_RESULT);
         }
 
         void UpdateAI(const uint32 /*diff*/)
         {
             if (KillCount >= 3 && PlayerGUID)
                 if (Player* player = Unit::GetPlayer(*me, PlayerGUID))
-                    CAST_PLR(player)->CompleteQuest(QUEST_UNEXPECTED_RESULT);
+                    player->CompleteQuest(QUEST_UNEXPECTED_RESULT);
 
             if (Summon)
             {
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/ghostlands.cpp
--- a/src/server/scripts/EasternKingdoms/ghostlands.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/ghostlands.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -130,61 +130,61 @@
     {
         npc_ranger_lilathaAI(Creature* creature) : npc_escortAI(creature) {}
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
-
             if (!player)
                 return;
 
-            switch (i)
+            switch (waypointId)
             {
-            case 0:
-                {
-                me->SetUInt32Value(UNIT_FIELD_BYTES_1, 0);
-                if (GameObject* Cage = me->FindNearestGameObject(GO_CAGE, 20))
-                    Cage->SetGoState(GO_STATE_ACTIVE);
-                DoScriptText(SAY_START, me, player);
-                break;
-                }
-            case 5:
-                DoScriptText(SAY_PROGRESS1, me, player);
-            case 11:
-                DoScriptText(SAY_PROGRESS2, me, player);
-                me->SetOrientation(4.762841f);
-                break;
-            case 18:
-                {
-                DoScriptText(SAY_PROGRESS3, me, player);
-                Creature* Summ1 = me->SummonCreature(16342, 7627.083984f, -7532.538086f, 152.128616f, 1.082733f, TEMPSUMMON_DEAD_DESPAWN, 0);
-                Creature* Summ2 = me->SummonCreature(16343, 7620.432129f, -7532.550293f, 152.454865f, 0.827478f, TEMPSUMMON_DEAD_DESPAWN, 0);
-                if (Summ1 && Summ2)
-                {
-                    Summ1->Attack(me, true);
-                    Summ2->Attack(player, true);
-                }
-                me->AI()->AttackStart(Summ1);
-                break;
-                }
-            case 19: me->SetWalk(false);
-                break;
-            case 25: me->SetWalk(true);
-                break;
-            case 30:
-                if (player && player->GetTypeId() == TYPEID_PLAYER)
-                    CAST_PLR(player)->GroupEventHappens(QUEST_ESCAPE_FROM_THE_CATACOMBS, me);
-                break;
-            case 32:
-                me->SetOrientation(2.978281f);
-                DoScriptText(SAY_END1, me, player);
-                break;
-            case 33:
-                me->SetOrientation(5.858011f);
-                DoScriptText(SAY_END2, me, player);
-                Unit* CaptainHelios = me->FindNearestCreature(NPC_CAPTAIN_HELIOS, 50);
-                if (CaptainHelios)
-                    DoScriptText(SAY_CAPTAIN_ANSWER, CaptainHelios, player);
-                break;
+                case 0:
+                    me->SetUInt32Value(UNIT_FIELD_BYTES_1, 0);
+                    if (GameObject* Cage = me->FindNearestGameObject(GO_CAGE, 20))
+                        Cage->SetGoState(GO_STATE_ACTIVE);
+                    DoScriptText(SAY_START, me, player);
+                    break;
+                case 5:
+                    DoScriptText(SAY_PROGRESS1, me, player);
+                    break;
+                case 11:
+                    DoScriptText(SAY_PROGRESS2, me, player);
+                    me->SetOrientation(4.762841f);
+                    break;
+                case 18:
+                    {
+                        DoScriptText(SAY_PROGRESS3, me, player);
+                        Creature* Summ1 = me->SummonCreature(16342, 7627.083984f, -7532.538086f, 152.128616f, 1.082733f, TEMPSUMMON_DEAD_DESPAWN, 0);
+                        Creature* Summ2 = me->SummonCreature(16343, 7620.432129f, -7532.550293f, 152.454865f, 0.827478f, TEMPSUMMON_DEAD_DESPAWN, 0);
+                        if (Summ1 && Summ2)
+                        {
+                            Summ1->Attack(me, true);
+                            Summ2->Attack(player, true);
+                        }
+                        me->AI()->AttackStart(Summ1);
+                    }
+                    break;
+                case 19:
+                    me->SetWalk(false);
+                    break;
+                case 25:
+                    me->SetWalk(true);
+                    break;
+                case 30:
+                    if (player->GetTypeId() == TYPEID_PLAYER)
+                        CAST_PLR(player)->GroupEventHappens(QUEST_ESCAPE_FROM_THE_CATACOMBS, me);
+                    break;
+                case 32:
+                    me->SetOrientation(2.978281f);
+                    DoScriptText(SAY_END1, me, player);
+                    break;
+                case 33:
+                    me->SetOrientation(5.858011f);
+                    DoScriptText(SAY_END2, me, player);
+                    Unit* CaptainHelios = me->FindNearestCreature(NPC_CAPTAIN_HELIOS, 50);
+                    if (CaptainHelios)
+                        DoScriptText(SAY_CAPTAIN_ANSWER, CaptainHelios, player);
+                    break;
             }
         }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/hinterlands.cpp
--- a/src/server/scripts/EasternKingdoms/hinterlands.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/hinterlands.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -87,9 +87,9 @@
 
         void Reset() { }
 
-        void WaypointReached(uint32 uiPointId)
+        void WaypointReached(uint32 waypointId)
         {
-            switch (uiPointId)
+            switch (waypointId)
             {
                 case 26:
                     DoScriptText(SAY_OOX_AMBUSH, me);
@@ -276,14 +276,13 @@
             summoned->GetMotionMaster()->MovePoint(0, m_afAmbushMoveTo[m_iSpawnId].m_fX, m_afAmbushMoveTo[m_iSpawnId].m_fY, m_afAmbushMoveTo[m_iSpawnId].m_fZ);
         }
 
-        void WaypointReached(uint32 uiPointId)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
-
             if (!player)
                 return;
 
-            switch (uiPointId)
+            switch (waypointId)
             {
                 case 1:
                     DoScriptText(SAY_RIN_FREE, me, player);
@@ -314,7 +313,7 @@
                     {
                         m_uiPostEventTimer = 3000;
 
-                        if (Unit* player = GetPlayerForEscort())
+                        if (Player* player = GetPlayerForEscort())
                         {
                             switch (m_uiPostEventCount)
                             {
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/isle_of_queldanas.cpp
--- a/src/server/scripts/EasternKingdoms/isle_of_queldanas.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/isle_of_queldanas.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -129,8 +129,8 @@
                 PlayerGUID = caster->GetGUID();
                 if (PlayerGUID)
                 {
-                    Unit* player = Unit::GetUnit((*me), PlayerGUID);
-                    if (player && CAST_PLR(player)->GetQuestStatus(QUESTG) == QUEST_STATUS_INCOMPLETE)
+                    Player* player = Unit::GetPlayer(*me, PlayerGUID);
+                    if (player && player->GetQuestStatus(QUESTG) == QUEST_STATUS_INCOMPLETE)
                         DoCast(player, 45110, true);
                 }
                 DoCast(me, ENRAGE);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/redridge_mountains.cpp
--- a/src/server/scripts/EasternKingdoms/redridge_mountains.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/redridge_mountains.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -76,17 +76,16 @@
             uiShieldBashTimer  = 8000;
         }
 
-        void WaypointReached(uint32 uiI)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
-
             if (!player)
                 return;
 
-            if (uiI >= 65 && me->GetUnitMovementFlags() == MOVEMENTFLAG_WALKING)
+            if (waypointId >= 65 && me->GetUnitMovementFlags() == MOVEMENTFLAG_WALKING)
                 me->SetWalk(false);
 
-            switch (uiI)
+            switch (waypointId)
             {
                 case 39:
                     SetEscortPaused(true);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/silverpine_forest.cpp
--- a/src/server/scripts/EasternKingdoms/silverpine_forest.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/silverpine_forest.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -66,34 +66,44 @@
     {
         npc_deathstalker_erlandAI(Creature* creature) : npc_escortAI(creature) {}
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
-
             if (!player)
                 return;
 
-            switch (i)
+            switch (waypointId)
             {
-            case 1: DoScriptText(SAY_START, me, player);break;
-            case 13:
-                DoScriptText(SAY_LAST, me, player);
-                player->GroupEventHappens(QUEST_ESCORTING, me); break;
-            case 14: DoScriptText(SAY_THANKS, me, player); break;
-            case 15: {
-                    Unit* Rane = me->FindNearestCreature(NPC_RANE, 20);
-                    if (Rane)
+                case 1:
+                    DoScriptText(SAY_START, me, player);
+                    break;
+                case 13:
+                    DoScriptText(SAY_LAST, me, player);
+                    player->GroupEventHappens(QUEST_ESCORTING, me);
+                    break;
+                case 14:
+                    DoScriptText(SAY_THANKS, me, player);
+                    break;
+                case 15:
+                    if (Unit* Rane = me->FindNearestCreature(NPC_RANE, 20))
                         DoScriptText(SAY_RANE, Rane);
-                    break;}
-            case 16: DoScriptText(SAY_ANSWER, me); break;
-            case 17: DoScriptText(SAY_MOVE_QUINN, me); break;
-            case 24: DoScriptText(SAY_GREETINGS, me); break;
-            case 25: {
-                    Unit* Quinn = me->FindNearestCreature(NPC_QUINN, 20);
-                    if (Quinn)
+                    break;
+                case 16:
+                    DoScriptText(SAY_ANSWER, me);
+                    break;
+                case 17:
+                    DoScriptText(SAY_MOVE_QUINN, me);
+                    break;
+                case 24:
+                    DoScriptText(SAY_GREETINGS, me);
+                    break;
+                case 25:
+                    if (Unit* Quinn = me->FindNearestCreature(NPC_QUINN, 20))
                         DoScriptText(SAY_QUINN, Quinn);
-                    break;}
-            case 26: DoScriptText(SAY_ON_BYE, me, NULL); break;
+                    break;
+                case 26:
+                    DoScriptText(SAY_ON_BYE, me, NULL);
+                    break;
             }
         }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/stormwind_city.cpp
--- a/src/server/scripts/EasternKingdoms/stormwind_city.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/stormwind_city.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -268,9 +268,9 @@
             }
         }
 
-        void WaypointReached(uint32 uiPointId)
+        void WaypointReached(uint32 waypointId)
         {
-            switch (uiPointId)
+            switch (waypointId)
             {
                 case 14:
                     SetEscortPaused(true);
@@ -403,7 +403,7 @@
             {
                 if (Unit* summoner = me->ToTempSummon()->GetSummoner())
                 {
-                    if (summoner && summoner->GetTypeId() == TYPEID_UNIT && summoner->isAlive() && !summoner->isInCombat())
+                    if (summoner->GetTypeId() == TYPEID_UNIT && summoner->isAlive() && !summoner->isInCombat())
                         summoner->ToCreature()->AI()->AttackStart(who);
                 }
             }
@@ -417,7 +417,7 @@
             {
                 if (Unit* summoner = me->ToTempSummon()->GetSummoner())
                 {
-                    if (summoner && summoner->GetTypeId() == TYPEID_UNIT && summoner->isAlive())
+                    if (summoner->GetTypeId() == TYPEID_UNIT && summoner->isAlive())
                         summoner->ToCreature()->DisappearAndDie();
                 }
             }
@@ -497,9 +497,9 @@
             uiPhase = 0;
         }
 
-        void WaypointReached(uint32 uiPointId)
+        void WaypointReached(uint32 waypointId)
         {
-            switch (uiPointId)
+            switch (waypointId)
             {
                 case 1:
                     SetEscortPaused(true);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/swamp_of_sorrows.cpp
--- a/src/server/scripts/EasternKingdoms/swamp_of_sorrows.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/swamp_of_sorrows.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -106,24 +106,24 @@
             }
         }
 
-        void WaypointReached(uint32 uiPointId)
+        void WaypointReached(uint32 waypointId)
         {
-            switch (uiPointId)
+            switch (waypointId)
             {
-            case 0:
-                if (GameObject* pCage = me->GetMap()->GetGameObject(m_uiGalensCageGUID))
-                    pCage->ResetDoorOrButton();
-                break;
-            case 20:
-                if (Player* player = GetPlayerForEscort())
-                {
-                    me->SetFacingToObject(player);
-                    DoScriptText(SAY_QUEST_COMPLETE, me, player);
-                    DoScriptText(EMOTE_WHISPER, me, player);
-                    player->GroupEventHappens(QUEST_GALENS_ESCAPE, me);
-                }
-                SetRun(true);
-                break;
+                case 0:
+                    if (GameObject* pCage = me->GetMap()->GetGameObject(m_uiGalensCageGUID))
+                        pCage->ResetDoorOrButton();
+                    break;
+                case 20:
+                    if (Player* player = GetPlayerForEscort())
+                    {
+                        me->SetFacingToObject(player);
+                        DoScriptText(SAY_QUEST_COMPLETE, me, player);
+                        DoScriptText(EMOTE_WHISPER, me, player);
+                        player->GroupEventHappens(QUEST_GALENS_ESCAPE, me);
+                    }
+                    SetRun(true);
+                    break;
             }
         }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/undercity.cpp
--- a/src/server/scripts/EasternKingdoms/undercity.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/undercity.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -31,7 +31,11 @@
 
 #include "ScriptPCH.h"
 
-enum SylvanasMisc
+/*######
+## npc_lady_sylvanas_windrunner
+######*/
+
+enum Sylvanas
 {
     QUEST_JOURNEY_TO_UNDERCITY  = 9180,
     SAY_LAMENT_END              = -1000196,
@@ -43,19 +47,15 @@
 
     SPELL_HIGHBORNE_AURA        = 37090,
     SPELL_SYLVANAS_CAST         = 36568,
-    SPELL_RIBBON_OF_SOULS       = 34432,                   //the real one to use might be 37099
-    
-    // abilities
-    SPELL_FADE              = 20672,
-    SPELL_BLACK_ARROW       = 59712,
-    SPELL_MULTI_SHOT        = 59713,
-    SPELL_SHOOT             = 59710,
-    SPELL_SUMMON_SKELETON   = 59711,
-    
-    NPC_SKELETON            = 6412,
+    SPELL_RIBBON_OF_SOULS       = 34432, // the real one to use might be 37099
 
-    SAY_AGGRO               = 1,
-    SAY_DEATH               = 2
+    // Combat spells
+    SPELL_BLACK_ARROW           = 59712,
+    SPELL_FADE                  = 20672,
+    SPELL_FADE_BLINK            = 29211,
+    SPELL_MULTI_SHOT            = 59713,
+    SPELL_SHOT                  = 59710,
+    SPELL_SUMMON_SKELETON       = 59711
 };
 
 float HighborneLoc[4][3]=
@@ -69,17 +69,17 @@
 #define HIGHBORNE_LOC_Y             -61.00f
 #define HIGHBORNE_LOC_Y_NEW         -55.50f
 
-class boss_lady_sylvanas_windrunner : public CreatureScript
+class npc_lady_sylvanas_windrunner : public CreatureScript
 {
 public:
-    boss_lady_sylvanas_windrunner() : CreatureScript("boss_lady_sylvanas_windrunner") { }
+    npc_lady_sylvanas_windrunner() : CreatureScript("npc_lady_sylvanas_windrunner") { }
 
     bool OnQuestReward(Player* /*player*/, Creature* creature, const Quest *_Quest, uint32 /*slot*/)
     {
         if (_Quest->GetQuestId() == QUEST_JOURNEY_TO_UNDERCITY)
         {
-            CAST_AI(boss_lady_sylvanas_windrunner::boss_lady_sylvanas_windrunnerAI, creature->AI())->LamentEvent = true;
-            CAST_AI(boss_lady_sylvanas_windrunner::boss_lady_sylvanas_windrunnerAI, creature->AI())->DoPlaySoundToSet(creature, SOUND_CREDIT);
+            CAST_AI(npc_lady_sylvanas_windrunner::npc_lady_sylvanas_windrunnerAI, creature->AI())->LamentEvent = true;
+            CAST_AI(npc_lady_sylvanas_windrunner::npc_lady_sylvanas_windrunnerAI, creature->AI())->DoPlaySoundToSet(creature, SOUND_CREDIT);
             creature->CastSpell(creature, SPELL_SYLVANAS_CAST, false);
 
             for (uint8 i = 0; i < 4; ++i)
@@ -89,40 +89,44 @@
         return true;
     }
 
-    struct boss_lady_sylvanas_windrunnerAI : public ScriptedAI
+    CreatureAI* GetAI(Creature* creature) const
     {
-        boss_lady_sylvanas_windrunnerAI(Creature* creature) : ScriptedAI(creature) , summons(me) {}
+        return new npc_lady_sylvanas_windrunnerAI (creature);
+    }
 
-        uint32  LamentEvent_Timer;
-        bool    LamentEvent;
-        uint64  targetGUID;
-        
+    struct npc_lady_sylvanas_windrunnerAI : public ScriptedAI
+    {
+        npc_lady_sylvanas_windrunnerAI(Creature* creature) : ScriptedAI(creature) {}
+
+        uint32 LamentEventTimer;
+        bool LamentEvent;
+        uint64 targetGUID;
+
+        uint32 FadeTimer;
+        uint32 SummonSkeletonTimer;
+        uint32 BlackArrowTimer;
+        uint32 ShotTimer;
+        uint32 MultiShotTimer;
+
         void Reset()
         {
-            LamentEvent_Timer = 5000;
+            LamentEventTimer = 5000;
             LamentEvent = false;
             targetGUID = 0;
 
-            _fadeTimer = 10 *IN_MILLISECONDS;
-            _blackarrowTimer = urand(6, 8) *IN_MILLISECONDS;
-            _multishotTimer = urand(4, 6) *IN_MILLISECONDS;
-            _shootTimer = urand(2, 4) *IN_MILLISECONDS;
-            _summonskeletonTimer = 0;
-
-            summons.DespawnAll();
+            FadeTimer = 30000;
+            SummonSkeletonTimer = 20000;
+            BlackArrowTimer = 15000;
+            ShotTimer = 8000;
+            MultiShotTimer = 10000;
         }
 
-        void EnterCombat(Unit* /*who*/) 
-        {
-            Talk(SAY_AGGRO);
-        }
+        void EnterCombat(Unit* /*who*/) {}
 
         void JustSummoned(Creature* summoned)
         {
             if (summoned->GetEntry() == ENTRY_HIGHBORNE_BUNNY)
             {
-                summons.Summon(summoned);
-
                 if (Creature* target = Unit::GetCreature(*summoned, targetGUID))
                 {
                     target->MonsterMoveWithSpeed(target->GetPositionX(), target->GetPositionY(), me->GetPositionZ()+15.0f, 0);
@@ -139,104 +143,73 @@
         {
             if (LamentEvent)
             {
-                if (LamentEvent_Timer <= diff)
+                if (LamentEventTimer <= diff)
                 {
                     DoSummon(ENTRY_HIGHBORNE_BUNNY, me, 10.0f, 3000, TEMPSUMMON_TIMED_DESPAWN);
 
-                    LamentEvent_Timer = 2000;
+                    LamentEventTimer = 2000;
                     if (!me->HasAura(SPELL_SYLVANAS_CAST))
                     {
                         DoScriptText(SAY_LAMENT_END, me);
                         DoScriptText(EMOTE_LAMENT_END, me);
                         LamentEvent = false;
                     }
-                } 
-                else 
-                    LamentEvent_Timer -= diff;
+                } else LamentEventTimer -= diff;
             }
 
             if (!UpdateVictim())
                 return;
 
-            if (_fadeTimer <= diff)
+            // Combat spells
+
+            if (FadeTimer <= diff)
             {
-                DoCast(SPELL_FADE);
-                _fadeTimer = 10 *IN_MILLISECONDS;
-            }
-            else
-                _fadeTimer -= diff;
-
-            if (_blackarrowTimer <= diff)
+                DoCast(me, SPELL_FADE);
+                // add a blink to simulate a stealthed movement and reappearing elsewhere
+                DoCast(me, SPELL_FADE_BLINK);
+                FadeTimer = 30000 + rand()%5000;
+                // if the victim is out of melee range she cast multi shot
+                if (Unit* victim = me->getVictim())
+                    if (me->GetDistance(victim) > 10.0f)
+                        DoCast(victim, SPELL_MULTI_SHOT);
+            } else FadeTimer -= diff;
+            
+            if (SummonSkeletonTimer <= diff)
             {
-                Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0);
-                if (target)
+                DoCast(me, SPELL_SUMMON_SKELETON);
+                SummonSkeletonTimer = 20000 + rand()%10000;
+            } else SummonSkeletonTimer -= diff;
+            
+            if (BlackArrowTimer <= diff)
+            {
+                if (Unit* victim = me->getVictim())
                 {
-                    DoCast(target, SPELL_BLACK_ARROW);
-                    _blackarrowTimer = urand(12, 15) *IN_MILLISECONDS;
+                    DoCast(me->getVictim(), SPELL_BLACK_ARROW);
+                    BlackArrowTimer = 15000 + rand()%5000;
                 }
-            }
-            else
-                _blackarrowTimer -= diff;
-
-            if (_multishotTimer <= diff)
+            } else BlackArrowTimer -= diff;
+            
+            if (ShotTimer <= diff)
             {
-                Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1);
-                if (target)
+                if (Unit* victim = me->getVictim())
                 {
-                    DoCast(target, SPELL_MULTI_SHOT);
-                    _multishotTimer = urand(8, 10) *IN_MILLISECONDS;
+                    DoCast(me->getVictim(), SPELL_SHOT);
+                    ShotTimer = 8000 + rand()%2000;
                 }
-            }
-            else
-                _multishotTimer -= diff;
-
-            if (_shootTimer <= diff)
+            } else ShotTimer -= diff;
+                   
+            if (MultiShotTimer <= diff)
             {
-                Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1);
-                if (target)
+                if (Unit* victim = me->getVictim())
                 {
-                    DoCast(target, SPELL_SHOOT);
-                    _shootTimer = urand(2, 4) *IN_MILLISECONDS;
+                    DoCast(me->getVictim(), SPELL_MULTI_SHOT);
+                    MultiShotTimer = 10000 + rand()%3000;
                 }
-            }
-            else
-                _shootTimer -= diff;
-
-            if (_summonskeletonTimer <= diff)
-            {
-                DoCast(SPELL_SUMMON_SKELETON);
-                _summonskeletonTimer = 10 *IN_MILLISECONDS;
-            }
-            else
-                _summonskeletonTimer -= diff;
+            } else MultiShotTimer -= diff;   
 
             DoMeleeAttackIfReady();
         }
-
-        void KilledUnit (Unit* victim)
-        {
-            me->SummonCreature(NPC_SKELETON, victim->GetPositionX(), victim->GetPositionY(), victim->GetPositionZ(), 0, TEMPSUMMON_CORPSE_DESPAWN, 0);
-        }
-
-        void JustDied (Unit* /*victim*/)
-        {
-            summons.DespawnAll();
-            Talk(SAY_DEATH);
-        }
-
-    private:
-        SummonList summons;
-        uint32  _fadeTimer;
-        uint32  _blackarrowTimer;
-        uint32  _multishotTimer;
-        uint32  _shootTimer;
-        uint32  _summonskeletonTimer;
     };
-
-    CreatureAI* GetAI(Creature* creature) const
-    {
-        return new boss_lady_sylvanas_windrunnerAI (creature);
-    }
 };
 
 /*######
@@ -257,15 +230,15 @@
     {
         npc_highborne_lamenterAI(Creature* creature) : ScriptedAI(creature) {}
 
-        uint32 EventMove_Timer;
-        uint32 EventCast_Timer;
+        uint32 EventMoveTimer;
+        uint32 EventCastTimer;
         bool EventMove;
         bool EventCast;
 
         void Reset()
         {
-            EventMove_Timer = 10000;
-            EventCast_Timer = 17500;
+            EventMoveTimer = 10000;
+            EventCastTimer = 17500;
             EventMove = true;
             EventCast = true;
         }
@@ -276,21 +249,21 @@
         {
             if (EventMove)
             {
-                if (EventMove_Timer <= diff)
+                if (EventMoveTimer <= diff)
                 {
                     me->SetDisableGravity(true);
                     me->MonsterMoveWithSpeed(me->GetPositionX(), me->GetPositionY(), HIGHBORNE_LOC_Y_NEW, me->GetDistance(me->GetPositionX(), me->GetPositionY(), HIGHBORNE_LOC_Y_NEW) / (5000 * 0.001f));
                     me->SetPosition(me->GetPositionX(), me->GetPositionY(), HIGHBORNE_LOC_Y_NEW, me->GetOrientation());
                     EventMove = false;
-                } else EventMove_Timer -= diff;
+                } else EventMoveTimer -= diff;
             }
             if (EventCast)
             {
-                if (EventCast_Timer <= diff)
+                if (EventCastTimer <= diff)
                 {
                     DoCast(me, SPELL_HIGHBORNE_AURA);
                     EventCast = false;
-                } else EventCast_Timer -= diff;
+                } else EventCastTimer -= diff;
             }
         }
     };
@@ -352,7 +325,7 @@
 
 void AddSC_undercity()
 {
-    new boss_lady_sylvanas_windrunner();
+    new npc_lady_sylvanas_windrunner();
     new npc_highborne_lamenter();
     new npc_parqual_fintallas();
 }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/western_plaguelands.cpp
--- a/src/server/scripts/EasternKingdoms/western_plaguelands.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/western_plaguelands.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -85,6 +85,7 @@
     {
         if (creature->isQuestGiver())
             player->PrepareQuestMenu(creature->GetGUID());
+
         if (creature->isVendor())
             player->ADD_GOSSIP_ITEM(GOSSIP_ICON_VENDOR, GOSSIP_TEXT_BROWSE_GOODS, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_TRADE);
 
@@ -95,7 +96,8 @@
             player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HDA3, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+3);
             player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HDA4, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+4);
             player->SEND_GOSSIP_MENU(3985, creature->GetGUID());
-        }else
+        }
+        else
             player->SEND_GOSSIP_MENU(player->GetGossipTextId(creature), creature->GetGUID());
 
         return true;
@@ -326,10 +328,11 @@
                 summoned->AI()->AttackStart(me);
         }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
-            switch (i)
+
+            switch (waypointId)
             {
                 case 8:
                     DoScriptText(SAY_WP_0, me);
@@ -378,8 +381,7 @@
 
          void JustDied(Unit* /*killer*/)
         {
-           Player* player = GetPlayerForEscort();
-            if (player)
+            if (Player* player = GetPlayerForEscort())
                 player->FailQuest(QUEST_TOMB_LIGHTBRINGER);
         }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/westfall.cpp
--- a/src/server/scripts/EasternKingdoms/westfall.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/westfall.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -85,9 +85,15 @@
             {
                 switch (uiWPHolder)
                 {
-                    case 7: DoScriptText(SAY_DS_DOWN_1, me); break;
-                    case 8: DoScriptText(SAY_DS_DOWN_2, me); break;
-                    case 9: DoScriptText(SAY_DS_DOWN_3, me); break;
+                    case 7:
+                        DoScriptText(SAY_DS_DOWN_1, me);
+                        break;
+                    case 8:
+                        DoScriptText(SAY_DS_DOWN_2, me);
+                        break;
+                    case 9:
+                        DoScriptText(SAY_DS_DOWN_3, me);
+                        break;
                 }
             }
             else
@@ -96,16 +102,15 @@
             uiShootTimer = 0;
         }
 
-        void WaypointReached(uint32 uiPoint)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
-
             if (!player)
                 return;
 
-            uiWPHolder = uiPoint;
+            uiWPHolder = waypointId;
 
-            switch (uiPoint)
+            switch (waypointId)
             {
                 case 4:
                     SetEquipmentSlots(false, EQUIP_NO_CHANGE, EQUIP_NO_CHANGE, EQUIP_ID_RIFLE);
@@ -226,14 +231,13 @@
     {
         npc_defias_traitorAI(Creature* creature) : npc_escortAI(creature) { Reset(); }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
-
             if (!player)
                 return;
 
-            switch (i)
+            switch (waypointId)
             {
                 case 35:
                     SetRun(false);
@@ -243,13 +247,11 @@
                     break;
                 case 44:
                     DoScriptText(SAY_END, me, player);
-                    {
-                        if (player)
-                            player->GroupEventHappens(QUEST_DEFIAS_BROTHERHOOD, me);
-                    }
+                    player->GroupEventHappens(QUEST_DEFIAS_BROTHERHOOD, me);
                     break;
             }
         }
+
         void EnterCombat(Unit* who)
         {
             DoScriptText(RAND(SAY_AGGRO_1, SAY_AGGRO_2), me, who);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/EasternKingdoms/wetlands.cpp
--- a/src/server/scripts/EasternKingdoms/wetlands.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/EasternKingdoms/wetlands.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -67,14 +67,13 @@
                 m_bFriendSummoned = false;
         }
 
-        void WaypointReached(uint32 uiPointId)
+        void WaypointReached(uint32 waypointId)
         {
-            switch (uiPointId)
+            switch (waypointId)
             {
                 case 2:
                     if (me->HasStealthAura())
                         me->RemoveAurasByType(SPELL_AURA_MOD_STEALTH);
-
                     SetRun();
                     me->setFaction(FACTION_ENEMY);
                     break;
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Examples/example_escort.cpp
--- a/src/server/scripts/Examples/example_escort.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Examples/example_escort.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -75,9 +75,9 @@
             }
 
             // Pure Virtual Functions (Have to be implemented)
-            void WaypointReached(uint32 uiWP)
+            void WaypointReached(uint32 waypointId)
             {
-                switch (uiWP)
+                switch (waypointId)
                 {
                     case 1:
                         DoScriptText(SAY_WP_1, me);
@@ -123,9 +123,7 @@
                     {
                         // not a likely case, code here for the sake of example
                         if (killer == me)
-                        {
                             DoScriptText(SAY_DEATH_1, me, player);
-                        }
                         else
                             DoScriptText(SAY_DEATH_2, me, player);
                     }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/BlackfathomDeeps/blackfathom_deeps.cpp
--- a/src/server/scripts/Kalimdor/BlackfathomDeeps/blackfathom_deeps.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/BlackfathomDeeps/blackfathom_deeps.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -236,9 +236,9 @@
             Start(false, false, 0);
         }
 
-        void WaypointReached(uint32 uiPoint)
+        void WaypointReached(uint32 waypointId)
         {
-            switch (uiPoint)
+            switch (waypointId)
             {
                 case 4:
                     SetEscortPaused(true);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/boss_anetheron.cpp
--- a/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/boss_anetheron.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/boss_anetheron.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -115,19 +115,19 @@
             }
         }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
-            if (i == 7 && instance)
+            if (waypointId == 7 && instance)
             {
-                Unit* target = Unit::GetUnit((*me), instance->GetData64(DATA_JAINAPROUDMOORE));
+                Unit* target = Unit::GetUnit(*me, instance->GetData64(DATA_JAINAPROUDMOORE));
                 if (target && target->isAlive())
                     me->AddThreat(target, 0.0f);
             }
         }
 
-        void JustDied(Unit* victim)
+        void JustDied(Unit* killer)
         {
-            hyjal_trashAI::JustDied(victim);
+            hyjal_trashAI::JustDied(killer);
             if (instance && IsEvent)
                 instance->SetData(DATA_ANETHERONEVENT, DONE);
             DoPlaySoundToSet(me, SOUND_ONDEATH);
@@ -272,7 +272,7 @@
         {
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
         }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/boss_archimonde.cpp
--- a/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/boss_archimonde.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/boss_archimonde.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -117,7 +117,7 @@
         {
             if (CheckTimer <= diff)
             {
-                if (Unit* Archimonde = Unit::GetUnit((*me), ArchimondeGUID))
+                if (Unit* Archimonde = Unit::GetUnit(*me, ArchimondeGUID))
                 {
                     if (Archimonde->HealthBelowPct(2) || !Archimonde->isAlive())
                         DoCast(me, SPELL_DENOUEMENT_WISP);
@@ -343,9 +343,9 @@
             ++SoulChargeCount;
         }
 
-        void JustDied(Unit* victim)
+        void JustDied(Unit* killer)
         {
-            hyjal_trashAI::JustDied(victim);
+            hyjal_trashAI::JustDied(killer);
             DoScriptText(SAY_DEATH, me);
 
             if (instance)
@@ -367,7 +367,7 @@
             std::list<HostileReference*>::const_iterator itr = m_threatlist.begin();
             for (; itr != m_threatlist.end(); ++itr)
             {
-                Unit* unit = Unit::GetUnit((*me), (*itr)->getUnitGuid());
+                Unit* unit = Unit::GetUnit(*me, (*itr)->getUnitGuid());
                 if (unit && unit->isAlive())
                     targets.push_back(unit);
             }
@@ -644,7 +644,11 @@
 
             DoMeleeAttackIfReady();
         }
-        void WaypointReached(uint32 /*i*/){}
+
+        void WaypointReached(uint32 /*waypointId*/)
+        {
+
+        }
     };
 
 };
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/boss_azgalor.cpp
--- a/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/boss_azgalor.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/boss_azgalor.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -111,19 +111,19 @@
             }
         }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
-            if (i == 7 && instance)
+            if (waypointId == 7 && instance)
             {
-                Unit* target = Unit::GetUnit((*me), instance->GetData64(DATA_THRALL));
+                Unit* target = Unit::GetUnit(*me, instance->GetData64(DATA_THRALL));
                 if (target && target->isAlive())
                     me->AddThreat(target, 0.0f);
             }
         }
 
-        void JustDied(Unit* victim)
+        void JustDied(Unit* killer)
         {
-            hyjal_trashAI::JustDied(victim);
+            hyjal_trashAI::JustDied(killer);
             if (instance && IsEvent)
                 instance->SetData(DATA_AZGALOREVENT, DONE);
             DoPlaySoundToSet(me, SOUND_ONDEATH);
@@ -241,7 +241,7 @@
         {
         }
 
-        void WaypointReached(uint32 /*i*/)
+        void WaypointReached(uint32 /*waypointId*/)
         {
         }
 
@@ -251,7 +251,7 @@
                 AttackStart(who);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
         }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/boss_kazrogal.cpp
--- a/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/boss_kazrogal.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/boss_kazrogal.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -103,19 +103,19 @@
             }
         }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
-            if (i == 7 && instance)
+            if (waypointId == 7 && instance)
             {
-                Unit* target = Unit::GetUnit((*me), instance->GetData64(DATA_THRALL));
+                Unit* target = Unit::GetUnit(*me, instance->GetData64(DATA_THRALL));
                 if (target && target->isAlive())
                     me->AddThreat(target, 0.0f);
             }
         }
 
-        void JustDied(Unit* victim)
+        void JustDied(Unit* killer)
         {
-            hyjal_trashAI::JustDied(victim);
+            hyjal_trashAI::JustDied(killer);
             if (instance && IsEvent)
                 instance->SetData(DATA_KAZROGALEVENT, DONE);
             DoPlaySoundToSet(me, SOUND_ONDEATH);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/boss_rage_winterchill.cpp
--- a/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/boss_rage_winterchill.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/boss_rage_winterchill.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -105,19 +105,19 @@
             }
         }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
-            if (i == 7 && instance)
+            if (waypointId == 7 && instance)
             {
-                Unit* target = Unit::GetUnit((*me), instance->GetData64(DATA_JAINAPROUDMOORE));
+                Unit* target = Unit::GetUnit(*me, instance->GetData64(DATA_JAINAPROUDMOORE));
                 if (target && target->isAlive())
                     me->AddThreat(target, 0.0f);
             }
         }
 
-        void JustDied(Unit* victim)
+        void JustDied(Unit* killer)
         {
-            hyjal_trashAI::JustDied(victim);
+            hyjal_trashAI::JustDied(killer);
             if (instance && IsEvent)
                 instance->SetData(DATA_RAGEWINTERCHILLEVENT, DONE);
             DoPlaySoundToSet(me, SOUND_ONDEATH);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/hyjal.cpp
--- a/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/hyjal.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/hyjal.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -226,7 +226,6 @@
                          player->SendNewItem(item, 1, true, false, true);
                 }
                 player->SEND_GOSSIP_MENU(907, creature->GetGUID());
-                CAST_AI(hyjalAI, creature->AI());
         }
         return true;
     }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/hyjalAI.cpp
--- a/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/hyjalAI.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/hyjalAI.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -855,7 +855,7 @@
         {
             if (BossGUID[i])
             {
-                Unit* unit = Unit::GetUnit((*me), BossGUID[i]);
+                Unit* unit = Unit::GetUnit(*me, BossGUID[i]);
                 if (unit && (!unit->isAlive()))
                 {
                     if (BossGUID[i] == BossGUID[0])
@@ -980,9 +980,9 @@
     cell.Visit(p, obj_worker, *me->GetMap(), *me, me->GetGridActivationRange());
 }
 
-void hyjalAI::WaypointReached(uint32 i)
+void hyjalAI::WaypointReached(uint32 waypointId)
 {
-    if (i == 1 || (i == 0 && me->GetEntry() == THRALL))
+    if (waypointId == 1 || (waypointId == 0 && me->GetEntry() == THRALL))
     {
         me->MonsterYell(YELL_HURRY, 0, 0);
         WaitForTeleport = true;
@@ -991,7 +991,7 @@
             DoCast(me, SPELL_MASS_TELEPORT, false);
         if (me->GetEntry() == THRALL && DummyGuid)
         {
-            Unit* Dummy = Unit::GetUnit((*me), DummyGuid);
+            Unit* Dummy = Unit::GetUnit(*me, DummyGuid);
             if (Dummy)
             {
                 CAST_AI(hyjalAI, CAST_CRE(Dummy)->AI())->DoMassTeleport = true;
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/hyjalAI.h
--- a/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/hyjalAI.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/hyjalAI.h	Mon Apr 16 14:29:17 2012 +0300
@@ -196,7 +196,7 @@
     void SummonedCreatureDespawn(Creature* summoned);
     void HideNearPos(float x, float y);
     void RespawnNearPos(float x, float y);
-    void WaypointReached(uint32 i);
+    void WaypointReached(uint32 waypointId);
     void DoOverrun(uint32 faction, const uint32 diff);
     void MoveInLineOfSight(Unit* who);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/hyjal_trash.cpp
--- a/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/hyjal_trash.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/hyjal_trash.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -377,10 +377,11 @@
     }
 }
 
-void hyjal_trashAI::JustDied(Unit* /*victim*/)
+void hyjal_trashAI::JustDied(Unit* /*killer*/)
 {
     if (!instance)
         return;
+
     if (IsEvent && !me->isWorldBoss())
         instance->SetData(DATA_TRASH, 0);//signal trash is dead
 
@@ -425,13 +426,13 @@
 
         void EnterCombat(Unit* /*who*/) {}
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
-            if (i == 0 && instance && !IsOverrun)
+            if (waypointId == 0 && instance && !IsOverrun)
             {
                 if (instance->GetData(DATA_ALLIANCE_RETREAT))//2.alliance boss down, attack thrall
                 {
-                    Unit* target = Unit::GetUnit((*me), instance->GetData64(DATA_THRALL));
+                    Unit* target = Unit::GetUnit(*me, instance->GetData64(DATA_THRALL));
                     if (target && target->isAlive())
                         me->AddThreat(target, 0.0f);
                 }
@@ -472,7 +473,7 @@
                     {
                         if (instance->GetData(DATA_ALLIANCE_RETREAT) && !instance->GetData(DATA_HORDE_RETREAT))
                         {
-                            Unit* target = Unit::GetUnit((*me), instance->GetData64(DATA_THRALL));
+                            Unit* target = Unit::GetUnit(*me, instance->GetData64(DATA_THRALL));
                             if (target && target->isAlive())
                                 me->AddThreat(target, 0.0f);
                         } else if (instance->GetData(DATA_ALLIANCE_RETREAT) && instance->GetData(DATA_HORDE_RETREAT)){
@@ -550,22 +551,24 @@
             KnockDownTimer = 10000;
         }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
-            if (i == 7 && instance && !IsOverrun)
+            if (waypointId == 7 && instance && !IsOverrun)
             {
                 if (instance->GetData(DATA_ALLIANCE_RETREAT))//2.alliance boss down, attack thrall
                 {
-                    Unit* target = Unit::GetUnit((*me), instance->GetData64(DATA_THRALL));
+                    Unit* target = Unit::GetUnit(*me, instance->GetData64(DATA_THRALL));
                     if (target && target->isAlive())
                         me->AddThreat(target, 0.0f);
-                }else{
-                    Unit* target = Unit::GetUnit((*me), instance->GetData64(DATA_JAINAPROUDMOORE));
+                }
+                else
+                {
+                    Unit* target = Unit::GetUnit(*me, instance->GetData64(DATA_JAINAPROUDMOORE));
                     if (target && target->isAlive())
                         me->AddThreat(target, 0.0f);
                 }
             }
-            if (i == LastOverronPos && IsOverrun)
+            if (waypointId == LastOverronPos && IsOverrun)
             {
                 if ((faction == 0 && LastOverronPos == 17) || (faction == 1 && LastOverronPos == 21))
                 {
@@ -652,22 +655,24 @@
             RandomMove = false;
         }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
-            if (i == 7 && instance && !IsOverrun)
+            if (waypointId == 7 && instance && !IsOverrun)
             {
                 if (instance->GetData(DATA_ALLIANCE_RETREAT))//2.alliance boss down, attack thrall
                 {
-                    Unit* target = Unit::GetUnit((*me), instance->GetData64(DATA_THRALL));
+                    Unit* target = Unit::GetUnit(*me, instance->GetData64(DATA_THRALL));
                     if (target && target->isAlive())
                         me->AddThreat(target, 0.0f);
-                }else{
-                    Unit* target = Unit::GetUnit((*me), instance->GetData64(DATA_JAINAPROUDMOORE));
+                }
+                else
+                {
+                    Unit* target = Unit::GetUnit(*me, instance->GetData64(DATA_JAINAPROUDMOORE));
                     if (target && target->isAlive())
                         me->AddThreat(target, 0.0f);
                 }
             }
-            if (i == LastOverronPos && IsOverrun)
+            if (waypointId == LastOverronPos && IsOverrun)
             {
                 me->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_ONESHOT_ATTACK_UNARMED);
                 if ((faction == 0 && LastOverronPos == 17) || (faction == 1 && LastOverronPos == 21))
@@ -675,7 +680,6 @@
                     me->setDeathState(DEAD);
                     me->RemoveCorpse();
                 }
-
             }
         }
 
@@ -770,17 +774,19 @@
             summons.Despawn(summon);
         }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
-            if (i == 7 && instance && !IsOverrun)
+            if (waypointId == 7 && instance && !IsOverrun)
             {
                 if (instance->GetData(DATA_ALLIANCE_RETREAT))//2.alliance boss down, attack thrall
                 {
-                    Unit* target = Unit::GetUnit((*me), instance->GetData64(DATA_THRALL));
+                    Unit* target = Unit::GetUnit(*me, instance->GetData64(DATA_THRALL));
                     if (target && target->isAlive())
                         me->AddThreat(target, 0.0f);
-                }else{
-                    Unit* target = Unit::GetUnit((*me), instance->GetData64(DATA_JAINAPROUDMOORE));
+                }
+                else
+                {
+                    Unit* target = Unit::GetUnit(*me, instance->GetData64(DATA_JAINAPROUDMOORE));
                     if (target && target->isAlive())
                         me->AddThreat(target, 0.0f);
                 }
@@ -888,17 +894,19 @@
             ShellTimer = 50000+rand()%10000;
         }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
-            if (i == 7 && instance && !IsOverrun)
+            if (waypointId == 7 && instance && !IsOverrun)
             {
                 if (instance->GetData(DATA_ALLIANCE_RETREAT))//2.alliance boss down, attack thrall
                 {
-                    Unit* target = Unit::GetUnit((*me), instance->GetData64(DATA_THRALL));
+                    Unit* target = Unit::GetUnit(*me, instance->GetData64(DATA_THRALL));
                     if (target && target->isAlive())
                         me->AddThreat(target, 0.0f);
-                }else{
-                    Unit* target = Unit::GetUnit((*me), instance->GetData64(DATA_JAINAPROUDMOORE));
+                }
+                else
+                {
+                    Unit* target = Unit::GetUnit(*me, instance->GetData64(DATA_JAINAPROUDMOORE));
                     if (target && target->isAlive())
                         me->AddThreat(target, 0.0f);
                 }
@@ -987,17 +995,19 @@
             WebTimer = 20000+rand()%5000;
         }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
-            if (i == 7 && instance && !IsOverrun)
+            if (waypointId == 7 && instance && !IsOverrun)
             {
                 if (instance->GetData(DATA_ALLIANCE_RETREAT))//2.alliance boss down, attack thrall
                 {
-                    Unit* target = Unit::GetUnit((*me), instance->GetData64(DATA_THRALL));
+                    Unit* target = Unit::GetUnit(*me, instance->GetData64(DATA_THRALL));
                     if (target && target->isAlive())
                         me->AddThreat(target, 0.0f);
-                }else{
-                    Unit* target = Unit::GetUnit((*me), instance->GetData64(DATA_JAINAPROUDMOORE));
+                }
+                else
+                {
+                    Unit* target = Unit::GetUnit(*me, instance->GetData64(DATA_JAINAPROUDMOORE));
                     if (target && target->isAlive())
                         me->AddThreat(target, 0.0f);
                 }
@@ -1077,17 +1087,19 @@
             ManaBurnTimer = 9000+rand()%5000;
         }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
-            if (i == 7 && instance && !IsOverrun)
+            if (waypointId == 7 && instance && !IsOverrun)
             {
                 if (instance->GetData(DATA_ALLIANCE_RETREAT))//2.alliance boss down, attack thrall
                 {
-                    Unit* target = Unit::GetUnit((*me), instance->GetData64(DATA_THRALL));
+                    Unit* target = Unit::GetUnit(*me, instance->GetData64(DATA_THRALL));
                     if (target && target->isAlive())
                         me->AddThreat(target, 0.0f);
-                }else{
-                    Unit* target = Unit::GetUnit((*me), instance->GetData64(DATA_JAINAPROUDMOORE));
+                }
+                else
+                {
+                    Unit* target = Unit::GetUnit(*me, instance->GetData64(DATA_JAINAPROUDMOORE));
                     if (target && target->isAlive())
                         me->AddThreat(target, 0.0f);
                 }
@@ -1170,11 +1182,11 @@
             me->SetDisableGravity(true);
         }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
-            if (i == 2 && instance && !IsOverrun)
+            if (waypointId == 2 && instance && !IsOverrun)
             {
-                Unit* target = Unit::GetUnit((*me), instance->GetData64(DATA_THRALL));
+                Unit* target = Unit::GetUnit(*me, instance->GetData64(DATA_THRALL));
                 if (target && target->isAlive())
                 {
                     me->AddThreat(target, 0.0f);
@@ -1183,7 +1195,7 @@
             }
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (instance && IsEvent)
                 instance->SetData(DATA_TRASH, 0);//signal trash is dead
@@ -1289,11 +1301,11 @@
             me->SetDisableGravity(true);
         }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
-            if (i == 2 && instance && !IsOverrun)
+            if (waypointId == 2 && instance && !IsOverrun)
             {
-                Unit* target = Unit::GetUnit((*me), instance->GetData64(DATA_THRALL));
+                Unit* target = Unit::GetUnit(*me, instance->GetData64(DATA_THRALL));
                 if (target && target->isAlive())
                 {
                     me->AddThreat(target, 0.0f);
@@ -1302,14 +1314,14 @@
             }
         }
 
-        void JustDied(Unit* victim)
+        void JustDied(Unit* killer)
         {
             float x, y, z;
             me->GetPosition(x, y, z);
             z = me->GetMap()->GetHeight(me->GetPhaseMask(), x, y, z);
             me->GetMotionMaster()->MovePoint(0, x, y, z);
             me->SetPosition(x, y, z, 0);
-            hyjal_trashAI::JustDied(victim);
+            hyjal_trashAI::JustDied(killer);
         }
 
         void UpdateAI(const uint32 diff)
@@ -1411,7 +1423,7 @@
 
         uint32 ExplodeTimer;
 
-        void JustDied(Unit* /*who*/)
+        void JustDied(Unit* /*killer*/)
         {
         }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/CavernsOfTime/CullingOfStratholme/culling_of_stratholme.cpp
--- a/src/server/scripts/Kalimdor/CavernsOfTime/CullingOfStratholme/culling_of_stratholme.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/CavernsOfTime/CullingOfStratholme/culling_of_stratholme.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -364,9 +364,9 @@
             ++uiStep;
         }
 
-        void WaypointReached(uint32 uiPointId)
+        void WaypointReached(uint32 waypointId)
         {
-            switch (uiPointId)
+            switch (waypointId)
             {
                 case 0:
                 case 1:
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/CavernsOfTime/DarkPortal/boss_aeonus.cpp
--- a/src/server/scripts/Kalimdor/CavernsOfTime/DarkPortal/boss_aeonus.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/CavernsOfTime/DarkPortal/boss_aeonus.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -93,7 +93,7 @@
             ScriptedAI::MoveInLineOfSight(who);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEATH, me);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/CavernsOfTime/DarkPortal/boss_chrono_lord_deja.cpp
--- a/src/server/scripts/Kalimdor/CavernsOfTime/DarkPortal/boss_chrono_lord_deja.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/CavernsOfTime/DarkPortal/boss_chrono_lord_deja.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -100,7 +100,7 @@
             DoScriptText(RAND(SAY_SLAY1, SAY_SLAY2), me);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEATH, me);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/CavernsOfTime/DarkPortal/boss_temporus.cpp
--- a/src/server/scripts/Kalimdor/CavernsOfTime/DarkPortal/boss_temporus.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/CavernsOfTime/DarkPortal/boss_temporus.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -84,7 +84,7 @@
             DoScriptText(RAND(SAY_SLAY1, SAY_SLAY2), me);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEATH, me);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/CavernsOfTime/DarkPortal/dark_portal.cpp
--- a/src/server/scripts/Kalimdor/CavernsOfTime/DarkPortal/dark_portal.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/CavernsOfTime/DarkPortal/dark_portal.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -153,9 +153,9 @@
                 SpellCorrupt_Timer = 3000;
         }
 
-        void JustDied(Unit* Killer)
+        void JustDied(Unit* killer)
         {
-            if (Killer->GetEntry() == me->GetEntry())
+            if (killer->GetEntry() == me->GetEntry())
                 return;
 
             DoScriptText(SAY_DEATH, me);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/CavernsOfTime/DarkPortal/instance_dark_portal.cpp
--- a/src/server/scripts/Kalimdor/CavernsOfTime/DarkPortal/instance_dark_portal.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/CavernsOfTime/DarkPortal/instance_dark_portal.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -116,9 +116,9 @@
             DoUpdateWorldState(WORLD_STATE_BM_RIFT, 0);
         }
 
-        bool IsEncounterInProgress()
+        bool IsEncounterInProgress() const
         {
-            if (GetData(TYPE_MEDIVH) == IN_PROGRESS)
+            if (const_cast<instance_dark_portal_InstanceMapScript*>(this)->GetData(TYPE_MEDIVH) == IN_PROGRESS)
                 return true;
 
             return false;
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/CavernsOfTime/EscapeFromDurnholdeKeep/boss_captain_skarloc.cpp
--- a/src/server/scripts/Kalimdor/CavernsOfTime/EscapeFromDurnholdeKeep/boss_captain_skarloc.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/CavernsOfTime/EscapeFromDurnholdeKeep/boss_captain_skarloc.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -88,7 +88,7 @@
             DoScriptText(RAND(SAY_SLAY1, SAY_SLAY2), me);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEATH, me);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/CavernsOfTime/EscapeFromDurnholdeKeep/boss_epoch_hunter.cpp
--- a/src/server/scripts/Kalimdor/CavernsOfTime/EscapeFromDurnholdeKeep/boss_epoch_hunter.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/CavernsOfTime/EscapeFromDurnholdeKeep/boss_epoch_hunter.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -84,7 +84,7 @@
             DoScriptText(RAND(SAY_SLAY1, SAY_SLAY2), me);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEATH, me);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/CavernsOfTime/EscapeFromDurnholdeKeep/boss_leutenant_drake.cpp
--- a/src/server/scripts/Kalimdor/CavernsOfTime/EscapeFromDurnholdeKeep/boss_leutenant_drake.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/CavernsOfTime/EscapeFromDurnholdeKeep/boss_leutenant_drake.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -142,7 +142,7 @@
             DoScriptText(RAND(SAY_SLAY1, SAY_SLAY2), me);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEATH, me);
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/CavernsOfTime/EscapeFromDurnholdeKeep/old_hillsbrad.cpp
--- a/src/server/scripts/Kalimdor/CavernsOfTime/EscapeFromDurnholdeKeep/old_hillsbrad.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/CavernsOfTime/EscapeFromDurnholdeKeep/old_hillsbrad.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -296,12 +296,12 @@
         bool LowHp;
         bool HadMount;
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             if (!instance)
                 return;
 
-            switch (i)
+            switch (waypointId)
             {
                 case 8:
                     SetRun(false);
@@ -413,7 +413,7 @@
                 case 94:
                     if (uint64 TarethaGUID = instance->GetData64(DATA_TARETHA))
                     {
-                        if (Unit* Taretha = Unit::GetUnit((*me), TarethaGUID))
+                        if (Unit* Taretha = Unit::GetUnit(*me, TarethaGUID))
                             DoScriptText(SAY_TA_ESCAPED, Taretha, me);
                     }
                     break;
@@ -433,7 +433,6 @@
                     //trigger epoch Yell("Thrall! Come outside and face your fate! ....")
                     //from here, thrall should not never be allowed to move to point 106 which he currently does.
                     break;
-
                 case 106:
                     {
                         //trigger taretha to run down outside
@@ -631,9 +630,9 @@
 
         InstanceScript* instance;
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
-            switch (i)
+            switch (waypointId)
             {
                 case 6:
                     DoScriptText(SAY_TA_FREE, me);
@@ -643,6 +642,7 @@
                     break;
             }
         }
+
         void Reset() {}
         void EnterCombat(Unit* /*who*/) {}
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/Maraudon/boss_celebras_the_cursed.cpp
--- a/src/server/scripts/Kalimdor/Maraudon/boss_celebras_the_cursed.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/Maraudon/boss_celebras_the_cursed.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -59,7 +59,7 @@
 
         void EnterCombat(Unit* /*who*/) { }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             me->SummonCreature(13716, me->GetPositionX(), me->GetPositionY(), me->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN, 600000);
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/RazorfenDowns/razorfen_downs.cpp
--- a/src/server/scripts/Kalimdor/RazorfenDowns/razorfen_downs.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/RazorfenDowns/razorfen_downs.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -52,7 +52,7 @@
 public:
     npc_henry_stern() : CreatureScript("npc_henry_stern") { }
 
-    bool OnGossipSelect (Player* player, Creature* creature, uint32 /*sender*/, uint32 action)
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 /*sender*/, uint32 action)
     {
         player->PlayerTalkClass->ClearMenus();
         if (action == GOSSIP_ACTION_INFO_DEF + 1)
@@ -70,7 +70,7 @@
         return true;
     }
 
-    bool OnGossipHello (Player* player, Creature* creature)
+    bool OnGossipHello(Player* player, Creature* creature)
     {
         if (player->GetBaseSkillValue(SKILL_COOKING) >= 175 && !player->HasSpell(SPELL_GOLDTHORN_TEA))
             player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_ITEM_TEA, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
@@ -81,7 +81,6 @@
         player->SEND_GOSSIP_MENU(player->GetGossipTextId(creature), creature->GetGUID());
         return true;
     }
-
 };
 
 /*######
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/RazorfenKraul/razorfen_kraul.cpp
--- a/src/server/scripts/Kalimdor/RazorfenKraul/razorfen_kraul.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/RazorfenKraul/razorfen_kraul.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -1,151 +1,150 @@
-/*
- * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
- * Copyright (C) 2006-2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-
-/* ScriptData
-SDName: Razorfen Kraul
-SD%Complete: 100
-SDComment: Quest support: 1144
-SDCategory: Razorfen Kraul
-EndScriptData */
-
-/* ContentData
-npc_willix
-EndContentData */
-
-#include "ScriptPCH.h"
-#include "ScriptedEscortAI.h"
-#include "razorfen_kraul.h"
-
-#define SAY_READY -1047000
-#define SAY_POINT -1047001
-#define SAY_AGGRO1 -1047002
-#define SAY_BLUELEAF -1047003
-#define SAY_DANGER -1047004
-#define SAY_BAD -1047005
-#define SAY_THINK -1047006
-#define SAY_SOON -1047007
-#define SAY_FINALY -1047008
-#define SAY_WIN -1047009
-#define SAY_END -1047010
-
-#define QUEST_WILLIX_THE_IMPORTER 1144
-#define ENTRY_BOAR 4514
-
-class npc_willix : public CreatureScript
-{
-public:
-    npc_willix() : CreatureScript("npc_willix") { }
-
-    bool OnQuestAccept(Player* player, Creature* creature, Quest const* quest)
-    {
-        if (quest->GetQuestId() == QUEST_WILLIX_THE_IMPORTER)
-        {
-            CAST_AI(npc_escortAI, (creature->AI()))->Start(true, false, player->GetGUID());
-            DoScriptText(SAY_READY, creature, player);
-            creature->setFaction(113);
-        }
-
-        return true;
-    }
-
-    CreatureAI* GetAI(Creature* creature) const
-    {
-        return new npc_willixAI(creature);
-    }
-
-    struct npc_willixAI : public npc_escortAI
-    {
-        npc_willixAI(Creature* creature) : npc_escortAI(creature) {}
-
-        void WaypointReached(uint32 i)
-        {
-            Player* player = GetPlayerForEscort();
-
-            if (!player)
-                return;
-
-            switch (i)
-            {
-            case 3:
-                me->HandleEmoteCommand(EMOTE_STATE_POINT);
-                DoScriptText(SAY_POINT, me, player);
-                break;
-            case 4:
-                me->SummonCreature(ENTRY_BOAR, 2137.66f, 1843.98f, 48.08f, 1.54f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 25000);
-                break;
-            case 8:
-                DoScriptText(SAY_BLUELEAF, me, player);
-                break;
-            case 9:
-                DoScriptText(SAY_DANGER, me, player);
-                break;
-            case 13:
-                DoScriptText(SAY_BAD, me, player);
-                break;
-            case 14:
-                me->SummonCreature(ENTRY_BOAR, 2078.91f, 1704.54f, 56.77f, 1.54f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 25000);
-                break;
-            case 25:
-                DoScriptText(SAY_THINK, me, player);
-                break;
-            case 31:
-                DoScriptText(SAY_SOON, me, player);
-                break;
-            case 42:
-                DoScriptText(SAY_FINALY, me, player);
-                break;
-            case 43:
-                me->SummonCreature(ENTRY_BOAR, 1956.43f, 1596.97f, 81.75f, 1.54f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 25000);
-                break;
-            case 45:
-                DoScriptText(SAY_WIN, me, player);
-                me->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_QUESTGIVER);
-                if (player && player->GetTypeId() == TYPEID_PLAYER)
-                    CAST_PLR(player)->GroupEventHappens(QUEST_WILLIX_THE_IMPORTER, me);
-                break;
-            case 46:
-                DoScriptText(SAY_END, me, player);
-                break;
-            }
-        }
-
-        void Reset() {}
-
-        void EnterCombat(Unit* /*who*/)
-        {
-            DoScriptText(SAY_AGGRO1, me, NULL);
-        }
-
-        void JustSummoned(Creature* summoned)
-        {
-            summoned->AI()->AttackStart(me);
-        }
-
-        void JustDied(Unit* /*killer*/)
-        {
-            if (Player* player = GetPlayerForEscort())
-                CAST_PLR(player)->FailQuest(QUEST_WILLIX_THE_IMPORTER);
-        }
-    };
-
-};
-
-void AddSC_razorfen_kraul()
-{
-    new npc_willix();
-}
+/*
+ * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2006-2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* ScriptData
+SDName: Razorfen Kraul
+SD%Complete: 100
+SDComment: Quest support: 1144
+SDCategory: Razorfen Kraul
+EndScriptData */
+
+/* ContentData
+npc_willix
+EndContentData */
+
+#include "ScriptPCH.h"
+#include "ScriptedEscortAI.h"
+#include "razorfen_kraul.h"
+
+#define SAY_READY -1047000
+#define SAY_POINT -1047001
+#define SAY_AGGRO1 -1047002
+#define SAY_BLUELEAF -1047003
+#define SAY_DANGER -1047004
+#define SAY_BAD -1047005
+#define SAY_THINK -1047006
+#define SAY_SOON -1047007
+#define SAY_FINALY -1047008
+#define SAY_WIN -1047009
+#define SAY_END -1047010
+
+#define QUEST_WILLIX_THE_IMPORTER 1144
+#define ENTRY_BOAR 4514
+
+class npc_willix : public CreatureScript
+{
+public:
+    npc_willix() : CreatureScript("npc_willix") { }
+
+    bool OnQuestAccept(Player* player, Creature* creature, Quest const* quest)
+    {
+        if (quest->GetQuestId() == QUEST_WILLIX_THE_IMPORTER)
+        {
+            CAST_AI(npc_escortAI, (creature->AI()))->Start(true, false, player->GetGUID());
+            DoScriptText(SAY_READY, creature, player);
+            creature->setFaction(113);
+        }
+
+        return true;
+    }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new npc_willixAI(creature);
+    }
+
+    struct npc_willixAI : public npc_escortAI
+    {
+        npc_willixAI(Creature* creature) : npc_escortAI(creature) {}
+
+        void WaypointReached(uint32 waypointId)
+        {
+            Player* player = GetPlayerForEscort();
+            if (!player)
+                return;
+
+            switch (waypointId)
+            {
+                case 3:
+                    me->HandleEmoteCommand(EMOTE_STATE_POINT);
+                    DoScriptText(SAY_POINT, me, player);
+                    break;
+                case 4:
+                    me->SummonCreature(ENTRY_BOAR, 2137.66f, 1843.98f, 48.08f, 1.54f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 25000);
+                    break;
+                case 8:
+                    DoScriptText(SAY_BLUELEAF, me, player);
+                    break;
+                case 9:
+                    DoScriptText(SAY_DANGER, me, player);
+                    break;
+                case 13:
+                    DoScriptText(SAY_BAD, me, player);
+                    break;
+                case 14:
+                    me->SummonCreature(ENTRY_BOAR, 2078.91f, 1704.54f, 56.77f, 1.54f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 25000);
+                    break;
+                case 25:
+                    DoScriptText(SAY_THINK, me, player);
+                    break;
+                case 31:
+                    DoScriptText(SAY_SOON, me, player);
+                    break;
+                case 42:
+                    DoScriptText(SAY_FINALY, me, player);
+                    break;
+                case 43:
+                    me->SummonCreature(ENTRY_BOAR, 1956.43f, 1596.97f, 81.75f, 1.54f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 25000);
+                    break;
+                case 45:
+                    DoScriptText(SAY_WIN, me, player);
+                    me->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_QUESTGIVER);
+                    if (player->GetTypeId() == TYPEID_PLAYER)
+                        CAST_PLR(player)->GroupEventHappens(QUEST_WILLIX_THE_IMPORTER, me);
+                    break;
+                case 46:
+                    DoScriptText(SAY_END, me, player);
+                    break;
+            }
+        }
+
+        void Reset() {}
+
+        void EnterCombat(Unit* /*who*/)
+        {
+            DoScriptText(SAY_AGGRO1, me, NULL);
+        }
+
+        void JustSummoned(Creature* summoned)
+        {
+            summoned->AI()->AttackStart(me);
+        }
+
+        void JustDied(Unit* /*killer*/)
+        {
+            if (Player* player = GetPlayerForEscort())
+                CAST_PLR(player)->FailQuest(QUEST_WILLIX_THE_IMPORTER);
+        }
+    };
+
+};
+
+void AddSC_razorfen_kraul()
+{
+    new npc_willix();
+}
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/RazorfenKraul/razorfen_kraul.h
--- a/src/server/scripts/Kalimdor/RazorfenKraul/razorfen_kraul.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/RazorfenKraul/razorfen_kraul.h	Mon Apr 16 14:29:17 2012 +0300
@@ -1,23 +1,23 @@
-/*
- * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
- * Copyright (C) 2006-2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef DEF_RAZORFEN_KRAUL_H
-#define DEF_RAZORFEN_KRAUL_H
-
-#define EVENT_WARD_KEEPER 1
-#endif
+/*
+ * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2006-2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef DEF_RAZORFEN_KRAUL_H
+#define DEF_RAZORFEN_KRAUL_H
+
+#define EVENT_WARD_KEEPER 1
+#endif
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/RuinsOfAhnQiraj/boss_moam.cpp
--- a/src/server/scripts/Kalimdor/RuinsOfAhnQiraj/boss_moam.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/RuinsOfAhnQiraj/boss_moam.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -147,7 +147,7 @@
                                         targetList.push_back((*itr)->getTarget());
                             }
 
-                            Trinity::RandomResizeList(targetList, 5);
+                            Trinity::Containers::RandomResizeList(targetList, 5);
 
                             for (std::list<Unit*>::iterator itr = targetList.begin(); itr != targetList.end(); ++itr)
                                 DoCast(*itr, SPELL_DRAIN_MANA);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/TempleOfAhnQiraj/boss_bug_trio.cpp
--- a/src/server/scripts/Kalimdor/TempleOfAhnQiraj/boss_bug_trio.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/TempleOfAhnQiraj/boss_bug_trio.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -168,7 +168,7 @@
             Enraged = false;
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (instance)
             {
@@ -261,7 +261,7 @@
             VemDead = false;
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (instance)
             {
@@ -303,8 +303,8 @@
             {
                 if (instance)
                 {
-                    Unit* pKri = Unit::GetUnit((*me), instance->GetData64(DATA_KRI));
-                    Unit* pVem = Unit::GetUnit((*me), instance->GetData64(DATA_VEM));
+                    Unit* pKri = Unit::GetUnit(*me, instance->GetData64(DATA_KRI));
+                    Unit* pVem = Unit::GetUnit(*me, instance->GetData64(DATA_VEM));
 
                     switch (urand(0, 2))
                     {
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/TempleOfAhnQiraj/boss_cthun.cpp
--- a/src/server/scripts/Kalimdor/TempleOfAhnQiraj/boss_cthun.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/TempleOfAhnQiraj/boss_cthun.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -950,7 +950,7 @@
         uint32 KillSelfTimer;
         uint64 Portal;
 
-        void JustDied(Unit* /*who*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (Unit* p = Unit::GetUnit(*me, Portal))
                 p->Kill(p);
@@ -1026,7 +1026,7 @@
         uint32 EvadeTimer;
         uint64 Portal;
 
-        void JustDied(Unit* /*who*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (Unit* p = Unit::GetUnit(*me, Portal))
                 p->Kill(p);
@@ -1137,7 +1137,7 @@
         uint32 EvadeTimer;
         uint64 Portal;
 
-        void JustDied(Unit* /*who*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (Unit* p = Unit::GetUnit(*me, Portal))
                 p->Kill(p);
@@ -1253,7 +1253,7 @@
         uint32 BeamTimer;
         uint64 Portal;
 
-        void JustDied(Unit* /*who*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (Unit* p = Unit::GetUnit(*me, Portal))
                 p->Kill(p);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/TempleOfAhnQiraj/boss_sartura.cpp
--- a/src/server/scripts/Kalimdor/TempleOfAhnQiraj/boss_sartura.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/TempleOfAhnQiraj/boss_sartura.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -84,7 +84,7 @@
             DoScriptText(SAY_AGGRO, me);
         }
 
-         void JustDied(Unit* /*Killer*/)
+         void JustDied(Unit* /*killer*/)
          {
              DoScriptText(SAY_DEATH, me);
          }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/TempleOfAhnQiraj/boss_skeram.cpp
--- a/src/server/scripts/Kalimdor/TempleOfAhnQiraj/boss_skeram.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/TempleOfAhnQiraj/boss_skeram.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -105,7 +105,7 @@
             DoScriptText(RAND(SAY_SLAY1, SAY_SLAY2, SAY_SLAY3), me);
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (!IsImage)
                 DoScriptText(SAY_DEATH, me);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/TempleOfAhnQiraj/boss_twinemperors.cpp
--- a/src/server/scripts/Kalimdor/TempleOfAhnQiraj/boss_twinemperors.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/TempleOfAhnQiraj/boss_twinemperors.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -120,7 +120,7 @@
         }
     }
 
-    void JustDied(Unit* /*Killer*/)
+    void JustDied(Unit* /*killer*/)
     {
         Creature* pOtherBoss = GetOtherBoss();
         if (pOtherBoss)
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/TempleOfAhnQiraj/mob_anubisath_sentinel.cpp
--- a/src/server/scripts/Kalimdor/TempleOfAhnQiraj/mob_anubisath_sentinel.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/TempleOfAhnQiraj/mob_anubisath_sentinel.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -242,7 +242,7 @@
             DoZoneInCombat();
         }
 
-        void JustDied(Unit* /*who*/)
+        void JustDied(Unit* /*killer*/)
         {
             for (int ni=0; ni<3; ++ni)
             {
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/WailingCaverns/wailing_caverns.cpp
--- a/src/server/scripts/Kalimdor/WailingCaverns/wailing_caverns.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/WailingCaverns/wailing_caverns.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -151,35 +151,35 @@
         uint32 eventProgress;
         InstanceScript* instance;
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             if (!instance)
                 return;
 
-            switch (i)
+            switch (waypointId)
             {
                 case 4:
                     eventProgress = 1;
                     currentEvent = TYPE_NARALEX_PART1;
                     instance->SetData(TYPE_NARALEX_PART1, IN_PROGRESS);
-                break;
+                    break;
                 case 5:
                     DoScriptText(SAY_MUST_CONTINUE, me);
                     instance->SetData(TYPE_NARALEX_PART1, DONE);
-                break;
+                    break;
                 case 11:
                     eventProgress = 1;
                     currentEvent = TYPE_NARALEX_PART2;
                     instance->SetData(TYPE_NARALEX_PART2, IN_PROGRESS);
-                break;
+                    break;
                 case 19:
                     DoScriptText(SAY_BEYOND_THIS_CORRIDOR, me);
-                break;
+                    break;
                 case 24:
                     eventProgress = 1;
                     currentEvent = TYPE_NARALEX_PART3;
                     instance->SetData(TYPE_NARALEX_PART3, IN_PROGRESS);
-                break;
+                    break;
             }
         }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/ZulFarrak/zulfarrak.cpp
--- a/src/server/scripts/Kalimdor/ZulFarrak/zulfarrak.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/ZulFarrak/zulfarrak.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -322,7 +322,7 @@
             AttackStartCaster(victim, 10);//keep back & toss bombs/shoot
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             /*if (instance)
                 instance->SetData(0, DONE);*/
@@ -399,9 +399,9 @@
 
 enum
 {
-    ZOMBIE = 7286,
-    DEAD_HERO = 7276,
-    ZOMBIE_CHANCE = 65,
+    ZOMBIE           = 7286,
+    DEAD_HERO        = 7276,
+    ZOMBIE_CHANCE    = 65,
     DEAD_HERO_CHANCE = 10
 };
 
@@ -419,13 +419,12 @@
             if (randomchance < ZOMBIE_CHANCE)
                 go->SummonCreature(ZOMBIE, go->GetPositionX(), go->GetPositionY(), go->GetPositionZ(), 0, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 30000);
             else
-                if ((randomchance-ZOMBIE_CHANCE) < DEAD_HERO_CHANCE)
+                if ((randomchance - ZOMBIE_CHANCE) < DEAD_HERO_CHANCE)
                     go->SummonCreature(DEAD_HERO, go->GetPositionX(), go->GetPositionY(), go->GetPositionZ(), 0, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 30000);
         }
         go->AddUse();
         return false;
     }
-
 };
 
 /*######
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/ashenvale.cpp
--- a/src/server/scripts/Kalimdor/ashenvale.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/ashenvale.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -76,36 +76,34 @@
             uint32 Thunderclap_Timer;
             bool Completed;
 
-            void WaypointReached(uint32 i)
+            void WaypointReached(uint32 waypointId)
             {
                 Player* player = GetPlayerForEscort();
-
                 if (!player)
                     return;
 
-                switch (i)
+                switch (waypointId)
                 {
-                case 1:
-                    Talk(SAY_MOVE, player->GetGUID());
-                    break;
-                case 8:
-                    Talk(SAY_PREPARE, player->GetGUID());
-                    break;
-                case 19:
-                    //TODO: verify location and creatures amount.
-                    me->SummonCreature(ENTRY_DURIEL, 1776.73f, -2049.06f, 109.83f, 1.54f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 25000);
-                    me->SummonCreature(ENTRY_SILVERWING_SENTINEL, 1774.64f, -2049.41f, 109.83f, 1.40f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 25000);
-                    me->SummonCreature(ENTRY_SILVERWING_WARRIOR, 1778.73f, -2049.50f, 109.83f, 1.67f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 25000);
-                    break;
-                case 20:
-                    DoScriptText(SAY_WIN, me, player);
-                    Completed = true;
-                    if (player)
+                    case 1:
+                        Talk(SAY_MOVE, player->GetGUID());
+                        break;
+                    case 8:
+                        Talk(SAY_PREPARE, player->GetGUID());
+                        break;
+                    case 19:
+                        //TODO: verify location and creatures amount.
+                        me->SummonCreature(ENTRY_DURIEL, 1776.73f, -2049.06f, 109.83f, 1.54f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 25000);
+                        me->SummonCreature(ENTRY_SILVERWING_SENTINEL, 1774.64f, -2049.41f, 109.83f, 1.40f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 25000);
+                        me->SummonCreature(ENTRY_SILVERWING_WARRIOR, 1778.73f, -2049.50f, 109.83f, 1.67f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 25000);
+                        break;
+                    case 20:
+                        DoScriptText(SAY_WIN, me, player);
+                        Completed = true;
                         player->GroupEventHappens(QUEST_TOREK_ASSULT, me);
-                    break;
-                case 21:
-                    Talk(SAY_END, player->GetGUID());
-                    break;
+                        break;
+                    case 21:
+                        Talk(SAY_END, player->GetGUID());
+                        break;
                 }
             }
 
@@ -177,47 +175,38 @@
 class npc_ruul_snowhoof : public CreatureScript
 {
     public:
-
-        npc_ruul_snowhoof()
-            : CreatureScript("npc_ruul_snowhoof")
-        {
-        }
+        npc_ruul_snowhoof() : CreatureScript("npc_ruul_snowhoof") { }
 
         struct npc_ruul_snowhoofAI : public npc_escortAI
         {
-            npc_ruul_snowhoofAI(Creature* creature) : npc_escortAI(creature) {}
+            npc_ruul_snowhoofAI(Creature* creature) : npc_escortAI(creature) { }
 
-            void WaypointReached(uint32 i)
+            void WaypointReached(uint32 waypointId)
             {
                 Player* player = GetPlayerForEscort();
-
                 if (!player)
                     return;
 
-                switch (i)
+                switch (waypointId)
                 {
-                case 0:    {
+                    case 0:
                         me->SetUInt32Value(UNIT_FIELD_BYTES_1, 0);
-                        GameObject* Cage = me->FindNearestGameObject(GO_CAGE, 20);
-                        if (Cage)
+                        if (GameObject* Cage = me->FindNearestGameObject(GO_CAGE, 20))
                             Cage->SetGoState(GO_STATE_ACTIVE);
-                        break;}
-                case 13:
+                        break;
+                    case 13:
                         me->SummonCreature(3922, 3449.218018f, -587.825073f, 174.978867f, 4.714445f, TEMPSUMMON_DEAD_DESPAWN, 60000);
                         me->SummonCreature(3921, 3446.384521f, -587.830872f, 175.186279f, 4.714445f, TEMPSUMMON_DEAD_DESPAWN, 60000);
                         me->SummonCreature(3926, 3444.218994f, -587.835327f, 175.380600f, 4.714445f, TEMPSUMMON_DEAD_DESPAWN, 60000);
                         break;
-                case 19:
+                    case 19:
                         me->SummonCreature(3922, 3508.344482f, -492.024261f, 186.929031f, 4.145029f, TEMPSUMMON_DEAD_DESPAWN, 60000);
                         me->SummonCreature(3921, 3506.265625f, -490.531006f, 186.740128f, 4.239277f, TEMPSUMMON_DEAD_DESPAWN, 60000);
                         me->SummonCreature(3926, 3503.682373f, -489.393799f, 186.629684f, 4.349232f, TEMPSUMMON_DEAD_DESPAWN, 60000);
                         break;
-
-                case 21:{
-                        if (player)
-                            player->GroupEventHappens(QUEST_FREEDOM_TO_RUUL, me);
-
-                        break;  }
+                    case 21:
+                        player->GroupEventHappens(QUEST_FREEDOM_TO_RUUL, me);
+                        break;
                 }
             }
 
@@ -323,11 +312,11 @@
                 summoned->AI()->AttackStart(me);
             }
 
-            void WaypointReached(uint32 i)
+            void WaypointReached(uint32 waypointId)
             {
                 Player* player = GetPlayerForEscort();
 
-                switch (i)
+                switch (waypointId)
                 {
                     case 0:
                         if (player)
@@ -345,9 +334,7 @@
                         break;
                     case 25:
                         DoScriptText(SAY_MUG_GRATITUDE, me);
-
-                        if (player)
-                            player->GroupEventHappens(QUEST_VORSHA, me);
+                        player->GroupEventHappens(QUEST_VORSHA, me);
                         break;
                     case 26:
                         DoScriptText(SAY_MUG_PATROL, me);
@@ -378,14 +365,9 @@
 
             void JustDied(Unit* /*killer*/)
             {
-                Player* player = GetPlayerForEscort();
                 if (HasEscortState(STATE_ESCORT_ESCORTING))
-                {
-                    if (player)
-                    {
+                    if (Player* player = GetPlayerForEscort())
                         player->FailQuest(QUEST_VORSHA);
-                    }
-                }
             }
 
             void DoWaveSummon()
@@ -459,11 +441,7 @@
 class go_naga_brazier : public GameObjectScript
 {
     public:
-
-        go_naga_brazier()
-            : GameObjectScript("go_naga_brazier")
-        {
-        }
+        go_naga_brazier() : GameObjectScript("go_naga_brazier") { }
 
         bool OnGossipHello(Player* /*player*/, GameObject* go)
         {
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/azuremyst_isle.cpp
--- a/src/server/scripts/Kalimdor/azuremyst_isle.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/azuremyst_isle.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -374,29 +374,28 @@
     {
         npc_magwinAI(Creature* creature) : npc_escortAI(creature) {}
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
-
             if (!player)
                 return;
 
-            switch (i)
+            switch (waypointId)
             {
-            case 0:
-                DoScriptText(SAY_START, me, player);
-                break;
-            case 17:
-                DoScriptText(SAY_PROGRESS, me, player);
-                break;
-            case 28:
-                DoScriptText(SAY_END1, me, player);
-                break;
-            case 29:
-                DoScriptText(EMOTE_HUG, me, player);
-                DoScriptText(SAY_END2, me, player);
-                player->GroupEventHappens(QUEST_A_CRY_FOR_SAY_HELP, me);
-                break;
+                case 0:
+                    DoScriptText(SAY_START, me, player);
+                    break;
+                case 17:
+                    DoScriptText(SAY_PROGRESS, me, player);
+                    break;
+                case 28:
+                    DoScriptText(SAY_END1, me, player);
+                    break;
+                case 29:
+                    DoScriptText(EMOTE_HUG, me, player);
+                    DoScriptText(SAY_END2, me, player);
+                    player->GroupEventHappens(QUEST_A_CRY_FOR_SAY_HELP, me);
+                    break;
             }
         }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/bloodmyst_isle.cpp
--- a/src/server/scripts/Kalimdor/bloodmyst_isle.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/bloodmyst_isle.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -59,7 +59,7 @@
         {
         }
 
-        void JustDied(Unit* Killer)
+        void JustDied(Unit* killer)
         {
             uint32 spawnCreatureID = 0;
 
@@ -67,8 +67,8 @@
             {
                 case 0:
                     spawnCreatureID = 17681;
-                    if (Killer->GetTypeId() == TYPEID_PLAYER)
-                        CAST_PLR(Killer)->KilledMonsterCredit(spawnCreatureID, 0);
+                    if (Player* player = killer->ToPlayer())
+                        player->KilledMonsterCredit(spawnCreatureID, 0);
                     break;
                 case 1:
                 case 2:
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/boss_azuregos.cpp
--- a/src/server/scripts/Kalimdor/boss_azuregos.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/boss_azuregos.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -87,7 +87,7 @@
                 std::list<HostileReference*>::const_iterator i = m_threatlist.begin();
                 for (i = m_threatlist.begin(); i!= m_threatlist.end(); ++i)
                 {
-                    Unit* unit = Unit::GetUnit((*me), (*i)->getUnitGuid());
+                    Unit* unit = Unit::GetUnit(*me, (*i)->getUnitGuid());
                     if (unit && (unit->GetTypeId() == TYPEID_PLAYER))
                     {
                         DoTeleportPlayer(unit, me->GetPositionX(), me->GetPositionY(), me->GetPositionZ()+3, unit->GetOrientation());
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/darkshore.cpp
--- a/src/server/scripts/Kalimdor/darkshore.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/darkshore.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -231,13 +231,13 @@
     {
         npc_prospector_remtravelAI(Creature* creature) : npc_escortAI(creature) {}
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
             if (!player)
                 return;
 
-            switch (i)
+            switch (waypointId)
             {
                 case 0:
                     DoScriptText(SAY_REM_START, me, player);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/desolace.cpp
--- a/src/server/scripts/Kalimdor/desolace.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/desolace.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -228,17 +228,18 @@
     {
         npc_dalindaAI(Creature* creature) : npc_escortAI(creature) { }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
-            switch (i)
+
+            switch (waypointId)
             {
                 case 1:
                     me->IsStandState();
                     break;
                 case 15:
                     if (player)
-                    player->GroupEventHappens(QUEST_RETURN_TO_VAHLARRIEL, me);
+                        player->GroupEventHappens(QUEST_RETURN_TO_VAHLARRIEL, me);
                     break;
             }
         }
@@ -249,8 +250,7 @@
 
         void JustDied(Unit* /*killer*/)
         {
-            Player* player = GetPlayerForEscort();
-            if (player)
+            if (Player* player = GetPlayerForEscort())
                 player->FailQuest(QUEST_RETURN_TO_VAHLARRIEL);
             return;
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/dustwallow_marsh.cpp
--- a/src/server/scripts/Kalimdor/dustwallow_marsh.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/dustwallow_marsh.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -607,49 +607,48 @@
     {
        npc_stinkyAI(Creature* creature) : npc_escortAI(creature) { }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
             if (!player)
                 return;
 
-            switch (i)
+            switch (waypointId)
             {
-            case 7:
-                DoScriptText(SAY_STAY_1, me, player);
-                break;
-            case 11:
-                DoScriptText(SAY_STAY_2, me, player);
-                break;
-            case 25:
-                DoScriptText(SAY_STAY_3, me, player);
-                break;
-            case 26:
-                DoScriptText(SAY_STAY_4, me, player);
-                break;
-            case 27:
-                DoScriptText(SAY_STAY_5, me, player);
-                break;
-            case 28:
-                DoScriptText(SAY_STAY_6, me, player);
-                me->SetStandState(UNIT_STAND_STATE_KNEEL);
-                break;
-            case 29:
-                me->SetStandState(UNIT_STAND_STATE_STAND);
-                break;
-            case 37:
-                DoScriptText(SAY_QUEST_COMPLETE, me, player);
-                me->SetSpeed(MOVE_RUN, 1.2f, true);
-                me->SetWalk(false);
-                if (player && player->GetQuestStatus(QUEST_STINKYS_ESCAPE_H))
-                    player->GroupEventHappens(QUEST_STINKYS_ESCAPE_H, me);
-                if (player && player->GetQuestStatus(QUEST_STINKYS_ESCAPE_A))
-                    player->GroupEventHappens(QUEST_STINKYS_ESCAPE_A, me);
-                break;
-            case 39:
-                DoScriptText(EMOTE_DISAPPEAR, me);
-                break;
-
+                case 7:
+                    DoScriptText(SAY_STAY_1, me, player);
+                    break;
+                case 11:
+                    DoScriptText(SAY_STAY_2, me, player);
+                    break;
+                case 25:
+                    DoScriptText(SAY_STAY_3, me, player);
+                    break;
+                case 26:
+                    DoScriptText(SAY_STAY_4, me, player);
+                    break;
+                case 27:
+                    DoScriptText(SAY_STAY_5, me, player);
+                    break;
+                case 28:
+                    DoScriptText(SAY_STAY_6, me, player);
+                    me->SetStandState(UNIT_STAND_STATE_KNEEL);
+                    break;
+                case 29:
+                    me->SetStandState(UNIT_STAND_STATE_STAND);
+                    break;
+                case 37:
+                    DoScriptText(SAY_QUEST_COMPLETE, me, player);
+                    me->SetSpeed(MOVE_RUN, 1.2f, true);
+                    me->SetWalk(false);
+                    if (player->GetQuestStatus(QUEST_STINKYS_ESCAPE_H))
+                        player->GroupEventHappens(QUEST_STINKYS_ESCAPE_H, me);
+                    if (player->GetQuestStatus(QUEST_STINKYS_ESCAPE_A))
+                        player->GroupEventHappens(QUEST_STINKYS_ESCAPE_A, me);
+                    break;
+                case 39:
+                    DoScriptText(EMOTE_DISAPPEAR, me);
+                    break;
             }
         }
 
@@ -663,10 +662,11 @@
         void JustDied(Unit* /*killer*/)
         {
             Player* player = GetPlayerForEscort();
-            if (HasEscortState(STATE_ESCORT_ESCORTING) && player)
+            if (player && HasEscortState(STATE_ESCORT_ESCORTING))
             {
                 if (player->GetQuestStatus(QUEST_STINKYS_ESCAPE_H))
                     player->FailQuest(QUEST_STINKYS_ESCAPE_H);
+
                 if (player->GetQuestStatus(QUEST_STINKYS_ESCAPE_A))
                     player->FailQuest(QUEST_STINKYS_ESCAPE_A);
             }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/feralas.cpp
--- a/src/server/scripts/Kalimdor/feralas.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/feralas.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -124,9 +124,9 @@
     {
         npc_oox22feAI(Creature* creature) : npc_escortAI(creature) { }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
-            switch (i)
+            switch (waypointId)
             {
                 // First Ambush(3 Yetis)
                 case 11:
@@ -154,9 +154,7 @@
                     DoScriptText(SAY_OOX_END, me);
                     // Award quest credit
                     if (Player* player = GetPlayerForEscort())
-                    {
-                            player->GroupEventHappens(QUEST_RESCUE_OOX22FE, me);
-                    }
+                        player->GroupEventHappens(QUEST_RESCUE_OOX22FE, me);
                     break;
             }
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/moonglade.cpp
--- a/src/server/scripts/Kalimdor/moonglade.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/moonglade.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -537,9 +537,9 @@
             } else if (Event_onWait) Event_Timer -= diff;
         }
 
-        void WaypointReached(uint32 id)
+        void WaypointReached(uint32 waypointId)
         {
-            CurrWP = id;
+            CurrWP = waypointId;
             Event_Timer = 0;
             Step = 0;
             Event_onWait = true;
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/silithus.cpp
--- a/src/server/scripts/Kalimdor/silithus.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/silithus.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -373,8 +373,13 @@
     {0, 0, 0}
 };
 
+struct Location
+{
+   float x, y, z, o;
+};
+
 //Cordinates for Spawns
-static const Position SpawnLocation[]=
+static Location SpawnLocation[]=
 {
     {-8085.0f, 1528.0f, 2.61f, 3.141592f}, //Kaldorei Infantry
     {-8080.0f, 1526.0f, 2.61f, 3.141592f}, //Kaldorei Infantry
@@ -485,9 +490,9 @@
 public:
     npc_anachronos_the_ancient() : CreatureScript("npc_anachronos_the_ancient") { }
 
-    CreatureAI* GetAI(Creature* c) const
+    CreatureAI* GetAI(Creature* creature) const
     {
-        return new npc_anachronos_the_ancientAI(c);
+        return new npc_anachronos_the_ancientAI(creature);
     }
 
     struct npc_anachronos_the_ancientAI : public ScriptedAI
@@ -813,9 +818,9 @@
 public:
     mob_qiraj_war_spawn() : CreatureScript("mob_qiraj_war_spawn") { }
 
-    CreatureAI* GetAI(Creature* c) const
+    CreatureAI* GetAI(Creature* creature) const
     {
-        return new mob_qiraj_war_spawnAI(c);
+        return new mob_qiraj_war_spawnAI(creature);
     }
 
     struct mob_qiraj_war_spawnAI : public ScriptedAI
@@ -928,9 +933,9 @@
 public:
     npc_anachronos_quest_trigger() : CreatureScript("npc_anachronos_quest_trigger") { }
 
-    CreatureAI* GetAI(Creature* c) const
+    CreatureAI* GetAI(Creature* creature) const
     {
-        return new npc_anachronos_quest_triggerAI(c);
+        return new npc_anachronos_quest_triggerAI(creature);
     }
 
     struct npc_anachronos_quest_triggerAI : public ScriptedAI
@@ -967,16 +972,19 @@
 
         void SummonNextWave()
         {
-            //uint8 count = WavesInfo[WaveCount].SpawnCount;
             uint8 locIndex = WavesInfo[WaveCount].UsedSpawnPoint;
-            //uint8 KaldoreiSoldierCount = 0;
-            //uint8 AnubisathConquerorCount = 0;
-            //uint8 QirajiWaspCount = 0;
-            for (uint8 i = 0; i < 67; ++i)
+            uint8 count = locIndex + WavesInfo[WaveCount].SpawnCount;
+
+            for (uint8 i = locIndex; i <= count; ++i)
             {
-                if (Creature* spawn = me->SummonCreature(WavesInfo[WaveCount].CreatureId, SpawnLocation[locIndex + i], TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, WavesInfo[WaveCount].DespTimer))
+                float x = SpawnLocation[i].x;
+                float y = SpawnLocation[i].y;
+                float z = SpawnLocation[i].z;
+                float o = SpawnLocation[i].o;
+                uint32 desptimer = WavesInfo[WaveCount].DespTimer;
+
+                if (Creature* spawn = me->SummonCreature(WavesInfo[WaveCount].CreatureId, x, y, z, o, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, desptimer))
                 {
-                    spawn->LoadCreaturesAddon();
                     if (spawn->GetEntry() == 15423)
                         spawn->SetUInt32Value(UNIT_FIELD_DISPLAYID, 15427+rand()%4);
                     if (i >= 30) WaveCount = 1;
@@ -986,12 +994,15 @@
 
                     if (WaveCount < 5) //1-4 Wave
                     {
-                        mob_qiraj_war_spawn::mob_qiraj_war_spawnAI* spawnAI = CAST_AI(mob_qiraj_war_spawn::mob_qiraj_war_spawnAI, spawn->AI());
-                        spawnAI->MobGUID = me->GetGUID();
-                        spawnAI->PlayerGUID = PlayerGUID;
+                        if (mob_qiraj_war_spawn::mob_qiraj_war_spawnAI* spawnAI = CAST_AI(mob_qiraj_war_spawn::mob_qiraj_war_spawnAI, spawn->AI()))
+                        {
+                            spawnAI->MobGUID = me->GetGUID();
+                            spawnAI->PlayerGUID = PlayerGUID;
+                        }
                     }
                 }
             }
+
             WaveTimer = WavesInfo[WaveCount].SpawnTimer;
             AnnounceTimer = WavesInfo[WaveCount].YellTimer;
         }
@@ -1005,27 +1016,27 @@
 
             if (Group* EventGroup = player->GetGroup())
             {
-                Player* GroupMember;
+                Player* groupMember;
 
                 uint8 GroupMemberCount = 0;
                 uint8 DeadMemberCount = 0;
                 uint8 FailedMemberCount = 0;
 
-                const Group::MemberSlotList members = EventGroup->GetMemberSlots();
+                Group::MemberSlotList const members = EventGroup->GetMemberSlots();
 
                 for (Group::member_citerator itr = members.begin(); itr!= members.end(); ++itr)
                 {
-                    GroupMember = (Unit::GetPlayer(*me, itr->guid));
-                    if (!GroupMember)
+                    groupMember = (Unit::GetPlayer(*me, itr->guid));
+                    if (!groupMember)
                         continue;
-                    if (!GroupMember->IsWithinDistInMap(me, EVENT_AREA_RADIUS) && GroupMember->GetQuestStatus(QUEST_A_PAWN_ON_THE_ETERNAL_BOARD) == QUEST_STATUS_INCOMPLETE)
+                    if (!groupMember->IsWithinDistInMap(me, EVENT_AREA_RADIUS) && groupMember->GetQuestStatus(QUEST_A_PAWN_ON_THE_ETERNAL_BOARD) == QUEST_STATUS_INCOMPLETE)
                     {
-                         GroupMember->FailQuest(QUEST_A_PAWN_ON_THE_ETERNAL_BOARD);
+                         groupMember->FailQuest(QUEST_A_PAWN_ON_THE_ETERNAL_BOARD);
                         ++FailedMemberCount;
                     }
                     ++GroupMemberCount;
 
-                    if (GroupMember->isDead())
+                    if (groupMember->isDead())
                         ++DeadMemberCount;
                 }
 
@@ -1069,8 +1080,13 @@
 void mob_qiraj_war_spawn::mob_qiraj_war_spawnAI::JustDied(Unit* /*slayer*/)
 {
     me->RemoveCorpse();
-    if (Creature* Mob = (Unit::GetCreature(*me, MobGUID)))
-        CAST_AI(npc_anachronos_quest_trigger::npc_anachronos_quest_triggerAI, Mob->AI())->LiveCounter();
+
+    if (!MobGUID)
+        return;
+
+    if (Creature* mob = Unit::GetCreature(*me, MobGUID))
+        if (npc_anachronos_quest_trigger::npc_anachronos_quest_triggerAI* triggerAI = CAST_AI(npc_anachronos_quest_trigger::npc_anachronos_quest_triggerAI, mob->AI()))
+            triggerAI->LiveCounter();
 
 };
 
@@ -1087,15 +1103,13 @@
     {
         if (quest->GetQuestId() == QUEST_A_PAWN_ON_THE_ETERNAL_BOARD)
         {
-
-            if (Unit* Anachronos_Quest_Trigger = go->FindNearestCreature(15454, 100, player))
+            if (Creature* trigger = go->FindNearestCreature(15454, 100, player))
             {
-
-                Unit* Merithra = Anachronos_Quest_Trigger->SummonCreature(15378, -8034.535f, 1535.14f, 2.61f, 0, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 220000);
-                Unit* Caelestrasz = Anachronos_Quest_Trigger->SummonCreature(15379, -8032.767f, 1533.148f, 2.61f, 1.5f, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 220000);
-                Unit* Arygos = Anachronos_Quest_Trigger->SummonCreature(15380, -8034.52f, 1537.843f, 2.61f, 5.7f, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 220000);
-                /* Unit* Fandral = */ Anachronos_Quest_Trigger->SummonCreature(15382, -8028.462f, 1535.843f, 2.61f, 3.141592f, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 220000);
-                Creature* Anachronos = Anachronos_Quest_Trigger->SummonCreature(15381, -8028.75f, 1538.795f, 2.61f, 4, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 220000);
+                Unit* Merithra = trigger->SummonCreature(15378, -8034.535f, 1535.14f, 2.61f, 0, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 220000);
+                Unit* Caelestrasz = trigger->SummonCreature(15379, -8032.767f, 1533.148f, 2.61f, 1.5f, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 220000);
+                Unit* Arygos = trigger->SummonCreature(15380, -8034.52f, 1537.843f, 2.61f, 5.7f, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 220000);
+                /* Unit* Fandral = */ trigger->SummonCreature(15382, -8028.462f, 1535.843f, 2.61f, 3.141592f, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 220000);
+                Creature* Anachronos = trigger->SummonCreature(15381, -8028.75f, 1538.795f, 2.61f, 4, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 220000);
 
                 if (Merithra)
                 {
@@ -1123,11 +1137,16 @@
 
                 if (Anachronos)
                 {
-                    CAST_AI(npc_anachronos_the_ancient::npc_anachronos_the_ancientAI, Anachronos->AI())->PlayerGUID = player->GetGUID();
-                    CAST_AI(npc_anachronos_quest_trigger::npc_anachronos_quest_triggerAI, CAST_CRE(Anachronos_Quest_Trigger)->AI())->Failed=false;
-                    CAST_AI(npc_anachronos_quest_trigger::npc_anachronos_quest_triggerAI, CAST_CRE(Anachronos_Quest_Trigger)->AI())->PlayerGUID = player->GetGUID();
-                    CAST_AI(npc_anachronos_quest_trigger::npc_anachronos_quest_triggerAI, CAST_CRE(Anachronos_Quest_Trigger)->AI())->EventStarted=true;
-                    CAST_AI(npc_anachronos_quest_trigger::npc_anachronos_quest_triggerAI, CAST_CRE(Anachronos_Quest_Trigger)->AI())->Announced=true;
+                    if (npc_anachronos_the_ancient::npc_anachronos_the_ancientAI* anachronosAI = CAST_AI(npc_anachronos_the_ancient::npc_anachronos_the_ancientAI, Anachronos->AI()))
+                        anachronosAI->PlayerGUID = player->GetGUID();
+
+                    if (npc_anachronos_quest_trigger::npc_anachronos_quest_triggerAI* triggerAI = CAST_AI(npc_anachronos_quest_trigger::npc_anachronos_quest_triggerAI, trigger->AI()))
+                    {
+                        triggerAI->Failed = false;
+                        triggerAI->PlayerGUID = player->GetGUID();
+                        triggerAI->EventStarted = true;
+                        triggerAI->Announced = true;
+                    }
                 }
             }
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/stonetalon_mountains.cpp
--- a/src/server/scripts/Kalimdor/stonetalon_mountains.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/stonetalon_mountains.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -114,26 +114,25 @@
     {
         npc_kaya_flathoofAI(Creature* creature) : npc_escortAI(creature) {}
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
-
             if (!player)
                 return;
 
-            switch (i)
+            switch (waypointId)
             {
-            case 16:
-                DoScriptText(SAY_AMBUSH, me);
-                me->SummonCreature(NPC_GRIMTOTEM_BRUTE, -48.53f, -503.34f, -46.31f, 0.0f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000);
-                me->SummonCreature(NPC_GRIMTOTEM_RUFFIAN, -38.85f, -503.77f, -45.90f, 0.0f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000);
-                me->SummonCreature(NPC_GRIMTOTEM_SORCERER, -36.37f, -496.23f, -45.71f, 0.0f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000);
-                break;
-            case 18: me->SetInFront(player);
-                DoScriptText(SAY_END, me, player);
-                if (player)
+                case 16:
+                    DoScriptText(SAY_AMBUSH, me);
+                    me->SummonCreature(NPC_GRIMTOTEM_BRUTE, -48.53f, -503.34f, -46.31f, 0.0f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000);
+                    me->SummonCreature(NPC_GRIMTOTEM_RUFFIAN, -38.85f, -503.77f, -45.90f, 0.0f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000);
+                    me->SummonCreature(NPC_GRIMTOTEM_SORCERER, -36.37f, -496.23f, -45.71f, 0.0f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000);
+                    break;
+                case 18:
+                    me->SetInFront(player);
+                    DoScriptText(SAY_END, me, player);
                     player->GroupEventHappens(QUEST_PROTECT_KAYA, me);
-                break;
+                    break;
             }
         }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/tanaris.cpp
--- a/src/server/scripts/Kalimdor/tanaris.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/tanaris.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -172,31 +172,65 @@
     {
         npc_custodian_of_timeAI(Creature* creature) : npc_escortAI(creature) {}
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
             if (!player)
                 return;
 
-            switch (i)
+            switch (waypointId)
             {
-                case 0: DoScriptText(WHISPER_CUSTODIAN_1, me, player); break;
-                case 1: DoScriptText(WHISPER_CUSTODIAN_2, me, player); break;
-                case 2: DoScriptText(WHISPER_CUSTODIAN_3, me, player); break;
-                case 3: DoScriptText(WHISPER_CUSTODIAN_4, me, player); break;
-                case 5: DoScriptText(WHISPER_CUSTODIAN_5, me, player); break;
-                case 6: DoScriptText(WHISPER_CUSTODIAN_6, me, player); break;
-                case 7: DoScriptText(WHISPER_CUSTODIAN_7, me, player); break;
-                case 8: DoScriptText(WHISPER_CUSTODIAN_8, me, player); break;
-                case 9: DoScriptText(WHISPER_CUSTODIAN_9, me, player); break;
-                case 10: DoScriptText(WHISPER_CUSTODIAN_4, me, player); break;
-                case 13: DoScriptText(WHISPER_CUSTODIAN_10, me, player); break;
-                case 14: DoScriptText(WHISPER_CUSTODIAN_4, me, player); break;
-                case 16: DoScriptText(WHISPER_CUSTODIAN_11, me, player); break;
-                case 17: DoScriptText(WHISPER_CUSTODIAN_12, me, player); break;
-                case 18: DoScriptText(WHISPER_CUSTODIAN_4, me, player); break;
-                case 22: DoScriptText(WHISPER_CUSTODIAN_13, me, player); break;
-                case 23: DoScriptText(WHISPER_CUSTODIAN_4, me, player); break;
+                case 0:
+                    DoScriptText(WHISPER_CUSTODIAN_1, me, player);
+                    break;
+                case 1:
+                    DoScriptText(WHISPER_CUSTODIAN_2, me, player);
+                    break;
+                case 2:
+                    DoScriptText(WHISPER_CUSTODIAN_3, me, player);
+                    break;
+                case 3:
+                    DoScriptText(WHISPER_CUSTODIAN_4, me, player);
+                    break;
+                case 5:
+                    DoScriptText(WHISPER_CUSTODIAN_5, me, player);
+                    break;
+                case 6:
+                    DoScriptText(WHISPER_CUSTODIAN_6, me, player);
+                    break;
+                case 7:
+                    DoScriptText(WHISPER_CUSTODIAN_7, me, player);
+                    break;
+                case 8:
+                    DoScriptText(WHISPER_CUSTODIAN_8, me, player);
+                    break;
+                case 9:
+                    DoScriptText(WHISPER_CUSTODIAN_9, me, player);
+                    break;
+                case 10:
+                    DoScriptText(WHISPER_CUSTODIAN_4, me, player);
+                    break;
+                case 13:
+                    DoScriptText(WHISPER_CUSTODIAN_10, me, player);
+                    break;
+                case 14:
+                    DoScriptText(WHISPER_CUSTODIAN_4, me, player);
+                    break;
+                case 16:
+                    DoScriptText(WHISPER_CUSTODIAN_11, me, player);
+                    break;
+                case 17:
+                    DoScriptText(WHISPER_CUSTODIAN_12, me, player);
+                    break;
+                case 18:
+                    DoScriptText(WHISPER_CUSTODIAN_4, me, player);
+                    break;
+                case 22:
+                    DoScriptText(WHISPER_CUSTODIAN_13, me, player);
+                    break;
+                case 23:
+                    DoScriptText(WHISPER_CUSTODIAN_4, me, player);
+                    break;
                 case 24:
                     DoScriptText(WHISPER_CUSTODIAN_14, me, player);
                     DoCast(player, 34883);
@@ -428,21 +462,20 @@
     {
         npc_OOX17AI(Creature* creature) : npc_escortAI(creature) {}
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
-
             if (!player)
                 return;
 
-            switch (i) {
+            switch (waypointId)
+            {
                 case 23:
                     me->SummonCreature(SPAWN_FIRST, -8350.96f, -4445.79f, 10.10f, 6.20f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 25000);
                     me->SummonCreature(SPAWN_FIRST, -8355.96f, -4447.79f, 10.10f, 6.27f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 25000);
                     me->SummonCreature(SPAWN_FIRST, -8353.96f, -4442.79f, 10.10f, 6.08f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 25000);
                     DoScriptText(SAY_OOX_AMBUSH, me);
                     break;
-
                 case 56:
                     me->SummonCreature(SPAWN_SECOND_1, -7510.07f, -4795.50f, 9.35f, 6.06f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 25000);
                     me->SummonCreature(SPAWN_SECOND_2, -7515.07f, -4797.50f, 9.35f, 6.22f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 25000);
@@ -451,13 +484,9 @@
                     if (Unit* scoff = me->FindNearestCreature(SPAWN_SECOND_2, 30))
                         DoScriptText(SAY_OOX17_AMBUSH_REPLY, scoff);
                     break;
-
                 case 86:
-                    if (player)
-                    {
-                        DoScriptText(SAY_OOX_END, me);
-                        player->GroupEventHappens(Q_OOX17, me);
-                    }
+                    DoScriptText(SAY_OOX_END, me);
+                    player->GroupEventHappens(Q_OOX17, me);
                     break;
             }
         }
@@ -474,7 +503,6 @@
             summoned->AI()->AttackStart(me);
         }
     };
-
 };
 
 /*####
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/the_barrens.cpp
--- a/src/server/scripts/Kalimdor/the_barrens.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/the_barrens.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -127,14 +127,13 @@
 
         void Reset() { }
 
-        void WaypointReached(uint32 uiPointId)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
-
             if (!player)
                 return;
 
-            switch (uiPointId)
+            switch (waypointId)
             {
                 case 16:
                     DoScriptText(SAY_GIL_AT_LAST, me, player);
@@ -593,31 +592,26 @@
             }
         }
 
-        void WaypointReached(uint32 uiPointId)
+        void WaypointReached(uint32 waypointId)
         {
-            Player* player = GetPlayerForEscort();
-
-            if (!player)
-                return;
-
-            switch (uiPointId)
+            switch (waypointId)
             {
-            case 0:
-                DoScriptText(SAY_STARTUP1, me);
-                break;
-            case 9:
-                SetRun(false);
-                break;
-            case 17:
-                if (Creature* temp = me->SummonCreature(NPC_MERCENARY, 1128.489f, -3037.611f, 92.701f, 1.472f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 120000))
-                {
-                    DoScriptText(SAY_MERCENARY, temp);
-                    me->SummonCreature(NPC_MERCENARY, 1160.172f, -2980.168f, 97.313f, 3.690f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 120000);
-                }
-                break;
-            case 24:
-                m_bIsPostEvent = true;
-                break;
+                case 0:
+                    DoScriptText(SAY_STARTUP1, me);
+                    break;
+                case 9:
+                    SetRun(false);
+                    break;
+                case 17:
+                    if (Creature* temp = me->SummonCreature(NPC_MERCENARY, 1128.489f, -3037.611f, 92.701f, 1.472f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 120000))
+                    {
+                        DoScriptText(SAY_MERCENARY, temp);
+                        me->SummonCreature(NPC_MERCENARY, 1160.172f, -2980.168f, 97.313f, 3.690f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 120000);
+                    }
+                    break;
+                case 24:
+                    m_bIsPostEvent = true;
+                    break;
             }
         }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/thousand_needles.cpp
--- a/src/server/scripts/Kalimdor/thousand_needles.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/thousand_needles.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -75,9 +75,9 @@
 
         void Reset() { }
 
-        void WaypointReached(uint32 uiPointId)
+        void WaypointReached(uint32 waypointId)
         {
-            switch (uiPointId)
+            switch (waypointId)
             {
                 case 0:
                     DoScriptText(SAY_KAN_START, me);
@@ -166,9 +166,9 @@
 
         void Reset() { }
 
-        void WaypointReached(uint32 uiPointId)
+        void WaypointReached(uint32 waypointId)
         {
-            switch (uiPointId)
+            switch (waypointId)
             {
                 case 8:
                     DoScriptText(SAY_LAKO_LOOK_OUT, me);
@@ -251,9 +251,9 @@
 
         void Reset() { }
 
-        void WaypointReached(uint32 uiPointId)
+        void WaypointReached(uint32 waypointId)
         {
-            switch (uiPointId)
+            switch (waypointId)
             {
                 case 15:
                     DoScriptText(SAY_WYVERN, me);
@@ -277,7 +277,6 @@
                 TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 60000);
         }
     };
-
 };
 
 /*#####
@@ -316,6 +315,7 @@
     {
         if (player->GetQuestStatus(QUEST_SCOOP) == QUEST_STATUS_INCOMPLETE)
             player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_P, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+
         player->SEND_GOSSIP_MENU(738, creature->GetGUID());
 
         return true;
@@ -410,7 +410,6 @@
 
     bool OnGossipHello(Player* player, GameObject* go)
     {
-
         if (player->GetQuestStatus(5151) == QUEST_STATUS_INCOMPLETE)
         {
             if (Creature* panther = go->FindNearestCreature(ENRAGED_PANTHER, 5, true))
@@ -421,7 +420,7 @@
             }
         }
 
-        return true ;
+        return true;
     }
 };
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/ungoro_crater.cpp
--- a/src/server/scripts/Kalimdor/ungoro_crater.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/ungoro_crater.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -78,14 +78,13 @@
 
         uint32 DEMORALIZINGSHOUT_Timer;
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
-
             if (!player)
                 return;
 
-            switch (i)
+            switch (waypointId)
             {
                 case 19:
                     me->SummonCreature(ENTRY_STOMPER, -6391.69f, -1730.49f, -272.83f, 4.96f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 25000);
@@ -104,8 +103,7 @@
                     break;
                 case 55:
                     DoScriptText(SAY_FINISH, me, player);
-                    if (player)
-                        player->GroupEventHappens(QUEST_CHASING_AME, me);
+                    player->GroupEventHappens(QUEST_CHASING_AME, me);
                     break;
             }
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Kalimdor/winterspring.cpp
--- a/src/server/scripts/Kalimdor/winterspring.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Kalimdor/winterspring.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -161,12 +161,12 @@
         {
             player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HWDM, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
             player->SEND_GOSSIP_MENU(3377, creature->GetGUID());
-        }else
+        }
+        else
             player->SEND_GOSSIP_MENU(3375, creature->GetGUID());
 
         return true;
     }
-
 };
 
 void AddSC_winterspring()
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/AzjolNerub/Ahnkahet/boss_amanitar.cpp
--- a/src/server/scripts/Northrend/AzjolNerub/Ahnkahet/boss_amanitar.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/AzjolNerub/Ahnkahet/boss_amanitar.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -83,7 +83,7 @@
             }
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (instance)
             {
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/AzjolNerub/Ahnkahet/boss_elder_nadox.cpp
--- a/src/server/scripts/Northrend/AzjolNerub/Ahnkahet/boss_elder_nadox.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/AzjolNerub/Ahnkahet/boss_elder_nadox.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -105,7 +105,7 @@
                 DoScriptText(RAND(SAY_SLAY_1, SAY_SLAY_2, SAY_SLAY_3), me);
             }
 
-            void JustDied(Unit* /*who*/)
+            void JustDied(Unit* /*killer*/)
             {
                 DoScriptText(SAY_SLAY_3, me); //SAY_SLAY_3 on death?
 
@@ -229,7 +229,7 @@
                 uiSprintTimer = 10000;
             }
 
-            void JustDied(Unit* /*who*/)
+            void JustDied(Unit* /*killer*/)
             {
                 if (me->GetEntry() == MOB_AHNKAHAR_GUARDIAN_ENTRY)
                     if (Creature* Nadox = ObjectAccessor::GetCreature(*me, instance->GetData64(DATA_ELDER_NADOX)))
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/AzjolNerub/Ahnkahet/boss_jedoga_shadowseeker.cpp
--- a/src/server/scripts/Northrend/AzjolNerub/Ahnkahet/boss_jedoga_shadowseeker.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/AzjolNerub/Ahnkahet/boss_jedoga_shadowseeker.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -149,7 +149,7 @@
             DoScriptText(RAND(TEXT_SLAY_1, TEXT_SLAY_2, TEXT_SLAY_3), me);
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(TEXT_DEATH, me);
             if (instance)
@@ -390,9 +390,9 @@
             }
         }
 
-        void JustDied(Unit* Killer)
+        void JustDied(Unit* killer)
         {
-            if (!Killer || !instance)
+            if (!killer || !instance)
                 return;
 
             if (bWalking)
@@ -402,7 +402,7 @@
                     if (!CAST_AI(boss_jedoga_shadowseeker::boss_jedoga_shadowseekerAI, boss->AI())->bOpFerok)
                         CAST_AI(boss_jedoga_shadowseeker::boss_jedoga_shadowseekerAI, boss->AI())->bOpFerokFail = true;
 
-                    if (Killer->GetTypeId() == TYPEID_PLAYER)
+                    if (killer->GetTypeId() == TYPEID_PLAYER)
                         boss->AI()->DoAction(ACTION_INITIAND_KILLED);
                 }
 
@@ -410,8 +410,8 @@
 
                 bWalking = false;
             }
-            if (Killer->GetTypeId() == TYPEID_PLAYER)
-                instance->SetData64(DATA_PL_JEDOGA_TARGET, Killer->GetGUID());
+            if (killer->GetTypeId() == TYPEID_PLAYER)
+                instance->SetData64(DATA_PL_JEDOGA_TARGET, killer->GetGUID());
         }
 
         void EnterCombat(Unit* who)
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/AzjolNerub/Ahnkahet/boss_prince_taldaram.cpp
--- a/src/server/scripts/Northrend/AzjolNerub/Ahnkahet/boss_prince_taldaram.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/AzjolNerub/Ahnkahet/boss_prince_taldaram.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -36,7 +36,8 @@
     SPELL_VANISH                                  = 55964,
     CREATURE_FLAME_SPHERE                         = 30106,
     H_CREATURE_FLAME_SPHERE_1                     = 31686,
-    H_CREATURE_FLAME_SPHERE_2                     = 31687
+    H_CREATURE_FLAME_SPHERE_2                     = 31687,
+    SPELL_HOVER_FALL                              = 60425
 };
 enum Misc
 {
@@ -45,18 +46,17 @@
     DATA_SPHERE_DISTANCE                          =    15
 };
 #define DATA_SPHERE_ANGLE_OFFSET            0.7f
-#define DATA_GROUND_POSITION_Z             11.4f
+#define DATA_GROUND_POSITION_Z             11.30809f
 
 enum Yells
 {
-    SAY_AGGRO                                     = -1619021,
-    SAY_SLAY_1                                    = -1619022,
-    SAY_SLAY_2                                    = -1619023,
-    SAY_DEATH                                     = -1619024,
-    SAY_FEED_1                                    = -1619025,
-    SAY_FEED_2                                    = -1619026,
-    SAY_VANISH_1                                  = -1619027,
-    SAY_VANISH_2                                  = -1619028
+    SAY_1                                         = 0,
+    SAY_WARNING                                   = 1,
+    SAY_AGGRO                                     = 2,
+    SAY_SLAY                                      = 3,
+    SAY_DEATH                                     = 4,
+    SAY_FEED                                      = 5,
+    SAY_VANISH                                    = 6,
 };
 enum CombatPhase
 {
@@ -82,8 +82,7 @@
         boss_taldaramAI(Creature* creature) : ScriptedAI(creature)
         {
             instance = creature->GetInstanceScript();
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            me->SetDisableGravity(true);
         }
 
         uint32 uiBloodthirstTimer;
@@ -118,7 +117,7 @@
         {
             if (instance)
                 instance->SetData(DATA_PRINCE_TALDARAM_EVENT, IN_PROGRESS);
-            DoScriptText(SAY_AGGRO, me);
+            Talk(SAY_AGGRO);
         }
 
         void UpdateAI(const uint32 diff)
@@ -180,7 +179,8 @@
                         break;
                     case VANISHED:
                         if (Unit* pEmbraceTarget = GetEmbraceTarget())
-                            DoCast(pEmbraceTarget, SPELL_EMBRACE_OF_THE_VAMPYR);
+                            DoCast(pEmbraceTarget, DUNGEON_MODE(SPELL_EMBRACE_OF_THE_VAMPYR, H_SPELL_EMBRACE_OF_THE_VAMPYR));
+                        Talk(SAY_FEED);
                         me->GetMotionMaster()->Clear();
                         me->SetSpeed(MOVE_WALK, 1.0f, true);
                         me->GetMotionMaster()->MoveChase(me->getVictim());
@@ -201,7 +201,8 @@
 
                         if (uiFlamesphereTimer <= diff)
                         {
-                            DoCast(me, SPELL_CONJURE_FLAME_SPHERE);
+                            // because TARGET_UNIT_TARGET_ENEMY we need a target selected to cast
+                            DoCastVictim(SPELL_CONJURE_FLAME_SPHERE);
                             Phase = CASTING_FLAME_SPHERES;
                             uiPhaseTimer = 3*IN_MILLISECONDS + diff;
                             uiFlamesphereTimer = 15*IN_MILLISECONDS;
@@ -224,7 +225,7 @@
                             //He only vanishes if there are 3 or more alive players
                             if (target_list.size() > 2)
                             {
-                                DoScriptText(RAND(SAY_VANISH_1, SAY_VANISH_2), me);
+                                Talk(SAY_VANISH);
                                 DoCast(me, SPELL_VANISH);
                                 Phase = JUST_VANISHED;
                                 uiPhaseTimer = 500;
@@ -260,7 +261,7 @@
 
         void JustDied(Unit* /*killer*/)
         {
-            DoScriptText(SAY_DEATH, me);
+            Talk(SAY_DEATH);
 
             if (instance)
                 instance->SetData(DATA_PRINCE_TALDARAM_EVENT, DONE);
@@ -278,7 +279,7 @@
                 uiPhaseTimer = 0;
                 uiEmbraceTarget = 0;
             }
-            DoScriptText(RAND(SAY_SLAY_1, SAY_SLAY_2), me);
+            Talk(SAY_SLAY);
         }
 
         bool CheckSpheres()
@@ -314,12 +315,13 @@
         {
             if (!instance)
                 return;
-            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
-            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
             me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
             me->RemoveAurasDueToSpell(SPELL_BEAM_VISUAL);
-            me->SetUnitMovementFlags(MOVEMENTFLAG_WALKING);
             me->SetHomePosition(me->GetPositionX(), me->GetPositionY(), DATA_GROUND_POSITION_Z, me->GetOrientation());
+            DoCast(SPELL_HOVER_FALL);
+            me->SetDisableGravity(false);
+            me->GetMotionMaster()->MovePoint(0, me->GetHomePosition());
+            Talk(SAY_WARNING);
             uint64 prison_GUID = instance->GetData64(DATA_PRINCE_TALDARAM_PLATFORM);
             instance->HandleGameObject(prison_GUID, true);
         }
@@ -362,7 +364,7 @@
         void EnterCombat(Unit* /*who*/) {}
         void MoveInLineOfSight(Unit* /*who*/) {}
 
-        void JustDied(Unit* /*who*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoCast(me, SPELL_FLAME_SPHERE_DEATH_EFFECT);
         }
@@ -404,10 +406,12 @@
             {
                 case GO_SPHERE1:
                     instance->SetData(DATA_SPHERE1_EVENT, IN_PROGRESS);
+                    pPrinceTaldaram->AI()->Talk(SAY_1);
                     break;
 
                 case GO_SPHERE2:
                     instance->SetData(DATA_SPHERE2_EVENT, IN_PROGRESS);
+                    pPrinceTaldaram->AI()->Talk(SAY_1);
                     break;
             }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/AzjolNerub/AzjolNerub/boss_anubarak.cpp
--- a/src/server/scripts/Northrend/AzjolNerub/AzjolNerub/boss_anubarak.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/AzjolNerub/AzjolNerub/boss_anubarak.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -267,7 +267,7 @@
                         }
                     } else DatterTimer -= diff;
 
-                    if(me->HasAura(SPELL_LEECHING_SWARM))
+                    if (me->HasAura(SPELL_LEECHING_SWARM))
                         me->RemoveAurasDueToSpell(SPELL_LEECHING_SWARM);
                 }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/AzjolNerub/AzjolNerub/boss_hadronox.cpp
--- a/src/server/scripts/Northrend/AzjolNerub/AzjolNerub/boss_hadronox.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/AzjolNerub/AzjolNerub/boss_hadronox.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -99,7 +99,7 @@
             me->ModifyHealth(int32(me->CountPctFromMaxHealth(10)));
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (instance)
                 instance->SetData(DATA_HADRONOX_EVENT, DONE);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/ChamberOfAspects/ObsidianSanctum/boss_sartharion.cpp
--- a/src/server/scripts/Northrend/ChamberOfAspects/ObsidianSanctum/boss_sartharion.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/ChamberOfAspects/ObsidianSanctum/boss_sartharion.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -951,7 +951,7 @@
                 return;
 
             // Twilight Revenge to main boss
-            if (Unit* pSartharion = Unit::GetUnit((*me), instance->GetData64(DATA_SARTHARION)))
+            if (Unit* pSartharion = Unit::GetUnit(*me, instance->GetData64(DATA_SARTHARION)))
                 if (pSartharion->isAlive())
                 {
                     pSartharion->RemoveAurasDueToSpell(uiSpellId);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_argent_challenge.cpp
--- a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_argent_challenge.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_argent_challenge.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -515,8 +515,8 @@
 
         void JustDied(Unit* pKiller)
         {
-            if (me->isSummon())
-                if (Unit* summoner = me->ToTempSummon()->GetSummoner())
+            if (TempSummon* summ = me->ToTempSummon())
+                if (Unit* summoner = summ->GetSummoner())
                     if (summoner->isAlive())
                         summoner->GetAI()->SetData(1, 0);
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_anubarak_trial.cpp
--- a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_anubarak_trial.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_anubarak_trial.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -280,7 +280,8 @@
             if (instance)
                 instance->SetData(TYPE_ANUBARAK, IN_PROGRESS);
             //Despawn Scarab Swarms neutral
-            Summons.DoAction(NPC_SCARAB, ACTION_SCARAB_SUBMERGE);
+            EntryCheckPredicate pred(NPC_SCARAB);
+            Summons.DoAction(ACTION_SCARAB_SUBMERGE, pred);
             //Spawn Burrow
             for (int i=0; i < 4; i++)
                 me->SummonCreature(NPC_BURROW, AnubarakLoc[i+2]);
@@ -321,7 +322,8 @@
 
                     if (IsHeroic() && m_uiNerubianShadowStrikeTimer <= uiDiff)
                     {
-                        Summons.DoAction(NPC_BURROWER, ACTION_SHADOW_STRIKE);
+                        EntryCheckPredicate pred(NPC_BURROWER);
+                        Summons.DoAction(ACTION_SHADOW_STRIKE, pred);
                         m_uiNerubianShadowStrikeTimer = 30*IN_MILLISECONDS;
                     } else m_uiNerubianShadowStrikeTimer -= uiDiff;
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_faction_champions.cpp
--- a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_faction_champions.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_faction_champions.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -292,7 +292,7 @@
         std::list<HostileReference*> const& tList = me->getThreatManager().getThreatList();
         for (std::list<HostileReference*>::const_iterator itr = tList.begin(); itr != tList.end(); ++itr)
         {
-            Unit* unit = Unit::GetUnit((*me), (*itr)->getUnitGuid());
+            Unit* unit = Unit::GetUnit(*me, (*itr)->getUnitGuid());
             if (unit && me->getThreatManager().getThreat(unit))
             {
                 if (unit->GetTypeId()==TYPEID_PLAYER)
@@ -384,7 +384,7 @@
         Unit* target;
         for (iter = tList.begin(); iter!=tList.end(); ++iter)
         {
-            target = Unit::GetUnit((*me), (*iter)->getUnitGuid());
+            target = Unit::GetUnit(*me, (*iter)->getUnitGuid());
             if (target && target->getPowerType() == POWER_MANA)
                 return target;
         }
@@ -399,7 +399,7 @@
         Unit* target;
         for (iter = tList.begin(); iter!=tList.end(); ++iter)
         {
-            target = Unit::GetUnit((*me), (*iter)->getUnitGuid());
+            target = Unit::GetUnit(*me, (*iter)->getUnitGuid());
                 if (target && me->GetDistance2d(target) < distance)
                     ++count;
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_lord_jaraxxus.cpp
--- a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_lord_jaraxxus.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_lord_jaraxxus.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -515,6 +515,36 @@
 
 };
 
+class spell_spinning_pain_spike : public SpellScriptLoader
+{
+    public:
+        spell_spinning_pain_spike() : SpellScriptLoader("spell_spinning_pain_spike") {}
+
+        class spell_spinning_pain_spike_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_spinning_pain_spike_SpellScript);
+
+            void HandleScript(SpellEffIndex /*eff*/)
+            {
+                Unit* target = GetHitUnit();
+                if (!target)
+                    return;
+
+                if (target->isAlive())
+                    SetHitDamage(target->CountPctFromMaxHealth(50));
+            }
+            void Register()
+            {
+                OnEffectHitTarget += SpellEffectFn(spell_spinning_pain_spike_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_SCHOOL_DAMAGE);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_spinning_pain_spike_SpellScript();
+        }
+};
+
 void AddSC_boss_jaraxxus()
 {
     new boss_jaraxxus();
@@ -523,4 +553,5 @@
     new mob_fel_infernal();
     new mob_nether_portal();
     new mob_mistress_of_pain();
+    new spell_spinning_pain_spike();
 }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_twin_valkyr.cpp
--- a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_twin_valkyr.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_twin_valkyr.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -619,8 +619,7 @@
         {
             if (m_uiRangeCheckTimer < uiDiff)
             {
-                if (Unit* target = me->SelectNearestTarget(2.0f))
-                    if (target->GetTypeId() == TYPEID_PLAYER && target->isAlive())
+                if (me->SelectNearestPlayer(2.0f))
                     {
                         DoCastAOE(SPELL_UNLEASHED_DARK);
                         me->GetMotionMaster()->MoveIdle();
@@ -661,8 +660,7 @@
         {
             if (m_uiRangeCheckTimer < uiDiff)
             {
-                if (Unit* target = me->SelectNearestTarget(2.0f))
-                    if (target->GetTypeId() == TYPEID_PLAYER && target->isAlive())
+                if (me->SelectNearestPlayer(2.0f))
                     {
                         DoCastAOE(SPELL_UNLEASHED_LIGHT);
                         me->GetMotionMaster()->MoveIdle();
@@ -761,7 +759,7 @@
 
             uint32 spellId;
 
-            bool Validate(SpellEntry const* /*spellEntry*/)
+            bool Load()
             {
                 spellId = sSpellMgr->GetSpellIdForDifficulty(SPELL_SURGE_OF_SPEED, GetCaster());
                 if (!sSpellMgr->GetSpellInfo(spellId))
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/instance_trial_of_the_crusader.cpp
--- a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/instance_trial_of_the_crusader.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/instance_trial_of_the_crusader.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -105,7 +105,7 @@
 
             bool IsEncounterInProgress() const
             {
-                for (uint8 i = 0; i < MAX_ENCOUNTERS ; ++i)
+                for (uint8 i = 0; i < MAX_ENCOUNTERS; ++i)
                     if (EncounterStatus[i] == IN_PROGRESS)
                         return true;
                 return false;
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/DraktharonKeep/boss_dred.cpp
--- a/src/server/scripts/Northrend/DraktharonKeep/boss_dred.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/DraktharonKeep/boss_dred.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -161,7 +161,7 @@
                 return 0;
             }
 
-            void JustDied(Unit* /*who*/)
+            void JustDied(Unit* /*killer*/)
             {
                 if (instance)
                     instance->SetData(DATA_DRED_EVENT, DONE);
@@ -211,7 +211,7 @@
                 DoMeleeAttackIfReady();
             }
 
-            void JustDied(Unit* /*who*/)
+            void JustDied(Unit* /*killer*/)
             {
                 if (Creature* Dred = ObjectAccessor::GetCreature(*me, instance->GetData64(DATA_DRED)))
                     Dred->AI()->DoAction(ACTION_RAPTOR_KILLED);
@@ -261,7 +261,7 @@
                 DoMeleeAttackIfReady();
             }
 
-            void JustDied(Unit* /*who*/)
+            void JustDied(Unit* /*killer*/)
             {
                 if (Creature* Dred = ObjectAccessor::GetCreature(*me, instance->GetData64(DATA_DRED)))
                     Dred->AI()->DoAction(ACTION_RAPTOR_KILLED);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/FrozenHalls/PitOfSaron/boss_krickandick.cpp
--- a/src/server/scripts/Northrend/FrozenHalls/PitOfSaron/boss_krickandick.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/FrozenHalls/PitOfSaron/boss_krickandick.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -497,10 +497,7 @@
                             break;
                         case EVENT_OUTRO_END:
                             if (Creature* tyrannus = ObjectAccessor::GetCreature(*me, _tyrannusGUID))
-                            {
-                                tyrannus->SetVisible(false);
                                 tyrannus->DespawnOrUnsummon();
-                            }
 
                             me->DisappearAndDie();
                             break;
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/Gundrak/boss_eck.cpp
--- a/src/server/scripts/Northrend/Gundrak/boss_eck.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/Gundrak/boss_eck.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -152,7 +152,7 @@
 
         InstanceScript* instance;
 
-        void JustDied(Unit* /*who*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (instance)
             {
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/IcecrownCitadel/boss_blood_queen_lana_thel.cpp
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_blood_queen_lana_thel.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_blood_queen_lana_thel.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -392,7 +392,7 @@
                                 ++targetCount;
                             if (Is25ManRaid())
                                 ++targetCount;
-                            Trinity::RandomResizeList<Player*>(targets, targetCount);
+                            Trinity::Containers::RandomResizeList<Player*>(targets, targetCount);
                             if (targets.size() > 1)
                             {
                                 Talk(SAY_PACT_OF_THE_DARKFALLEN);
@@ -415,7 +415,7 @@
                         {
                             std::list<Player*> targets;
                             SelectRandomTarget(false, &targets);
-                            Trinity::RandomResizeList<Player*>(targets, uint32(Is25ManRaid() ? 4 : 2));
+                            Trinity::Containers::RandomResizeList<Player*>(targets, uint32(Is25ManRaid() ? 4 : 2));
                             for (std::list<Player*>::iterator itr = targets.begin(); itr != targets.end(); ++itr)
                                 DoCast(*itr, SPELL_TWILIGHT_BLOODBOLT);
                             DoCast(me, SPELL_TWILIGHT_BLOODBOLT_TARGET);
@@ -487,7 +487,7 @@
                     return tempTargets.front();
                 }
 
-                return SelectRandomContainerElement(tempTargets);
+                return Trinity::Containers::SelectRandomContainerElement(tempTargets);
             }
 
             std::set<uint64> _vampires;
@@ -664,7 +664,7 @@
             {
                 uint32 targetCount = (targets.size() + 2) / 3;
                 targets.remove_if (BloodboltHitCheck(static_cast<LanaThelAI*>(GetCaster()->GetAI())));
-                Trinity::RandomResizeList(targets, targetCount);
+                Trinity::Containers::RandomResizeList(targets, targetCount);
                 // mark targets now, effect hook has missile travel time delay (might cast next in that time)
                 for (std::list<Unit*>::const_iterator itr = targets.begin(); itr != targets.end(); ++itr)
                     GetCaster()->GetAI()->SetGUID((*itr)->GetGUID(), GUID_BLOODBOLT);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/IcecrownCitadel/boss_deathbringer_saurfang.cpp
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_deathbringer_saurfang.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_deathbringer_saurfang.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -1286,7 +1286,7 @@
                 if (unitList.empty())
                     return;
 
-                Unit* target = SelectRandomContainerElement(unitList);
+                Unit* target = Trinity::Containers::SelectRandomContainerElement(unitList);
                 unitList.clear();
                 unitList.push_back(target);
             }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/IcecrownCitadel/boss_festergut.cpp
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_festergut.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_festergut.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -329,7 +329,7 @@
                 DoMeleeAttackIfReady();
             }
 
-            void JustDied(Unit* /*who*/)
+            void JustDied(Unit* /*killer*/)
             {
                 if (Creature* festergut = me->GetCreature(*me, _instance->GetData64(DATA_FESTERGUT)))
                     if (festergut->isAlive())
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/IcecrownCitadel/boss_lady_deathwhisper.cpp
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_lady_deathwhisper.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_lady_deathwhisper.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -605,7 +605,7 @@
                     return;
 
                 // select random cultist
-                Creature* cultist = SelectRandomContainerElement(temp);
+                Creature* cultist = Trinity::Containers::SelectRandomContainerElement(temp);
                 DoCast(cultist, cultist->GetEntry() == NPC_CULT_FANATIC ? SPELL_DARK_TRANSFORMATION_T : SPELL_DARK_EMPOWERMENT_T, true);
                 Talk(uint8(cultist->GetEntry() == NPC_CULT_FANATIC ? SAY_DARK_TRANSFORMATION : SAY_DARK_EMPOWERMENT));
             }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/IcecrownCitadel/boss_professor_putricide.cpp
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_professor_putricide.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_professor_putricide.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -64,6 +64,9 @@
     SPELL_MALLEABLE_GOO                 = 70852,
     SPELL_UNSTABLE_EXPERIMENT           = 70351,
     SPELL_TEAR_GAS                      = 71617,    // phase transition
+    SPELL_TEAR_GAS_CREATURE             = 71618,
+    SPELL_TEAR_GAS_CANCEL               = 71620,
+    SPELL_TEAR_GAS_PERIODIC_TRIGGER     = 73170,
     SPELL_CREATE_CONCOCTION             = 71621,
     SPELL_GUZZLE_POTIONS                = 71893,
     SPELL_OOZE_TANK_PROTECTION          = 71770,    // protects the tank
@@ -86,6 +89,7 @@
     SPELL_GASEOUS_BLOAT_PROC            = 70215,
     SPELL_GASEOUS_BLOAT                 = 70672,
     SPELL_GASEOUS_BLOAT_PROTECTION      = 70812,
+    SPELL_EXPUNGED_GAS                  = 70701,
 
     // Volatile Ooze
     SPELL_OOZE_ERUPTION                 = 70492,
@@ -167,6 +171,33 @@
 #define EXPERIMENT_STATE_OOZE   false
 #define EXPERIMENT_STATE_GAS    true
 
+class AbominationDespawner
+{
+    public:
+        explicit AbominationDespawner(Unit* owner) : _owner(owner) { }
+
+        bool operator()(uint64 guid)
+        {
+            if (Unit* summon = ObjectAccessor::GetUnit(*_owner, guid))
+            {
+                if (summon->GetEntry() == NPC_MUTATED_ABOMINATION_10 || summon->GetEntry() == NPC_MUTATED_ABOMINATION_25)
+                {
+                    if (Vehicle* veh = summon->GetVehicleKit())
+                        veh->RemoveAllPassengers(); // also despawns the vehicle
+
+                    return true;
+                }
+
+                return false;
+            }
+
+            return true;
+        }
+
+    private:
+        Unit* _owner;
+};
+
 class boss_professor_putricide : public CreatureScript
 {
     public:
@@ -480,8 +511,7 @@
                                 SetPhase(PHASE_COMBAT_3);
                                 events.ScheduleEvent(EVENT_MUTATED_PLAGUE, 25000);
                                 events.CancelEvent(EVENT_UNSTABLE_EXPERIMENT);
-                                summons.DespawnEntry(NPC_MUTATED_ABOMINATION_10);
-                                summons.DespawnEntry(NPC_MUTATED_ABOMINATION_25);
+                                summons.remove_if(AbominationDespawner(me));
                                 break;
                             default:
                                 break;
@@ -574,13 +604,15 @@
                             me->RemoveAurasDueToSpell(71615);
                             me->RemoveAurasDueToSpell(71618);
                             me->GetMotionMaster()->MovePoint(POINT_TABLE, tablePos);
+                            DoCast(me, SPELL_TEAR_GAS_PERIODIC_TRIGGER, true);
                             break;
                         case EVENT_RESUME_ATTACK:
                             me->SetReactState(REACT_DEFENSIVE);
                             AttackStart(me->getVictim());
                             // remove Tear Gas
+                            me->RemoveAurasDueToSpell(SPELL_TEAR_GAS_PERIODIC_TRIGGER);
                             instance->DoRemoveAurasDueToSpellOnPlayers(71615);
-                            instance->DoRemoveAurasDueToSpellOnPlayers(71618);
+                            DoCastAOE(SPELL_TEAR_GAS_CANCEL);
                             instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_GAS_VARIABLE);
                             instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_OOZE_VARIABLE);
                             break;
@@ -678,9 +710,9 @@
     public:
         npc_volatile_ooze() : CreatureScript("npc_volatile_ooze") { }
 
-        struct npc_volatile_oozeAI : public ScriptedAI
+        struct npc_putricide_oozeAI : public ScriptedAI
         {
-            npc_volatile_oozeAI(Creature* creature) : ScriptedAI(creature)
+            npc_putricide_oozeAI(Creature* creature) : ScriptedAI(creature)
             {
                 _newTargetSelectTimer = 0;
                 me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_KNOCK_BACK, true);
@@ -689,17 +721,26 @@
 
             void SpellHitTarget(Unit* /*target*/, SpellInfo const* spell)
             {
-                if (!_newTargetSelectTimer && sSpellMgr->GetSpellDifficultyId(spell->Id) == sSpellMgr->GetSpellDifficultyId(SPELL_OOZE_ERUPTION))
+                if (!_newTargetSelectTimer && spell->Id == sSpellMgr->GetSpellIdForDifficulty(SPELL_OOZE_ERUPTION, me))
+                    _newTargetSelectTimer = 1000;
+            }
+
+            void SpellHit(Unit* /*caster*/, SpellInfo const* spell)
+            {
+                if (spell->Id == SPELL_TEAR_GAS_CREATURE)
                     _newTargetSelectTimer = 1000;
             }
 
             void UpdateAI(uint32 const diff)
             {
-                if (!UpdateVictim())
+                if (!UpdateVictim() && !_newTargetSelectTimer)
                     return;
 
                 if (!_newTargetSelectTimer)
                     return;
+                    
+                if (me->HasAura(SPELL_TEAR_GAS_CREATURE))
+                    return;
 
                 if (_newTargetSelectTimer <= diff)
                 {
@@ -711,13 +752,12 @@
             }
 
         private:
-            // no need to use EventMap for just one event
             uint32 _newTargetSelectTimer;
         };
 
         CreatureAI* GetAI(Creature* creature) const
         {
-            return GetIcecrownCitadelAI<npc_volatile_oozeAI>(creature);
+            return GetIcecrownCitadelAI<npc_putricide_oozeAI>(creature);
         }
 };
 
@@ -730,14 +770,52 @@
         {
             npc_gas_cloudAI(Creature* creature) : ScriptedAI(creature)
             {
+                _newTargetSelectTimer = 0;
                 me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_KNOCK_BACK, true);
                 me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
             }
+
+            void SpellHitTarget(Unit* /*target*/, SpellInfo const* spell)
+            {
+                if (!_newTargetSelectTimer && spell->Id == sSpellMgr->GetSpellIdForDifficulty(SPELL_EXPUNGED_GAS, me))
+                    _newTargetSelectTimer = 1000;
+            }
+
+            void SpellHit(Unit* /*caster*/, SpellInfo const* spell)
+            {
+                if (spell->Id == SPELL_TEAR_GAS_CREATURE)
+                    _newTargetSelectTimer = 1000;
+            }
+
+            void UpdateAI(uint32 const diff)
+            {
+                if (!UpdateVictim() && !_newTargetSelectTimer)
+                    return;
+
+                DoMeleeAttackIfReady();
+
+                if (!_newTargetSelectTimer)
+                    return;
+
+                if (me->HasAura(SPELL_TEAR_GAS_CREATURE))
+                    return;
+
+                if (_newTargetSelectTimer <= diff)
+                {
+                    _newTargetSelectTimer = 0;
+                    me->CastCustomSpell(SPELL_GASEOUS_BLOAT, SPELLVALUE_AURA_STACK, 10, me, false);
+                }
+                else
+                    _newTargetSelectTimer -= diff;
+            }
+
+        private:
+            uint32 _newTargetSelectTimer;
         };
 
         CreatureAI* GetAI(Creature* creature) const
         {
-            return new npc_gas_cloudAI(creature);
+            return GetIcecrownCitadelAI<npc_gas_cloudAI>(creature);
         }
 };
 
@@ -756,8 +834,8 @@
                 if (Unit* caster = GetCaster())
                 {
                     target->RemoveAuraFromStack(GetSpellInfo()->Id, GetCasterGUID());
-                    if (!target->HasAura(GetId())&& caster->GetTypeId() == TYPEID_UNIT)
-                        caster->ToCreature()->DespawnOrUnsummon();
+                    if (!target->HasAura(GetId()))
+                        caster->CastCustomSpell(SPELL_GASEOUS_BLOAT, SPELLVALUE_AURA_STACK, 10, caster, false);
                 }
             }
 
@@ -808,7 +886,7 @@
                     return;
                 }
 
-                Unit* target = SelectRandomContainerElement(targetList);
+                Unit* target = Trinity::Containers::SelectRandomContainerElement(targetList);
                 targetList.clear();
                 targetList.push_back(target);
                 _target = target;
@@ -824,7 +902,19 @@
             void StartAttack()
             {
                 GetCaster()->ClearUnitState(UNIT_STATE_CASTING);
+                GetCaster()->DeleteThreatList();
                 GetCaster()->ToCreature()->AI()->AttackStart(GetHitUnit());
+                GetCaster()->AddThreat(GetHitUnit(), 500000000.0f);    // value seen in sniff
+            }
+
+            // temporary, until SelectTarget are not called on empty lists
+            void CheckTarget()
+            {
+                if (_target)
+                    return;
+
+                FinishCast(SPELL_FAILED_NO_VALID_TARGETS);
+                GetCaster()->ToCreature()->DespawnOrUnsummon(1);    // despawn next update
             }
 
             void Register()
@@ -833,6 +923,7 @@
                 OnUnitTargetSelect += SpellUnitTargetFn(spell_putricide_ooze_channel_SpellScript::SetTarget, EFFECT_1, TARGET_UNIT_SRC_AREA_ENEMY);
                 OnUnitTargetSelect += SpellUnitTargetFn(spell_putricide_ooze_channel_SpellScript::SetTarget, EFFECT_2, TARGET_UNIT_SRC_AREA_ENEMY);
                 AfterHit += SpellHitFn(spell_putricide_ooze_channel_SpellScript::StartAttack);
+                OnCast += SpellCastFn(spell_putricide_ooze_channel_SpellScript::CheckTarget);
             }
 
             Unit* _target;
@@ -932,13 +1023,13 @@
                 uint32 stage = GetCaster()->ToCreature()->AI()->GetData(DATA_EXPERIMENT_STAGE);
                 Creature* target = NULL;
                 std::list<Creature*> creList;
-                GetCreatureListWithEntryInGrid(creList, GetCaster(), NPC_ABOMINATION_WING_MAD_SCIENTIST_STALKER, 100.0f);
+                GetCreatureListWithEntryInGrid(creList, GetCaster(), NPC_ABOMINATION_WING_MAD_SCIENTIST_STALKER, 200.0f);
                 // 2 of them are spawned at green place - weird trick blizz
                 for (std::list<Creature*>::iterator itr = creList.begin(); itr != creList.end(); ++itr)
                 {
                     target = *itr;
                     std::list<Creature*> tmp;
-                    GetCreatureListWithEntryInGrid(tmp, target, NPC_ABOMINATION_WING_MAD_SCIENTIST_STALKER, 1.0f);
+                    GetCreatureListWithEntryInGrid(tmp, target, NPC_ABOMINATION_WING_MAD_SCIENTIST_STALKER, 10.0f);
                     if ((!stage && tmp.size() > 1) || (stage && tmp.size() == 1))
                         break;
                 }
@@ -958,42 +1049,6 @@
         }
 };
 
-class spell_putricide_ooze_summon : public SpellScriptLoader
-{
-    public:
-        spell_putricide_ooze_summon() : SpellScriptLoader("spell_putricide_ooze_summon") { }
-
-        class spell_putricide_ooze_summon_AuraScript : public AuraScript
-        {
-            PrepareAuraScript(spell_putricide_ooze_summon_AuraScript);
-
-            void HandleTriggerSpell(AuraEffect const* aurEff)
-            {
-                PreventDefaultAction();
-                if (Unit* caster = GetCaster())
-                {
-                    uint32 triggerSpellId = GetSpellInfo()->Effects[aurEff->GetEffIndex()].TriggerSpell;
-                    float x, y, z;
-                    GetTarget()->GetPosition(x, y, z);
-                    z = GetTarget()->GetMap()->GetHeight(GetTarget()->GetPhaseMask(), x, y, z, true, 25.0f);
-                    x += 10.0f * cosf(caster->GetOrientation());
-                    y += 10.0f * sinf(caster->GetOrientation());
-                    caster->CastSpell(x, y, z, triggerSpellId, true, NULL, NULL, GetCasterGUID());
-                }
-            }
-
-            void Register()
-            {
-                OnEffectPeriodic += AuraEffectPeriodicFn(spell_putricide_ooze_summon_AuraScript::HandleTriggerSpell, EFFECT_0, SPELL_AURA_PERIODIC_TRIGGER_SPELL);
-            }
-        };
-
-        AuraScript* GetAuraScript() const
-        {
-            return new spell_putricide_ooze_summon_AuraScript();
-        }
-};
-
 class spell_putricide_ooze_eruption_searcher : public SpellScriptLoader
 {
     public:
@@ -1456,14 +1511,15 @@
         }
 };
 
-class spell_putricide_clear_mutated_plague : public SpellScriptLoader
+// Removes aura with id stored in effect value
+class spell_putricide_clear_aura_effect_value : public SpellScriptLoader
 {
     public:
-        spell_putricide_clear_mutated_plague() : SpellScriptLoader("spell_putricide_clear_mutated_plague") { }
+        spell_putricide_clear_aura_effect_value() : SpellScriptLoader("spell_putricide_clear_aura_effect_value") { }
 
-        class spell_putricide_clear_mutated_plague_SpellScript : public SpellScript
+        class spell_putricide_clear_aura_effect_value_SpellScript : public SpellScript
         {
-            PrepareSpellScript(spell_putricide_clear_mutated_plague_SpellScript);
+            PrepareSpellScript(spell_putricide_clear_aura_effect_value_SpellScript);
 
             void HandleScript(SpellEffIndex effIndex)
             {
@@ -1474,13 +1530,13 @@
 
             void Register()
             {
-                OnEffectHitTarget += SpellEffectFn(spell_putricide_clear_mutated_plague_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
+                OnEffectHitTarget += SpellEffectFn(spell_putricide_clear_aura_effect_value_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
             }
         };
 
         SpellScript* GetSpellScript() const
         {
-            return new spell_putricide_clear_mutated_plague_SpellScript();
+            return new spell_putricide_clear_aura_effect_value_SpellScript();
         }
 };
 
@@ -1525,7 +1581,6 @@
     new spell_putricide_slime_puddle();
     new spell_putricide_slime_puddle_aura();
     new spell_putricide_unstable_experiment();
-    new spell_putricide_ooze_summon();
     new spell_putricide_ooze_eruption_searcher();
     new spell_putricide_choking_gas_bomb();
     new spell_putricide_unbound_plague();
@@ -1536,6 +1591,6 @@
     new spell_putricide_mutated_transformation();
     new spell_putricide_mutated_transformation_dmg();
     new spell_putricide_regurgitated_ooze();
-    new spell_putricide_clear_mutated_plague();
+    new spell_putricide_clear_aura_effect_value();
     new spell_stinky_precious_decimate();
 }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/IcecrownCitadel/boss_rotface.cpp
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_rotface.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_rotface.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -499,7 +499,7 @@
                 if (targets.empty())
                     return;
 
-                Unit* target = SelectRandomContainerElement(targets);
+                Unit* target = Trinity::Containers::SelectRandomContainerElement(targets);
                 targets.clear();
                 targets.push_back(target);
                 _target = target;
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/IcecrownCitadel/boss_sindragosa.cpp
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_sindragosa.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_sindragosa.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -61,6 +61,7 @@
     SPELL_ASPHYXIATION          = 71665,
     SPELL_FROST_BOMB_TRIGGER    = 69846,
     SPELL_FROST_BOMB_VISUAL     = 70022,
+    SPELL_BIRTH_NO_VISUAL       = 40031,
     SPELL_FROST_BOMB            = 69845,
     SPELL_MYSTIC_BUFFET         = 70128,
 
@@ -98,6 +99,8 @@
     EVENT_LAND                      = 12,
     EVENT_AIR_MOVEMENT              = 21,
     EVENT_THIRD_PHASE_CHECK         = 22,
+    EVENT_AIR_MOVEMENT_FAR          = 23,
+    EVENT_LAND_GROUND               = 24,
 
     // Spinestalker
     EVENT_BELLOWING_ROAR            = 13,
@@ -133,6 +136,8 @@
     POINT_AIR_PHASE         = 3,
     POINT_TAKEOFF           = 4,
     POINT_LAND              = 5,
+    POINT_AIR_PHASE_FAR     = 6,
+    POINT_LAND_GROUND       = 7,
 };
 
 enum Shadowmourne
@@ -152,6 +157,8 @@
 Position const SindragosaFlyPos    = {4475.190f, 2484.570f, 234.8510f, 3.141593f};
 Position const SindragosaLandPos   = {4419.190f, 2484.570f, 203.3848f, 3.141593f};
 Position const SindragosaAirPos    = {4475.990f, 2484.430f, 247.9340f, 3.141593f};
+Position const SindragosaAirPosFar = {4525.600f, 2485.150f, 245.0820f, 3.141593f};
+Position const SindragosaFlyInPos  = {4419.190f, 2484.360f, 232.5150f, 3.141593f};
 
 class FrostwyrmLandEvent : public BasicEvent
 {
@@ -169,6 +176,23 @@
         Position const& _dest;
 };
 
+class FrostBombExplosion : public BasicEvent
+{
+    public:
+        FrostBombExplosion(Creature* owner, uint64 sindragosaGUID) : _owner(owner), _sindragosaGUID(sindragosaGUID) { }
+
+        bool Execute(uint64 /*eventTime*/, uint32 /*updateTime*/)
+        {
+            _owner->CastSpell((Unit*)NULL, SPELL_FROST_BOMB, true, NULL, NULL, _sindragosaGUID);
+            _owner->RemoveAurasDueToSpell(SPELL_FROST_BOMB_VISUAL);
+            return true;
+        }
+
+    private:
+        Creature* _owner;
+        uint64 _sindragosaGUID;
+};
+
 class boss_sindragosa : public CreatureScript
 {
     public:
@@ -312,20 +336,31 @@
                         break;
                     case POINT_AIR_PHASE:
                         me->CastCustomSpell(SPELL_ICE_TOMB_TARGET, SPELLVALUE_MAX_TARGETS, RAID_MODE<int32>(2, 5, 2, 6), NULL);
-                        events.ScheduleEvent(EVENT_FROST_BOMB, 8000);
+                        me->SetFacingTo(float(M_PI));
+                        events.ScheduleEvent(EVENT_AIR_MOVEMENT_FAR, 1);
+                        events.ScheduleEvent(EVENT_FROST_BOMB, 9000);
+                        break;
+                    case POINT_AIR_PHASE_FAR:
+                        me->SetFacingTo(float(M_PI));
+                        events.ScheduleEvent(EVENT_LAND, 30000);
                         break;
                     case POINT_LAND:
+                        events.ScheduleEvent(EVENT_LAND_GROUND, 1);
+                        break;
+                    case POINT_LAND_GROUND:
+                    {
                         me->SetCanFly(false);
                         me->SetDisableGravity(false);
                         me->RemoveByteFlag(UNIT_FIELD_BYTES_1, 3, UNIT_BYTE1_FLAG_ALWAYS_STAND | UNIT_BYTE1_FLAG_HOVER);
                         me->SetReactState(REACT_DEFENSIVE);
                         if (me->GetMotionMaster()->GetCurrentMovementGeneratorType() == POINT_MOTION_TYPE)
                             me->GetMotionMaster()->MovementExpired();
-                        DoStartMovement(me->getVictim());
                         _isInAirPhase = false;
                         // trigger Asphyxiation
-                        summons.DoAction(NPC_ICE_TOMB, ACTION_TRIGGER_ASPHYXIATION);
+                        EntryCheckPredicate pred(NPC_ICE_TOMB);
+                        summons.DoAction(ACTION_TRIGGER_ASPHYXIATION, pred);
                         break;
+                    }
                     default:
                         break;
                 }
@@ -344,6 +379,12 @@
             void JustSummoned(Creature* summon)
             {
                 summons.Summon(summon);
+                if (summon->GetEntry() == NPC_FROST_BOMB)
+                {
+                    summon->CastSpell(summon, SPELL_FROST_BOMB_VISUAL, true);
+                    summon->CastSpell(summon, SPELL_BIRTH_NO_VISUAL, true);
+                    summon->m_Events.AddEvent(new FrostBombExplosion(summon, me->GetGUID()), summon->m_Events.CalculateTime(5500));
+                }
             }
 
             void SummonedCreatureDespawn(Creature* summon)
@@ -356,18 +397,25 @@
             void SpellHitTarget(Unit* target, SpellInfo const* spell)
             {
                 if (uint32 spellId = sSpellMgr->GetSpellIdForDifficulty(70127, me))
+                {
                     if (spellId == spell->Id)
+                    {
                         if (Aura const* mysticBuffet = target->GetAura(spell->Id))
                             _mysticBuffetStack = std::max<uint8>(_mysticBuffetStack, mysticBuffet->GetStackAmount());
 
+                        return;
+                    }
+                }
+
                 // Frost Infusion
                 if (Player* player = target->ToPlayer())
                 {
                     if (uint32 spellId = sSpellMgr->GetSpellIdForDifficulty(_isThirdPhase ? SPELL_FROST_BREATH_P2 : SPELL_FROST_BREATH_P1, me))
                     {
-                        if (player->GetQuestStatus(QUEST_FROST_INFUSION) == QUEST_STATUS_INCOMPLETE && spellId == spell->Id)
+                        if (spellId == spell->Id)
                         {
-                            if (Item* shadowsEdge = player->GetWeaponForAttack(BASE_ATTACK, true))
+                            Item* shadowsEdge = player->GetWeaponForAttack(BASE_ATTACK, true);
+                            if (player->GetQuestStatus(QUEST_FROST_INFUSION) == QUEST_STATUS_INCOMPLETE && shadowsEdge)
                             {
                                 if (!player->HasAura(SPELL_FROST_IMBUED_BLADE) && shadowsEdge->GetEntry() == ITEM_SHADOW_S_EDGE)
                                 {
@@ -385,15 +433,11 @@
                                         player->CastSpell(player, SPELL_FROST_INFUSION, true);
                                 }
                             }
+
+                            return;
                         }
                     }
                 }
-
-                if (spell->Id == SPELL_FROST_BOMB_TRIGGER)
-                {
-                    target->CastSpell(target, SPELL_FROST_BOMB, true);
-                    target->RemoveAurasDueToSpell(SPELL_FROST_BOMB_VISUAL);
-                }
             }
 
             void UpdateAI(uint32 const diff)
@@ -434,7 +478,6 @@
                             break;
                         case EVENT_ICY_GRIP:
                             DoCast(me, SPELL_ICY_GRIP);
-                            events.ScheduleEvent(EVENT_ICY_GRIP, urand(70000, 75000), EVENT_GROUP_LAND_PHASE);
                             events.ScheduleEvent(EVENT_BLISTERING_COLD, 1000, EVENT_GROUP_LAND_PHASE);
                             break;
                         case EVENT_BLISTERING_COLD:
@@ -453,19 +496,21 @@
                             me->SetDisableGravity(true);
                             me->SetByteFlag(UNIT_FIELD_BYTES_1, 3, UNIT_BYTE1_FLAG_ALWAYS_STAND | UNIT_BYTE1_FLAG_HOVER);
                             me->SetReactState(REACT_PASSIVE);
+                            me->AttackStop();
                             Position pos;
                             pos.Relocate(me);
                             pos.m_positionZ += 17.0f;
                             me->GetMotionMaster()->MoveTakeoff(POINT_TAKEOFF, pos, 8.30078125f);
-                            events.DelayEvents(45000, EVENT_GROUP_LAND_PHASE);
+                            events.CancelEventGroup(EVENT_GROUP_LAND_PHASE);
                             events.ScheduleEvent(EVENT_AIR_PHASE, 110000);
-                            events.RescheduleEvent(EVENT_UNCHAINED_MAGIC, urand(55000, 60000), EVENT_GROUP_LAND_PHASE);
-                            events.ScheduleEvent(EVENT_LAND, 45000);
                             break;
                         }
                         case EVENT_AIR_MOVEMENT:
                             me->GetMotionMaster()->MovePoint(POINT_AIR_PHASE, SindragosaAirPos);
                             break;
+                        case EVENT_AIR_MOVEMENT_FAR:
+                            me->GetMotionMaster()->MovePoint(POINT_AIR_PHASE_FAR, SindragosaAirPosFar);
+                            break;
                         case EVENT_ICE_TOMB:
                             if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 0.0f, true, -SPELL_ICE_TOMB_UNTARGETABLE))
                             {
@@ -477,30 +522,28 @@
                         case EVENT_FROST_BOMB:
                         {
                             float destX, destY, destZ;
-                            destX = float(rand_norm()) * 117.25f + 4339.25f;
-                            if (destX > 4371.5f && destX < 4432.0f)
-                                destY = float(rand_norm()) * 111.0f + 2429.0f;
-                            else
-                                destY = float(rand_norm()) * 31.23f + 2454.64f;
+                            destX = float(rand_norm()) * 75.0f + 4350.0f;
+                            destY = float(rand_norm()) * 75.0f + 2450.0f;
                             destZ = 205.0f; // random number close to ground, get exact in next call
                             me->UpdateGroundPositionZ(destX, destY, destZ);
-                            Position pos;
-                            pos.Relocate(destX, destY, destZ, 0.0f);
-                            if (TempSummon* summ = me->SummonCreature(NPC_FROST_BOMB, pos, TEMPSUMMON_TIMED_DESPAWN, 40000))
-                            {
-                                summ->CastSpell(summ, SPELL_FROST_BOMB_VISUAL, true);
-                                DoCast(summ, SPELL_FROST_BOMB_TRIGGER);
-                                //me->CastSpell(destX, destY, destZ, SPELL_FROST_BOMB_TRIGGER, false);
-                            }
-                            events.ScheduleEvent(EVENT_FROST_BOMB, urand(5000, 10000));
+                            me->CastSpell(destX, destY, destZ, SPELL_FROST_BOMB_TRIGGER, false);
+                            events.ScheduleEvent(EVENT_FROST_BOMB, urand(6000, 8000));
                             break;
                         }
                         case EVENT_LAND:
                         {
                             events.CancelEvent(EVENT_FROST_BOMB);
-                            me->GetMotionMaster()->MovePoint(POINT_LAND, SindragosaLandPos);
+                            me->GetMotionMaster()->MovePoint(POINT_LAND, SindragosaFlyInPos);
                             break;
                         }
+                        case EVENT_LAND_GROUND:
+                            events.ScheduleEvent(EVENT_CLEAVE, urand(13000, 15000), EVENT_GROUP_LAND_PHASE);
+                            events.ScheduleEvent(EVENT_TAIL_SMASH, urand(19000, 23000), EVENT_GROUP_LAND_PHASE);
+                            events.ScheduleEvent(EVENT_FROST_BREATH, urand(10000, 15000), EVENT_GROUP_LAND_PHASE);
+                            events.ScheduleEvent(EVENT_UNCHAINED_MAGIC, urand(12000, 17000), EVENT_GROUP_LAND_PHASE);
+                            events.ScheduleEvent(EVENT_ICY_GRIP, urand(35000, 40000), EVENT_GROUP_LAND_PHASE);
+                            me->GetMotionMaster()->MoveLand(POINT_LAND_GROUND, SindragosaLandPos, 0.0f);
+                            break;
                         case EVENT_THIRD_PHASE_CHECK:
                         {
                             if (!_isInAirPhase)
@@ -1073,10 +1116,10 @@
 
             void FilterTargets(std::list<Unit*>& unitList)
             {
-                unitList.remove_if (UnchainedMagicTargetSelector());
-                uint32 maxSize = uint32(GetCaster()->GetMap()->GetSpawnMode() & 1 ? 5 : 2);
+                unitList.remove_if(UnchainedMagicTargetSelector());
+                uint32 maxSize = uint32(GetCaster()->GetMap()->GetSpawnMode() & 1 ? 6 : 2);
                 if (unitList.size() > maxSize)
-                    Trinity::RandomResizeList(unitList, maxSize);
+                    Trinity::Containers::RandomResizeList(unitList, maxSize);
             }
 
             void Register()
@@ -1259,6 +1302,46 @@
         }
 };
 
+class MysticBuffetTargetFilter
+{
+    public:
+        explicit MysticBuffetTargetFilter(Unit* caster) : _caster(caster) { }
+
+        bool operator()(Unit* unit)
+        {
+            return !unit->IsWithinLOSInMap(_caster);
+        }
+
+    private:
+        Unit* _caster;
+};
+
+class spell_sindragosa_mystic_buffet : public SpellScriptLoader
+{
+    public:
+        spell_sindragosa_mystic_buffet() : SpellScriptLoader("spell_sindragosa_mystic_buffet") { }
+
+        class spell_sindragosa_mystic_buffet_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_sindragosa_mystic_buffet_SpellScript);
+
+            void FilterTargets(std::list<Unit*>& unitList)
+            {
+                unitList.remove_if(MysticBuffetTargetFilter(GetCaster()));
+            }
+
+            void Register()
+            {
+                OnUnitTargetSelect += SpellUnitTargetFn(spell_sindragosa_mystic_buffet_SpellScript::FilterTargets, EFFECT_0, TARGET_UNIT_SRC_AREA_ENEMY);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_sindragosa_mystic_buffet_SpellScript();
+        }
+};
+
 class spell_rimefang_icy_blast : public SpellScriptLoader
 {
     public:
@@ -1340,7 +1423,7 @@
                 if (unitList.empty())
                     return;
 
-                Unit* target = SelectRandomContainerElement(unitList);
+                Unit* target = Trinity::Containers::SelectRandomContainerElement(unitList);
                 unitList.clear();
                 unitList.push_back(target);
             }
@@ -1357,7 +1440,7 @@
                 if (unitList.empty())
                     return;
 
-                SelectRandomContainerElement(unitList)->CastSpell(GetHitUnit(), uint32(GetEffectValue()), true);
+                Trinity::Containers::SelectRandomContainerElement(unitList)->CastSpell(GetHitUnit(), uint32(GetEffectValue()), true);
             }
 
             void Register()
@@ -1484,6 +1567,7 @@
     new spell_sindragosa_frost_beacon();
     new spell_sindragosa_ice_tomb();
     new spell_sindragosa_icy_grip();
+    new spell_sindragosa_mystic_buffet();
     new spell_rimefang_icy_blast();
     new spell_frostwarden_handler_order_whelp();
     new spell_frostwarden_handler_focus_fire();
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/IcecrownCitadel/boss_the_lich_king.cpp
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_the_lich_king.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_the_lich_king.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -554,7 +554,8 @@
                 if (Creature* tirion = ObjectAccessor::GetCreature(*me, instance->GetData64(DATA_HIGHLORD_TIRION_FORDRING)))
                     tirion->AI()->EnterEvadeMode();
                 DoCastAOE(SPELL_KILL_FROSTMOURNE_PLAYERS);
-                summons.DoAction(NPC_STRANGULATE_VEHICLE, ACTION_TELEPORT_BACK);
+                EntryCheckPredicate pred(NPC_STRANGULATE_VEHICLE);
+                summons.DoAction(ACTION_TELEPORT_BACK, pred);
             }
 
             void KilledUnit(Unit* victim)
@@ -595,12 +596,15 @@
                         events.ScheduleEvent(EVENT_OUTRO_TALK_8, 17000, 0, PHASE_OUTRO);
                         break;
                     case ACTION_TELEPORT_BACK:
-                        summons.DoAction(NPC_STRANGULATE_VEHICLE, ACTION_TELEPORT_BACK);
+                    {
+                        EntryCheckPredicate pred(NPC_STRANGULATE_VEHICLE);
+                        summons.DoAction(ACTION_TELEPORT_BACK, pred);
                         if (!IsHeroic())
                             Talk(SAY_LK_FROSTMOURNE_ESCAPE);
                         else
                             DoCastAOE(SPELL_TRIGGER_VILE_SPIRIT_HEROIC);
                         break;
+                    }
                     default:
                         break;
                 }
@@ -2555,7 +2559,7 @@
                 if (unitList.empty())
                     return;
 
-                _target = SelectRandomContainerElement(unitList);
+                _target = Trinity::Containers::SelectRandomContainerElement(unitList);
                 unitList.clear();
                 unitList.push_back(_target);
                 GetCaster()->GetAI()->SetGUID(_target->GetGUID());
@@ -2763,7 +2767,7 @@
                 if (targets.empty())
                     return;
 
-                _target = SelectRandomContainerElement(targets);
+                _target = Trinity::Containers::SelectRandomContainerElement(targets);
             }
 
             void HandleScript(SpellEffIndex effIndex)
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/IcecrownCitadel/boss_valithria_dreamwalker.cpp
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_valithria_dreamwalker.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_valithria_dreamwalker.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -1215,7 +1215,7 @@
                 if (targets.empty())
                     return;
 
-                Unit* target = SelectRandomContainerElement(targets);
+                Unit* target = Trinity::Containers::SelectRandomContainerElement(targets);
                 targets.clear();
                 targets.push_back(target);
             }
@@ -1261,7 +1261,7 @@
                 std::list<Creature*> summoners;
                 GetCreatureListWithEntryInGrid(summoners, caster, NPC_WORLD_TRIGGER, 100.0f);
                 summoners.remove_if (Trinity::UnitAuraCheck(true, SPELL_RECENTLY_SPAWNED));
-                Trinity::RandomResizeList(summoners, 2);
+                Trinity::Containers::RandomResizeList(summoners, 2);
                 if (summoners.empty())
                     return;
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.cpp
--- a/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -1374,7 +1374,7 @@
                         case EVENT_ARNATH_PW_SHIELD:
                         {
                             std::list<Creature*> targets = DoFindFriendlyMissingBuff(40.0f, SPELL_POWER_WORD_SHIELD);
-                            DoCast(SelectRandomContainerElement(targets), SPELL_POWER_WORD_SHIELD);
+                            DoCast(Trinity::Containers::SelectRandomContainerElement(targets), SPELL_POWER_WORD_SHIELD);
                             Events.ScheduleEvent(EVENT_ARNATH_PW_SHIELD, urand(15000, 20000));
                             break;
                         }
@@ -1828,7 +1828,7 @@
                 unitList.remove_if (DeathPlagueTargetSelector(GetCaster()));
                 if (!unitList.empty())
                 {
-                    Unit* target = SelectRandomContainerElement(unitList);
+                    Unit* target = Trinity::Containers::SelectRandomContainerElement(unitList);
                     unitList.clear();
                     unitList.push_back(target);
                 }
@@ -1937,7 +1937,7 @@
             void RemoveAliveTarget(std::list<Unit*>& unitList)
             {
                 unitList.remove_if(AliveCheck());
-                Trinity::RandomResizeList(unitList, 2);
+                Trinity::Containers::RandomResizeList(unitList, 2);
             }
 
             void Land(SpellEffIndex /*effIndex*/)
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/Naxxramas/boss_anubrekhan.cpp
--- a/src/server/scripts/Northrend/Naxxramas/boss_anubrekhan.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/Naxxramas/boss_anubrekhan.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -99,7 +99,7 @@
             DoScriptText(SAY_SLAY, me);
         }
 
-        void JustDied(Unit*)
+        void JustDied(Unit* /*killer*/)
         {
             _JustDied();
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/Naxxramas/boss_four_horsemen.cpp
--- a/src/server/scripts/Northrend/Naxxramas/boss_four_horsemen.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/Naxxramas/boss_four_horsemen.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -136,10 +136,10 @@
             if (!instance)
                 return false;
 
-            Creature* Thane = CAST_CRE(Unit::GetUnit(*me, instance->GetData64(DATA_THANE)));
-            Creature* Lady = CAST_CRE(Unit::GetUnit(*me, instance->GetData64(DATA_LADY)));
-            Creature* Baron = CAST_CRE(Unit::GetUnit(*me, instance->GetData64(DATA_BARON)));
-            Creature* Sir = CAST_CRE(Unit::GetUnit(*me, instance->GetData64(DATA_SIR)));
+            Creature* Thane = Unit::GetCreature(*me, instance->GetData64(DATA_THANE));
+            Creature* Lady = Unit::GetCreature(*me, instance->GetData64(DATA_LADY));
+            Creature* Baron = Unit::GetCreature(*me, instance->GetData64(DATA_BARON));
+            Creature* Sir = Unit::GetCreature(*me, instance->GetData64(DATA_SIR));
 
             if (Thane && Lady && Baron && Sir)
             {
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/Naxxramas/boss_gothik.cpp
--- a/src/server/scripts/Northrend/Naxxramas/boss_gothik.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/Naxxramas/boss_gothik.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -234,7 +234,7 @@
                     DoScriptText(SAY_KILL, me);
             }
 
-            void JustDied(Unit* /*Killer*/)
+            void JustDied(Unit* /*killer*/)
             {
                 LiveTriggerGUID.clear();
                 DeadTriggerGUID.clear();
@@ -424,7 +424,8 @@
                                     {
                                         if (instance)
                                             instance->SetData(DATA_GOTHIK_GATE, GO_STATE_ACTIVE);
-                                        summons.DoAction(0, 0);
+                                        DummyEntryCheckPredicate pred;
+                                        summons.DoAction(0, pred);  //! Magic numbers fail
                                         summons.DoZoneInCombat();
                                         mergedSides = true;
                                     }
@@ -447,7 +448,8 @@
                                 DoScriptText(SAY_TELEPORT, me);
                                 DoTeleportTo(PosGroundLiveSide);
                                 me->SetReactState(REACT_AGGRESSIVE);
-                                summons.DoAction(0, 0);
+                                DummyEntryCheckPredicate pred;
+                                summons.DoAction(0, pred);  //! Magic numbers fail
                                 summons.DoZoneInCombat();
                                 events.ScheduleEvent(EVENT_BOLT, 1000);
                                 events.ScheduleEvent(EVENT_HARVEST, urand(3000, 15000));
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/Naxxramas/boss_heigan.cpp
--- a/src/server/scripts/Northrend/Naxxramas/boss_heigan.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/Naxxramas/boss_heigan.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -86,7 +86,7 @@
             return 0;
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             _JustDied();
             DoScriptText(SAY_DEATH, me);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/Naxxramas/boss_kelthuzad.cpp
--- a/src/server/scripts/Northrend/Naxxramas/boss_kelthuzad.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/Naxxramas/boss_kelthuzad.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -338,7 +338,7 @@
             DoScriptText(RAND(SAY_SLAY_1, SAY_SLAY_2), me);
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             _JustDied();
             DoScriptText(SAY_DEATH, me);
@@ -457,7 +457,7 @@
                 {
                     if (HealthBelowPct(45))
                     {
-                        Phase = 3 ;
+                        Phase = 3;
                         DoScriptText(SAY_REQUEST_AID, me);
                         //here Lich King should respond to KelThuzad but I don't know which Creature to make talk
                         //so for now just make Kelthuzad says it.
@@ -667,7 +667,7 @@
         if (!instance || instance->IsEncounterInProgress() || instance->GetBossState(BOSS_KELTHUZAD) == DONE)
             return false;
 
-        Creature* pKelthuzad = CAST_CRE(Unit::GetUnit(*player, instance->GetData64(DATA_KELTHUZAD)));
+        Creature* pKelthuzad = Unit::GetCreature(*player, instance->GetData64(DATA_KELTHUZAD));
         if (!pKelthuzad)
             return false;
 
@@ -714,7 +714,6 @@
 
         return true;
     }
-
 };
 
 class npc_kelthuzad_abomination : public CreatureScript
@@ -726,16 +725,13 @@
         {
             npc_kelthuzad_abominationAI(Creature* creature) : ScriptedAI(creature)
             {
-                instance = me->GetInstanceScript();
+                _instance = creature->GetInstanceScript();
             }
 
-            InstanceScript* instance;
-            EventMap events;
-
             void Reset()
             {
-                events.Reset();
-                events.ScheduleEvent(EVENT_MORTAL_WOUND, urand(2000, 5000));
+                _events.Reset();
+                _events.ScheduleEvent(EVENT_MORTAL_WOUND, urand(2000, 5000));
                 DoCast(me, SPELL_FRENZY, true);
             }
 
@@ -744,15 +740,15 @@
                 if (!UpdateVictim())
                     return;
 
-                events.Update(diff);
+                _events.Update(diff);
 
-                while (uint32 eventId = events.ExecuteEvent())
+                while (uint32 eventId = _events.ExecuteEvent())
                 {
                     switch (eventId)
                     {
                         case EVENT_MORTAL_WOUND:
                             DoCastVictim(SPELL_MORTAL_WOUND, true);
-                            events.ScheduleEvent(EVENT_MORTAL_WOUND, urand(10000, 15000));
+                            _events.ScheduleEvent(EVENT_MORTAL_WOUND, urand(10000, 15000));
                             break;
                         default:
                             break;
@@ -760,11 +756,15 @@
                 }
             }
 
-            void JustDied(Unit* /*who*/)
+            void JustDied(Unit* /*killer*/)
             {
-                if (instance)
-                    instance->SetData(DATA_ABOMINATION_KILLED, instance->GetData(DATA_ABOMINATION_KILLED) + 1);
+                if (_instance)
+                    _instance->SetData(DATA_ABOMINATION_KILLED, _instance->GetData(DATA_ABOMINATION_KILLED) + 1);
             }
+
+        private:
+            InstanceScript* _instance;
+            EventMap _events;
         };
 
         CreatureAI* GetAI(Creature* creature) const
@@ -776,9 +776,7 @@
 class achievement_just_cant_get_enough : public AchievementCriteriaScript
 {
    public:
-       achievement_just_cant_get_enough() : AchievementCriteriaScript("achievement_just_cant_get_enough")
-       {
-       }
+       achievement_just_cant_get_enough() : AchievementCriteriaScript("achievement_just_cant_get_enough") { }
 
        bool OnCheck(Player* /*player*/, Unit* target)
        {
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/Naxxramas/boss_noth.cpp
--- a/src/server/scripts/Northrend/Naxxramas/boss_noth.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/Naxxramas/boss_noth.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -124,7 +124,7 @@
             summon->AI()->DoZoneInCombat();
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             _JustDied();
             DoScriptText(SAY_DEATH, me);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/Naxxramas/boss_patchwerk.cpp
--- a/src/server/scripts/Northrend/Naxxramas/boss_patchwerk.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/Naxxramas/boss_patchwerk.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -80,7 +80,7 @@
                 DoScriptText(SAY_SLAY, me);
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             _JustDied();
             DoScriptText(SAY_DEATH, me);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/Naxxramas/boss_sapphiron.cpp
--- a/src/server/scripts/Northrend/Naxxramas/boss_sapphiron.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/Naxxramas/boss_sapphiron.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -145,7 +145,7 @@
             }
         }
 
-        void JustDied(Unit* /*who*/)
+        void JustDied(Unit* /*killer*/)
         {
             _JustDied();
             me->CastSpell(me, SPELL_DIES, true);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/Naxxramas/boss_thaddius.cpp
--- a/src/server/scripts/Northrend/Naxxramas/boss_thaddius.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/Naxxramas/boss_thaddius.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -158,7 +158,7 @@
                 DoScriptText(SAY_SLAY, me);
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             _JustDied();
             DoScriptText(SAY_DEATH, me);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/Naxxramas/instance_naxxramas.cpp
--- a/src/server/scripts/Northrend/Naxxramas/instance_naxxramas.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/Naxxramas/instance_naxxramas.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -465,7 +465,6 @@
             playerDied = buff2;
         }
     };
-
 };
 
 void AddSC_instance_naxxramas()
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/Nexus/EyeOfEternity/boss_malygos.cpp
--- a/src/server/scripts/Northrend/Nexus/EyeOfEternity/boss_malygos.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/Nexus/EyeOfEternity/boss_malygos.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -963,8 +963,9 @@
             // we dont do melee damage!
         }
 
-        void WaypointReached(uint32 /*i*/)
+        void WaypointReached(uint32 /*waypointId*/)
         {
+
         }
 
     private:
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/Nexus/Nexus/boss_anomalus.cpp
--- a/src/server/scripts/Northrend/Nexus/Nexus/boss_anomalus.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/Nexus/Nexus/boss_anomalus.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -101,7 +101,7 @@
                     instance->SetData(DATA_ANOMALUS_EVENT, IN_PROGRESS);
             }
 
-            void JustDied(Unit* /*who*/)
+            void JustDied(Unit* /*killer*/)
             {
                 DoScriptText(SAY_DEATH, me);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/Nexus/Nexus/boss_ormorok.cpp
--- a/src/server/scripts/Northrend/Nexus/Nexus/boss_ormorok.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/Nexus/Nexus/boss_ormorok.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -195,7 +195,7 @@
                         std::list<HostileReference*>::const_iterator i = me->getThreatManager().getThreatList().begin();
                         for (; i != me->getThreatManager().getThreatList().end(); ++i)
                         {
-                            Unit* temp = Unit::GetUnit((*me), (*i)->getUnitGuid());
+                            Unit* temp = Unit::GetUnit(*me, (*i)->getUnitGuid());
                             if (temp && temp->GetTypeId() == TYPEID_PLAYER && temp->getClass() == Healer)
                             {
                                 target = temp;
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/Nexus/Oculus/boss_urom.cpp
--- a/src/server/scripts/Northrend/Nexus/Oculus/boss_urom.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/Nexus/Oculus/boss_urom.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -203,7 +203,7 @@
             if (!instance || instance->GetData(DATA_UROM_PLATAFORM) > 2)
                 return;
 
-            for (uint8 i = 0; i < 4 ; i++)
+            for (uint8 i = 0; i < 4; i++)
             {
                 SetPosition(i);
                 me->SummonCreature(Group[group[instance->GetData(DATA_UROM_PLATAFORM)]].entry[i], x, y, me->GetPositionZ(), me->GetOrientation());
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/Nexus/Oculus/boss_varos.cpp
--- a/src/server/scripts/Northrend/Nexus/Oculus/boss_varos.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/Nexus/Oculus/boss_varos.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -308,7 +308,7 @@
 
                 float orientation = CAST_AI(boss_varos::boss_varosAI, varos->AI())->GetCoreEnergizeOrientation();
 
-                for (std::list<Unit*>::iterator itr = targetList.begin() ; itr != targetList.end();)
+                for (std::list<Unit*>::iterator itr = targetList.begin(); itr != targetList.end();)
                 {
                     Position pos;
                     (*itr)->GetPosition(&pos);
@@ -355,7 +355,7 @@
 
                 float orientation = CAST_AI(boss_varos::boss_varosAI, varos->AI())->GetCoreEnergizeOrientation();
 
-                for (std::list<Unit*>::iterator itr = targetList.begin() ; itr != targetList.end();)
+                for (std::list<Unit*>::iterator itr = targetList.begin(); itr != targetList.end();)
                 {
                     Position pos;
                     (*itr)->GetPosition(&pos);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/Ulduar/HallsOfStone/halls_of_stone.cpp
--- a/src/server/scripts/Northrend/Ulduar/HallsOfStone/halls_of_stone.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/Ulduar/HallsOfStone/halls_of_stone.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -346,9 +346,9 @@
             lDwarfGUIDList.clear();
         }
 
-        void WaypointReached(uint32 uiPointId)
+        void WaypointReached(uint32 waypointId)
         {
-            switch (uiPointId)
+            switch (waypointId)
             {
                 case 7:
                     if (Creature* creature = GetClosestCreatureWithEntry(me, CREATURE_TRIBUNAL_OF_THE_AGES, 100.0f))
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/Ulduar/Ulduar/boss_assembly_of_iron.cpp
--- a/src/server/scripts/Northrend/Ulduar/Ulduar/boss_assembly_of_iron.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/Ulduar/Ulduar/boss_assembly_of_iron.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -362,7 +362,7 @@
                     if (playerList.empty())
                         return NULL;
 
-                    return SelectRandomContainerElement(playerList);
+                    return Trinity::Containers::SelectRandomContainerElement(playerList);
                 }
                 else
                     return NULL;
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/Ulduar/Ulduar/boss_flame_leviathan.cpp
--- a/src/server/scripts/Northrend/Ulduar/Ulduar/boss_flame_leviathan.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/Ulduar/Ulduar/boss_flame_leviathan.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -1765,14 +1765,14 @@
                 if (!tempList.empty())
                 {
                     // found one or more vehicles, select a random one
-                    _target = SelectRandomContainerElement(tempList);
+                    _target = Trinity::Containers::SelectRandomContainerElement(tempList);
                     unitList.clear();
                     unitList.push_back(_target);
                 }
                 else
                 {
                     // found no vehicles, select a random player or pet
-                    _target = SelectRandomContainerElement(unitList);
+                    _target = Trinity::Containers::SelectRandomContainerElement(unitList);
                     unitList.clear();
                     unitList.push_back(_target);
                 }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/Ulduar/Ulduar/boss_freya.cpp
--- a/src/server/scripts/Northrend/Ulduar/Ulduar/boss_freya.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/Ulduar/Ulduar/boss_freya.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -626,7 +626,7 @@
                 if (uiNaturalBomb_Timer <= diff)
                 {
                     std::list<Player*> playerList = me->GetNearestPlayersList(500.0f);
-                    Trinity::RandomResizeList<Player*>(playerList, uint32(Is25ManRaid() ? urand(10, 15) : urand(4, 6)));
+                    Trinity::Containers::RandomResizeList<Player*>(playerList, uint32(Is25ManRaid() ? urand(10, 15) : urand(4, 6)));
                     for (std::list<Player*>::const_iterator itr = playerList.begin(); itr != playerList.end(); ++itr)
                         me->CastSpell(*itr, SPELL_NATURE_BOMB_VISUAL, true);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/Ulduar/Ulduar/boss_general_vezax.cpp
--- a/src/server/scripts/Northrend/Ulduar/Ulduar/boss_general_vezax.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/Ulduar/Ulduar/boss_general_vezax.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -238,7 +238,7 @@
                     if (size < PlayersMin)
                         return NULL;
 
-                    return SelectRandomContainerElement(playerList);
+                    return Trinity::Containers::SelectRandomContainerElement(playerList);
                 }
                 else
                     return NULL;
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/Ulduar/Ulduar/boss_kologarn.cpp
--- a/src/server/scripts/Northrend/Ulduar/Ulduar/boss_kologarn.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/Ulduar/Ulduar/boss_kologarn.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -263,7 +263,7 @@
                     if (playerList.empty())
                         return NULL;
 
-                    return SelectRandomContainerElement(playerList);
+                    return Trinity::Containers::SelectRandomContainerElement(playerList);
                 }
                 else
                     return NULL;
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/Ulduar/Ulduar/boss_mimiron.cpp
--- a/src/server/scripts/Northrend/Ulduar/Ulduar/boss_mimiron.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/Ulduar/Ulduar/boss_mimiron.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -988,7 +988,7 @@
                     if (playerList.empty())
                         return NULL;
 
-                    return SelectRandomContainerElement(playerList);
+                    return Trinity::Containers::SelectRandomContainerElement(playerList);
                 }
                 else
                     return NULL;
@@ -1326,7 +1326,7 @@
                             me->GetCreatureListWithEntryInGrid(_flames, NPC_FLAME_SPREAD, 150.0f);
                             if (!_flames.empty())
                             {
-                                if (Creature* flame = SelectRandomContainerElement(_flames))
+                                if (Creature* flame = Trinity::Containers::SelectRandomContainerElement(_flames))
                                     me->SummonCreature(NPC_FROST_BOMB, *flame, TEMPSUMMON_TIMED_DESPAWN, 11000);
                             }
                             else
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/Ulduar/Ulduar/boss_razorscale.cpp
--- a/src/server/scripts/Northrend/Ulduar/Ulduar/boss_razorscale.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/Ulduar/Ulduar/boss_razorscale.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -342,7 +342,8 @@
                     controller->AI()->DoAction(ACTION_REMOVE_HARPOON);
                     controller->AI()->DoAction(ACTION_PLACE_BROKEN_HARPOON);
                 }
-                summons.DoAction(MOLE_MACHINE_TRIGGER, ACTION_DESPAWN_ADDS);
+                EntryCheckPredicate pred(MOLE_MACHINE_TRIGGER);
+                summons.DoAction(ACTION_DESPAWN_ADDS,pred);
                 _Reset();
                 me->SetCanFly(true);
                 me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/Ulduar/Ulduar/boss_xt002.cpp
--- a/src/server/scripts/Northrend/Ulduar/Ulduar/boss_xt002.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/Ulduar/Ulduar/boss_xt002.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -855,7 +855,7 @@
                 if (unitList.empty())
                     return;
 
-                _target = SelectRandomContainerElement(unitList);
+                _target = Trinity::Containers::SelectRandomContainerElement(unitList);
                 unitList.clear();
                 unitList.push_back(_target);
             }
@@ -927,7 +927,7 @@
                 if (unitList.empty())
                     return;
 
-                _target = SelectRandomContainerElement(unitList);
+                _target = Trinity::Containers::SelectRandomContainerElement(unitList);
                 unitList.clear();
                 unitList.push_back(_target);
             }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/UtgardeKeep/UtgardeKeep/boss_ingvar_the_plunderer.cpp
--- a/src/server/scripts/Northrend/UtgardeKeep/UtgardeKeep/boss_ingvar_the_plunderer.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/UtgardeKeep/UtgardeKeep/boss_ingvar_the_plunderer.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -344,7 +344,7 @@
         {
             if (type != POINT_MOTION_TYPE)
                 return;
-            Unit* ingvar = Unit::GetUnit((*me), instance ? instance->GetData64(DATA_INGVAR) : 0);
+            Unit* ingvar = Unit::GetUnit(*me, instance ? instance->GetData64(DATA_INGVAR) : 0);
             if (ingvar)
             {
                 switch (id)
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/UtgardeKeep/UtgardeKeep/boss_skarvald_dalronn.cpp
--- a/src/server/scripts/Northrend/UtgardeKeep/UtgardeKeep/boss_skarvald_dalronn.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/UtgardeKeep/UtgardeKeep/boss_skarvald_dalronn.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -93,7 +93,7 @@
             ghost = (me->GetEntry() == MOB_SKARVALD_GHOST);
             if (!ghost && instance)
             {
-                Unit* dalronn = Unit::GetUnit((*me), instance->GetData64(DATA_DALRONN));
+                Unit* dalronn = Unit::GetUnit(*me, instance->GetData64(DATA_DALRONN));
                 if (dalronn && dalronn->isDead())
                     CAST_CRE(dalronn)->Respawn();
 
@@ -107,7 +107,7 @@
             {
                 DoScriptText(YELL_SKARVALD_AGGRO, me);
 
-                Unit* dalronn = Unit::GetUnit((*me), instance->GetData64(DATA_DALRONN));
+                Unit* dalronn = Unit::GetUnit(*me, instance->GetData64(DATA_DALRONN));
                 if (dalronn && dalronn->isAlive() && !dalronn->getVictim())
                     dalronn->getThreatManager().addThreat(who, 0.0f);
 
@@ -115,11 +115,11 @@
             }
         }
 
-        void JustDied(Unit* Killer)
+        void JustDied(Unit* killer)
         {
             if (!ghost && instance)
             {
-                Unit* dalronn = Unit::GetUnit((*me), instance->GetData64(DATA_DALRONN));
+                Unit* dalronn = Unit::GetUnit(*me, instance->GetData64(DATA_DALRONN));
                 if (dalronn)
                 {
                     if (dalronn->isDead())
@@ -138,7 +138,7 @@
                         if (temp)
                         {
                             temp->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-                            temp->AI()->AttackStart(Killer);
+                            temp->AI()->AttackStart(killer);
                         }
                     }
                 }
@@ -250,7 +250,7 @@
             ghost = me->GetEntry() == MOB_DALRONN_GHOST;
             if (!ghost && instance)
             {
-                Unit* skarvald = Unit::GetUnit((*me), instance->GetData64(DATA_SKARVALD));
+                Unit* skarvald = Unit::GetUnit(*me, instance->GetData64(DATA_SKARVALD));
                 if (skarvald && skarvald->isDead())
                     CAST_CRE(skarvald)->Respawn();
 
@@ -262,7 +262,7 @@
         {
             if (!ghost && instance)
             {
-                Unit* skarvald = Unit::GetUnit((*me), instance->GetData64(DATA_SKARVALD));
+                Unit* skarvald = Unit::GetUnit(*me, instance->GetData64(DATA_SKARVALD));
                 if (skarvald && skarvald->isAlive() && !skarvald->getVictim())
                     skarvald->getThreatManager().addThreat(who, 0.0f);
 
@@ -273,11 +273,11 @@
             }
         }
 
-        void JustDied(Unit* Killer)
+        void JustDied(Unit* killer)
         {
             if (!ghost && instance)
             {
-                Unit* skarvald = Unit::GetUnit((*me), instance->GetData64(DATA_SKARVALD));
+                Unit* skarvald = Unit::GetUnit(*me, instance->GetData64(DATA_SKARVALD));
                 if (skarvald)
                 {
                     if (skarvald->isDead())
@@ -297,7 +297,7 @@
                         if (temp)
                         {
                             temp->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-                            temp->AI()->AttackStart(Killer);
+                            temp->AI()->AttackStart(killer);
                         }
                     }
                 }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/UtgardeKeep/UtgardeKeep/utgarde_keep.cpp
--- a/src/server/scripts/Northrend/UtgardeKeep/UtgardeKeep/utgarde_keep.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/UtgardeKeep/UtgardeKeep/utgarde_keep.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -48,65 +48,77 @@
 
         void Reset()
         {
-            if (fm_Type == 0) fm_Type = GetForgeMasterType();
+            if (fm_Type == 0)
+                fm_Type = GetForgeMasterType();
+
             CheckForge();
         }
 
         void CheckForge()
         {
-           if (instance)
+            if (instance)
             {
                 switch (fm_Type)
                 {
-                case 1:
-                    instance->SetData(EVENT_FORGE_1, me->isAlive() ? NOT_STARTED : DONE);
-                    break;
-                case 2:
-                    instance->SetData(EVENT_FORGE_2, me->isAlive() ? NOT_STARTED : DONE);
-                    break;
-                case 3:
-                    instance->SetData(EVENT_FORGE_3, me->isAlive() ? NOT_STARTED : DONE);
-                    break;
+                    case 1:
+                        instance->SetData(EVENT_FORGE_1, me->isAlive() ? NOT_STARTED : DONE);
+                        break;
+
+                    case 2:
+                        instance->SetData(EVENT_FORGE_2, me->isAlive() ? NOT_STARTED : DONE);
+                        break;
+
+                    case 3:
+                        instance->SetData(EVENT_FORGE_3, me->isAlive() ? NOT_STARTED : DONE);
+                        break;
                 }
             }
         }
 
         void JustDied(Unit* /*killer*/)
         {
-            if (fm_Type == 0) fm_Type = GetForgeMasterType();
+            if (fm_Type == 0)
+                fm_Type = GetForgeMasterType();
+
             if (instance)
             {
                 switch (fm_Type)
                 {
-                case 1:
-                    instance->SetData(EVENT_FORGE_1, DONE);
-                    break;
-                case 2:
-                    instance->SetData(EVENT_FORGE_2, DONE);
-                    break;
-                case 3:
-                    instance->SetData(EVENT_FORGE_3, DONE);
-                    break;
+                    case 1:
+                        instance->SetData(EVENT_FORGE_1, DONE);
+                        break;
+
+                    case 2:
+                        instance->SetData(EVENT_FORGE_2, DONE);
+                        break;
+
+                    case 3:
+                        instance->SetData(EVENT_FORGE_3, DONE);
+                        break;
                 }
             }
         }
 
         void EnterCombat(Unit* /*who*/)
         {
-            if (fm_Type == 0) fm_Type = GetForgeMasterType();
+            if (fm_Type == 0)
+                fm_Type = GetForgeMasterType();
+
             if (instance)
             {
                 switch (fm_Type)
                 {
-                case 1:
-                    instance->SetData(EVENT_FORGE_1, IN_PROGRESS);
-                    break;
-                case 2:
-                    instance->SetData(EVENT_FORGE_2, IN_PROGRESS);
-                    break;
-                case 3:
-                    instance->SetData(EVENT_FORGE_3, IN_PROGRESS);
-                    break;
+                    case 1:
+                        instance->SetData(EVENT_FORGE_1, IN_PROGRESS);
+                        break;
+
+                    case 2:
+                        instance->SetData(EVENT_FORGE_2, IN_PROGRESS);
+                        break;
+
+                    case 3:
+                        instance->SetData(EVENT_FORGE_3, IN_PROGRESS);
+                        break;
                 }
             }
             me->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_ONESHOT_NONE);
@@ -115,29 +127,26 @@
         uint8 GetForgeMasterType()
         {
             float diff = 30.0f;
-            int near_f = 0;
+            uint8 near_f = 0;
 
-            for (uint8 i = 0; i < 3 ; ++i)
+            for (uint8 i = 0; i < 3; ++i)
             {
-                GameObject* temp;
-                temp = me->FindNearestGameObject(entry_search[i], 30);
-                if (temp)
+                if (GameObject* go = me->FindNearestGameObject(entry_search[i], 30))
                 {
-                    if (me->IsWithinDist(temp, diff, false))
+                    if (me->IsWithinDist(go, diff, false))
                     {
                         near_f = i + 1;
-                        diff = me->GetDistance2d(temp);
-
+                        diff = me->GetDistance2d(go);
                     }
                 }
             }
 
             switch (near_f)
             {
-            case 1:  return 1;
-            case 2:  return 2;
-            case 3:  return 3;
-            default: return 0;
+                case 1:  return 1;
+                case 2:  return 2;
+                case 3:  return 3;
+                default: return 0;
             }
         }
 
@@ -152,7 +161,6 @@
             DoMeleeAttackIfReady();
         }
     };
-
 };
 
 void AddSC_utgarde_keep()
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/VaultOfArchavon/boss_emalon.cpp
--- a/src/server/scripts/Northrend/VaultOfArchavon/boss_emalon.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/VaultOfArchavon/boss_emalon.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -139,7 +139,7 @@
                         case EVENT_OVERCHARGE:
                             if (!summons.empty())
                             {
-                                Creature* minion = Unit::GetCreature(*me, SelectRandomContainerElement(summons));
+                                Creature* minion = Unit::GetCreature(*me, Trinity::Containers::SelectRandomContainerElement(summons));
                                 if (minion && minion->isAlive())
                                 {
                                     minion->CastSpell(me, SPELL_OVERCHARGED, true);
@@ -189,7 +189,7 @@
                 OverchargedTimer = 0;
             }
 
-            void JustDied(Unit* /*Killer*/)
+            void JustDied(Unit* /*killer*/)
             {
                 if (Creature* emalon = Unit::GetCreature(*me, instance ? instance->GetData64(DATA_EMALON) : 0))
                 {
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/VioletHold/boss_cyanigosa.cpp
--- a/src/server/scripts/Northrend/VioletHold/boss_cyanigosa.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/VioletHold/boss_cyanigosa.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -168,6 +168,9 @@
 
         bool OnCheck(Player* /*player*/, Unit* target)
         {
+            if (!target)
+                return false;
+
             InstanceScript* instance = target->GetInstanceScript();
             if (!instance)
                 return false;
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/VioletHold/violet_hold.cpp
--- a/src/server/scripts/Northrend/VioletHold/violet_hold.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/VioletHold/violet_hold.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -447,32 +447,32 @@
             me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
         }
 
-        void WaypointReached(uint32 uiWPointId)
+        void WaypointReached(uint32 waypointId)
         {
             switch (uiBoss)
             {
                 case 1:
-                    if (uiWPointId == 2)
+                    if (waypointId == 2)
                         FinishPointReached();
                     break;
                 case 2:
-                    if (uiWPointId == 2)
+                    if (waypointId == 2)
                         FinishPointReached();
                     break;
                 case 3:
-                    if (uiWPointId == 1)
+                    if (waypointId == 1)
                         FinishPointReached();
                     break;
                 case 4:
-                    if (uiWPointId == 0)
+                    if (waypointId == 0)
                         FinishPointReached();
                     break;
                 case 5:
-                    if (uiWPointId == 0)
+                    if (waypointId == 0)
                         FinishPointReached();
                     break;
                 case 6:
-                    if (uiWPointId == 4)
+                    if (waypointId == 4)
                         FinishPointReached();
                     break;
             }
@@ -690,32 +690,32 @@
         uint32 portalLocationID;
         uint32 secondPortalRouteID;
 
-    void WaypointReached(uint32 uiPointId)
+    void WaypointReached(uint32 waypointId)
     {
         switch (portalLocationID)
         {
             case 0:
-                if (uiPointId == 5)
+                if (waypointId == 5)
                    CreatureStartAttackDoor();
                 break;
             case 1:
-                if ((uiPointId == 8 && secondPortalRouteID == 0) || (uiPointId == 7 && secondPortalRouteID == 1))
+                if ((waypointId == 8 && secondPortalRouteID == 0) || (waypointId == 7 && secondPortalRouteID == 1))
                     CreatureStartAttackDoor();
                 break;
             case 2:
-                if (uiPointId == 7)
+                if (waypointId == 7)
                    CreatureStartAttackDoor();
                 break;
             case 3:
-                if (uiPointId == 8)
+                if (waypointId == 8)
                     CreatureStartAttackDoor();
                 break;
             case 4:
-                if (uiPointId == 5)
+                if (waypointId == 5)
                     CreatureStartAttackDoor();
                 break;
             case 5:
-                if (uiPointId == 3)
+                if (waypointId == 3)
                     CreatureStartAttackDoor();
                 break;
         }
@@ -778,7 +778,7 @@
         }
     }
 
-    void JustDied(Unit* /*unit*/)
+    void JustDied(Unit* /*killer*/)
     {
         if (Creature* portal = Unit::GetCreature((*me), instance->GetData64(DATA_TELEPORTATION_PORTAL)))
             CAST_AI(npc_teleportation_portal_vh::npc_teleportation_portalAI, portal->AI())->SummonedMobDied(me);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/borean_tundra.cpp
--- a/src/server/scripts/Northrend/borean_tundra.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/borean_tundra.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -355,21 +355,22 @@
         void EnterCombat(Unit* /*who*/) {}
         void MoveInLineOfSight(Unit* /*who*/) {}
 
-        void JustDied(Unit* Killer)
+        void JustDied(Unit* killer)
         {
-            if (Killer->GetTypeId() == TYPEID_PLAYER)
+            Player* player = killer->ToPlayer();
+            if (!player)
+                return;
+
+            if (player->GetQuestStatus(11611) == QUEST_STATUS_INCOMPLETE)
             {
-                if (CAST_PLR(Killer)->GetQuestStatus(11611) == QUEST_STATUS_INCOMPLETE)
+                uint8 uiRand = urand(0, 99);
+                if (uiRand < 25)
                 {
-                    uint8 uiRand = urand(0, 99);
-                    if (uiRand < 25)
-                    {
-                        Killer->CastSpell(me, 45532, true);
-                        CAST_PLR(Killer)->KilledMonsterCredit(WARSONG_PEON, 0);
-                    }
-                    else if (uiRand < 75)
-                        Killer->CastSpell(me, nerubarVictims[urand(0, 2)], true);
+                    player->CastSpell(me, 45532, true);
+                    player->KilledMonsterCredit(WARSONG_PEON, 0);
                 }
+                else if (uiRand < 75)
+                    player->CastSpell(me, nerubarVictims[urand(0, 2)], true);
             }
         }
     };
@@ -591,7 +592,7 @@
         void EnterCombat(Unit* /*who*/) {}
         void MoveInLineOfSight(Unit* /*who*/) {}
 
-        void JustDied(Unit* /*who*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (GameObject* go_caribou = me->GetMap()->GetGameObject(go_caribouGUID))
                 go_caribou->SetLootState(GO_JUST_DEACTIVATED);
@@ -716,9 +717,9 @@
             }
         }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
-            switch (i)
+            switch (waypointId)
             {
                 case 0:
                     IntroPhase = 1;
@@ -1012,13 +1013,13 @@
             uiPhaseTimer = 0;
         }
 
-        void WaypointReached(uint32 uiPointId)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
             if (!player)
                 return;
 
-            switch (uiPointId)
+            switch (waypointId)
             {
                 case 3:
                     SetEscortPaused(true);
@@ -1038,7 +1039,6 @@
                     }
                     me->SetWalk(false);
                     break;
-
                 case 4:
                     SetEscortPaused(true);
                     uiPhase = 7;
@@ -1446,8 +1446,8 @@
             pLeryssa->SetWalk(false);
             pLeryssa->GetMotionMaster()->MovePoint(0, 3722.114502f, 3564.201660f, 477.441437f);
 
-            if (killer->GetTypeId() == TYPEID_PLAYER)
-                CAST_PLR(killer)->RewardPlayerAndGroupAtEvent(NPC_PRINCE_VALANAR, 0);
+            if (Player* player = killer->ToPlayer())
+                player->RewardPlayerAndGroupAtEvent(NPC_PRINCE_VALANAR, 0);
         }
     };
 
@@ -1628,7 +1628,10 @@
                 StartFollow(pCaster->ToPlayer(), 0, NULL);
                 me->UpdateEntry(NPC_CAPTURED_BERLY_SORCERER, TEAM_NEUTRAL);
                 DoCast(me, SPELL_COSMETIC_ENSLAVE_CHAINS_SELF, true);
-                CAST_PLR(pCaster)->KilledMonsterCredit(NPC_CAPTURED_BERLY_SORCERER, 0);
+
+                if (Player* player = pCaster->ToPlayer())
+                    player->KilledMonsterCredit(NPC_CAPTURED_BERLY_SORCERER, 0);
+
                 bEnslaved = true;
             }
         }
@@ -1851,35 +1854,33 @@
                 player->FailQuest(QUEST_ESCAPING_THE_MIST);
         }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
-
             if (!player)
                 return;
 
-            switch (i)
+            switch (waypointId)
             {
-            case 10:
-                me->HandleEmoteCommand(EMOTE_ONESHOT_EXCLAMATION);
-                DoScriptText(SAY_2, me);
-                break;
-            case 12:
-                DoScriptText(SAY_3, me);
-                me->HandleEmoteCommand(EMOTE_ONESHOT_LOOT);
-                break;
-            case 16:
-                DoScriptText(SAY_4, me);
-                me->HandleEmoteCommand(EMOTE_ONESHOT_EXCLAMATION);
-                break;
-            case 20:
-                me->SetPhaseMask(1, true);
-                DoScriptText(SAY_5, me);
-                me->HandleEmoteCommand(EMOTE_ONESHOT_EXCLAMATION);
-                if (player)
+                case 10:
+                    me->HandleEmoteCommand(EMOTE_ONESHOT_EXCLAMATION);
+                    DoScriptText(SAY_2, me);
+                    break;
+                case 12:
+                    DoScriptText(SAY_3, me);
+                    me->HandleEmoteCommand(EMOTE_ONESHOT_LOOT);
+                    break;
+                case 16:
+                    DoScriptText(SAY_4, me);
+                    me->HandleEmoteCommand(EMOTE_ONESHOT_EXCLAMATION);
+                    break;
+                case 20:
+                    me->SetPhaseMask(1, true);
+                    DoScriptText(SAY_5, me);
+                    me->HandleEmoteCommand(EMOTE_ONESHOT_EXCLAMATION);
                     player->GroupEventHappens(QUEST_ESCAPING_THE_MIST, me);
-                SetRun(true);
-                break;
+                    SetRun(true);
+                    break;
             }
         }
     };
@@ -1952,14 +1953,13 @@
             else Bonker_agro=0;
         }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
-
             if (!player)
                 return;
 
-            switch (i)
+            switch (waypointId)
             {
                 case 29:
                     player->GroupEventHappens(QUEST_GET_ME_OUTA_HERE, me);
@@ -2115,14 +2115,17 @@
 
         void JustDied(Unit* killer)
         {
-            if (killer->GetTypeId() == TYPEID_PLAYER &&
-                CAST_PLR(killer)->GetQuestStatus(QUEST_YOU_RE_NOT_SO_BIG_NOW) == QUEST_STATUS_INCOMPLETE &&
+            Player* player = killer->ToPlayer();
+            if (!player)
+                return;
+
+            if (player->GetQuestStatus(QUEST_YOU_RE_NOT_SO_BIG_NOW) == QUEST_STATUS_INCOMPLETE &&
                 (me->HasAura(SPELL_AURA_NOTSOBIG_1) || me->HasAura(SPELL_AURA_NOTSOBIG_2) ||
                 me->HasAura(SPELL_AURA_NOTSOBIG_3) || me->HasAura(SPELL_AURA_NOTSOBIG_4)))
             {
                 Quest const* qInfo = sObjectMgr->GetQuestTemplate(QUEST_YOU_RE_NOT_SO_BIG_NOW);
                 if (qInfo)
-                    CAST_PLR(killer)->KilledMonsterCredit(qInfo->RequiredNpcOrGo[0], 0);
+                    player->KilledMonsterCredit(qInfo->RequiredNpcOrGo[0], 0);
             }
         }
     };
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/grizzly_hills.cpp
--- a/src/server/scripts/Northrend/grizzly_hills.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/grizzly_hills.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -75,12 +75,13 @@
                 summoned->AI()->AttackStart(me->getVictim());
         }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
             if (!player)
                 return;
-            switch (i)
+
+            switch (waypointId)
             {
                 case 9:
                     if (Creature* Mrfloppy = GetClosestCreatureWithEntry(me, NPC_MRFLOPPY, 100.0f))
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/howling_fjord.cpp
--- a/src/server/scripts/Northrend/howling_fjord.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/howling_fjord.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -98,20 +98,20 @@
                 DoMeleeAttackIfReady();
         }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
             if (!player)
                 return;
-            switch (i)
+
+            switch (waypointId)
             {
                 case 1:
                     me->SetReactState(REACT_AGGRESSIVE);
                     SetRun(true);
                     break;
                 case 23:
-                    if (player)
-                        player->GroupEventHappens(QUEST_TRAIL_OF_FIRE, me);
+                    player->GroupEventHappens(QUEST_TRAIL_OF_FIRE, me);
                     me->DespawnOrUnsummon();
                     break;
                 case 5:
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/sholazar_basin.cpp
--- a/src/server/scripts/Northrend/sholazar_basin.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/sholazar_basin.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -70,39 +70,40 @@
             }
         }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
-
             if (!player)
                 return;
 
-            switch (i)
+            switch (waypointId)
             {
-            case 1: SetRun(); break;
-            case 10:
-            case 11:
-            case 12:
-            case 13:
-            case 14:
-            case 15:
-            case 16:
-            case 17:
-            case 18:
-                me->RemoveUnitMovementFlag(MOVEMENTFLAG_SWIMMING);
-                me->RemoveUnitMovementFlag(MOVEMENTFLAG_FALLING);
-                me->SetSpeed(MOVE_SWIM, 0.85f, true);
-                me->AddUnitMovementFlag(MOVEMENTFLAG_SWIMMING | MOVEMENTFLAG_DISABLE_GRAVITY);
-                break;
-            case 19:
-                me->SetUnitMovementFlags(MOVEMENTFLAG_FALLING);
-                break;
-            case 28:
-                player->GroupEventHappens(QUEST_FORTUNATE_MISUNDERSTANDINGS, me);
-              //  me->RestoreFaction();
-                DoScriptText(SAY_END_IRO, me);
-                SetRun(false);
-                break;
+                case 1:
+                    SetRun();
+                    break;
+                case 10:
+                case 11:
+                case 12:
+                case 13:
+                case 14:
+                case 15:
+                case 16:
+                case 17:
+                case 18:
+                    me->RemoveUnitMovementFlag(MOVEMENTFLAG_SWIMMING);
+                    me->RemoveUnitMovementFlag(MOVEMENTFLAG_FALLING);
+                    me->SetSpeed(MOVE_SWIM, 0.85f, true);
+                    me->AddUnitMovementFlag(MOVEMENTFLAG_SWIMMING | MOVEMENTFLAG_DISABLE_GRAVITY);
+                    break;
+                case 19:
+                    me->SetUnitMovementFlags(MOVEMENTFLAG_FALLING);
+                    break;
+                case 28:
+                    player->GroupEventHappens(QUEST_FORTUNATE_MISUNDERSTANDINGS, me);
+                    // me->RestoreFaction();
+                    DoScriptText(SAY_END_IRO, me);
+                    SetRun(false);
+                    break;
             }
         }
 
@@ -113,8 +114,8 @@
 
             if (Player* player = GetPlayerForEscort())
             {
-              if (player->GetQuestStatus(QUEST_FORTUNATE_MISUNDERSTANDINGS) != QUEST_STATUS_COMPLETE)
-                player->FailQuest(QUEST_FORTUNATE_MISUNDERSTANDINGS);
+                if (player->GetQuestStatus(QUEST_FORTUNATE_MISUNDERSTANDINGS) != QUEST_STATUS_COMPLETE)
+                    player->FailQuest(QUEST_FORTUNATE_MISUNDERSTANDINGS);
             }
         }
     };
@@ -306,10 +307,9 @@
             if (me->isDead())
                 return;
 
-            if (me->isSummon())
-                if (Unit* summoner = me->ToTempSummon()->GetSummoner())
-                    if (summoner)
-                        me->GetMotionMaster()->MovePoint(0, summoner->GetPositionX(), summoner->GetPositionY(), summoner->GetPositionZ());
+            if (TempSummon* summ = me->ToTempSummon())
+                if (Unit* summoner = summ->GetSummoner())
+                    me->GetMotionMaster()->MovePoint(0, summoner->GetPositionX(), summoner->GetPositionY(), summoner->GetPositionZ());
 
             Reset();
         }
@@ -360,10 +360,11 @@
 
         uint32 m_uiChatTimer;
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
-            switch (i)
+
+            switch (waypointId)
             {
                 case 0:
                     DoScriptText(SAY_WP_2, me);
@@ -402,12 +403,12 @@
         {
             m_uiChatTimer = 4000;
         }
+
         void JustDied(Unit* /*killer*/)
         {
-            Player* player = GetPlayerForEscort();
             if (HasEscortState(STATE_ESCORT_ESCORTING))
             {
-                if (player)
+                if (Player* player = GetPlayerForEscort())
                     player->FailQuest(QUEST_DISASTER);
             }
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/storm_peaks.cpp
--- a/src/server/scripts/Northrend/storm_peaks.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/storm_peaks.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -374,18 +374,20 @@
     {
         npc_injured_goblinAI(Creature* creature) : npc_escortAI(creature) { }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
-            switch (i)
+            if (!player)
+                return;
+
+            switch (waypointId)
             {
-            case 26:
-                DoScriptText(SAY_END_WP_REACHED, me, player);
-                break;
-            case 27:
-                if (player)
+                case 26:
+                    DoScriptText(SAY_END_WP_REACHED, me, player);
+                    break;
+                case 27:
                     player->GroupEventHappens(QUEST_BITTER_DEPARTURE, me);
-                break;
+                    break;
             }
         }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Northrend/zuldrak.cpp
--- a/src/server/scripts/Northrend/zuldrak.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Northrend/zuldrak.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -740,9 +740,9 @@
             bEnrage = false;
         }
 
-        void WaypointReached(uint32 uiI)
+        void WaypointReached(uint32 waypointId)
         {
-            switch (uiI)
+            switch (waypointId)
             {
                 case 6:
                     me->SetHomePosition(me->GetPositionX(), me->GetPositionY(), me->GetPositionZ(), 0);
@@ -934,9 +934,9 @@
             bThunderClap = false;
         }
 
-        void WaypointReached(uint32 uiI)
+        void WaypointReached(uint32 waypointId)
         {
-            switch (uiI)
+            switch (waypointId)
             {
                 case 7:
                     me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
@@ -1071,7 +1071,7 @@
 
             SummonList.clear();
 
-            for (uint8 uiI = 0; uiI < 16 ; uiI++)
+            for (uint8 uiI = 0; uiI < 16; uiI++)
             {
                 if (Creature* summon = me->SummonCreature(Boss[uiBossRandom].uiAdd, AddSpawnPosition[uiI]))
                 {
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/Auchindoun/AuchenaiCrypts/boss_exarch_maladaar.cpp
--- a/src/server/scripts/Outland/Auchindoun/AuchenaiCrypts/boss_exarch_maladaar.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/Auchindoun/AuchenaiCrypts/boss_exarch_maladaar.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -233,7 +233,7 @@
             DoScriptText(RAND(SAY_SLAY_1, SAY_SLAY_2), me);
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEATH, me);
             //When Exarch Maladar is defeated D'ore appear.
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/Auchindoun/ManaTombs/boss_nexusprince_shaffar.cpp
--- a/src/server/scripts/Outland/Auchindoun/ManaTombs/boss_nexusprince_shaffar.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/Auchindoun/ManaTombs/boss_nexusprince_shaffar.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -145,7 +145,7 @@
             DoScriptText(RAND(SAY_SLAY_1, SAY_SLAY_2), me);
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEAD, me);
             summons.DespawnAll();
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/Auchindoun/ManaTombs/boss_pandemonius.cpp
--- a/src/server/scripts/Outland/Auchindoun/ManaTombs/boss_pandemonius.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/Auchindoun/ManaTombs/boss_pandemonius.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -68,7 +68,7 @@
             VoidBlast_Counter = 0;
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEATH, me);
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/Auchindoun/SethekkHalls/boss_darkweaver_syth.cpp
--- a/src/server/scripts/Outland/Auchindoun/SethekkHalls/boss_darkweaver_syth.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/Auchindoun/SethekkHalls/boss_darkweaver_syth.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -97,7 +97,7 @@
             DoScriptText(RAND(SAY_AGGRO_1, SAY_AGGRO_2, SAY_AGGRO_3), me);
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEATH, me);
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/Auchindoun/SethekkHalls/boss_tailonking_ikiss.cpp
--- a/src/server/scripts/Outland/Auchindoun/SethekkHalls/boss_tailonking_ikiss.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/Auchindoun/SethekkHalls/boss_tailonking_ikiss.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -118,7 +118,7 @@
             DoScriptText(RAND(SAY_AGGRO_1, SAY_AGGRO_2, SAY_AGGRO_3), me);
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEATH, me);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/Auchindoun/ShadowLabyrinth/boss_ambassador_hellmaw.cpp
--- a/src/server/scripts/Outland/Auchindoun/ShadowLabyrinth/boss_ambassador_hellmaw.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/Auchindoun/ShadowLabyrinth/boss_ambassador_hellmaw.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -102,7 +102,7 @@
             npc_escortAI::MoveInLineOfSight(who);
         }
 
-        void WaypointReached(uint32 /*i*/)
+        void WaypointReached(uint32 /*waypointId*/)
         {
         }
 
@@ -136,7 +136,7 @@
             DoScriptText(RAND(SAY_SLAY1, SAY_SLAY2), me);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEATH, me);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/Auchindoun/ShadowLabyrinth/boss_blackheart_the_inciter.cpp
--- a/src/server/scripts/Outland/Auchindoun/ShadowLabyrinth/boss_blackheart_the_inciter.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/Auchindoun/ShadowLabyrinth/boss_blackheart_the_inciter.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -96,7 +96,7 @@
             DoScriptText(RAND(SAY_SLAY1, SAY_SLAY2), me);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEATH, me);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/Auchindoun/ShadowLabyrinth/boss_grandmaster_vorpil.cpp
--- a/src/server/scripts/Outland/Auchindoun/ShadowLabyrinth/boss_grandmaster_vorpil.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/Auchindoun/ShadowLabyrinth/boss_grandmaster_vorpil.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -201,7 +201,7 @@
             {
                 for (uint8 i = 0; i < 5; ++i)
                 {
-                    Unit* Portal = Unit::GetUnit((*me), PortalsGuid[i]);
+                    Unit* Portal = Unit::GetUnit(*me, PortalsGuid[i]);
                     if (Portal && Portal->isAlive())
                         Portal->DealDamage(Portal, Portal->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
                     PortalsGuid[i] = 0;
@@ -232,7 +232,7 @@
             DoScriptText(RAND(SAY_SLAY1, SAY_SLAY2), me);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEATH, me);
             destroyPortals();
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/Auchindoun/ShadowLabyrinth/boss_murmur.cpp
--- a/src/server/scripts/Outland/Auchindoun/ShadowLabyrinth/boss_murmur.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/Auchindoun/ShadowLabyrinth/boss_murmur.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -166,7 +166,7 @@
                 {
                     std::list<HostileReference*>& m_threatlist = me->getThreatManager().getThreatList();
                     for (std::list<HostileReference*>::const_iterator i = m_threatlist.begin(); i != m_threatlist.end(); ++i)
-                        if (Unit* target = Unit::GetUnit((*me), (*i)->getUnitGuid()))
+                        if (Unit* target = Unit::GetUnit(*me, (*i)->getUnitGuid()))
                             if (target->isAlive() && !me->IsWithinDist(target, 35, false))
                                 DoCast(target, SPELL_THUNDERING_STORM, true);
                     ThunderingStorm_Timer = 15000;
@@ -189,7 +189,7 @@
             {
                 std::list<HostileReference*>& m_threatlist = me->getThreatManager().getThreatList();
                 for (std::list<HostileReference*>::const_iterator i = m_threatlist.begin(); i != m_threatlist.end(); ++i)
-                    if (Unit* target = Unit::GetUnit((*me), (*i)->getUnitGuid()))
+                    if (Unit* target = Unit::GetUnit(*me, (*i)->getUnitGuid()))
                         if (target->isAlive() && me->IsWithinMeleeRange(target))
                         {
                             me->TauntApply(target);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/BlackTemple/boss_bloodboil.cpp
--- a/src/server/scripts/Outland/BlackTemple/boss_bloodboil.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/BlackTemple/boss_bloodboil.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -130,7 +130,7 @@
             DoScriptText(RAND(SAY_SLAY1, SAY_SLAY2), me);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (instance)
                 instance->SetData(DATA_GURTOGGBLOODBOILEVENT, DONE);
@@ -186,7 +186,7 @@
         void RevertThreatOnTarget(uint64 guid)
         {
             Unit* unit = NULL;
-            unit = Unit::GetUnit((*me), guid);
+            unit = Unit::GetUnit(*me, guid);
             if (unit)
             {
                 if (DoGetThreat(unit))
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/BlackTemple/boss_illidan.cpp
--- a/src/server/scripts/Outland/BlackTemple/boss_illidan.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/BlackTemple/boss_illidan.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -865,7 +865,7 @@
                 {
                     if (GlaiveGUID[i])
                     {
-                        Unit* Glaive = Unit::GetUnit((*me), GlaiveGUID[i]);
+                        Unit* Glaive = Unit::GetUnit(*me, GlaiveGUID[i]);
                         if (Glaive)
                         {
                             Glaive->CastSpell(me, SPELL_GLAIVE_RETURNS, false); // Make it look like the Glaive flies back up to us
@@ -1492,7 +1492,7 @@
             std::vector<Unit*> eliteList;
             for (std::list<HostileReference*>::const_iterator itr = threatList.begin(); itr != threatList.end(); ++itr)
             {
-                Unit* unit = Unit::GetUnit((*me), (*itr)->getUnitGuid());
+                Unit* unit = Unit::GetUnit(*me, (*itr)->getUnitGuid());
                 if (unit && unit->GetEntry() == ILLIDARI_ELITE)
                     eliteList.push_back(unit);
             }
@@ -1649,9 +1649,9 @@
             Unit* Channel = NULL, *Spirit[2] = { NULL, NULL };
             if (ChannelCount <= 5)
             {
-                Channel = Unit::GetUnit((*me), ChannelGUID);
-                Spirit[0] = Unit::GetUnit((*me), SpiritGUID[0]);
-                Spirit[1] = Unit::GetUnit((*me), SpiritGUID[1]);
+                Channel = Unit::GetUnit(*me, ChannelGUID);
+                Spirit[0] = Unit::GetUnit(*me, SpiritGUID[0]);
+                Spirit[1] = Unit::GetUnit(*me, SpiritGUID[1]);
                 if (!Channel || !Spirit[0] || !Spirit[1])
                     return;
             }
@@ -2145,7 +2145,7 @@
 
         void JustDied(Unit* /*killer*/)
         {
-            if (Unit* target = Unit::GetUnit((*me), TargetGUID))
+            if (Unit* target = Unit::GetUnit(*me, TargetGUID))
                 target->RemoveAurasDueToSpell(SPELL_PARALYZE);
         }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/BlackTemple/boss_mother_shahraz.cpp
--- a/src/server/scripts/Outland/BlackTemple/boss_mother_shahraz.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/BlackTemple/boss_mother_shahraz.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -149,7 +149,7 @@
             DoScriptText(RAND(SAY_SLAY1, SAY_SLAY2), me);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (instance)
                 instance->SetData(DATA_MOTHERSHAHRAZEVENT, DONE);
@@ -250,7 +250,7 @@
                         Unit* unit = NULL;
                         if (TargetGUID[i])
                         {
-                            unit = Unit::GetUnit((*me), TargetGUID[i]);
+                            unit = Unit::GetUnit(*me, TargetGUID[i]);
                             if (unit)
                                 unit->CastSpell(unit, SPELL_ATTRACTION, true);
                             TargetGUID[i] = 0;
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/BlackTemple/boss_reliquary_of_souls.cpp
--- a/src/server/scripts/Outland/BlackTemple/boss_reliquary_of_souls.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/BlackTemple/boss_reliquary_of_souls.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -219,7 +219,7 @@
             std::list<HostileReference*>::const_iterator itr = m_threatlist.begin();
             for (; itr != m_threatlist.end(); ++itr)
             {
-                Unit* unit = Unit::GetUnit((*me), (*itr)->getUnitGuid());
+                Unit* unit = Unit::GetUnit(*me, (*itr)->getUnitGuid());
                 if (unit)
                 {
                     DoModifyThreatPercent(unit, -100);
@@ -441,7 +441,7 @@
             std::list<HostileReference*>::const_iterator itr = m_threatlist.begin();
             for (; itr != m_threatlist.end(); ++itr)
             {
-                Unit* unit = Unit::GetUnit((*me), (*itr)->getUnitGuid());
+                Unit* unit = Unit::GetUnit(*me, (*itr)->getUnitGuid());
                 if (unit && unit->isAlive() && (unit->GetTypeId() == TYPEID_PLAYER)) // Only alive players
                     targets.push_back(unit);
             }
@@ -643,7 +643,7 @@
             DoCast(me, AURA_OF_ANGER, true);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(ANGER_SAY_DEATH, me);
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/BlackTemple/boss_supremus.cpp
--- a/src/server/scripts/Outland/BlackTemple/boss_supremus.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/BlackTemple/boss_supremus.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -134,7 +134,8 @@
             if (!phase || phase == PHASE_CHASE)
             {
                 phase = PHASE_STRIKE;
-                summons.DoAction(EVENT_VOLCANO, 0);
+                DummyEntryCheckPredicate pred;
+                summons.DoAction(EVENT_VOLCANO, pred);
                 events.ScheduleEvent(EVENT_HATEFUL_STRIKE, 5000, GCD_CAST, PHASE_STRIKE);
                 me->SetSpeed(MOVE_RUN, 1.2f);
                 me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_TAUNT, false);
@@ -184,7 +185,7 @@
             std::list<HostileReference*>::const_iterator i = m_threatlist.begin();
             for (i = m_threatlist.begin(); i!= m_threatlist.end(); ++i)
             {
-                Unit* unit = Unit::GetUnit((*me), (*i)->getUnitGuid());
+                Unit* unit = Unit::GetUnit(*me, (*i)->getUnitGuid());
                 if (unit && me->IsWithinMeleeRange(unit))
                 {
                     if (unit->GetHealth() > health)
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/BlackTemple/boss_teron_gorefiend.cpp
--- a/src/server/scripts/Outland/BlackTemple/boss_teron_gorefiend.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/BlackTemple/boss_teron_gorefiend.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -175,7 +175,7 @@
             std::list<Unit*> targets;
             for (; itr != m_threatlist.end(); ++itr)
             {
-                Unit* unit = Unit::GetUnit((*me), (*itr)->getUnitGuid());
+                Unit* unit = Unit::GetUnit(*me, (*itr)->getUnitGuid());
                 if (unit && unit->isAlive())
                     targets.push_back(unit);
             }
@@ -293,7 +293,7 @@
             DoScriptText(RAND(SAY_SLAY1, SAY_SLAY2), me);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (instance)
                 instance->SetData(DATA_TERONGOREFIENDEVENT, DONE);
@@ -325,7 +325,7 @@
             std::list<HostileReference*>::const_iterator i = m_threatlist.begin();
             for (i = m_threatlist.begin(); i != m_threatlist.end(); ++i)
             {
-                Unit* unit = Unit::GetUnit((*me), (*i)->getUnitGuid());
+                Unit* unit = Unit::GetUnit(*me, (*i)->getUnitGuid());
                 if (unit && unit->isAlive())
                 {
                     float threat = DoGetThreat(unit);
@@ -345,7 +345,7 @@
 
             Unit* Ghost = NULL;
             if (GhostGUID)
-                Ghost = Unit::GetUnit((*me), GhostGUID);
+                Ghost = Unit::GetUnit(*me, GhostGUID);
             if (Ghost && Ghost->isAlive() && Ghost->HasAura(SPELL_SHADOW_OF_DEATH))
             {
                 /*float x, y, z;
@@ -392,7 +392,7 @@
                     Done = true;
                     if (AggroTargetGUID)
                     {
-                        Unit* unit = Unit::GetUnit((*me), AggroTargetGUID);
+                        Unit* unit = Unit::GetUnit(*me, AggroTargetGUID);
                         if (unit)
                             AttackStart(unit);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/BlackTemple/boss_warlord_najentus.cpp
--- a/src/server/scripts/Outland/BlackTemple/boss_warlord_najentus.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/BlackTemple/boss_warlord_najentus.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -98,7 +98,7 @@
             events.DelayEvents(5000, GCD_YELL);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (instance)
                 instance->SetData(DATA_HIGHWARLORDNAJENTUSEVENT, DONE);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/BlackTemple/illidari_council.cpp
--- a/src/server/scripts/Outland/BlackTemple/illidari_council.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/BlackTemple/illidari_council.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -299,7 +299,7 @@
                     Unit* Member = NULL;
                     if (Council[i])
                     {
-                        Member = Unit::GetUnit((*me), Council[i]);
+                        Member = Unit::GetUnit(*me, Council[i]);
                         if (Member && Member->isAlive())
                             CAST_CRE(Member)->AI()->AttackStart(target);
                     }
@@ -498,7 +498,7 @@
             DoScriptText(SAY_GATH_SLAY, me);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_GATH_DEATH, me);
         }
@@ -512,7 +512,7 @@
                 member = urand(1, 3);
 
             if (member != 2)                                     // No need to create another pointer to us using Unit::GetUnit
-                unit = Unit::GetUnit((*me), Council[member]);
+                unit = Unit::GetUnit(*me, Council[member]);
             return unit;
         }
 
@@ -526,7 +526,7 @@
             }
             for (uint8 i = 0; i < 4; ++i)
             {
-                Unit* unit = Unit::GetUnit((*me), Council[i]);
+                Unit* unit = Unit::GetUnit(*me, Council[i]);
                 if (unit)
                     unit->CastSpell(unit, spellid, true, 0, 0, me->GetGUID());
             }
@@ -632,7 +632,7 @@
             DoScriptText(SAY_ZERE_SLAY, me);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_ZERE_DEATH, me);
         }
@@ -732,7 +732,7 @@
             DoScriptText(SAY_MALA_SLAY, me);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_MALA_DEATH, me);
         }
@@ -818,7 +818,7 @@
             DoScriptText(SAY_VERA_SLAY, me);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_VERA_DEATH, me);
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/CoilfangReservoir/SerpentShrine/boss_fathomlord_karathress.cpp
--- a/src/server/scripts/Outland/CoilfangReservoir/SerpentShrine/boss_fathomlord_karathress.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/CoilfangReservoir/SerpentShrine/boss_fathomlord_karathress.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -225,7 +225,7 @@
             //Only if not incombat check if the event is started
             if (!me->isInCombat() && instance && instance->GetData(DATA_KARATHRESSEVENT))
             {
-                Unit* target = Unit::GetUnit((*me), instance->GetData64(DATA_KARATHRESSEVENT_STARTER));
+                Unit* target = Unit::GetUnit(*me, instance->GetData64(DATA_KARATHRESSEVENT_STARTER));
 
                 if (target)
                 {
@@ -354,7 +354,7 @@
                 instance->SetData(DATA_KARATHRESSEVENT, NOT_STARTED);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (instance)
             {
@@ -381,7 +381,7 @@
             //Only if not incombat check if the event is started
             if (!me->isInCombat() && instance && instance->GetData(DATA_KARATHRESSEVENT))
             {
-                Unit* target = Unit::GetUnit((*me), instance->GetData64(DATA_KARATHRESSEVENT_STARTER));
+                Unit* target = Unit::GetUnit(*me, instance->GetData64(DATA_KARATHRESSEVENT_STARTER));
 
                 if (target)
                 {
@@ -494,7 +494,7 @@
                 instance->SetData(DATA_KARATHRESSEVENT, NOT_STARTED);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (instance)
             {
@@ -522,7 +522,7 @@
             //Only if not incombat check if the event is started
             if (!me->isInCombat() && instance && instance->GetData(DATA_KARATHRESSEVENT))
             {
-                Unit* target = Unit::GetUnit((*me), instance->GetData64(DATA_KARATHRESSEVENT_STARTER));
+                Unit* target = Unit::GetUnit(*me, instance->GetData64(DATA_KARATHRESSEVENT_STARTER));
 
                 if (target)
                 {
@@ -621,7 +621,7 @@
                 instance->SetData(DATA_KARATHRESSEVENT, NOT_STARTED);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (instance)
             {
@@ -648,7 +648,7 @@
             //Only if not incombat check if the event is started
             if (!me->isInCombat() && instance && instance->GetData(DATA_KARATHRESSEVENT))
             {
-                Unit* target = Unit::GetUnit((*me), instance->GetData64(DATA_KARATHRESSEVENT_STARTER));
+                Unit* target = Unit::GetUnit(*me, instance->GetData64(DATA_KARATHRESSEVENT_STARTER));
 
                 if (target)
                 {
@@ -730,13 +730,13 @@
                 switch (rand()%4)
                 {
                 case 0:
-                    unit = Unit::GetUnit((*me), instance->GetData64(DATA_KARATHRESS));
+                    unit = Unit::GetUnit(*me, instance->GetData64(DATA_KARATHRESS));
                     break;
                 case 1:
-                    unit = Unit::GetUnit((*me), instance->GetData64(DATA_SHARKKIS));
+                    unit = Unit::GetUnit(*me, instance->GetData64(DATA_SHARKKIS));
                     break;
                 case 2:
-                    unit = Unit::GetUnit((*me), instance->GetData64(DATA_TIDALVESS));
+                    unit = Unit::GetUnit(*me, instance->GetData64(DATA_TIDALVESS));
                     break;
                 case 3:
                     unit = me;
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/CoilfangReservoir/SerpentShrine/boss_hydross_the_unstable.cpp
--- a/src/server/scripts/Outland/CoilfangReservoir/SerpentShrine/boss_hydross_the_unstable.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/CoilfangReservoir/SerpentShrine/boss_hydross_the_unstable.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -203,7 +203,7 @@
             Summons.Despawn(summon);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (CorruptedForm)
                 DoScriptText(SAY_CORRUPT_DEATH, me);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/CoilfangReservoir/SerpentShrine/boss_lady_vashj.cpp
--- a/src/server/scripts/Outland/CoilfangReservoir/SerpentShrine/boss_lady_vashj.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/CoilfangReservoir/SerpentShrine/boss_lady_vashj.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -226,7 +226,7 @@
             DoScriptText(RAND(SAY_SLAY1, SAY_SLAY2, SAY_SLAY3), me);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEATH, me);
 
@@ -491,7 +491,7 @@
                     Creature* coilfangElite = me->SummonCreature(COILFANG_ELITE, CoilfangElitePos[pos][0], CoilfangElitePos[pos][1], CoilfangElitePos[pos][2], CoilfangElitePos[pos][3], TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
                     if (coilfangElite)
                     {
-                        if (Unit* target = target = SelectTarget(SELECT_TARGET_RANDOM, 0))
+                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0))
                             coilfangElite->AI()->AttackStart(target);
                         else if (me->getVictim())
                             coilfangElite->AI()->AttackStart(me->getVictim());
@@ -783,7 +783,7 @@
                 if (instance)
                 {
                     // check if vashj is death
-                    Unit* Vashj = Unit::GetUnit((*me), instance->GetData64(DATA_LADYVASHJ));
+                    Unit* Vashj = Unit::GetUnit(*me, instance->GetData64(DATA_LADYVASHJ));
                     if (!Vashj || (Vashj && !Vashj->isAlive()) || (Vashj && CAST_AI(boss_lady_vashj::boss_lady_vashjAI, CAST_CRE(Vashj)->AI())->Phase != 3))
                     {
                         // remove
@@ -839,7 +839,7 @@
 
             if (CheckTimer <= diff)
             {
-                Unit* vashj = Unit::GetUnit((*me), instance->GetData64(DATA_LADYVASHJ));
+                Unit* vashj = Unit::GetUnit(*me, instance->GetData64(DATA_LADYVASHJ));
 
                 if (vashj && vashj->isAlive())
                 {
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/CoilfangReservoir/SerpentShrine/boss_leotheras_the_blind.cpp
--- a/src/server/scripts/Outland/CoilfangReservoir/SerpentShrine/boss_leotheras_the_blind.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/CoilfangReservoir/SerpentShrine/boss_leotheras_the_blind.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -109,9 +109,9 @@
             return 0;
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
-            Unit* unit = Unit::GetUnit((*me), victimGUID);
+            Unit* unit = Unit::GetUnit(*me, victimGUID);
             if (unit && unit->HasAura(SPELL_INSIDIOUS_WHISPER))
                 unit->RemoveAurasDueToSpell(SPELL_INSIDIOUS_WHISPER);
         }
@@ -140,7 +140,7 @@
             if (me->getVictim()->GetGUID() != victimGUID)
             {
                 DoModifyThreatPercent(me->getVictim(), -100);
-                Unit* owner = Unit::GetUnit((*me), victimGUID);
+                Unit* owner = Unit::GetUnit(*me, victimGUID);
                 if (owner && owner->isAlive())
                 {
                     me->AddThreat(owner, 999999);
@@ -399,7 +399,7 @@
             }
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEATH, me);
 
@@ -641,7 +641,7 @@
             DoScriptText(RAND(SAY_DEMON_SLAY1, SAY_DEMON_SLAY2, SAY_DEMON_SLAY3), me);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             //invisibility (blizzlike, at the end of the fight he doesn't die, he disappears)
             DoCast(me, 8149, true);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/CoilfangReservoir/SerpentShrine/boss_morogrim_tidewalker.cpp
--- a/src/server/scripts/Outland/CoilfangReservoir/SerpentShrine/boss_morogrim_tidewalker.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/CoilfangReservoir/SerpentShrine/boss_morogrim_tidewalker.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -140,7 +140,7 @@
             DoScriptText(RAND(SAY_SLAY1, SAY_SLAY2, SAY_SLAY3), me);
         }
 
-        void JustDied(Unit* /*victim*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEATH, me);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/CoilfangReservoir/SteamVault/boss_hydromancer_thespia.cpp
--- a/src/server/scripts/Outland/CoilfangReservoir/SteamVault/boss_hydromancer_thespia.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/CoilfangReservoir/SteamVault/boss_hydromancer_thespia.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -79,7 +79,7 @@
                 instance->SetData(TYPE_HYDROMANCER_THESPIA, NOT_STARTED);
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEAD, me);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/CoilfangReservoir/SteamVault/boss_mekgineer_steamrigger.cpp
--- a/src/server/scripts/Outland/CoilfangReservoir/SteamVault/boss_mekgineer_steamrigger.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/CoilfangReservoir/SteamVault/boss_mekgineer_steamrigger.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -88,7 +88,7 @@
                 instance->SetData(TYPE_MEKGINEER_STEAMRIGGER, NOT_STARTED);
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEATH, me);
 
@@ -231,7 +231,7 @@
             {
                 if (instance && instance->GetData64(DATA_MEKGINEERSTEAMRIGGER) && instance->GetData(TYPE_MEKGINEER_STEAMRIGGER) == IN_PROGRESS)
                 {
-                    if (Unit* pMekgineer = Unit::GetUnit((*me), instance->GetData64(DATA_MEKGINEERSTEAMRIGGER)))
+                    if (Unit* pMekgineer = Unit::GetUnit(*me, instance->GetData64(DATA_MEKGINEERSTEAMRIGGER)))
                     {
                         if (me->IsWithinDistInMap(pMekgineer, MAX_REPAIR_RANGE))
                         {
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/CoilfangReservoir/SteamVault/boss_warlord_kalithresh.cpp
--- a/src/server/scripts/Outland/CoilfangReservoir/SteamVault/boss_warlord_kalithresh.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/CoilfangReservoir/SteamVault/boss_warlord_kalithresh.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -157,7 +157,7 @@
                         me->RemoveAurasDueToSpell(SPELL_WARLORDS_RAGE_PROC);
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEATH, me);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/CoilfangReservoir/underbog/boss_the_black_stalker.cpp
--- a/src/server/scripts/Outland/CoilfangReservoir/underbog/boss_the_black_stalker.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/CoilfangReservoir/underbog/boss_the_black_stalker.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -88,7 +88,7 @@
             }
         }
 
-        void JustDied(Unit* /*who*/)
+        void JustDied(Unit* /*killer*/)
         {
             for (std::list<uint64>::const_iterator i = Striders.begin(); i != Striders.end(); ++i)
                 if (Creature* strider = Unit::GetCreature(*me, *i))
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/GruulsLair/boss_gruul.cpp
--- a/src/server/scripts/Outland/GruulsLair/boss_gruul.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/GruulsLair/boss_gruul.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -109,7 +109,7 @@
             DoScriptText(RAND(SAY_SLAY1, SAY_SLAY2, SAY_SLAY3), me);
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEATH, me);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/GruulsLair/boss_high_king_maulgar.cpp
--- a/src/server/scripts/Outland/GruulsLair/boss_high_king_maulgar.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/GruulsLair/boss_high_king_maulgar.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -173,7 +173,7 @@
             DoScriptText(RAND(SAY_SLAY1, SAY_SLAY2, SAY_SLAY3), me);
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             DoScriptText(SAY_DEATH, me);
 
@@ -223,7 +223,7 @@
             //Only if not incombat check if the event is started
             if (!me->isInCombat() && instance && instance->GetData(DATA_MAULGAREVENT))
             {
-                Unit* target = Unit::GetUnit((*me), instance->GetData64(DATA_MAULGAREVENT_TANK));
+                Unit* target = Unit::GetUnit(*me, instance->GetData64(DATA_MAULGAREVENT_TANK));
 
                 if (target)
                 {
@@ -363,7 +363,7 @@
             }
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (instance)
             {
@@ -383,7 +383,7 @@
             //Only if not incombat check if the event is started
             if (!me->isInCombat() && instance && instance->GetData(DATA_MAULGAREVENT))
             {
-                Unit* target = Unit::GetUnit((*me), instance->GetData64(DATA_MAULGAREVENT_TANK));
+                Unit* target = Unit::GetUnit(*me, instance->GetData64(DATA_MAULGAREVENT_TANK));
 
                 if (target)
                 {
@@ -478,7 +478,7 @@
             }
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (instance)
             {
@@ -498,7 +498,7 @@
             //Only if not incombat check if the event is started
             if (!me->isInCombat() && instance && instance->GetData(DATA_MAULGAREVENT))
             {
-                Unit* target = Unit::GetUnit((*me), instance->GetData64(DATA_MAULGAREVENT_TANK));
+                Unit* target = Unit::GetUnit(*me, instance->GetData64(DATA_MAULGAREVENT_TANK));
 
                 if (target)
                 {
@@ -598,7 +598,7 @@
             }
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (instance)
             {
@@ -618,7 +618,7 @@
             //Only if not incombat check if the event is started
             if (!me->isInCombat() && instance && instance->GetData(DATA_MAULGAREVENT))
             {
-                Unit* target = Unit::GetUnit((*me), instance->GetData64(DATA_MAULGAREVENT_TANK));
+                Unit* target = Unit::GetUnit(*me, instance->GetData64(DATA_MAULGAREVENT_TANK));
 
                 if (target)
                 {
@@ -708,7 +708,7 @@
             }
         }
 
-        void JustDied(Unit* /*Killer*/)
+        void JustDied(Unit* /*killer*/)
         {
             if (instance)
             {
@@ -728,7 +728,7 @@
             //Only if not incombat check if the event is started
             if (!me->isInCombat() && instance && instance->GetData(DATA_MAULGAREVENT))
             {
-                Unit* target = Unit::GetUnit((*me), instance->GetData64(DATA_MAULGAREVENT_TANK));
+                Unit* target = Unit::GetUnit(*me, instance->GetData64(DATA_MAULGAREVENT_TANK));
 
                 if (target)
                 {
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/HellfireCitadel/BloodFurnace/boss_broggok.cpp
--- a/src/server/scripts/Outland/HellfireCitadel/BloodFurnace/boss_broggok.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/HellfireCitadel/BloodFurnace/boss_broggok.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -121,7 +121,7 @@
                 DoMeleeAttackIfReady();
             }
 
-            void JustDied(Unit* /*who*/)
+            void JustDied(Unit* /*killer*/)
             {
                 if (instance)
                 {
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/HellfireCitadel/BloodFurnace/boss_kelidan_the_breaker.cpp
--- a/src/server/scripts/Outland/HellfireCitadel/BloodFurnace/boss_kelidan_the_breaker.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/HellfireCitadel/BloodFurnace/boss_kelidan_the_breaker.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -185,7 +185,7 @@
                 }
             }
 
-            void JustDied(Unit* /*Killer*/)
+            void JustDied(Unit* /*killer*/)
             {
                 DoScriptText(SAY_DIE, me);
 
@@ -326,10 +326,10 @@
                 DoStartMovement(who);
             }
 
-            void JustDied(Unit* Killer)
+            void JustDied(Unit* killer)
             {
                if (Creature* Kelidan = me->FindNearestCreature(ENTRY_KELIDAN, 100))
-                   CAST_AI(boss_kelidan_the_breaker::boss_kelidan_the_breakerAI, Kelidan->AI())->ChannelerDied(Killer);
+                   CAST_AI(boss_kelidan_the_breaker::boss_kelidan_the_breakerAI, Kelidan->AI())->ChannelerDied(killer);
             }
 
             void UpdateAI(const uint32 diff)
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/HellfireCitadel/BloodFurnace/boss_the_maker.cpp
--- a/src/server/scripts/Outland/HellfireCitadel/BloodFurnace/boss_the_maker.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/HellfireCitadel/BloodFurnace/boss_the_maker.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -94,7 +94,7 @@
                 DoScriptText(RAND(SAY_KILL_1, SAY_KILL_2), me);
             }
 
-            void JustDied(Unit* /*Killer*/)
+            void JustDied(Unit* /*killer*/)
             {
                 DoScriptText(SAY_DIE, me);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/HellfireCitadel/HellfireRamparts/boss_omor_the_unscarred.cpp
--- a/src/server/scripts/Outland/HellfireCitadel/HellfireRamparts/boss_omor_the_unscarred.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/HellfireCitadel/HellfireRamparts/boss_omor_the_unscarred.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -113,7 +113,7 @@
                 ++SummonedCount;
             }
 
-            void JustDied(Unit* /*Killer*/)
+            void JustDied(Unit* /*killer*/)
             {
                 DoScriptText(SAY_DIE, me);
             }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/HellfireCitadel/HellfireRamparts/boss_vazruden_the_herald.cpp
--- a/src/server/scripts/Outland/HellfireCitadel/HellfireRamparts/boss_vazruden_the_herald.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/HellfireCitadel/HellfireRamparts/boss_vazruden_the_herald.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -236,9 +236,9 @@
                     DoScriptText(RAND(SAY_KILL_1, SAY_KILL_2), me);
             }
 
-            void JustDied(Unit* who)
+            void JustDied(Unit* killer)
             {
-                if (who && who != me)
+                if (killer && killer != me)
                     DoScriptText(SAY_DIE, me);
             }
 
@@ -480,10 +480,10 @@
 
             void EnterCombat(Unit* /*who*/) {}
 
-            void JustDied(Unit* who)
+            void JustDied(Unit* killer)
             {
                 if (Creature* herald = me->FindNearestCreature(ENTRY_VAZRUDEN_HERALD, 150))
-                    CAST_AI(boss_vazruden_the_herald::boss_vazruden_the_heraldAI, herald->AI())->SentryDownBy(who);
+                    CAST_AI(boss_vazruden_the_herald::boss_vazruden_the_heraldAI, herald->AI())->SentryDownBy(killer);
             }
 
             void UpdateAI(const uint32 diff)
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/HellfireCitadel/HellfireRamparts/boss_watchkeeper_gargolmar.cpp
--- a/src/server/scripts/Outland/HellfireCitadel/HellfireRamparts/boss_watchkeeper_gargolmar.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/HellfireCitadel/HellfireRamparts/boss_watchkeeper_gargolmar.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -109,7 +109,7 @@
                 DoScriptText(RAND(SAY_KILL_1, SAY_KILL_2), me);
             }
 
-            void JustDied(Unit* /*Killer*/)
+            void JustDied(Unit* /*killer*/)
             {
                 DoScriptText(SAY_DIE, me);
             }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/HellfireCitadel/MagtheridonsLair/boss_magtheridon.cpp
--- a/src/server/scripts/Outland/HellfireCitadel/MagtheridonsLair/boss_magtheridon.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/HellfireCitadel/MagtheridonsLair/boss_magtheridon.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -322,7 +322,7 @@
                 DoScriptText(SAY_PLAYER_KILLED, me);
             }
 
-            void JustDied(Unit* /*Killer*/)
+            void JustDied(Unit* /*killer*/)
             {
                 if (instance)
                     instance->SetData(DATA_MAGTHERIDON_EVENT, DONE);
@@ -533,7 +533,7 @@
                     DoCast(me, SPELL_SOUL_TRANSFER, true);
             }
 
-            void JustDied(Unit* /*who*/)
+            void JustDied(Unit* /*killer*/)
             {
                 if (instance)
                     instance->SetData(DATA_CHANNELER_EVENT, DONE);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/HellfireCitadel/ShatteredHalls/boss_nethekurse.cpp
--- a/src/server/scripts/Outland/HellfireCitadel/ShatteredHalls/boss_nethekurse.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/HellfireCitadel/ShatteredHalls/boss_nethekurse.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -224,7 +224,7 @@
                 DoScriptText(RAND(SAY_SLAY_1, SAY_SLAY_2), me);
             }
 
-            void JustDied(Unit* /*Killer*/)
+            void JustDied(Unit* /*killer*/)
             {
                 DoScriptText(SAY_DIE, me);
 
@@ -356,7 +356,7 @@
                 }
             }
 
-            void JustDied(Unit* /*Killer*/)
+            void JustDied(Unit* /*killer*/)
             {
                 if (instance)
                 {
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/HellfireCitadel/ShatteredHalls/boss_warbringer_omrogg.cpp
--- a/src/server/scripts/Outland/HellfireCitadel/ShatteredHalls/boss_warbringer_omrogg.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/HellfireCitadel/ShatteredHalls/boss_warbringer_omrogg.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -295,7 +295,7 @@
                 }
             }
 
-            void JustDied(Unit* /*Killer*/)
+            void JustDied(Unit* /*killer*/)
             {
                 Unit* pLeftHead  = Unit::GetUnit(*me, LeftHeadGUID);
                 Unit* pRightHead = Unit::GetUnit(*me, RightHeadGUID);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/HellfireCitadel/ShatteredHalls/boss_warchief_kargath_bladefist.cpp
--- a/src/server/scripts/Outland/HellfireCitadel/ShatteredHalls/boss_warchief_kargath_bladefist.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/HellfireCitadel/ShatteredHalls/boss_warchief_kargath_bladefist.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -137,7 +137,7 @@
                 }
             }
 
-            void JustDied(Unit* /*Killer*/)
+            void JustDied(Unit* /*killer*/)
             {
                 DoScriptText(SAY_DEATH, me);
                 removeAdds();
@@ -166,7 +166,7 @@
             {
                 for (std::vector<uint64>::const_iterator itr = adds.begin(); itr!= adds.end(); ++itr)
                 {
-                    Unit* temp = Unit::GetUnit((*me), *itr);
+                    Unit* temp = Unit::GetUnit(*me, *itr);
                     if (temp && temp->isAlive())
                     {
                         (*temp).GetMotionMaster()->Clear(true);
@@ -178,7 +178,7 @@
 
                 for (std::vector<uint64>::const_iterator itr = assassins.begin(); itr!= assassins.end(); ++itr)
                 {
-                    Unit* temp = Unit::GetUnit((*me), *itr);
+                    Unit* temp = Unit::GetUnit(*me, *itr);
                     if (temp && temp->isAlive())
                     {
                         (*temp).GetMotionMaster()->Clear(true);
@@ -236,8 +236,8 @@
                                 float x, y, randx, randy;
                                 randx = 0.0f + rand()%40;
                                 randy = 0.0f + rand()%40;
-                                x = 210+ randx ;
-                                y = -60- randy ;
+                                x = 210+ randx;
+                                y = -60- randy;
                                 me->GetMotionMaster()->MovePoint(1, x, y, me->GetPositionZ());
                                 Wait_Timer = 0;
                             }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/TempestKeep/Eye/boss_alar.cpp
--- a/src/server/scripts/Outland/TempestKeep/Eye/boss_alar.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/TempestKeep/Eye/boss_alar.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -145,7 +145,7 @@
                 me->setActive(true);
             }
 
-            void JustDied(Unit* /*victim*/)
+            void JustDied(Unit* /*killer*/)
             {
                 if (instance)
                     instance->SetData(DATA_ALAREVENT, DONE);
@@ -500,7 +500,7 @@
                     me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
                     if (instance && instance->GetData(DATA_ALAREVENT) == 2)
                     {
-                        if (Unit* Alar = Unit::GetUnit((*me), instance->GetData64(DATA_ALAR)))
+                        if (Unit* Alar = Unit::GetUnit(*me, instance->GetData64(DATA_ALAR)))
                         {
                             int32 AlarHealth = int32(Alar->GetHealth()) - int32(Alar->CountPctFromMaxHealth(3));
                             if (AlarHealth > 0)
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/TempestKeep/Eye/boss_astromancer.cpp
--- a/src/server/scripts/Outland/TempestKeep/Eye/boss_astromancer.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/TempestKeep/Eye/boss_astromancer.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -151,7 +151,7 @@
                 DoScriptText(RAND(SAY_KILL1, SAY_KILL2, SAY_KILL3), me);
             }
 
-            void JustDied(Unit* /*victim*/)
+            void JustDied(Unit* /*killer*/)
             {
                 me->SetFloatValue(OBJECT_FIELD_SCALE_X, defaultsize);
                 me->SetDisplayId(MODEL_HUMAN);
@@ -454,7 +454,7 @@
                     {
                         case 0:
                             if (instance)
-                                target = Unit::GetUnit((*me), instance->GetData64(DATA_ASTROMANCER));
+                                target = Unit::GetUnit(*me, instance->GetData64(DATA_ASTROMANCER));
                             break;
                         case 1:
                             target = me;
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/TempestKeep/Eye/boss_kaelthas.cpp
--- a/src/server/scripts/Outland/TempestKeep/Eye/boss_kaelthas.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/TempestKeep/Eye/boss_kaelthas.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -253,7 +253,7 @@
                 DelayRes_Timer = 0;
                 FakeDeath = false;
 
-                Unit* Target = Unit::GetUnit((*me), DelayRes_Target);
+                Unit* Target = Unit::GetUnit(*me, DelayRes_Target);
                 if (!Target)
                     Target = me->getVictim();
 
@@ -450,7 +450,7 @@
                 summons.Despawn(summon);
             }
 
-            void JustDied(Unit* /*Killer*/)
+            void JustDied(Unit* /*killer*/)
             {
                 me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
                 me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
@@ -464,7 +464,7 @@
 
                 for (uint8 i = 0; i < MAX_ADVISORS; ++i)
                 {
-                    if (Unit* pAdvisor = Unit::GetUnit((*me), m_auiAdvisorGuid[i]))
+                    if (Unit* pAdvisor = Unit::GetUnit(*me, m_auiAdvisorGuid[i]))
                         pAdvisor->Kill(pAdvisor);
                 }
             }
@@ -895,7 +895,7 @@
                                         // 1) Kael'thas will portal the whole raid right into his body
                                         for (i = me->getThreatManager().getThreatList().begin(); i!= me->getThreatManager().getThreatList().end(); ++i)
                                         {
-                                            Unit* unit = Unit::GetUnit((*me), (*i)->getUnitGuid());
+                                            Unit* unit = Unit::GetUnit(*me, (*i)->getUnitGuid());
                                             if (unit && (unit->GetTypeId() == TYPEID_PLAYER))
                                             {
                                                 //Use work around packet to prevent player from being dropped from combat
@@ -916,7 +916,7 @@
                                         // 2) At that point he will put a Gravity Lapse debuff on everyone
                                         for (i = me->getThreatManager().getThreatList().begin(); i != me->getThreatManager().getThreatList().end(); ++i)
                                         {
-                                            if (Unit* unit = Unit::GetUnit((*me), (*i)->getUnitGuid()))
+                                            if (Unit* unit = Unit::GetUnit(*me, (*i)->getUnitGuid()))
                                             {
                                                 DoCast(unit, SPELL_KNOCKBACK, true);
                                                 //Gravity lapse - needs an exception in Spell system to work
@@ -949,7 +949,7 @@
                                         //Remove flight
                                         for (i = me->getThreatManager().getThreatList().begin(); i!= me->getThreatManager().getThreatList().end(); ++i)
                                         {
-                                            if (Unit* unit = Unit::GetUnit((*me), (*i)->getUnitGuid()))
+                                            if (Unit* unit = Unit::GetUnit(*me, (*i)->getUnitGuid()))
                                             {
                                                 //Using packet workaround
                                                 WorldPacket data(12);
@@ -1137,7 +1137,7 @@
                 DoScriptText(SAY_SANGUINAR_AGGRO, me);
             }
 
-            void JustDied(Unit* /*Killer*/)
+            void JustDied(Unit* /*killer*/)
             {
                 if (instance && instance->GetData(DATA_KAELTHASEVENT) == 3)
                     DoScriptText(SAY_SANGUINAR_DEATH, me);
@@ -1289,7 +1289,7 @@
                     std::list<HostileReference*>& m_threatlist = me->getThreatManager().getThreatList();
                     for (std::list<HostileReference*>::const_iterator i = m_threatlist.begin(); i!= m_threatlist.end(); ++i)
                     {
-                        Unit* unit = Unit::GetUnit((*me), (*i)->getUnitGuid());
+                        Unit* unit = Unit::GetUnit(*me, (*i)->getUnitGuid());
                                                                     //if in melee range
                         if (unit && unit->IsWithinDistInMap(me, 5))
                         {
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/TempestKeep/Eye/boss_void_reaver.cpp
--- a/src/server/scripts/Outland/TempestKeep/Eye/boss_void_reaver.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/TempestKeep/Eye/boss_void_reaver.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -85,7 +85,7 @@
                 DoScriptText(RAND(SAY_SLAY1, SAY_SLAY2, SAY_SLAY3), me);
             }
 
-            void JustDied(Unit* /*victim*/)
+            void JustDied(Unit* /*killer*/)
             {
                 DoScriptText(SAY_DEATH, me);
                 DoZoneInCombat();
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/TempestKeep/Mechanar/boss_gatewatcher_ironhand.cpp
--- a/src/server/scripts/Outland/TempestKeep/Mechanar/boss_gatewatcher_ironhand.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/TempestKeep/Mechanar/boss_gatewatcher_ironhand.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -86,7 +86,7 @@
                     DoScriptText(RAND(SAY_SLAY_1, SAY_SLAY_2), me);
                 }
 
-                void JustDied(Unit* /*Killer*/)
+                void JustDied(Unit* /*killer*/)
                 {
                     DoScriptText(SAY_DEATH_1, me);
                     //TODO: Add door check/open code
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/TempestKeep/Mechanar/boss_nethermancer_sepethrea.cpp
--- a/src/server/scripts/Outland/TempestKeep/Mechanar/boss_nethermancer_sepethrea.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/TempestKeep/Mechanar/boss_nethermancer_sepethrea.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -101,7 +101,7 @@
                 DoScriptText(RAND(SAY_SLAY1, SAY_SLAY2), me);
             }
 
-            void JustDied(Unit* /*Killer*/)
+            void JustDied(Unit* /*killer*/)
             {
                 DoScriptText(SAY_DEATH, me);
                 if (instance)
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/TempestKeep/Mechanar/boss_pathaleon_the_calculator.cpp
--- a/src/server/scripts/Outland/TempestKeep/Mechanar/boss_pathaleon_the_calculator.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/TempestKeep/Mechanar/boss_pathaleon_the_calculator.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -103,7 +103,7 @@
                 DoScriptText(RAND(SAY_SLAY_1, SAY_SLAY_2), me);
             }
 
-            void JustDied(Unit* /*Killer*/)
+            void JustDied(Unit* /*killer*/)
             {
                 DoScriptText(SAY_DEATH, me);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/TempestKeep/arcatraz/arcatraz.cpp
--- a/src/server/scripts/Outland/TempestKeep/arcatraz/arcatraz.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/TempestKeep/arcatraz/arcatraz.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -128,7 +128,7 @@
                 Talk(SAY_KILL);
             }
 
-            void JustDied(Unit* /*victim*/)
+            void JustDied(Unit* /*killer*/)
             {
                 Talk(SAY_DEATH);
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/TempestKeep/arcatraz/boss_harbinger_skyriss.cpp
--- a/src/server/scripts/Outland/TempestKeep/arcatraz/boss_harbinger_skyriss.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/TempestKeep/arcatraz/boss_harbinger_skyriss.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -112,7 +112,7 @@
 
             void EnterCombat(Unit* /*who*/) {}
 
-            void JustDied(Unit* /*Killer*/)
+            void JustDied(Unit* /*killer*/)
             {
                 DoScriptText(SAY_DEATH, me);
                 if (instance)
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/TempestKeep/botanica/boss_high_botanist_freywinn.cpp
--- a/src/server/scripts/Outland/TempestKeep/botanica/boss_high_botanist_freywinn.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/TempestKeep/botanica/boss_high_botanist_freywinn.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -107,7 +107,7 @@
                 DoScriptText(RAND(SAY_KILL_1, SAY_KILL_2), me);
             }
 
-            void JustDied(Unit* /*Killer*/)
+            void JustDied(Unit* /*killer*/)
             {
                 DoScriptText(SAY_DEATH, me);
             }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/TempestKeep/botanica/boss_warp_splinter.cpp
--- a/src/server/scripts/Outland/TempestKeep/botanica/boss_warp_splinter.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/TempestKeep/botanica/boss_warp_splinter.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -169,7 +169,7 @@
                 DoScriptText(RAND(SAY_SLAY_1, SAY_SLAY_2), me);
             }
 
-            void JustDied(Unit* /*Killer*/)
+            void JustDied(Unit* /*killer*/)
             {
                 DoScriptText(SAY_DEATH, me);
             }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/blades_edge_mountains.cpp
--- a/src/server/scripts/Outland/blades_edge_mountains.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/blades_edge_mountains.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -880,7 +880,7 @@
                 colorSequence.clear();
                 playableSequence.clear();
                 playerSequence.clear();
-                me->SetFloatValue(OBJECT_FIELD_SCALE_X, large ? 2 : 1);
+                me->SetFloatValue(OBJECT_FIELD_SCALE_X, large ? 2.0f : 1.0f);
 
                 std::list<WorldObject*> ClusterList;
                 Trinity::AllWorldObjectsInRange objects(me, searchDistance);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/boss_doomlord_kazzak.cpp
--- a/src/server/scripts/Outland/boss_doomlord_kazzak.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/boss_doomlord_kazzak.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -97,7 +97,7 @@
                 Talk(SAY_KILL);
             }
 
-            void JustDied(Unit* /*victim*/)
+            void JustDied(Unit* /*killer*/)
             {
                 Talk(SAY_DEATH);
             }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/boss_doomwalker.cpp
--- a/src/server/scripts/Outland/boss_doomwalker.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/boss_doomwalker.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -79,7 +79,7 @@
                 Talk(SAY_SLAY);
             }
 
-            void JustDied(Unit* /*Killer*/)
+            void JustDied(Unit* /*killer*/)
             {
                 Talk(SAY_DEATH);
             }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/hellfire_peninsula.cpp
--- a/src/server/scripts/Outland/hellfire_peninsula.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/hellfire_peninsula.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -180,9 +180,9 @@
             npc_escortAI::MoveInLineOfSight(who);
         }
 
-        void WaypointReached(uint32 uiPointId)
+        void WaypointReached(uint32 waypointId)
         {
-            switch (uiPointId)
+            switch (waypointId)
             {
                 case 0:
                     DoScriptText(EMOTE_WOLF_LIFT_HEAD, me);
@@ -402,38 +402,37 @@
     {
         npc_wounded_blood_elfAI(Creature* creature) : npc_escortAI(creature) {}
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
-
             if (!player)
                 return;
 
-            switch (i)
+            switch (waypointId)
             {
-            case 0:
-                DoScriptText(SAY_ELF_START, me, player);
-                break;
-            case 9:
-                DoScriptText(SAY_ELF_SUMMON1, me, player);
-                // Spawn two Haal'eshi Talonguard
-                DoSpawnCreature(16967, -15, -15, 0, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
-                DoSpawnCreature(16967, -17, -17, 0, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
-                break;
-            case 13:
-                DoScriptText(SAY_ELF_RESTING, me, player);
-                break;
-            case 14:
-                DoScriptText(SAY_ELF_SUMMON2, me, player);
-                // Spawn two Haal'eshi Windwalker
-                DoSpawnCreature(16966, -15, -15, 0, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
-                DoSpawnCreature(16966, -17, -17, 0, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
-                break;
-            case 27:
-                DoScriptText(SAY_ELF_COMPLETE, me, player);
-                // Award quest credit
-                player->GroupEventHappens(QUEST_ROAD_TO_FALCON_WATCH, me);
-                break;
+                case 0:
+                    DoScriptText(SAY_ELF_START, me, player);
+                    break;
+                case 9:
+                    DoScriptText(SAY_ELF_SUMMON1, me, player);
+                    // Spawn two Haal'eshi Talonguard
+                    DoSpawnCreature(16967, -15, -15, 0, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+                    DoSpawnCreature(16967, -17, -17, 0, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+                    break;
+                case 13:
+                    DoScriptText(SAY_ELF_RESTING, me, player);
+                    break;
+                case 14:
+                    DoScriptText(SAY_ELF_SUMMON2, me, player);
+                    // Spawn two Haal'eshi Windwalker
+                    DoSpawnCreature(16966, -15, -15, 0, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+                    DoSpawnCreature(16966, -17, -17, 0, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+                    break;
+                case 27:
+                    DoScriptText(SAY_ELF_COMPLETE, me, player);
+                    // Award quest credit
+                    player->GroupEventHappens(QUEST_ROAD_TO_FALCON_WATCH, me);
+                    break;
             }
         }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/nagrand.cpp
--- a/src/server/scripts/Outland/nagrand.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/nagrand.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -90,7 +90,6 @@
                 player->AreaExploredOrEventHappens(10044);
                 player->CLOSE_GOSSIP_MENU();
                 break;
-
             case GOSSIP_ACTION_INFO_DEF + 10:
                 player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_SGG7, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 11);
                 player->SEND_GOSSIP_MENU(player->GetGossipTextId(creature), creature->GetGUID());
@@ -135,12 +134,10 @@
             player->SEND_GOSSIP_MENU(player->GetGossipTextId(creature), creature->GetGUID());
         }
         else
-
             player->SEND_GOSSIP_MENU(player->GetGossipTextId(creature), creature->GetGUID());
 
         return true;
     }
-
 };
 
 /*#####
@@ -224,9 +221,9 @@
             DoCast(me, SPELL_EARTHBIND_TOTEM, false);
         }
 
-        void WaypointReached(uint32 uiPointId)
+        void WaypointReached(uint32 waypointId)
         {
-            switch (uiPointId)
+            switch (waypointId)
             {
                 case 7:
                     DoScriptText(SAY_MAG_MORE, me);
@@ -235,7 +232,6 @@
                         DoScriptText(SAY_MAG_MORE_REPLY, temp);
 
                     me->SummonCreature(NPC_MURK_PUTRIFIER, m_afAmbushB[0]-2.5f, m_afAmbushB[1]-2.5f, m_afAmbushB[2], 0.0f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 25000);
-
                     me->SummonCreature(NPC_MURK_SCAVENGER, m_afAmbushB[0]+2.5f, m_afAmbushB[1]+2.5f, m_afAmbushB[2], 0.0f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 25000);
                     me->SummonCreature(NPC_MURK_SCAVENGER, m_afAmbushB[0]+2.5f, m_afAmbushB[1]-2.5f, m_afAmbushB[2], 0.0f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 25000);
                     break;
@@ -311,7 +307,6 @@
             DoMeleeAttackIfReady();
         }
     };
-
 };
 
 /*######
@@ -356,7 +351,6 @@
             }
         }
     };
-
 };
 
 /*######
@@ -401,6 +395,7 @@
                   player->KilledMonsterCredit(NPC_CORKI_CREDIT_1, 0);
           }
       }
+
       if (go->GetEntry() == GO_CORKIS_PRISON_2)
       {
           if (Creature* corki = go->FindNearestCreature(NPC_CORKI_2, 25, true))
@@ -411,6 +406,7 @@
                   player->KilledMonsterCredit(NPC_CORKI_2, 0);
           }
       }
+
       if (go->GetEntry() == GO_CORKIS_PRISON_3)
       {
           if (Creature* corki = go->FindNearestCreature(NPC_CORKI_3, 25, true))
@@ -444,18 +440,22 @@
 
       void Reset()
       {
+          Say_Timer = 5000;
           ReleasedFromCage = false;
       }
 
       void UpdateAI(uint32 const diff)
       {
-          if (Say_Timer <= diff && ReleasedFromCage)
+          if (ReleasedFromCage)
           {
-              me->ForcedDespawn();
-              ReleasedFromCage = false;
+              if (Say_Timer <= diff)
+              {
+                  me->ForcedDespawn();
+                  ReleasedFromCage = false;
+              }
+              else
+                  Say_Timer -= diff;
           }
-          else
-              Say_Timer -= diff;
       }
 
       void MovementInform(uint32 type, uint32 id)
@@ -565,9 +565,9 @@
             }
         }
 
-        void WaypointReached(uint32 PointId)
+        void WaypointReached(uint32 waypointId)
         {
-            switch(PointId)
+            switch (waypointId)
             {
                 case 3:
                 {
@@ -685,15 +685,11 @@
 
             if (Creature* prisoner = go->FindNearestCreature(NPC_MAGHAR_PRISONER, 5.0f))
             {
-                if (prisoner)
-                {
-                    go->UseDoorOrButton();
-                    if (player)
-                        player->KilledMonsterCredit(NPC_MAGHAR_PRISONER, 0);
+                go->UseDoorOrButton();
+                player->KilledMonsterCredit(NPC_MAGHAR_PRISONER, 0);
 
-                    prisoner->AI()->Talk(SAY_FREE, player->GetGUID());
-                    prisoner->ForcedDespawn(6000);
-                }
+                prisoner->AI()->Talk(SAY_FREE, player->GetGUID());
+                prisoner->ForcedDespawn(6000);
             }
             return true;
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/netherstorm.cpp
--- a/src/server/scripts/Outland/netherstorm.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/netherstorm.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -115,7 +115,7 @@
 
             if (someplayer)
             {
-                Unit* p = Unit::GetUnit((*me), someplayer);
+                Unit* p = Unit::GetUnit(*me, someplayer);
                 if (p && p->GetTypeId() == TYPEID_PLAYER)
                 {
                     switch (me->GetEntry())
@@ -142,7 +142,7 @@
 
             if (goConsole)
             {
-                if (GameObject* go = GameObject::GetGameObject((*me), goConsole))
+                if (GameObject* go = GameObject::GetGameObject(*me, goConsole))
                     go->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_IN_USE);
             }
         }
@@ -243,7 +243,7 @@
                     case 1:
                         if (someplayer)
                         {
-                            Unit* u = Unit::GetUnit((*me), someplayer);
+                            Unit* u = Unit::GetUnit(*me, someplayer);
                             if (u && u->GetTypeId() == TYPEID_PLAYER) DoScriptText(EMOTE_START, me, u);
                         }
                         Event_Timer = 60000;
@@ -271,14 +271,14 @@
                         DoScriptText(EMOTE_COMPLETE, me);
                         if (someplayer)
                         {
-                            Unit* u = Unit::GetUnit((*me), someplayer);
+                            Unit* u = Unit::GetUnit(*me, someplayer);
                             if (u && u->GetTypeId() == TYPEID_PLAYER)
                                 CAST_PLR(u)->KilledMonsterCredit(me->GetEntry(), me->GetGUID());
                             DoCast(me, SPELL_DISABLE_VISUAL);
                         }
                         if (goConsole)
                         {
-                            if (GameObject* go = GameObject::GetGameObject((*me), goConsole))
+                            if (GameObject* go = GameObject::GetGameObject(*me, goConsole))
                                 go->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_IN_USE);
                         }
                         ++Phase;
@@ -812,7 +812,7 @@
                 }
                 if (!UnitsWithMana.empty())
                 {
-                    DoCast(SelectRandomContainerElement(UnitsWithMana), SPELL_MANA_BURN);
+                    DoCast(Trinity::Containers::SelectRandomContainerElement(UnitsWithMana), SPELL_MANA_BURN);
                     ManaBurnTimer = 8000 + (rand() % 10 * 1000); // 8-18 sec cd
                 }
                 else
@@ -889,34 +889,32 @@
                 player->FailQuest(Q_ALMABTRIEB);
         }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
-
             if (!player)
                 return;
 
-            switch (i)
+            switch (waypointId)
             {
                 case 3: //first spawn
                     me->SummonCreature(SPAWN_FIRST, 2449.67f, 2183.11f, 96.85f, 6.20f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 25000);
                     me->SummonCreature(SPAWN_FIRST, 2449.53f, 2184.43f, 96.36f, 6.27f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 25000);
                     me->SummonCreature(SPAWN_FIRST, 2449.85f, 2186.34f, 97.57f, 6.08f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 25000);
                     break;
-
                 case 7:
                     me->SummonCreature(SPAWN_SECOND, 2309.64f, 2186.24f, 92.25f, 6.06f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 25000);
                     me->SummonCreature(SPAWN_SECOND, 2309.25f, 2183.46f, 91.75f, 6.22f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 25000);
                     break;
-
                 case 12:
-                    if (player)
-                        player->GroupEventHappens(Q_ALMABTRIEB, me);
+                    player->GroupEventHappens(Q_ALMABTRIEB, me);
                     if (me->FindNearestCreature(N_THADELL, 30))
-                        DoScriptText(SAY_THADELL_1, me); break;
+                        DoScriptText(SAY_THADELL_1, me);
+                    break;
                 case 13:
                     if (me->FindNearestCreature(N_THADELL, 30))
-                        DoScriptText(SAY_THADELL_2, me, player); break;
+                        DoScriptText(SAY_THADELL_2, me, player);
+                    break;
             }
         }
 
@@ -965,13 +963,13 @@
             uiTakeTimer=3000;
         }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
             if (!player)
                 return;
 
-            switch (i)
+            switch (waypointId)
             {
                 case 7:
                 case 17:
@@ -986,16 +984,14 @@
                     }
                     break;
                 case 36: //return and quest_complete
-                    if (player)
-                        player->CompleteQuest(QUEST_MARK_V_IS_ALIVE);
+                    player->CompleteQuest(QUEST_MARK_V_IS_ALIVE);
                     break;
             }
         }
 
         void JustDied(Unit* /*killer*/)
         {
-            Player* player = GetPlayerForEscort();
-            if (player)
+            if (Player* player = GetPlayerForEscort())
                 player->FailQuest(QUEST_MARK_V_IS_ALIVE);
         }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/shadowmoon_valley.cpp
--- a/src/server/scripts/Outland/shadowmoon_valley.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/shadowmoon_valley.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -262,7 +262,7 @@
             {
                 if (PlayerGUID)
                 {
-                    Unit* player = Unit::GetUnit((*me), PlayerGUID);
+                    Unit* player = Unit::GetUnit(*me, PlayerGUID);
                     if (player)
                         DoCast(player, SPELL_FORCE_OF_NELTHARAKU, true);
 
@@ -758,8 +758,8 @@
 
         uint32 NextStep(uint32 Step)
         {
-            Unit* player = Unit::GetUnit((*me), PlayerGUID);
-            Unit* Illi = Unit::GetUnit((*me), IllidanGUID);
+            Player* player = Unit::GetPlayer(*me, PlayerGUID);
+            Unit* Illi = Unit::GetUnit(*me, IllidanGUID);
 
             if (!player || !Illi)
             {
@@ -769,213 +769,178 @@
 
             switch (Step)
             {
-            case 0:
-                return 0;
-                break;
-
-            case 1:
-                me->GetMotionMaster()->MovePoint(0, -5104.41f, 595.297f, 85.6838f);
-                return 9000;
-                break;
-
-            case 2:
-                DoScriptText(OVERLORD_YELL_1, me, player);
-                return 4500;
-                break;
-
-            case 3:
-                me->SetInFront(player);
-                return 3200;
-                break;
-
-            case 4:
-                DoScriptText(OVERLORD_SAY_2, me, player);
-                return 2000;
-                break;
-
-            case 5:
-                Illi->SetVisible(true);
-                Illi->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
-                return 350;
-                break;
-
-            case 6:
-                Illi->CastSpell(Illi, SPELL_ONE, true);
-                Illi->SetTarget(me->GetGUID());
-                me->SetTarget(IllidanGUID);
-                return 2000;
-                break;
-
-            case 7:
-                DoScriptText(OVERLORD_YELL_2, me);
-                return 4500;
-                break;
-
-            case 8:
-                me->SetUInt32Value(UNIT_FIELD_BYTES_1, 8);
-                return 2500;
-                break;
-
-            case 9:
-                DoScriptText(OVERLORD_SAY_3, me);
-                return 6500;
-                break;
-
-            case 10:
-                DoScriptText(LORD_ILLIDAN_SAY_1, Illi);
-                return 5000;
-                break;
-
-            case 11:
-                DoScriptText(OVERLORD_SAY_4, me, player);
-                return 6000;
-                break;
-
-            case 12:
-                DoScriptText(LORD_ILLIDAN_SAY_2, Illi);
-                return 5500;
-                break;
-
-            case 13:
-                DoScriptText(LORD_ILLIDAN_SAY_3, Illi);
-                return 4000;
-                break;
-
-            case 14:
-                Illi->SetTarget(PlayerGUID);
-                return 1500;
-                break;
-
-            case 15:
-                DoScriptText(LORD_ILLIDAN_SAY_4, Illi);
-                return 1500;
-                break;
-
-            case 16:
-                if (player)
-                {
-                    Illi->CastSpell(player, SPELL_TWO, true);
-                    player->RemoveAurasDueToSpell(SPELL_THREE);
-                    player->RemoveAurasDueToSpell(SPELL_FOUR);
+                case 0:
+                    return 0;
+                    break;
+                case 1:
+                    me->GetMotionMaster()->MovePoint(0, -5104.41f, 595.297f, 85.6838f);
+                    return 9000;
+                    break;
+                case 2:
+                    DoScriptText(OVERLORD_YELL_1, me, player);
+                    return 4500;
+                    break;
+                case 3:
+                    me->SetInFront(player);
+                    return 3200;
+                    break;
+                case 4:
+                    DoScriptText(OVERLORD_SAY_2, me, player);
+                    return 2000;
+                    break;
+                case 5:
+                    Illi->SetVisible(true);
+                    Illi->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                    return 350;
+                    break;
+                case 6:
+                    Illi->CastSpell(Illi, SPELL_ONE, true);
+                    Illi->SetTarget(me->GetGUID());
+                    me->SetTarget(IllidanGUID);
+                    return 2000;
+                    break;
+                case 7:
+                    DoScriptText(OVERLORD_YELL_2, me);
+                    return 4500;
+                    break;
+                case 8:
+                    me->SetUInt32Value(UNIT_FIELD_BYTES_1, 8);
+                    return 2500;
+                    break;
+                case 9:
+                    DoScriptText(OVERLORD_SAY_3, me);
+                    return 6500;
+                    break;
+                case 10:
+                    DoScriptText(LORD_ILLIDAN_SAY_1, Illi);
                     return 5000;
-                }
-                else
-                {
-                    CAST_PLR(player)->FailQuest(QUEST_LORD_ILLIDAN_STORMRAGE);
-                    Step = 30;
+                    break;
+                case 11:
+                    DoScriptText(OVERLORD_SAY_4, me, player);
+                    return 6000;
+                    break;
+                case 12:
+                    DoScriptText(LORD_ILLIDAN_SAY_2, Illi);
+                    return 5500;
+                    break;
+                case 13:
+                    DoScriptText(LORD_ILLIDAN_SAY_3, Illi);
+                    return 4000;
+                    break;
+                case 14:
+                    Illi->SetTarget(PlayerGUID);
+                    return 1500;
+                    break;
+                case 15:
+                    DoScriptText(LORD_ILLIDAN_SAY_4, Illi);
+                    return 1500;
+                    break;
+                case 16:
+                    if (player)
+                    {
+                        Illi->CastSpell(player, SPELL_TWO, true);
+                        player->RemoveAurasDueToSpell(SPELL_THREE);
+                        player->RemoveAurasDueToSpell(SPELL_FOUR);
+                        return 5000;
+                    }
+                    else
+                    {
+                        player->FailQuest(QUEST_LORD_ILLIDAN_STORMRAGE);
+                        Step = 30;
+                        return 100;
+                    }
+                    break;
+                case 17:
+                    DoScriptText(LORD_ILLIDAN_SAY_5, Illi);
+                    return 5000;
+                    break;
+                case 18:
+                    DoScriptText(LORD_ILLIDAN_SAY_6, Illi);
+                    return 5000;
+                    break;
+                case 19:
+                    DoScriptText(LORD_ILLIDAN_SAY_7, Illi);
+                    return 5000;
+                    break;
+                case 20:
+                    Illi->HandleEmoteCommand(EMOTE_ONESHOT_LIFTOFF);
+                    Illi->SetDisableGravity(true);
+                    return 500;
+                    break;
+                case 21:
+                    DoScriptText(OVERLORD_SAY_5, me);
+                    return 500;
+                    break;
+                case 22:
+                    Illi->SetVisible(false);
+                    Illi->setDeathState(JUST_DIED);
+                    return 1000;
+                    break;
+                case 23:
+                    me->SetUInt32Value(UNIT_FIELD_BYTES_1, 0);
+                    return 2000;
+                    break;
+                case 24:
+                    me->SetTarget(PlayerGUID);
+                    return 5000;
+                    break;
+                case 25:
+                    DoScriptText(OVERLORD_SAY_6, me);
+                    return 2000;
+                    break;
+                case 26:
+                    player->GroupEventHappens(QUEST_LORD_ILLIDAN_STORMRAGE, me);
+                    return 6000;
+                    break;
+                case 27:
+                    {
+                        Unit* Yarzill = me->FindNearestCreature(C_YARZILL, 50);
+                        if (Yarzill)
+                            Yarzill->SetTarget(PlayerGUID);
+                        return 500;
+                    }
+                    break;
+                case 28:
+                    player->RemoveAurasDueToSpell(SPELL_TWO);
+                    player->RemoveAurasDueToSpell(41519);
+                    player->CastSpell(player, SPELL_THREE, true);
+                    player->CastSpell(player, SPELL_FOUR, true);
+                    return 1000;
+                    break;
+                case 29:
+                    {
+                        Unit* Yarzill = me->FindNearestCreature(C_YARZILL, 50);
+                        if (Yarzill)
+                            DoScriptText(YARZILL_THE_MERC_SAY, Yarzill, player);
+                        return 5000;
+                    }
+                    break;
+                case 30:
+                    {
+                        Unit* Yarzill = me->FindNearestCreature(C_YARZILL, 50);
+                        if (Yarzill)
+                            Yarzill->SetTarget(0);
+                        return 5000;
+                    }
+                    break;
+                case 31:
+                    {
+                        Unit* Yarzill = me->FindNearestCreature(C_YARZILL, 50);
+                        if (Yarzill)
+                            Yarzill->CastSpell(player, 41540, true);
+                        return 1000;
+                    }
+                    break;
+                case 32:
+                    me->GetMotionMaster()->MovePoint(0, -5085.77f, 577.231f, 86.6719f); return 5000;
+                    break;
+                case 33:
+                    Reset();
                     return 100;
-                }
-                break;
-
-            case 17:
-                DoScriptText(LORD_ILLIDAN_SAY_5, Illi);
-                return 5000;
-                break;
-
-            case 18:
-                DoScriptText(LORD_ILLIDAN_SAY_6, Illi);
-                return 5000;
-                break;
-
-            case 19:
-                DoScriptText(LORD_ILLIDAN_SAY_7, Illi);
-                return 5000;
-                break;
-
-            case 20:
-                Illi->HandleEmoteCommand(EMOTE_ONESHOT_LIFTOFF);
-                Illi->SetDisableGravity(true);
-                return 500;
-                break;
-
-            case 21:
-                DoScriptText(OVERLORD_SAY_5, me);
-                return 500;
-                break;
-
-            case 22:
-                Illi->SetVisible(false);
-                Illi->setDeathState(JUST_DIED);
-                return 1000;
-                break;
-
-            case 23:
-                me->SetUInt32Value(UNIT_FIELD_BYTES_1, 0);
-                return 2000;
-                break;
-
-            case 24:
-                me->SetTarget(PlayerGUID);
-                return 5000;
-                break;
-
-            case 25:
-                DoScriptText(OVERLORD_SAY_6, me);
-                return 2000;
-                break;
-
-            case 26:
-                if (player)
-                    CAST_PLR(player)->GroupEventHappens(QUEST_LORD_ILLIDAN_STORMRAGE, me);
-                return 6000;
-                break;
-
-            case 27:
-                {
-                    Unit* Yarzill = me->FindNearestCreature(C_YARZILL, 50);
-                    if (Yarzill)
-                        Yarzill->SetTarget(PlayerGUID);
-                    return 500;
-                }
-                break;
-
-            case 28:
-                player->RemoveAurasDueToSpell(SPELL_TWO);
-                player->RemoveAurasDueToSpell(41519);
-                player->CastSpell(player, SPELL_THREE, true);
-                player->CastSpell(player, SPELL_FOUR, true);
-                return 1000;
-                break;
-
-            case 29:
-                {
-                    Unit* Yarzill = me->FindNearestCreature(C_YARZILL, 50);
-                    if (Yarzill)
-                        DoScriptText(YARZILL_THE_MERC_SAY, Yarzill, player);
-                    return 5000;
-                }
-                break;
-
-            case 30:
-                {
-                    Unit* Yarzill = me->FindNearestCreature(C_YARZILL, 50);
-                    if (Yarzill)
-                        Yarzill->SetTarget(0);
-                    return 5000;
-                }
-                break;
-
-            case 31:
-                {
-                    Unit* Yarzill = me->FindNearestCreature(C_YARZILL, 50);
-                    if (Yarzill)
-                        Yarzill->CastSpell(player, 41540, true);
-                    return 1000;
-                }
-                break;
-
-            case 32:
-                me->GetMotionMaster()->MovePoint(0, -5085.77f, 577.231f, 86.6719f); return 5000;
-                break;
-
-            case 33:
-                Reset();
-                return 100;
-                break;
-
-            default :
-                return 0;
-                break;
+                    break;
+                default :
+                    return 0;
+                    break;
             }
         }
 
@@ -1054,14 +1019,13 @@
             m_uiHealingTimer = 0;
         }
 
-        void WaypointReached(uint32 uiPointId)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
-
             if (!player)
                 return;
 
-            switch (uiPointId)
+            switch (waypointId)
             {
                 case 13:
                     DoScriptText(SAY_WIL_PROGRESS1, me, player);
@@ -1108,7 +1072,6 @@
                     break;
                 case 50:
                     DoScriptText(SAY_WIL_END, me, player);
-
                     player->GroupEventHappens(QUEST_ESCAPE_COILSCAR, me);
                     break;
             }
@@ -1400,27 +1363,25 @@
             DoMeleeAttackIfReady();
         }
 
-        void JustDied(Unit* slayer)
+        void JustDied(Unit* killer)
         {
-            if (slayer)
-                switch (slayer->GetTypeId())
-                {
-                    case TYPEID_UNIT:
-                        if (Unit* owner = slayer->GetOwner())
-                            if (owner->GetTypeId() == TYPEID_PLAYER)
-                                CAST_PLR(owner)->GroupEventHappens(QUEST_BATTLE_OF_THE_CRIMSON_WATCH, me);
-                        break;
-
-                    case TYPEID_PLAYER:
-                        CAST_PLR(slayer)->GroupEventHappens(QUEST_BATTLE_OF_THE_CRIMSON_WATCH, me);
-                        break;
-                    default:
-                        break;
-                }
+            switch (killer->GetTypeId())
+            {
+                case TYPEID_UNIT:
+                    if (Unit* owner = killer->GetOwner())
+                        if (owner->GetTypeId() == TYPEID_PLAYER)
+                            CAST_PLR(owner)->GroupEventHappens(QUEST_BATTLE_OF_THE_CRIMSON_WATCH, me);
+                    break;
+                case TYPEID_PLAYER:
+                    CAST_PLR(killer)->GroupEventHappens(QUEST_BATTLE_OF_THE_CRIMSON_WATCH, me);
+                    break;
+                default:
+                    break;
+            }
 
             if (Creature* LordIllidan = (Unit::GetCreature(*me, LordIllidanGUID)))
             {
-                DoScriptText(END_TEXT, LordIllidan, slayer);
+                DoScriptText(END_TEXT, LordIllidan, killer);
                 LordIllidan->AI()->EnterEvadeMode();
             }
         }
@@ -1601,7 +1562,8 @@
         }
 
         void EnterCombat(Unit* /*who*/) {}
-        void JustDied(Unit* /*slayer*/)
+
+        void JustDied(Unit* /*killer*/)
         {
             me->RemoveCorpse();
             if (Creature* LordIllidan = (Unit::GetCreature(*me, LordIllidanGUID)))
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/shattrath_city.cpp
--- a/src/server/scripts/Outland/shattrath_city.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/shattrath_city.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -319,39 +319,80 @@
     public:
         npc_kservantAI(Creature* creature) : npc_escortAI(creature) {}
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
-
             if (!player)
                 return;
 
-            switch (i)
+            switch (waypointId)
             {
-                case 0: DoScriptText(SAY1, me, player); break;
-                case 4: DoScriptText(WHISP1, me, player); break;
-                case 6: DoScriptText(WHISP2, me, player); break;
-                case 7: DoScriptText(WHISP3, me, player); break;
-                case 8: DoScriptText(WHISP4, me, player); break;
-                case 17: DoScriptText(WHISP5, me, player); break;
-                case 18: DoScriptText(WHISP6, me, player); break;
-                case 19: DoScriptText(WHISP7, me, player); break;
-                case 33: DoScriptText(WHISP8, me, player); break;
-                case 34: DoScriptText(WHISP9, me, player); break;
-                case 35: DoScriptText(WHISP10, me, player); break;
-                case 36: DoScriptText(WHISP11, me, player); break;
-                case 43: DoScriptText(WHISP12, me, player); break;
-                case 44: DoScriptText(WHISP13, me, player); break;
-                case 49: DoScriptText(WHISP14, me, player); break;
-                case 50: DoScriptText(WHISP15, me, player); break;
-                case 51: DoScriptText(WHISP16, me, player); break;
-                case 52: DoScriptText(WHISP17, me, player); break;
-                case 53: DoScriptText(WHISP18, me, player); break;
-                case 54: DoScriptText(WHISP19, me, player); break;
-                case 55: DoScriptText(WHISP20, me, player); break;
-                case 56: DoScriptText(WHISP21, me, player);
-                    if (player)
-                        player->GroupEventHappens(10211, me);
+                case 0:
+                    DoScriptText(SAY1, me, player);
+                    break;
+                case 4:
+                    DoScriptText(WHISP1, me, player);
+                    break;
+                case 6:
+                    DoScriptText(WHISP2, me, player);
+                    break;
+                case 7:
+                    DoScriptText(WHISP3, me, player);
+                    break;
+                case 8:
+                    DoScriptText(WHISP4, me, player);
+                    break;
+                case 17:
+                    DoScriptText(WHISP5, me, player);
+                    break;
+                case 18:
+                    DoScriptText(WHISP6, me, player);
+                    break;
+                case 19:
+                    DoScriptText(WHISP7, me, player);
+                    break;
+                case 33:
+                    DoScriptText(WHISP8, me, player);
+                    break;
+                case 34:
+                    DoScriptText(WHISP9, me, player);
+                    break;
+                case 35:
+                    DoScriptText(WHISP10, me, player);
+                    break;
+                case 36:
+                    DoScriptText(WHISP11, me, player);
+                    break;
+                case 43:
+                    DoScriptText(WHISP12, me, player);
+                    break;
+                case 44:
+                    DoScriptText(WHISP13, me, player);
+                    break;
+                case 49:
+                    DoScriptText(WHISP14, me, player);
+                    break;
+                case 50:
+                    DoScriptText(WHISP15, me, player);
+                    break;
+                case 51:
+                    DoScriptText(WHISP16, me, player);
+                    break;
+                case 52:
+                    DoScriptText(WHISP17, me, player);
+                    break;
+                case 53:
+                    DoScriptText(WHISP18, me, player);
+                    break;
+                case 54:
+                    DoScriptText(WHISP19, me, player);
+                    break;
+                case 55:
+                    DoScriptText(WHISP20, me, player);
+                    break;
+                case 56:
+                    DoScriptText(WHISP21, me, player);
+                    player->GroupEventHappens(10211, me);
                     break;
             }
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/terokkar_forest.cpp
--- a/src/server/scripts/Outland/terokkar_forest.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/terokkar_forest.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -202,13 +202,13 @@
     public:
         npc_skywingAI(Creature* creature) : npc_escortAI(creature) {}
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
             if (!player)
                 return;
 
-            switch (i)
+            switch (waypointId)
             {
                 case 8:
                     player->AreaExploredOrEventHappens(10898);
@@ -306,24 +306,26 @@
         void EnterCombat(Unit* /*who*/) { }
         void MoveInLineOfSight(Unit* /*who*/) { }
 
-        void JustDied(Unit* Killer)
+        void JustDied(Unit* killer)
         {
-            if (Killer->GetTypeId() == TYPEID_PLAYER)
+            Player* player = killer->ToPlayer();
+            if (!player)
+                return;
+
+            if (player->GetQuestStatus(10873) == QUEST_STATUS_INCOMPLETE)
             {
-                if (CAST_PLR(Killer)->GetQuestStatus(10873) == QUEST_STATUS_INCOMPLETE)
+                if (rand()%100 < 25)
                 {
-                    if (rand()%100 < 25)
-                    {
-                        me->SummonCreature(QUEST_TARGET, 0.0f, 0.0f, 0.0f, 0.0f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 60000);
-                        CAST_PLR(Killer)->KilledMonsterCredit(QUEST_TARGET, 0);
-                    }
-                    else
-                        me->SummonCreature(netherwebVictims[rand()%6], 0.0f, 0.0f, 0.0f, 0.0f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 60000);
+                    me->SummonCreature(QUEST_TARGET, 0.0f, 0.0f, 0.0f, 0.0f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 60000);
+                    player->KilledMonsterCredit(QUEST_TARGET, 0);
+                }
+                else
+                    me->SummonCreature(netherwebVictims[rand()%6], 0.0f, 0.0f, 0.0f, 0.0f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 60000);
 
-                    if (rand()%100 < 75)
-                        me->SummonCreature(netherwebVictims[rand()%6], 0.0f, 0.0f, 0.0f, 0.0f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 60000);
+                if (rand()%100 < 75)
                     me->SummonCreature(netherwebVictims[rand()%6], 0.0f, 0.0f, 0.0f, 0.0f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 60000);
-                }
+
+                me->SummonCreature(netherwebVictims[rand()%6], 0.0f, 0.0f, 0.0f, 0.0f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 60000);
             }
         }
     };
@@ -461,38 +463,42 @@
     {
         npc_isla_starmaneAI(Creature* creature) : npc_escortAI(creature) {}
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
-
             if (!player)
                 return;
 
-            switch (i)
+            switch (waypointId)
             {
-            case 0:
-                {
-                GameObject* Cage = me->FindNearestGameObject(GO_CAGE, 10);
-                if (Cage)
-                    Cage->SetGoState(GO_STATE_ACTIVE);
-                }
-                break;
-            case 2: DoScriptText(SAY_PROGRESS_1, me, player); break;
-            case 5: DoScriptText(SAY_PROGRESS_2, me, player); break;
-            case 6: DoScriptText(SAY_PROGRESS_3, me, player); break;
-            case 29:DoScriptText(SAY_PROGRESS_4, me, player);
-                if (player)
-                {
+                case 0:
+                    if (GameObject* Cage = me->FindNearestGameObject(GO_CAGE, 10))
+                        Cage->SetGoState(GO_STATE_ACTIVE);
+                    break;
+                case 2:
+                    DoScriptText(SAY_PROGRESS_1, me, player);
+                    break;
+                case 5:
+                    DoScriptText(SAY_PROGRESS_2, me, player);
+                    break;
+                case 6:
+                    DoScriptText(SAY_PROGRESS_3, me, player);
+                    break;
+                case 29:
+                    DoScriptText(SAY_PROGRESS_4, me, player);
                     if (player->GetTeam() == ALLIANCE)
                         player->GroupEventHappens(QUEST_EFTW_A, me);
                     else if (player->GetTeam() == HORDE)
                         player->GroupEventHappens(QUEST_EFTW_H, me);
-                }
-                me->SetInFront(player); break;
-            case 30: me->HandleEmoteCommand(EMOTE_ONESHOT_WAVE); break;
-            case 31: DoCast(me, SPELL_CAT);
-                me->SetWalk(false);
-                break;
+                    me->SetInFront(player);
+                    break;
+                case 30:
+                    me->HandleEmoteCommand(EMOTE_ONESHOT_WAVE);
+                    break;
+                case 31:
+                    DoCast(me, SPELL_CAT);
+                    me->SetWalk(false);
+                    break;
             }
         }
 
@@ -662,21 +668,20 @@
     {
         npc_akunoAI(Creature* creature) : npc_escortAI(creature) {}
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
-
             if (!player)
                 return;
 
-            switch (i)
+            switch (waypointId)
             {
                 case 3:
                     me->SummonCreature(NPC_CABAL_SKRIMISHER, -2795.99f, 5420.33f, -34.53f, 0.0f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 25000);
                     me->SummonCreature(NPC_CABAL_SKRIMISHER, -2793.55f, 5412.79f, -34.53f, 0.0f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 25000);
                     break;
                 case 11:
-                    if (player && player->GetTypeId() == TYPEID_PLAYER)
+                    if (player->GetTypeId() == TYPEID_PLAYER)
                         player->GroupEventHappens(QUEST_ESCAPING_THE_TOMB, me);
                     break;
             }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Outland/zangarmarsh.cpp
--- a/src/server/scripts/Outland/zangarmarsh.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Outland/zangarmarsh.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -56,6 +56,7 @@
         {
             if (creature->GetEntry() == 17900)
                 player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_ITEM_BLESS_ASH, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+
             if (creature->GetEntry() == 17901)
                 player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_ITEM_BLESS_KEL, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
         }
@@ -321,14 +322,13 @@
 
         void Reset() { }
 
-        void WaypointReached(uint32 i)
+        void WaypointReached(uint32 waypointId)
         {
             Player* player = GetPlayerForEscort();
-
             if (!player)
                 return;
 
-            switch (i)
+            switch (waypointId)
             {
                 case 4:
                     DoScriptText(SAY_AMBUSH1, me, player);
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Spells/spell_dk.cpp
--- a/src/server/scripts/Spells/spell_dk.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Spells/spell_dk.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -337,7 +337,7 @@
             void FilterTargets(std::list<Unit*>& unitList)
             {
                 Unit* unit_to_add = NULL;
-                for (std::list<Unit*>::iterator itr = unitList.begin() ; itr != unitList.end(); ++itr)
+                for (std::list<Unit*>::iterator itr = unitList.begin(); itr != unitList.end(); ++itr)
                 {
                     if ((*itr)->GetTypeId() == TYPEID_UNIT
                         && (*itr)->GetOwnerGUID() == GetCaster()->GetGUID()
@@ -642,9 +642,7 @@
 
         void HandleEffectRemove(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*mode*/)
         {
-            Unit* target = GetTarget();
-            if (target->HasAura(DK_SPELL_UNHOLY_PRESENCE))
-                target->RemoveAura(DK_SPELL_IMPROVED_UNHOLY_PRESENCE_TRIGGERED);
+            GetTarget()->RemoveAura(DK_SPELL_IMPROVED_UNHOLY_PRESENCE_TRIGGERED);
         }
 
         void Register()
@@ -713,6 +711,7 @@
 {
     SPELL_DEATH_COIL_DAMAGE     = 47632,
     SPELL_DEATH_COIL_HEAL       = 47633,
+    SPELL_SIGIL_VENGEFUL_HEART  = 64962,
 };
 
 class spell_dk_death_coil : public SpellScriptLoader
@@ -743,7 +742,11 @@
                         caster->CastCustomSpell(target, SPELL_DEATH_COIL_HEAL, &bp, NULL, NULL, true);
                     }
                     else
+                    {
+                        if (AuraEffect const* auraEffect = caster->GetAuraEffect(SPELL_SIGIL_VENGEFUL_HEART, EFFECT_1))
+                            damage += auraEffect->GetBaseAmount();
                         caster->CastCustomSpell(target, SPELL_DEATH_COIL_DAMAGE, &damage, NULL, NULL, true);
+                    }
                 }
             }
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Spells/spell_druid.cpp
--- a/src/server/scripts/Spells/spell_druid.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Spells/spell_druid.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -250,7 +250,7 @@
                         return;
                     }
 
-                    Unit* target = SelectRandomContainerElement(tempTargets);
+                    Unit* target = Trinity::Containers::SelectRandomContainerElement(tempTargets);
                     unitList.clear();
                     unitList.push_back(target);
                 }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Spells/spell_generic.cpp
--- a/src/server/scripts/Spells/spell_generic.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Spells/spell_generic.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -1277,30 +1277,30 @@
 
 class spell_gen_allow_cast_from_item_only : public SpellScriptLoader
 {
-public:
-    spell_gen_allow_cast_from_item_only() : SpellScriptLoader("spell_gen_allow_cast_from_item_only") { }
-
-    class spell_gen_allow_cast_from_item_only_SpellScript : public SpellScript
-    {
-        PrepareSpellScript(spell_gen_allow_cast_from_item_only_SpellScript);
-
-        SpellCastResult CheckRequirement()
+    public:
+        spell_gen_allow_cast_from_item_only() : SpellScriptLoader("spell_gen_allow_cast_from_item_only") { }
+
+        class spell_gen_allow_cast_from_item_only_SpellScript : public SpellScript
         {
-            if (!GetCastItem())
-                return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;
-            return SPELL_CAST_OK;
+            PrepareSpellScript(spell_gen_allow_cast_from_item_only_SpellScript);
+
+            SpellCastResult CheckRequirement()
+            {
+                if (!GetCastItem())
+                    return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;
+                return SPELL_CAST_OK;
+            }
+
+            void Register()
+            {
+                OnCheckCast += SpellCheckCastFn(spell_gen_allow_cast_from_item_only_SpellScript::CheckRequirement);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_gen_allow_cast_from_item_only_SpellScript();
         }
-
-        void Register()
-        {
-            OnCheckCast += SpellCheckCastFn(spell_gen_allow_cast_from_item_only_SpellScript::CheckRequirement);
-        }
-    };
-
-    SpellScript* GetSpellScript() const
-    {
-        return new spell_gen_allow_cast_from_item_only_SpellScript();
-    }
 };
 
 enum Launch
@@ -3002,6 +3002,34 @@
         }
 };
 
+class spell_gen_wg_water : public SpellScriptLoader
+{
+    public:
+        spell_gen_wg_water() : SpellScriptLoader("spell_gen_wg_water") {}
+
+        class spell_gen_wg_water_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_gen_wg_water_SpellScript);
+
+            SpellCastResult CheckCast()
+            {
+                if (!GetSpellInfo()->CheckTargetCreatureType(GetCaster()))
+                    return SPELL_FAILED_DONT_REPORT;
+                return SPELL_CAST_OK;
+            }
+
+            void Register()
+            {
+                OnCheckCast += SpellCheckCastFn(spell_gen_wg_water_SpellScript::CheckCast);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_gen_wg_water_SpellScript();
+        }
+};
+
 void AddSC_generic_spell_scripts()
 {
     new spell_gen_absorb0_hitlimit1();
@@ -3070,4 +3098,5 @@
     new spell_gen_tournament_pennant();
     new spell_gen_chaos_blast();
     new spell_gen_ds_flush_knockback();
+    new spell_gen_wg_water();
 }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Spells/spell_hunter.cpp
--- a/src/server/scripts/Spells/spell_hunter.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Spells/spell_hunter.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -560,6 +560,64 @@
         }
 };
 
+// 34477 Misdirection
+class spell_hun_misdirection : public SpellScriptLoader
+{
+    public:
+        spell_hun_misdirection() : SpellScriptLoader("spell_hun_misdirection") { }
+
+        class spell_hun_misdirection_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_hun_misdirection_AuraScript);
+
+            void OnRemove(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*mode*/)
+            {
+                if (Unit* caster = GetCaster())
+                    if (!GetDuration())
+                        caster->SetReducedThreatPercent(0, 0);
+            }
+
+            void Register()
+            {
+                AfterEffectRemove += AuraEffectRemoveFn(spell_hun_misdirection_AuraScript::OnRemove, EFFECT_1, SPELL_AURA_DUMMY, AURA_EFFECT_HANDLE_REAL);
+            }
+        };
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_hun_misdirection_AuraScript();
+        }
+};
+
+// 35079 Misdirection proc
+class spell_hun_misdirection_proc : public SpellScriptLoader
+{
+    public:
+        spell_hun_misdirection_proc() : SpellScriptLoader("spell_hun_misdirection_proc") { }
+
+        class spell_hun_misdirection_proc_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_hun_misdirection_proc_AuraScript);
+
+            void OnRemove(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*mode*/)
+            {
+                if (GetCaster())
+                    GetCaster()->SetReducedThreatPercent(0, 0);
+            }
+
+            void Register()
+            {
+                AfterEffectRemove += AuraEffectRemoveFn(spell_hun_misdirection_proc_AuraScript::OnRemove, EFFECT_0, SPELL_AURA_DUMMY, AURA_EFFECT_HANDLE_REAL);
+            }
+        };
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_hun_misdirection_proc_AuraScript();
+        }
+};
+
+
 void AddSC_hunter_spell_scripts()
 {
     new spell_hun_aspect_of_the_beast();
@@ -572,4 +630,6 @@
     new spell_hun_sniper_training();
     new spell_hun_pet_heart_of_the_phoenix();
     new spell_hun_pet_carrion_feeder();
+    new spell_hun_misdirection();
+    new spell_hun_misdirection_proc();
 }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Spells/spell_item.cpp
--- a/src/server/scripts/Spells/spell_item.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Spells/spell_item.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -1589,15 +1589,15 @@
                     {
                         case SPELL_BREWFEST_MOUNT_TRANSFORM:
                             if (caster->GetSpeedRate(MOVE_RUN) >= 2.0f)
-                                spell_id = caster->GetTeam() == ALLIANCE ? SPELL_MOUNT_RAM_100 : SPELL_MOUNT_KODO_100 ;
+                                spell_id = caster->GetTeam() == ALLIANCE ? SPELL_MOUNT_RAM_100 : SPELL_MOUNT_KODO_100;
                             else
-                                spell_id = caster->GetTeam() == ALLIANCE ? SPELL_MOUNT_RAM_60 : SPELL_MOUNT_KODO_60 ;
+                                spell_id = caster->GetTeam() == ALLIANCE ? SPELL_MOUNT_RAM_60 : SPELL_MOUNT_KODO_60;
                             break;
                         case SPELL_BREWFEST_MOUNT_TRANSFORM_REVERSE:
                             if (caster->GetSpeedRate(MOVE_RUN) >= 2.0f)
-                                spell_id = caster->GetTeam() == HORDE ? SPELL_MOUNT_RAM_100 : SPELL_MOUNT_KODO_100 ;
+                                spell_id = caster->GetTeam() == HORDE ? SPELL_MOUNT_RAM_100 : SPELL_MOUNT_KODO_100;
                             else
-                                spell_id = caster->GetTeam() == HORDE ? SPELL_MOUNT_RAM_60 : SPELL_MOUNT_KODO_60 ;
+                                spell_id = caster->GetTeam() == HORDE ? SPELL_MOUNT_RAM_60 : SPELL_MOUNT_KODO_60;
                             break;
                         default:
                             return;
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Spells/spell_mage.cpp
--- a/src/server/scripts/Spells/spell_mage.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Spells/spell_mage.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -250,9 +250,11 @@
 
                     if (roll_chance_i(chance))
                     {
-                        absorbAmount = dmgInfo.GetDamage();
-                        int32 bp = absorbAmount;
+                        int32 bp = dmgInfo.GetDamage();
+                        dmgInfo.AbsorbDamage(bp);
                         target->CastCustomSpell(target, SPELL_MAGE_FROST_WARDING_TRIGGERED, &bp, NULL, NULL, true, NULL, aurEff);
+                        absorbAmount = 0;
+                        PreventDefaultAction();
                     }
                 }
             }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Spells/spell_priest.cpp
--- a/src/server/scripts/Spells/spell_priest.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Spells/spell_priest.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -185,6 +185,11 @@
         {
             PrepareSpellScript(spell_pri_penance_SpellScript);
 
+            bool Load()
+            {
+                return GetCaster()->GetTypeId() == TYPEID_PLAYER;
+            }
+
             bool Validate(SpellInfo const* spellEntry)
             {
                 if (!sSpellMgr->GetSpellInfo(PRIEST_SPELL_PENANCE_R1))
@@ -207,7 +212,7 @@
                 Unit* caster = GetCaster();
                 if (Unit* unitTarget = GetHitUnit())
                 {
-                    if(!unitTarget->isAlive())
+                    if (!unitTarget->isAlive())
                         return;
 
                     uint8 rank = sSpellMgr->GetSpellRank(GetSpellInfo()->Id);
@@ -219,10 +224,21 @@
                 }
             }
 
+            SpellCastResult CheckCast()
+            {
+                Player* caster = GetCaster()->ToPlayer();
+                if (GetTargetUnit())
+                    if (Player* target = GetTargetUnit()->ToPlayer())
+                        if (caster->GetTeam() != target->GetTeam() && !caster->IsValidAttackTarget(target))
+                            return SPELL_FAILED_BAD_TARGETS;
+                return SPELL_CAST_OK;
+            }
+
             void Register()
             {
                 // add dummy effect spell handler to Penance
                 OnEffectHitTarget += SpellEffectFn(spell_pri_penance_SpellScript::HandleDummy, EFFECT_0, SPELL_EFFECT_DUMMY);
+                OnCheckCast += SpellCheckCastFn(spell_pri_penance_SpellScript::CheckCast);
             }
         };
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Spells/spell_quest.cpp
--- a/src/server/scripts/Spells/spell_quest.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Spells/spell_quest.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -637,6 +637,10 @@
                 if (Unit* caster = GetCaster())
                 {
                     Unit* target = GetTarget();
+                    // Already in fire
+                    if (target->HasAura(SPELL_ABLAZE))
+                        return;
+                        
                     if (Player* player = caster->GetCharmerOrOwnerPlayerOrPlayerItself())
                     {
                         switch (target->GetEntry())
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Spells/spell_shaman.cpp
--- a/src/server/scripts/Spells/spell_shaman.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Spells/spell_shaman.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -35,6 +35,9 @@
     SHAMAN_SPELL_FIRE_NOVA_TRIGGERED_R1    = 8349,
     SHAMAN_SPELL_SATED                     = 57724,
     SHAMAN_SPELL_EXHAUSTION                = 57723,
+    
+    SHAMAN_SPELL_STORM_EARTH_AND_FIRE      = 51483,
+    EARTHBIND_TOTEM_SPELL_EARTHGRAB        = 64695,
 
     // For Earthen Power
     SHAMAN_TOTEM_SPELL_EARTHBIND_TOTEM     = 6474,
@@ -221,9 +224,25 @@
                                         caster->CastSpell(caster, SHAMAN_TOTEM_SPELL_EARTHEN_POWER, true, NULL, aurEff);
             }
 
+            void Apply(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*mode*/)
+            {
+                if (!GetCaster())
+                    return;
+                Player* owner = GetCaster()->GetCharmerOrOwnerPlayerOrPlayerItself();
+                if (!owner)
+                    return;
+                // Storm, Earth and Fire
+                if (AuraEffect* aurEff = owner->GetAuraEffectOfRankedSpell(SHAMAN_SPELL_STORM_EARTH_AND_FIRE, EFFECT_1))
+                {
+                    if (roll_chance_i(aurEff->GetAmount()))
+                        GetCaster()->CastSpell(GetCaster(), EARTHBIND_TOTEM_SPELL_EARTHGRAB, false);
+                }
+            }
+
             void Register()
             {
                  OnEffectPeriodic += AuraEffectPeriodicFn(spell_sha_earthbind_totem_AuraScript::HandleEffectPeriodic, EFFECT_0, SPELL_AURA_PERIODIC_TRIGGER_SPELL);
+                 OnEffectApply += AuraEffectApplyFn(spell_sha_earthbind_totem_AuraScript::Apply, EFFECT_0, SPELL_AURA_PERIODIC_TRIGGER_SPELL, AURA_EFFECT_HANDLE_REAL);
             }
         };
 
@@ -542,6 +561,55 @@
         }
 };
 
+// 1064 Chain Heal
+class spell_sha_chain_heal : public SpellScriptLoader
+{
+    public:
+        spell_sha_chain_heal() : SpellScriptLoader("spell_sha_chain_heal") { }
+
+        class spell_sha_chain_heal_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_sha_chain_heal_SpellScript);
+
+            bool Load()
+            {
+                firstHeal = true;
+                riptide = false;
+                return true;
+            }
+
+            void HandleHeal(SpellEffIndex /*effIndex*/)
+            {
+                if (firstHeal)
+                {
+                    // Check if the target has Riptide
+                    if (AuraEffect* aurEff = GetHitUnit()->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_SHAMAN, 0, 0, 0x10, GetCaster()->GetGUID()))
+                    {
+                        riptide = true;
+                        // Consume it
+                        GetHitUnit()->RemoveAura(aurEff->GetBase());
+                    }
+                    firstHeal = false;
+                }
+                // Riptide increases the Chain Heal effect by 25%
+                if (riptide)
+                    SetHitHeal(GetHitHeal() * 1.25f);
+            }
+
+            void Register()
+            {
+                OnEffectHitTarget += SpellEffectFn(spell_sha_chain_heal_SpellScript::HandleHeal, EFFECT_0, SPELL_EFFECT_HEAL);
+            }
+
+            bool firstHeal;
+            bool riptide;
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_sha_chain_heal_SpellScript();
+        }
+};
 
 void AddSC_shaman_spell_scripts()
 {
@@ -556,4 +624,5 @@
     new spell_sha_healing_stream_totem();
     new spell_sha_mana_spring_totem();
     new spell_sha_lava_lash();
+    new spell_sha_chain_heal();
 }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Spells/spell_warlock.cpp
--- a/src/server/scripts/Spells/spell_warlock.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Spells/spell_warlock.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -172,6 +172,19 @@
                 return true;
             }
 
+            SpellCastResult CheckCast()
+            {
+                if (Player* caster = GetCaster()->ToPlayer())
+                {
+                    uint8 spellRank = sSpellMgr->GetSpellRank(GetSpellInfo()->Id);
+                    ItemPosCountVec dest;
+                    InventoryResult msg = caster->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, iTypes[spellRank - 1][0], 1, NULL);
+                    if (msg != EQUIP_ERR_OK)
+                        return SPELL_FAILED_TOO_MANY_OF_ITEM;
+                }
+                return SPELL_CAST_OK;
+            }
+
             void HandleScriptEffect(SpellEffIndex effIndex)
             {
                 if (Unit* unitTarget = GetHitUnit())
@@ -198,6 +211,7 @@
             void Register()
             {
                 OnEffectHitTarget += SpellEffectFn(spell_warl_create_healthstone_SpellScript::HandleScriptEffect, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
+                OnCheckCast += SpellCheckCastFn(spell_warl_create_healthstone_SpellScript::CheckCast);
             }
         };
 
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/Spells/spell_warrior.cpp
--- a/src/server/scripts/Spells/spell_warrior.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/Spells/spell_warrior.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -413,6 +413,51 @@
         }
 };
 
+enum Overpower
+{
+    SPELL_UNRELENTING_ASSAULT_RANK_1        = 46859,
+    SPELL_UNRELENTING_ASSAULT_RANK_2        = 46860,
+    SPELL_UNRELENTING_ASSAULT_TRIGGER_1     = 64849,
+    SPELL_UNRELENTING_ASSAULT_TRIGGER_2     = 64850,
+};
+
+class spell_warr_overpower : public SpellScriptLoader
+{
+public:
+    spell_warr_overpower() : SpellScriptLoader("spell_warr_overpower") { }
+
+    class spell_warr_overpower_SpellScript : public SpellScript
+    {
+        PrepareSpellScript(spell_warr_overpower_SpellScript);
+
+        void HandleEffect(SpellEffIndex /* effIndex */)
+        {
+            uint32 spellId = 0;
+            if (GetCaster()->HasAura(SPELL_UNRELENTING_ASSAULT_RANK_1))
+                spellId = SPELL_UNRELENTING_ASSAULT_TRIGGER_1;
+            else if (GetCaster()->HasAura(SPELL_UNRELENTING_ASSAULT_RANK_2))
+                spellId = SPELL_UNRELENTING_ASSAULT_TRIGGER_2;
+
+            if (!spellId)
+                return;
+
+            if (Player* target = GetHitPlayer())
+                if (target->HasUnitState(UNIT_STATE_CASTING))
+                    target->CastSpell(target, spellId, true);
+        }
+
+        void Register()
+        {
+            OnEffectHitTarget += SpellEffectFn(spell_warr_overpower_SpellScript::HandleEffect, EFFECT_0, SPELL_EFFECT_ANY);
+        }
+    };
+
+    SpellScript* GetSpellScript() const
+    {
+        return new spell_warr_overpower_SpellScript();
+    }
+};
+
 void AddSC_warrior_spell_scripts()
 {
     new spell_warr_last_stand();
@@ -424,4 +469,5 @@
     new spell_warr_execute();
     new spell_warr_concussion_blow();
     new spell_warr_bloodthirst();
+    new spell_warr_overpower();
 }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/World/boss_emerald_dragons.cpp
--- a/src/server/scripts/World/boss_emerald_dragons.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/World/boss_emerald_dragons.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -371,7 +371,7 @@
                 {
                     Talk(SAY_YSONDRE_SUMMON_DRUIDS);
 
-                    for (uint8 i = 0 ; i < 10 ; ++i)
+                    for (uint8 i = 0; i < 10; ++i)
                         DoCast(me, SPELL_SUMMON_DRUID_SPIRITS, true);
                     ++_stage;
                 }
diff -r b4c056460923 -r da13f4f7a26c src/server/scripts/World/npcs_special.cpp
--- a/src/server/scripts/World/npcs_special.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/scripts/World/npcs_special.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -1039,8 +1039,9 @@
             }
         }
 
-        void WaypointReached(uint32 /*point*/)
+        void WaypointReached(uint32 /*waypointId*/)
         {
+
         }
 
         void UpdateAI(uint32 const diff)
diff -r b4c056460923 -r da13f4f7a26c src/server/shared/AutoPtr.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/server/shared/AutoPtr.h	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _TRINITY_AUTO_PTR_H
+#define _TRINITY_AUTO_PTR_H
+
+#include <ace/Bound_Ptr.h>
+
+namespace Trinity
+{
+    template <class Pointer, class Lock>
+    class AutoPtr : public ACE_Strong_Bound_Ptr<Pointer, Lock>
+    {
+        public:
+            AutoPtr() : ACE_Strong_Bound_Ptr<Pointer, Lock>() {}
+ 
+            AutoPtr(Pointer* x)
+            {
+                ACE_Strong_Bound_Ptr<Pointer, Lock>::reset(x);
+            }
+
+            operator bool() const
+            {
+                return ACE_Strong_Bound_Ptr<Pointer, Lock>::get() != NULL;
+            }
+
+            bool operator !() const
+            {
+                return ACE_Strong_Bound_Ptr<Pointer, Lock>::get() == NULL;
+            }
+
+            bool operator !=(Pointer* x) const
+            {
+                return ACE_Strong_Bound_Ptr<Pointer, Lock>::get() != x;
+            }
+    };
+};
+
+#endif
\ No newline at end of file
diff -r b4c056460923 -r da13f4f7a26c src/server/shared/CMakeLists.txt
--- a/src/server/shared/CMakeLists.txt	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/shared/CMakeLists.txt	Mon Apr 16 14:29:17 2012 +0300
@@ -53,7 +53,6 @@
 include_directories(
   ${CMAKE_BINARY_DIR}
   ${CMAKE_SOURCE_DIR}/dep/SFMT
-  ${CMAKE_SOURCE_DIR}/dep/mersennetwister
   ${CMAKE_SOURCE_DIR}/dep/sockets/include
   ${CMAKE_SOURCE_DIR}/dep/utf8cpp
   ${CMAKE_SOURCE_DIR}/src/server
diff -r b4c056460923 -r da13f4f7a26c src/server/shared/Containers.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/server/shared/Containers.h	Mon Apr 16 14:29:17 2012 +0300
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef TRINITY_CONTAINERS_H
+#define TRINITY_CONTAINERS_H
+
+#include <list>
+
+//! Because circular includes are bad
+extern uint32 urand(uint32 min, uint32 max);
+
+namespace Trinity
+{
+    namespace Containers
+    {
+        template<class T>
+        void RandomResizeList(std::list<T> &list, uint32 size)
+        {
+            size_t list_size = list.size();
+
+            while (list_size > size)
+            {
+                typename std::list<T>::iterator itr = list.begin();
+                std::advance(itr, urand(0, list_size - 1));
+                list.erase(itr);
+                --list_size;
+            }
+        }
+
+        template<class T, class Predicate>
+        void RandomResizeList(std::list<T> &list, Predicate& predicate, uint32 size)
+        {
+            //! First use predicate filter
+            std::list<T> listCopy;
+            for (typename std::list<T>::iterator itr = list.begin(); itr != list.end(); ++itr)
+                if (predicate(*itr))
+                    listCopy.push_back(*itr);
+
+            if (size)
+                RandomResizeList(listCopy, size);
+
+            list = listCopy;
+        }
+
+        /* Select a random element from a container. Note: make sure you explicitly empty check the container */
+        template <class C> typename C::value_type const& SelectRandomContainerElement(C const& container)
+        {
+            typename C::const_iterator it = container.begin();
+            std::advance(it, urand(0, container.size() - 1));
+            return *it;
+        }
+    };
+    //! namespace Containers
+};
+//! namespace Trinity
+
+#endif //! #ifdef TRINITY_CONTAINERS_H
\ No newline at end of file
diff -r b4c056460923 -r da13f4f7a26c src/server/shared/Database/DatabaseWorkerPool.h
--- a/src/server/shared/Database/DatabaseWorkerPool.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/shared/Database/DatabaseWorkerPool.h	Mon Apr 16 14:29:17 2012 +0300
@@ -1,492 +1,510 @@
-/*
- * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef _DATABASEWORKERPOOL_H
-#define _DATABASEWORKERPOOL_H
-
-#include <ace/Thread_Mutex.h>
-
-#include "Common.h"
-#include "Callback.h"
-#include "MySQLConnection.h"
-#include "Transaction.h"
-#include "DatabaseWorker.h"
-#include "PreparedStatement.h"
-#include "Log.h"
-#include "QueryResult.h"
-#include "QueryHolder.h"
-#include "AdhocStatement.h"
-
-class PingOperation : public SQLOperation
-{
-    /// Operation for idle delaythreads
-    bool Execute()
-    {
-        if (m_conn->LockIfReady())
-        {
-            m_conn->Ping();
-            m_conn->Unlock();
-            return true;
-        }
-
-        return false;
-    }
-};
-
-template <class T>
-class DatabaseWorkerPool
-{
-    public:
-        /* Activity state */
-        DatabaseWorkerPool() :
-        m_queue(new ACE_Activation_Queue(new ACE_Message_Queue<ACE_MT_SYNCH>))
-        {
-            memset(m_connectionCount, 0, sizeof(m_connectionCount));
-            m_connections.resize(IDX_SIZE);
-
-            WPFatal (mysql_thread_safe(), "Used MySQL library isn't thread-safe.");
-        }
-
-        ~DatabaseWorkerPool()
-        {
-        }
-
-        bool Open(const std::string& infoString, uint8 async_threads, uint8 synch_threads)
-        {
-            bool res = true;
-            m_connectionInfo = MySQLConnectionInfo(infoString);
-
-            //sLog->outSQLDriver("Opening databasepool '%s'. Async threads: %u, synch threads: %u", m_connectionInfo.database.c_str(), async_threads, synch_threads);
-
-            /// Open asynchronous connections (delayed operations)
-            m_connections[IDX_ASYNC].resize(async_threads);
-            for (uint8 i = 0; i < async_threads; ++i)
-            {
-                T* t = new T(m_queue, m_connectionInfo);
-                res &= t->Open();
-                m_connections[IDX_ASYNC][i] = t;
-                ++m_connectionCount[IDX_ASYNC];
-            }
-
-            /// Open synchronous connections (direct, blocking operations)
-            m_connections[IDX_SYNCH].resize(synch_threads);
-            for (uint8 i = 0; i < synch_threads; ++i)
-            {
-                T* t = new T(m_connectionInfo);
-                res &= t->Open();
-                m_connections[IDX_SYNCH][i] = t;
-                ++m_connectionCount[IDX_SYNCH];
-            }
-
-            //sLog->outSQLDriver("Databasepool opened successfully. %u total connections running.", (m_connectionCount[IDX_SYNCH] + m_connectionCount[IDX_ASYNC]));
-            return res;
-        }
-
-        void Close()
-        {
-            sLog->outSQLDriver("Closing down databasepool '%s'.", m_connectionInfo.database.c_str());
-
-            /// Shuts down delaythreads for this connection pool by underlying deactivate()
-            m_queue->queue()->close();
-
-            for (uint8 i = 0; i < m_connectionCount[IDX_ASYNC]; ++i)
-            {
-                /// TODO: Better way. probably should flip a boolean and check it on low level code before doing anything on the mysql ctx
-                /// Now we just wait until m_queue gives the signal to the worker threads to stop
-                T* t = m_connections[IDX_ASYNC][i];
-                DatabaseWorker* worker = t->m_worker;
-                worker->wait();
-                delete worker;
-                t->Close();
-            }
-
-            sLog->outSQLDriver("Asynchronous connections on databasepool '%s' terminated. Proceeding with synchronous connections.", m_connectionInfo.database.c_str());
-
-            /// Shut down the synchronous connections
-            for (uint8 i = 0; i < m_connectionCount[IDX_SYNCH]; ++i)
-            {
-                T* t = m_connections[IDX_SYNCH][i];
-                //while (1)
-                //    if (t->LockIfReady()) -- For some reason deadlocks us
-                t->Close();
-            }
-
-            sLog->outSQLDriver("All connections on databasepool %s closed.", m_connectionInfo.database.c_str());
-        }
-
-        /**
-            Delayed one-way statement methods.
-        */
-
-        //! Enqueues a one-way SQL operation in string format that will be executed asynchronously.
-		//! This method should only be used for queries that are only executed once, e.g during startup.
-        void Execute(const char* sql)
-        {
-            if (!sql)
-                return;
-
-            BasicStatementTask* task = new BasicStatementTask(sql);
-            Enqueue(task);
-        }
-
-        //! Enqueues a one-way SQL operation in string format -with variable args- that will be executed asynchronously.
-		//! This method should only be used for queries that are only executed once, e.g during startup.
-        void PExecute(const char* sql, ...)
-        {
-            if (!sql)
-                return;
-
-            va_list ap;
-            char szQuery[MAX_QUERY_LEN];
-            va_start(ap, sql);
-            vsnprintf(szQuery, MAX_QUERY_LEN, sql, ap);
-            va_end(ap);
-
-            Execute(szQuery);
-        }
-
-        //! Enqueues a one-way SQL operation in prepared statement format that will be executed asynchronously.
-		//! Statement must be prepared with CONNECTION_ASYNC flag.
-        void Execute(PreparedStatement* stmt)
-        {
-            PreparedStatementTask* task = new PreparedStatementTask(stmt);
-            Enqueue(task);
-        }
-
-        /**
-            Direct synchronous one-way statement methods.
-        */
-
-        //! Directly executes a one-way SQL operation in string format, that will block the calling thread until finished.
-		//! This method should only be used for queries that are only executed once, e.g during startup.
-        void DirectExecute(const char* sql)
-        {
-            if (!sql)
-                return;
-
-            T* t = GetFreeConnection();
-            t->Execute(sql);
-            t->Unlock();
-        }
-
-        //! Directly executes a one-way SQL operation in string format -with variable args-, that will block the calling thread until finished.
-		//! This method should only be used for queries that are only executed once, e.g during startup.
-        void DirectPExecute(const char* sql, ...)
-        {
-            if (!sql)
-                return;
-
-            va_list ap;
-            char szQuery[MAX_QUERY_LEN];
-            va_start(ap, sql);
-            vsnprintf(szQuery, MAX_QUERY_LEN, sql, ap);
-            va_end(ap);
-
-            return DirectExecute(szQuery);
-        }
-
-        //! Directly executes a one-way SQL operation in prepared statement format, that will block the calling thread until finished.
-        void DirectExecute(PreparedStatement* stmt)
-        {
-            T* t = GetFreeConnection();
-            t->Execute(stmt);
-            t->Unlock();
-        }
-
-        /**
-            Syncrhonous query (with resultset) methods.
-        */
-
-        //! Directly executes an SQL query in string format that will block the calling thread until finished.
-        //! Returns reference counted auto pointer, no need for manual memory management in upper level code.
-		//! Statement must be prepared with CONNECTION_SYNCH flag.
-        QueryResult Query(const char* sql, MySQLConnection* conn = NULL)
-        {
-            if (!conn)
-                conn = GetFreeConnection();
-
-            ResultSet* result = conn->Query(sql);
-            conn->Unlock();
-            if (!result || !result->GetRowCount())
-                return QueryResult(NULL);
-
-            result->NextRow();
-            return QueryResult(result);
-        }
-
-        //! Directly executes an SQL query in string format -with variable args- that will block the calling thread until finished.
-        //! Returns reference counted auto pointer, no need for manual memory management in upper level code.
-        QueryResult PQuery(const char* sql, MySQLConnection* conn, ...)
-        {
-            if (!sql)
-                return QueryResult(NULL);
-
-            va_list ap;
-            char szQuery[MAX_QUERY_LEN];
-            va_start(ap, sql);
-            vsnprintf(szQuery, MAX_QUERY_LEN, sql, ap);
-            va_end(ap);
-
-            return Query(szQuery, conn);
-        }
-
-        //! Directly executes an SQL query in string format -with variable args- that will block the calling thread until finished.
-        //! Returns reference counted auto pointer, no need for manual memory management in upper level code.
-        QueryResult PQuery(const char* sql, ...)
-        {
-            if (!sql)
-                return QueryResult(NULL);
-
-            va_list ap;
-            char szQuery[MAX_QUERY_LEN];
-            va_start(ap, sql);
-            vsnprintf(szQuery, MAX_QUERY_LEN, sql, ap);
-            va_end(ap);
-
-            return Query(szQuery);
-        }
-
-        //! Directly executes an SQL query in prepared format that will block the calling thread until finished.
-        //! Returns reference counted auto pointer, no need for manual memory management in upper level code.
-        PreparedQueryResult Query(PreparedStatement* stmt)
-        {
-            T* t = GetFreeConnection();
-            PreparedResultSet* ret = t->Query(stmt);
-            t->Unlock();
-
-            if (!ret || !ret->GetRowCount())
-                return PreparedQueryResult(NULL);
-
-            return PreparedQueryResult(ret);
-        }
-
-        /**
-            Asynchronous query (with resultset) methods.
-        */
-
-        //! Enqueues a query in string format that will set the value of the QueryResultFuture return object as soon as the query is executed.
-        //! The return value is then processed in ProcessQueryCallback methods.
-		//! Statement must be prepared with CONNECTION_ASYNC flag.
-        QueryResultFuture AsyncQuery(const char* sql)
-        {
-            QueryResultFuture res;
-            BasicStatementTask* task = new BasicStatementTask(sql, res);
-            Enqueue(task);
-            return res;         //! Actual return value has no use yet
-        }
-
-        //! Enqueues a query in string format -with variable args- that will set the value of the QueryResultFuture return object as soon as the query is executed.
-        //! The return value is then processed in ProcessQueryCallback methods.
-        QueryResultFuture AsyncPQuery(const char* sql, ...)
-        {
-            va_list ap;
-            char szQuery[MAX_QUERY_LEN];
-            va_start(ap, sql);
-            vsnprintf(szQuery, MAX_QUERY_LEN, sql, ap);
-            va_end(ap);
-
-            return AsyncQuery(szQuery);
-        }
-
-        //! Enqueues a query in prepared format that will set the value of the PreparedQueryResultFuture return object as soon as the query is executed.
-        //! The return value is then processed in ProcessQueryCallback methods.
-        PreparedQueryResultFuture AsyncQuery(PreparedStatement* stmt)
-        {
-            PreparedQueryResultFuture res;
-            PreparedStatementTask* task = new PreparedStatementTask(stmt, res);
-            Enqueue(task);
-            return res;
-        }
-
-        //! Enqueues a vector of SQL operations (can be both adhoc and prepared) that will set the value of the QueryResultHolderFuture
-        //! return object as soon as the query is executed.
-        //! The return value is then processed in ProcessQueryCallback methods.
-        QueryResultHolderFuture DelayQueryHolder(SQLQueryHolder* holder)
-        {
-            QueryResultHolderFuture res;
-            SQLQueryHolderTask* task = new SQLQueryHolderTask(holder, res);
-            Enqueue(task);
-            return res;     //! Fool compiler, has no use yet
-        }
-
-        /**
-            Transaction context methods.
-        */
-
-        //! Begins an automanaged transaction pointer that will automatically rollback if not commited. (Autocommit=0)
-        SQLTransaction BeginTransaction()
-        {
-            return SQLTransaction(new Transaction);
-        }
-
-        //! Enqueues a collection of one-way SQL operations (can be both adhoc and prepared). The order in which these operations
-        //! were appended to the transaction will be respected during execution.
-        void CommitTransaction(SQLTransaction transaction)
-        {
-            if (sLog->GetSQLDriverQueryLogging())
-            {
-                switch (transaction->GetSize())
-                {
-                    case 0:
-                        sLog->outSQLDriver("Transaction contains 0 queries. Not executing.");
-                        return;
-                    case 1:
-                        sLog->outSQLDriver("Warning: Transaction only holds 1 query, consider removing Transaction context in code.");
-                        break;
-                    default:
-                        break;
-                }
-            }
-
-            Enqueue(new TransactionTask(transaction));
-        }
-
-        //! Directly executes a collection of one-way SQL operations (can be both adhoc and prepared). The order in which these operations
-        //! were appended to the transaction will be respected during execution.
-        void DirectCommitTransaction(SQLTransaction& transaction)
-        {
-            MySQLConnection* con = GetFreeConnection();
-            if (con->ExecuteTransaction(transaction))
-            {
-                con->Unlock();      // OK, operation succesful
-                return;
-            }
-
-            if (con->GetLastError() == 1213)
-            {
-                uint8 loopBreaker = 5;  // Handle MySQL Errno 1213 without extending deadlock to the core itself
-                for (uint8 i = 0; i < loopBreaker; ++i)
-                {
-                    if (con->ExecuteTransaction(transaction))
-                        break;
-                }
-            }
-			
-            // Clean up now.
-            transaction->Cleanup();
-
-            con->Unlock();
-        }
-
-        //! Method used to execute prepared statements in a diverse context.
-        //! Will be wrapped in a transaction if valid object is present, otherwise executed standalone.
-        void ExecuteOrAppend(SQLTransaction& trans, PreparedStatement* stmt)
-        {
-            if (trans.null())
-                Execute(stmt);
-            else
-                trans->Append(stmt);
-        }
-
-        //! Method used to execute ad-hoc statements in a diverse context.
-        //! Will be wrapped in a transaction if valid object is present, otherwise executed standalone.
-        void ExecuteOrAppend(SQLTransaction& trans, const char* sql)
-        {
-            if (trans.null())
-                Execute(sql);
-            else
-                trans->Append(sql);
-        }
-
-        /**
-            Other
-        */
-
-        //! Automanaged (internally) pointer to a prepared statement object for usage in upper level code.
-        //! This object is not tied to the prepared statement on the MySQL context yet until execution.
-        PreparedStatement* GetPreparedStatement(uint32 index)
-        {
-            return new PreparedStatement(index);
-        }
-
-        //! Apply escape string'ing for current collation. (utf8)
-        void EscapeString(std::string& str)
-        {
-            if (str.empty())
-                return;
-
-            char* buf = new char[str.size()*2+1];
-            EscapeString(buf, str.c_str(), str.size());
-            str = buf;
-            delete[] buf;
-        }
-
-        //! Keeps all our MySQL connections alive, prevent the server from disconnecting us.
-        void KeepAlive()
-        {
-            /// Ping synchronous connections
-            for (uint8 i = 0; i < m_connectionCount[IDX_SYNCH]; ++i)
-            {
-                T* t = m_connections[IDX_SYNCH][i];
-                if (t->LockIfReady())
-                {
-                    t->Ping();
-                    t->Unlock();
-                }
-            }
-
-            /// Assuming all worker threads are free, every worker thread will receive 1 ping operation request
-            /// If one or more worker threads are busy, the ping operations will not be split evenly, but this doesn't matter
-            /// as the sole purpose is to prevent connections from idling.
-            for (size_t i = 0; i < m_connections[IDX_ASYNC].size(); ++i)
-                Enqueue(new PingOperation);
-        }
-
-    private:
-        unsigned long EscapeString(char *to, const char *from, unsigned long length)
-        {
-            if (!to || !from || !length)
-                return 0;
-
-            return mysql_real_escape_string(m_connections[IDX_SYNCH][0]->GetHandle(), to, from, length);
-        }
-
-        void Enqueue(SQLOperation* op)
-        {
-            m_queue->enqueue(op);
-        }
-
-        T* GetFreeConnection()
-        {
-            uint8 i = 0;
-            size_t num_cons = m_connectionCount[IDX_SYNCH];
-            for (;;)    /// Block forever until a connection is free
-            {
-                T* t = m_connections[IDX_SYNCH][++i % num_cons ];
-                if (t->LockIfReady())   /// Must be matched with t->Unlock() or you will get deadlocks
-                    return t;
-            }
-
-            // This will be called when Celine Dion learns to sing
-            return NULL;
-        }
-
-    private:
-        enum
-        {
-            IDX_ASYNC,
-            IDX_SYNCH,
-            IDX_SIZE,
-        };
-
-        ACE_Activation_Queue*           m_queue;             //! Queue shared by async worker threads.
-        std::vector< std::vector<T*> >  m_connections;
-        uint32                          m_connectionCount[2];       //! Counter of MySQL connections;
-        MySQLConnectionInfo             m_connectionInfo;
-};
-
-#endif
+/*
+ * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _DATABASEWORKERPOOL_H
+#define _DATABASEWORKERPOOL_H
+
+#include <ace/Thread_Mutex.h>
+
+#include "Common.h"
+#include "Callback.h"
+#include "MySQLConnection.h"
+#include "Transaction.h"
+#include "DatabaseWorker.h"
+#include "PreparedStatement.h"
+#include "Log.h"
+#include "QueryResult.h"
+#include "QueryHolder.h"
+#include "AdhocStatement.h"
+
+class PingOperation : public SQLOperation
+{
+    //! Operation for idle delaythreads
+    bool Execute()
+    {
+        m_conn->Ping();
+        return true;
+    }
+};
+
+template <class T>
+class DatabaseWorkerPool
+{
+    public:
+        /* Activity state */
+        DatabaseWorkerPool() :
+        _queue(new ACE_Activation_Queue())
+        {
+            memset(_connectionCount, 0, sizeof(_connectionCount));
+            _connections.resize(IDX_SIZE);
+
+            WPFatal (mysql_thread_safe(), "Used MySQL library isn't thread-safe.");
+        }
+
+        ~DatabaseWorkerPool()
+        {
+        }
+
+        bool Open(const std::string& infoString, uint8 async_threads, uint8 synch_threads)
+        {
+            bool res = true;
+            _connectionInfo = MySQLConnectionInfo(infoString);
+
+            //sLog->outSQLDriver("Opening DatabasePool '%s'. Asynchronous connections: %u, synchronous connections: %u.",
+                //GetDatabaseName(), async_threads, synch_threads);
+
+            //! Open asynchronous connections (delayed operations)
+            _connections[IDX_ASYNC].resize(async_threads);
+            for (uint8 i = 0; i < async_threads; ++i)
+            {
+                T* t = new T(_queue, _connectionInfo);
+                res &= t->Open();
+                _connections[IDX_ASYNC][i] = t;
+                ++_connectionCount[IDX_ASYNC];
+            }
+
+            //! Open synchronous connections (direct, blocking operations)
+            _connections[IDX_SYNCH].resize(synch_threads);
+            for (uint8 i = 0; i < synch_threads; ++i)
+            {
+                T* t = new T(_connectionInfo);
+                res &= t->Open();
+                _connections[IDX_SYNCH][i] = t;
+                ++_connectionCount[IDX_SYNCH];
+            }
+
+            if (!res)
+                sLog->outError("DatabasePool %s NOT opened. There were errors opening the MySQL connections. Check your SQLDriverLogFile "
+                    "for specific errors.", GetDatabaseName());
+            return res;
+        }
+
+        void Close()
+        {
+            sLog->outSQLDriver("Closing down DatabasePool '%s'.", GetDatabaseName());
+
+            //! Shuts down delaythreads for this connection pool by underlying deactivate().
+            //! The next dequeue attempt in the worker thread tasks will result in an error,
+            //! ultimately ending the worker thread task.
+            _queue->queue()->close();
+
+            for (uint8 i = 0; i < _connectionCount[IDX_ASYNC]; ++i)
+            {
+                T* t = _connections[IDX_ASYNC][i];
+                DatabaseWorker* worker = t->m_worker;
+                worker->wait();     //! Block until no more threads are running this task.
+                delete worker;
+                t->Close();         //! Closes the actualy MySQL connection.
+            }
+
+            sLog->outSQLDriver("Asynchronous connections on DatabasePool '%s' terminated. Proceeding with synchronous connections.",
+                GetDatabaseName());
+
+            //! Shut down the synchronous connections
+            //! There's no need for locking the connection, because DatabaseWorkerPool<>::Close
+            //! should only be called after any other thread tasks in the core have exited,
+            //! meaning there can be no concurrent access at this point.
+            for (uint8 i = 0; i < _connectionCount[IDX_SYNCH]; ++i)
+                _connections[IDX_SYNCH][i]->Close();
+
+            //! Deletes the ACE_Activation_Queue object and its underlying ACE_Message_Queue
+            delete _queue;
+
+            sLog->outSQLDriver("All connections on DatabasePool '%s' closed.", GetDatabaseName());
+        }
+
+        /**
+            Delayed one-way statement methods.
+        */
+
+        //! Enqueues a one-way SQL operation in string format that will be executed asynchronously.
+        //! This method should only be used for queries that are only executed once, e.g during startup.
+        void Execute(const char* sql)
+        {
+            if (!sql)
+                return;
+
+            BasicStatementTask* task = new BasicStatementTask(sql);
+            Enqueue(task);
+        }
+
+        //! Enqueues a one-way SQL operation in string format -with variable args- that will be executed asynchronously.
+        //! This method should only be used for queries that are only executed once, e.g during startup.
+        void PExecute(const char* sql, ...)
+        {
+            if (!sql)
+                return;
+
+            va_list ap;
+            char szQuery[MAX_QUERY_LEN];
+            va_start(ap, sql);
+            vsnprintf(szQuery, MAX_QUERY_LEN, sql, ap);
+            va_end(ap);
+
+            Execute(szQuery);
+        }
+
+        //! Enqueues a one-way SQL operation in prepared statement format that will be executed asynchronously.
+        //! Statement must be prepared with CONNECTION_ASYNC flag.
+        void Execute(PreparedStatement* stmt)
+        {
+            PreparedStatementTask* task = new PreparedStatementTask(stmt);
+            Enqueue(task);
+        }
+
+        /**
+            Direct synchronous one-way statement methods.
+        */
+
+        //! Directly executes a one-way SQL operation in string format, that will block the calling thread until finished.
+        //! This method should only be used for queries that are only executed once, e.g during startup.
+        void DirectExecute(const char* sql)
+        {
+            if (!sql)
+                return;
+
+            T* t = GetFreeConnection();
+            t->Execute(sql);
+            t->Unlock();
+        }
+
+        //! Directly executes a one-way SQL operation in string format -with variable args-, that will block the calling thread until finished.
+        //! This method should only be used for queries that are only executed once, e.g during startup.
+        void DirectPExecute(const char* sql, ...)
+        {
+            if (!sql)
+                return;
+
+            va_list ap;
+            char szQuery[MAX_QUERY_LEN];
+            va_start(ap, sql);
+            vsnprintf(szQuery, MAX_QUERY_LEN, sql, ap);
+            va_end(ap);
+
+            return DirectExecute(szQuery);
+        }
+
+        //! Directly executes a one-way SQL operation in prepared statement format, that will block the calling thread until finished.
+        //! Statement must be prepared with the CONNECTION_SYNCH flag.
+        void DirectExecute(PreparedStatement* stmt)
+        {
+            T* t = GetFreeConnection();
+            t->Execute(stmt);
+            t->Unlock();
+        }
+
+        /**
+            Synchronous query (with resultset) methods.
+        */
+
+        //! Directly executes an SQL query in string format that will block the calling thread until finished.
+        //! Returns reference counted auto pointer, no need for manual memory management in upper level code.
+        QueryResult Query(const char* sql, MySQLConnection* conn = NULL)
+        {
+            if (!conn)
+                conn = GetFreeConnection();
+
+            ResultSet* result = conn->Query(sql);
+            conn->Unlock();
+            if (!result || !result->GetRowCount())
+                return QueryResult(NULL);
+
+            result->NextRow();
+            return QueryResult(result);
+        }
+
+        //! Directly executes an SQL query in string format -with variable args- that will block the calling thread until finished.
+        //! Returns reference counted auto pointer, no need for manual memory management in upper level code.
+        QueryResult PQuery(const char* sql, MySQLConnection* conn, ...)
+        {
+            if (!sql)
+                return QueryResult(NULL);
+
+            va_list ap;
+            char szQuery[MAX_QUERY_LEN];
+            va_start(ap, conn);
+            vsnprintf(szQuery, MAX_QUERY_LEN, sql, ap);
+            va_end(ap);
+
+            return Query(szQuery, conn);
+        }
+
+        //! Directly executes an SQL query in string format -with variable args- that will block the calling thread until finished.
+        //! Returns reference counted auto pointer, no need for manual memory management in upper level code.
+        QueryResult PQuery(const char* sql, ...)
+        {
+            if (!sql)
+                return QueryResult(NULL);
+
+            va_list ap;
+            char szQuery[MAX_QUERY_LEN];
+            va_start(ap, sql);
+            vsnprintf(szQuery, MAX_QUERY_LEN, sql, ap);
+            va_end(ap);
+
+            return Query(szQuery);
+        }
+
+        //! Directly executes an SQL query in prepared format that will block the calling thread until finished.
+        //! Returns reference counted auto pointer, no need for manual memory management in upper level code.
+        //! Statement must be prepared with CONNECTION_SYNCH flag.
+        PreparedQueryResult Query(PreparedStatement* stmt)
+        {
+            T* t = GetFreeConnection();
+            PreparedResultSet* ret = t->Query(stmt);
+            t->Unlock();
+
+            //! Delete proxy-class. Not needed anymore
+            delete stmt;
+
+            if (!ret || !ret->GetRowCount())
+                return PreparedQueryResult(NULL);
+
+            return PreparedQueryResult(ret);
+        }
+
+        /**
+            Asynchronous query (with resultset) methods.
+        */
+
+        //! Enqueues a query in string format that will set the value of the QueryResultFuture return object as soon as the query is executed.
+        //! The return value is then processed in ProcessQueryCallback methods.
+        QueryResultFuture AsyncQuery(const char* sql)
+        {
+            QueryResultFuture res;
+            BasicStatementTask* task = new BasicStatementTask(sql, res);
+            Enqueue(task);
+            return res;         //! Actual return value has no use yet
+        }
+
+        //! Enqueues a query in string format -with variable args- that will set the value of the QueryResultFuture return object as soon as the query is executed.
+        //! The return value is then processed in ProcessQueryCallback methods.
+        QueryResultFuture AsyncPQuery(const char* sql, ...)
+        {
+            va_list ap;
+            char szQuery[MAX_QUERY_LEN];
+            va_start(ap, sql);
+            vsnprintf(szQuery, MAX_QUERY_LEN, sql, ap);
+            va_end(ap);
+
+            return AsyncQuery(szQuery);
+        }
+
+        //! Enqueues a query in prepared format that will set the value of the PreparedQueryResultFuture return object as soon as the query is executed.
+        //! The return value is then processed in ProcessQueryCallback methods.
+        //! Statement must be prepared with CONNECTION_ASYNC flag.
+        PreparedQueryResultFuture AsyncQuery(PreparedStatement* stmt)
+        {
+            PreparedQueryResultFuture res;
+            PreparedStatementTask* task = new PreparedStatementTask(stmt, res);
+            Enqueue(task);
+            return res;
+        }
+
+        //! Enqueues a vector of SQL operations (can be both adhoc and prepared) that will set the value of the QueryResultHolderFuture
+        //! return object as soon as the query is executed.
+        //! The return value is then processed in ProcessQueryCallback methods.
+        //! Any prepared statements added to this holder need to be prepared with the CONNECTION_ASYNC flag.
+        QueryResultHolderFuture DelayQueryHolder(SQLQueryHolder* holder)
+        {
+            QueryResultHolderFuture res;
+            SQLQueryHolderTask* task = new SQLQueryHolderTask(holder, res);
+            Enqueue(task);
+            return res;     //! Fool compiler, has no use yet
+        }
+
+        /**
+            Transaction context methods.
+        */
+
+        //! Begins an automanaged transaction pointer that will automatically rollback if not commited. (Autocommit=0)
+        SQLTransaction BeginTransaction()
+        {
+            return SQLTransaction(new Transaction);
+        }
+
+        //! Enqueues a collection of one-way SQL operations (can be both adhoc and prepared). The order in which these operations
+        //! were appended to the transaction will be respected during execution.
+        void CommitTransaction(SQLTransaction transaction)
+        {
+            #ifdef TRINITY_DEBUG
+            //! Only analyze transaction weaknesses in Debug mode.
+            //! Ideally we catch the faults in Debug mode and then correct them,
+            //! so there's no need to waste these CPU cycles in Release mode.
+            switch (transaction->GetSize())
+            {
+                case 0:
+                    sLog->outSQLDriver("Transaction contains 0 queries. Not executing.");
+                    return;
+                case 1:
+                    sLog->outSQLDriver("Warning: Transaction only holds 1 query, consider removing Transaction context in code.");
+                    break;
+                default:
+                    break;
+            }
+            #endif // TRINITY_DEBUG
+
+            Enqueue(new TransactionTask(transaction));
+        }
+
+        //! Directly executes a collection of one-way SQL operations (can be both adhoc and prepared). The order in which these operations
+        //! were appended to the transaction will be respected during execution.
+        void DirectCommitTransaction(SQLTransaction& transaction)
+        {
+            MySQLConnection* con = GetFreeConnection();
+            if (con->ExecuteTransaction(transaction))
+            {
+                con->Unlock();      // OK, operation succesful
+                return;
+            }
+
+            //! Handle MySQL Errno 1213 without extending deadlock to the core itself
+            //! TODO: More elegant way
+            if (con->GetLastError() == 1213)
+            {
+                uint8 loopBreaker = 5;
+                for (uint8 i = 0; i < loopBreaker; ++i)
+                {
+                    if (con->ExecuteTransaction(transaction))
+                        break;
+                }
+            }
+
+            //! Clean up now.
+            transaction->Cleanup();
+
+            con->Unlock();
+        }
+
+        //! Method used to execute prepared statements in a diverse context.
+        //! Will be wrapped in a transaction if valid object is present, otherwise executed standalone.
+        void ExecuteOrAppend(SQLTransaction& trans, PreparedStatement* stmt)
+        {
+            if (trans.null())
+                Execute(stmt);
+            else
+                trans->Append(stmt);
+        }
+
+        //! Method used to execute ad-hoc statements in a diverse context.
+        //! Will be wrapped in a transaction if valid object is present, otherwise executed standalone.
+        void ExecuteOrAppend(SQLTransaction& trans, const char* sql)
+        {
+            if (trans.null())
+                Execute(sql);
+            else
+                trans->Append(sql);
+        }
+
+        /**
+            Other
+        */
+
+        //! Automanaged (internally) pointer to a prepared statement object for usage in upper level code.
+        //! Pointer is deleted in this->Query(PreparedStatement*) or PreparedStatementTask::~PreparedStatementTask.
+        //! This object is not tied to the prepared statement on the MySQL context yet until execution.
+        PreparedStatement* GetPreparedStatement(uint32 index)
+        {
+            return new PreparedStatement(index);
+        }
+
+        //! Apply escape string'ing for current collation. (utf8)
+        void EscapeString(std::string& str)
+        {
+            if (str.empty())
+                return;
+
+            char* buf = new char[str.size()*2+1];
+            EscapeString(buf, str.c_str(), str.size());
+            str = buf;
+            delete[] buf;
+        }
+
+        //! Keeps all our MySQL connections alive, prevent the server from disconnecting us.
+        void KeepAlive()
+        {
+            //! Ping synchronous connections
+            for (uint8 i = 0; i < _connectionCount[IDX_SYNCH]; ++i)
+            {
+                T* t = _connections[IDX_SYNCH][i];
+                if (t->LockIfReady())
+                {
+                    t->Ping();
+                    t->Unlock();
+                }
+            }
+
+            //! Assuming all worker threads are free, every worker thread will receive 1 ping operation request
+            //! If one or more worker threads are busy, the ping operations will not be split evenly, but this doesn't matter
+            //! as the sole purpose is to prevent connections from idling.
+            for (size_t i = 0; i < _connections[IDX_ASYNC].size(); ++i)
+                Enqueue(new PingOperation);
+        }
+
+    private:
+        unsigned long EscapeString(char *to, const char *from, unsigned long length)
+        {
+            if (!to || !from || !length)
+                return 0;
+
+            return mysql_real_escape_string(_connections[IDX_SYNCH][0]->GetHandle(), to, from, length);
+        }
+
+        void Enqueue(SQLOperation* op)
+        {
+            _queue->enqueue(op);
+        }
+
+        //! Gets a free connection in the synchronous connection pool.
+        //! Caller MUST call t->Unlock() after touching the MySQL context to prevent deadlocks.
+        T* GetFreeConnection()
+        {
+            uint8 i = 0;
+            size_t num_cons = _connectionCount[IDX_SYNCH];
+            //! Block forever until a connection is free
+            for (;;)
+            {
+                T* t = _connections[IDX_SYNCH][++i % num_cons];
+                //! Must be matched with t->Unlock() or you will get deadlocks
+                if (t->LockIfReady())
+                    return t;
+            }
+
+            //! This will be called when Celine Dion learns to sing
+            return NULL;
+        }
+
+        char const* GetDatabaseName() const
+        {
+            return _connectionInfo.database.c_str();
+        }
+
+    private:
+        enum _internalIndex
+        {
+            IDX_ASYNC,
+            IDX_SYNCH,
+            IDX_SIZE,
+        };
+
+        ACE_Activation_Queue*           _queue;             //! Queue shared by async worker threads.
+        std::vector< std::vector<T*> >  _connections;
+        uint32                          _connectionCount[2];       //! Counter of MySQL connections;
+        MySQLConnectionInfo             _connectionInfo;
+};
+
+#endif
diff -r b4c056460923 -r da13f4f7a26c src/server/shared/Database/Field.h
--- a/src/server/shared/Database/Field.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/shared/Database/Field.h	Mon Apr 16 14:29:17 2012 +0300
@@ -1,332 +1,385 @@
-/*
- * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef _FIELD_H
-#define _FIELD_H
-
-#include "Common.h"
-#include "Log.h"
-
-#include <mysql.h>
-
-class Field
-{
-    friend class ResultSet;
-    friend class PreparedResultSet;
-
-    public:
-
-        bool GetBool() const // Wrapper, actually gets integer
-        {
-            return GetUInt8() == 1 ? true : false;
-        }
-
-        uint8 GetUInt8() const
-        {
-            if (!data.value)
-                return 0;
-
-            #ifdef TRINITY_DEBUG
-            if (!IsNumeric())
-            {
-                sLog->outSQLDriver("Error: GetUInt8() on non-numeric field.");
-                return 0;
-            }
-            #endif
-            if (data.raw)
-                return *reinterpret_cast<uint8*>(data.value);
-            return static_cast<uint8>(atol((char*)data.value));
-        }
-
-        int8 GetInt8() const
-        {
-            if (!data.value)
-                return 0;
-
-            #ifdef TRINITY_DEBUG
-            if (!IsNumeric())
-            {
-                sLog->outSQLDriver("Error: GeInt8() on non-numeric field.");
-                return 0;
-            }
-            #endif
-            if (data.raw)
-                return *reinterpret_cast<int8*>(data.value);
-            return static_cast<int8>(atol((char*)data.value));
-        }
-
-        uint16 GetUInt16() const
-        {
-            if (!data.value)
-                return 0;
-
-            #ifdef TRINITY_DEBUG
-            if (!IsNumeric())
-            {
-                sLog->outSQLDriver("Error: GetUInt16() on non-numeric field.");
-                return 0;
-            }
-            #endif
-            if (data.raw)
-                return *reinterpret_cast<uint16*>(data.value);
-            return static_cast<uint16>(atol((char*)data.value));
-        }
-
-        int16 GetInt16() const
-        {
-            if (!data.value)
-                return 0;
-
-            #ifdef TRINITY_DEBUG
-            if (!IsNumeric())
-            {
-                sLog->outSQLDriver("Error: GetInt16() on non-numeric field.");
-                return 0;
-            }
-            #endif
-            if (data.raw)
-                return *reinterpret_cast<int16*>(data.value);
-            return static_cast<int16>(atol((char*)data.value));
-        }
-
-        uint32 GetUInt32() const
-        {
-            if (!data.value)
-                return 0;
-
-            #ifdef TRINITY_DEBUG
-            if (!IsNumeric())
-            {
-                sLog->outSQLDriver("Error: GetUInt32() on non-numeric field.");
-                return 0;
-            }
-            #endif
-            if (data.raw)
-                return *reinterpret_cast<uint32*>(data.value);
-            return static_cast<uint32>(atol((char*)data.value));
-        }
-
-        int32 GetInt32() const
-        {
-            if (!data.value)
-                return 0;
-
-            #ifdef TRINITY_DEBUG
-            if (!IsNumeric())
-            {
-                sLog->outSQLDriver("Error: GetInt32() on non-numeric field.");
-                return 0;
-            }
-            #endif
-            if (data.raw)
-                return *reinterpret_cast<int32*>(data.value);
-            return static_cast<int32>(atol((char*)data.value));
-        }
-
-        uint64 GetUInt64() const
-        {
-            if (!data.value)
-                return 0;
-
-            #ifdef TRINITY_DEBUG
-            if (!IsNumeric())
-            {
-                sLog->outSQLDriver("Error: GetUInt64() on non-numeric field.");
-                return 0;
-            }
-            #endif
-            if (data.raw)
-                return *reinterpret_cast<uint64*>(data.value);
-            return static_cast<uint64>(atol((char*)data.value));
-        }
-
-        int64 GetInt64() const
-        {
-            if (!data.value)
-                return 0;
-
-            #ifdef TRINITY_DEBUG
-            if (!IsNumeric())
-            {
-                sLog->outSQLDriver("Error: GetInt64() on non-numeric field.");
-                return 0;
-            }
-            #endif
-            if (data.raw)
-                return *reinterpret_cast<int64*>(data.value);
-            return static_cast<int64>(strtol((char*)data.value, NULL, 10));
-        }
-
-        float GetFloat() const
-        {
-            if (!data.value)
-                return 0.0f;
-
-            #ifdef TRINITY_DEBUG
-            if (!IsNumeric())
-            {
-                sLog->outSQLDriver("Error: GetFloat() on non-numeric field.");
-                return 0.0f;
-            }
-            #endif
-            if (data.raw)
-                return *reinterpret_cast<float*>(data.value);
-            return static_cast<float>(atof((char*)data.value));
-        }
-
-        double GetDouble() const
-        {
-            if (!data.value)
-                return 0.0f;
-
-            #ifdef TRINITY_DEBUG
-            if (!IsNumeric())
-            {
-                sLog->outSQLDriver("Error: GetDouble() on non-numeric field.");
-                return 0.0f;
-            }
-            #endif
-            if (data.raw)
-                return *reinterpret_cast<double*>(data.value);
-            return static_cast<double>(atof((char*)data.value));
-        }
-
-        const char* GetCString() const
-        {
-            if (!data.value)
-                return NULL;
-
-            #ifdef TRINITY_DEBUG
-            if (IsNumeric())
-            {
-                sLog->outSQLDriver("Error: GetCString() on numeric field.");
-                return NULL;
-            }
-            #endif
-            return static_cast<const char*>(data.value);
-        }
-
-        std::string GetString() const
-        {
-            if (!data.value)
-                return "";
-
-            if (data.raw)
-            {
-                const char* string = GetCString();
-                if (!string)
-                    string = "";
-                return std::string(string, data.length);
-            }
-            return std::string((char*)data.value);
-        }
-
-    protected:
-        Field();
-        ~Field();
-
-        #if defined(__GNUC__)
-        #pragma pack(1)
-        #else
-        #pragma pack(push, 1)
-        #endif
-        struct
-        {
-            uint32 length;          // Length (prepared strings only)
-            void* value;            // Actual data in memory
-            enum_field_types type;  // Field type
-            bool raw;               // Raw bytes? (Prepared statement or ad hoc)
-         } data;
-        #if defined(__GNUC__)
-        #pragma pack()
-        #else
-        #pragma pack(pop)
-        #endif
-
-        void SetByteValue(const void* newValue, const size_t newSize, enum_field_types newType, uint32 length);
-        void SetStructuredValue(char* newValue, enum_field_types newType);
-
-        void CleanUp()
-        {
-            delete[] ((char*)data.value);
-            data.value = NULL;
-        }
-
-        static size_t SizeForType(MYSQL_FIELD* field)
-        {
-            switch (field->type)
-            {
-                case MYSQL_TYPE_NULL:
-                    return 0;
-                case MYSQL_TYPE_TINY:
-                    return 1;
-                case MYSQL_TYPE_YEAR:
-                case MYSQL_TYPE_SHORT:
-                    return 2;
-                case MYSQL_TYPE_INT24:
-                case MYSQL_TYPE_LONG:
-                case MYSQL_TYPE_FLOAT:
-                    return 4;
-                case MYSQL_TYPE_DOUBLE:
-                case MYSQL_TYPE_LONGLONG:
-                case MYSQL_TYPE_BIT:
-                    return 8;
-
-                case MYSQL_TYPE_TIMESTAMP:
-                case MYSQL_TYPE_DATE:
-                case MYSQL_TYPE_TIME:
-                case MYSQL_TYPE_DATETIME:
-                    return sizeof(MYSQL_TIME);
-
-                case MYSQL_TYPE_TINY_BLOB:
-                case MYSQL_TYPE_MEDIUM_BLOB:
-                case MYSQL_TYPE_LONG_BLOB:
-                case MYSQL_TYPE_BLOB:
-                case MYSQL_TYPE_STRING:
-                case MYSQL_TYPE_VAR_STRING:
-                    return field->max_length + 1;
-
-                case MYSQL_TYPE_DECIMAL:
-                case MYSQL_TYPE_NEWDECIMAL:
-                    return 64;
-
-                case MYSQL_TYPE_GEOMETRY:
-                /*
-                Following types are not sent over the wire:
-                MYSQL_TYPE_ENUM:
-                MYSQL_TYPE_SET:
-                */
-                default:
-                    sLog->outSQLDriver("SQL::SizeForType(): invalid field type %u", uint32(field->type));
-                    return 0;
-            }
-        }
-
-        bool IsNumeric() const
-        {
-            return (data.type == MYSQL_TYPE_TINY ||
-                    data.type == MYSQL_TYPE_SHORT ||
-                    data.type == MYSQL_TYPE_INT24 ||
-                    data.type == MYSQL_TYPE_LONG ||
-                    data.type == MYSQL_TYPE_FLOAT ||
-                    data.type == MYSQL_TYPE_DOUBLE ||
-                    data.type == MYSQL_TYPE_LONGLONG );
-        }
-};
-
-#endif
-
+/*
+ * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _FIELD_H
+#define _FIELD_H
+
+#include "Common.h"
+#include "Log.h"
+
+#include <mysql.h>
+
+class Field
+{
+    friend class ResultSet;
+    friend class PreparedResultSet;
+
+    public:
+
+        bool GetBool() const // Wrapper, actually gets integer
+        {
+            return GetUInt8() == 1 ? true : false;
+        }
+
+        uint8 GetUInt8() const
+        {
+            if (!data.value)
+                return 0;
+
+            #ifdef TRINITY_DEBUG
+            if (!IsType(MYSQL_TYPE_TINY))
+            {
+                sLog->outSQLDriver("Warning: GetUInt8() on non-tinyint field. Using type: %s.", FieldTypeToString(data.type));
+                return 0;
+            }
+            #endif
+
+            if (data.raw)
+                return *reinterpret_cast<uint8*>(data.value);
+            return static_cast<uint8>(atol((char*)data.value));
+        }
+
+        int8 GetInt8() const
+        {
+            if (!data.value)
+                return 0;
+
+            #ifdef TRINITY_DEBUG
+            if (!IsType(MYSQL_TYPE_TINY))
+            {
+                sLog->outSQLDriver("Warning: GetInt8() on non-tinyint field. Using type: %s.", FieldTypeToString(data.type));
+                return 0;
+            }
+            #endif
+
+            if (data.raw)
+                return *reinterpret_cast<int8*>(data.value);
+            return static_cast<int8>(atol((char*)data.value));
+        }
+
+        uint16 GetUInt16() const
+        {
+            if (!data.value)
+                return 0;
+
+            #ifdef TRINITY_DEBUG
+            if (!IsType(MYSQL_TYPE_SHORT) && !IsType(MYSQL_TYPE_YEAR))
+            {
+                sLog->outSQLDriver("Warning: GetUInt16() on non-smallint field. Using type: %s.", FieldTypeToString(data.type));
+                return 0;
+            }
+            #endif
+
+            if (data.raw)
+                return *reinterpret_cast<uint16*>(data.value);
+            return static_cast<uint16>(atol((char*)data.value));
+        }
+
+        int16 GetInt16() const
+        {
+            if (!data.value)
+                return 0;
+
+            #ifdef TRINITY_DEBUG
+            if (!IsType(MYSQL_TYPE_SHORT) && !IsType(MYSQL_TYPE_YEAR))
+            {
+                sLog->outSQLDriver("Warning: GetInt16() on non-smallint field. Using type: %s.", FieldTypeToString(data.type));
+                return 0;
+            }
+            #endif
+
+            if (data.raw)
+                return *reinterpret_cast<int16*>(data.value);
+            return static_cast<int16>(atol((char*)data.value));
+        }
+
+        uint32 GetUInt32() const
+        {
+            if (!data.value)
+                return 0;
+
+            #ifdef TRINITY_DEBUG
+            if (!IsType(MYSQL_TYPE_INT24) && !IsType(MYSQL_TYPE_LONG))
+            {
+                sLog->outSQLDriver("Warning: GetUInt32() on non-(medium)int field. Using type: %s.", FieldTypeToString(data.type));
+                return 0;
+            }
+            #endif
+
+            if (data.raw)
+                return *reinterpret_cast<uint32*>(data.value);
+            return static_cast<uint32>(atol((char*)data.value));
+        }
+
+        int32 GetInt32() const
+        {
+            if (!data.value)
+                return 0;
+
+            #ifdef TRINITY_DEBUG
+            if (!IsType(MYSQL_TYPE_INT24) && !IsType(MYSQL_TYPE_LONG))
+            {
+                sLog->outSQLDriver("Warning: GetInt32() on non-(medium)int field. Using type: %s.", FieldTypeToString(data.type));
+                return 0;
+            }
+            #endif
+
+            if (data.raw)
+                return *reinterpret_cast<int32*>(data.value);
+            return static_cast<int32>(atol((char*)data.value));
+        }
+
+        uint64 GetUInt64() const
+        {
+            if (!data.value)
+                return 0;
+
+            #ifdef TRINITY_DEBUG
+            if (!IsType(MYSQL_TYPE_LONGLONG) && !IsType(MYSQL_TYPE_BIT))
+            {
+                sLog->outSQLDriver("Warning: GetUInt64() on non-bigint field. Using type: %s.", FieldTypeToString(data.type));
+                return 0;
+            }
+            #endif
+
+            if (data.raw)
+                return *reinterpret_cast<uint64*>(data.value);
+            return static_cast<uint64>(atol((char*)data.value));
+        }
+
+        int64 GetInt64() const
+        {
+            if (!data.value)
+                return 0;
+
+            #ifdef TRINITY_DEBUG
+            if (!IsType(MYSQL_TYPE_LONGLONG) && !IsType(MYSQL_TYPE_BIT))
+            {
+                sLog->outSQLDriver("Warning: GetInt64() on non-bigint field. Using type: %s.", FieldTypeToString(data.type));
+                return 0;
+            }
+            #endif
+
+            if (data.raw)
+                return *reinterpret_cast<int64*>(data.value);
+            return static_cast<int64>(strtol((char*)data.value, NULL, 10));
+        }
+
+        float GetFloat() const
+        {
+            if (!data.value)
+                return 0.0f;
+
+            #ifdef TRINITY_DEBUG
+            if (!IsType(MYSQL_TYPE_FLOAT))
+            {
+                sLog->outSQLDriver("Warning: GetFloat() on non-float field. Using type: %s.", FieldTypeToString(data.type));
+                return 0.0f;
+            }
+            #endif
+
+            if (data.raw)
+                return *reinterpret_cast<float*>(data.value);
+            return static_cast<float>(atof((char*)data.value));
+        }
+
+        double GetDouble() const
+        {
+            if (!data.value)
+                return 0.0f;
+
+            #ifdef TRINITY_DEBUG
+            if (!IsType(MYSQL_TYPE_DOUBLE))
+            {
+                sLog->outSQLDriver("Warning: GetDouble() on non-double field. Using type: %s.", FieldTypeToString(data.type));
+                return 0.0f;
+            }
+            #endif
+
+            if (data.raw)
+                return *reinterpret_cast<double*>(data.value);
+            return static_cast<double>(atof((char*)data.value));
+        }
+
+        char const* GetCString() const
+        {
+            if (!data.value)
+                return NULL;
+
+            #ifdef TRINITY_DEBUG
+            if (IsNumeric())
+            {
+                sLog->outSQLDriver("Error: GetCString() on numeric field. Using type: %s.", FieldTypeToString(data.type));
+                return NULL;
+            }
+            #endif
+            return static_cast<char const*>(data.value);
+
+        }
+
+        std::string GetString() const
+        {
+            if (!data.value)
+                return "";
+
+            if (data.raw)
+            {
+                char const* string = GetCString();
+                if (!string)
+                    string = "";
+                return std::string(string, data.length);
+            }
+            return std::string((char*)data.value);
+        }
+
+    protected:
+        Field();
+        ~Field();
+
+        #if defined(__GNUC__)
+        #pragma pack(1)
+        #else
+        #pragma pack(push, 1)
+        #endif
+        struct
+        {
+            uint32 length;          // Length (prepared strings only)
+            void* value;            // Actual data in memory
+            enum_field_types type;  // Field type
+            bool raw;               // Raw bytes? (Prepared statement or ad hoc)
+         } data;
+        #if defined(__GNUC__)
+        #pragma pack()
+        #else
+        #pragma pack(pop)
+        #endif
+
+        void SetByteValue(void const* newValue, size_t const newSize, enum_field_types newType, uint32 length);
+        void SetStructuredValue(char* newValue, enum_field_types newType);
+
+        void CleanUp()
+        {
+            delete[] ((char*)data.value);
+            data.value = NULL;
+        }
+
+        static size_t SizeForType(MYSQL_FIELD* field)
+        {
+            switch (field->type)
+            {
+                case MYSQL_TYPE_NULL:
+                    return 0;
+                case MYSQL_TYPE_TINY:
+                    return 1;
+                case MYSQL_TYPE_YEAR:
+                case MYSQL_TYPE_SHORT:
+                    return 2;
+                case MYSQL_TYPE_INT24:
+                case MYSQL_TYPE_LONG:
+                case MYSQL_TYPE_FLOAT:
+                    return 4;
+                case MYSQL_TYPE_DOUBLE:
+                case MYSQL_TYPE_LONGLONG:
+                case MYSQL_TYPE_BIT:
+                    return 8;
+
+                case MYSQL_TYPE_TIMESTAMP:
+                case MYSQL_TYPE_DATE:
+                case MYSQL_TYPE_TIME:
+                case MYSQL_TYPE_DATETIME:
+                    return sizeof(MYSQL_TIME);
+
+                case MYSQL_TYPE_TINY_BLOB:
+                case MYSQL_TYPE_MEDIUM_BLOB:
+                case MYSQL_TYPE_LONG_BLOB:
+                case MYSQL_TYPE_BLOB:
+                case MYSQL_TYPE_STRING:
+                case MYSQL_TYPE_VAR_STRING:
+                    return field->max_length + 1;
+
+                case MYSQL_TYPE_DECIMAL:
+                case MYSQL_TYPE_NEWDECIMAL:
+                    return 64;
+
+                case MYSQL_TYPE_GEOMETRY:
+                /*
+                Following types are not sent over the wire:
+                MYSQL_TYPE_ENUM:
+                MYSQL_TYPE_SET:
+                */
+                default:
+                    sLog->outSQLDriver("SQL::SizeForType(): invalid field type %u", uint32(field->type));
+                    return 0;
+            }
+        }
+
+        bool IsType(enum_field_types type) const
+        {
+            return data.type == type;
+        }
+
+        bool IsNumeric() const
+        {
+            return (data.type == MYSQL_TYPE_TINY ||
+                    data.type == MYSQL_TYPE_SHORT ||
+                    data.type == MYSQL_TYPE_INT24 ||
+                    data.type == MYSQL_TYPE_LONG ||
+                    data.type == MYSQL_TYPE_FLOAT ||
+                    data.type == MYSQL_TYPE_DOUBLE ||
+                    data.type == MYSQL_TYPE_LONGLONG );
+        }
+
+    private:
+        #ifdef TRINITY_DEBUG
+        static char const* FieldTypeToString(enum_field_types type)
+        {
+            switch (type)
+            {
+                case MYSQL_TYPE_BIT:         return "BIT";
+                case MYSQL_TYPE_BLOB:        return "BLOB";
+                case MYSQL_TYPE_DATE:        return "DATE";
+                case MYSQL_TYPE_DATETIME:    return "DATETIME";
+                case MYSQL_TYPE_NEWDECIMAL:  return "NEWDECIMAL";
+                case MYSQL_TYPE_DECIMAL:     return "DECIMAL";
+                case MYSQL_TYPE_DOUBLE:      return "DOUBLE";
+                case MYSQL_TYPE_ENUM:        return "ENUM";
+                case MYSQL_TYPE_FLOAT:       return "FLOAT";
+                case MYSQL_TYPE_GEOMETRY:    return "GEOMETRY";
+                case MYSQL_TYPE_INT24:       return "INT24";
+                case MYSQL_TYPE_LONG:        return "LONG";
+                case MYSQL_TYPE_LONGLONG:    return "LONGLONG";
+                case MYSQL_TYPE_LONG_BLOB:   return "LONG_BLOB";
+                case MYSQL_TYPE_MEDIUM_BLOB: return "MEDIUM_BLOB";
+                case MYSQL_TYPE_NEWDATE:     return "NEWDATE";
+                case MYSQL_TYPE_NULL:        return "NULL";
+                case MYSQL_TYPE_SET:         return "SET";
+                case MYSQL_TYPE_SHORT:       return "SHORT";
+                case MYSQL_TYPE_STRING:      return "STRING";
+                case MYSQL_TYPE_TIME:        return "TIME";
+                case MYSQL_TYPE_TIMESTAMP:   return "TIMESTAMP";
+                case MYSQL_TYPE_TINY:        return "TINY";
+                case MYSQL_TYPE_TINY_BLOB:   return "TINY_BLOB";
+                case MYSQL_TYPE_VAR_STRING:  return "VAR_STRING";
+                case MYSQL_TYPE_YEAR:        return "YEAR";
+                default:                     return "-Unknown-";
+            }
+        }
+        #endif
+};
+
+#endif
+
diff -r b4c056460923 -r da13f4f7a26c src/server/shared/Database/Implementation/CharacterDatabase.cpp
--- a/src/server/shared/Database/Implementation/CharacterDatabase.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/shared/Database/Implementation/CharacterDatabase.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -27,13 +27,14 @@
     PREPARE_STATEMENT(CHAR_DEL_NONEXISTENT_GUILD_BANK_ITEM, "DELETE FROM guild_bank_item WHERE guildid = ? AND TabId = ? AND SlotId = ?", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_DEL_EXPIRED_BANS, "UPDATE character_banned SET active = 0 WHERE unbandate <= UNIX_TIMESTAMP() AND unbandate <> bandate", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_SEL_GUID_BY_NAME, "SELECT guid FROM characters WHERE name = ?", CONNECTION_BOTH);
-    PREPARE_STATEMENT(CHAR_SEL_CHECK_NAME, "SELECT 1 FROM characters WHERE name = ?", CONNECTION_ASYNC);
-    PREPARE_STATEMENT(CHAR_SEL_SUM_CHARS, "SELECT COUNT(guid) FROM characters WHERE account = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_SEL_CHECK_NAME, "SELECT 1 FROM characters WHERE name = ?", CONNECTION_BOTH);
+    PREPARE_STATEMENT(CHAR_SEL_CHECK_GUID, "SELECT 1 FROM characters WHERE guid = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_SUM_CHARS, "SELECT COUNT(guid) FROM characters WHERE account = ?", CONNECTION_BOTH);
     PREPARE_STATEMENT(CHAR_SEL_CHAR_CREATE_INFO, "SELECT level, race, class FROM characters WHERE account = ? LIMIT 0, ?", CONNECTION_ASYNC);
     PREPARE_STATEMENT(CHAR_INS_CHARACTER_BAN, "INSERT INTO character_banned VALUES (?, UNIX_TIMESTAMP(), UNIX_TIMESTAMP()+?, ?, ?, 1)", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_UPD_CHARACTER_BAN, "UPDATE character_banned SET active = 0 WHERE guid = ? AND active != 0", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_SEL_BANINFO, "SELECT FROM_UNIXTIME(bandate), unbandate-bandate, active, unbandate, banreason, bannedby FROM character_banned WHERE guid = ? ORDER BY bandate ASC", CONNECTION_SYNCH)
-    PREPARE_STATEMENT(CHAR_SEL_GUID_BY_NAME_FILTER, "SELECT guid, name FROM characters WHERE name LIKE CONCAT('%', ?, '%')", CONNECTION_SYNCH)
+    PREPARE_STATEMENT(CHAR_SEL_GUID_BY_NAME_FILTER, "SELECT guid, name FROM characters WHERE name LIKE CONCAT('%%', ?, '%%')", CONNECTION_SYNCH)
     PREPARE_STATEMENT(CHAR_SEL_BANINFO_LIST, "SELECT bandate, unbandate, bannedby, banreason FROM character_banned WHERE guid = ? ORDER BY unbandate", CONNECTION_SYNCH)
     PREPARE_STATEMENT(CHAR_SEL_BANNED_NAME, "SELECT characters.name FROM characters, character_banned WHERE character_banned.guid = ? AND character_banned.guid = characters.guid", CONNECTION_SYNCH)
     PREPARE_STATEMENT(CHAR_SEL_ENUM, "SELECT c.guid, c.name, c.race, c.class, c.gender, c.playerBytes, c.playerBytes2, c.level, c.zone, c.map, c.position_x, c.position_y, c.position_z, gm.guildid, c.playerFlags, c.at_login, cp.entry, cp.modelid, cp.level, c.equipmentCache, cb.guid FROM characters AS c LEFT JOIN character_pet AS cp ON c.guid = cp.owner AND cp.slot = ? LEFT JOIN guild_member AS gm ON c.guid = gm.guid LEFT JOIN character_banned AS cb ON c.guid = cb.guid AND cb.active = 1 WHERE c.account = ? ORDER BY c.guid", CONNECTION_ASYNC);
@@ -44,6 +45,12 @@
     PREPARE_STATEMENT(CHAR_SEL_PET_SLOT_BY_ID, "SELECT slot, entry FROM character_pet WHERE owner = ? AND id = ?", CONNECTION_ASYNC);
     PREPARE_STATEMENT(CHAR_SEL_FREE_NAME, "SELECT guid, name FROM characters WHERE guid = ? AND account = ? AND (at_login & ?) = ? AND NOT EXISTS (SELECT NULL FROM characters WHERE name = ?)", CONNECTION_ASYNC);
     PREPARE_STATEMENT(CHAR_SEL_GUID_RACE_ACC_BY_NAME, "SELECT guid, race, account FROM characters WHERE name = ?", CONNECTION_BOTH);
+    PREPARE_STATEMENT(CHAR_SEL_CHAR_RACE, "SELECT race FROM characters WHERE guid = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_CHAR_LEVEL, "SELECT level FROM characters WHERE guid = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_CHAR_ZONE, "SELECT zone FROM characters WHERE guid = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_CHARACTER_NAME_DATA, "SELECT race, class, gender FROM characters WHERE guid = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_CHAR_POSITION_XYZ, "SELECT map, position_x, position_y, position_z FROM characters WHERE guid = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_CHAR_POSITION, "SELECT position_x, position_y, position_z, orientation, map, taxi_path FROM characters WHERE guid = ?", CONNECTION_SYNCH);
     PREPARE_STATEMENT(CHAR_DEL_QUEST_STATUS_DAILY, "DELETE FROM character_queststatus_daily", CONNECTION_ASYNC);
     PREPARE_STATEMENT(CHAR_DEL_QUEST_STATUS_WEEKLY, "DELETE FROM character_queststatus_weekly", CONNECTION_ASYNC);
     PREPARE_STATEMENT(CHAR_DEL_QUEST_STATUS_SEASONAL, "DELETE FROM character_queststatus_seasonal WHERE event = ?", CONNECTION_ASYNC);
@@ -59,13 +66,13 @@
     "resettalents_time, trans_x, trans_y, trans_z, trans_o, transguid, extra_flags, stable_slots, at_login, zone, online, death_expire_time, taxi_path, instance_mode_mask, "
     "arenaPoints, totalHonorPoints, todayHonorPoints, yesterdayHonorPoints, totalKills, todayKills, yesterdayKills, chosenTitle, knownCurrencies, watchedFaction, drunk, "
     "health, power1, power2, power3, power4, power5, power6, power7, instance_id, speccount, activespec, exploredZones, equipmentCache, ammoId, knownTitles, actionBars, grantableLevels FROM characters WHERE guid = ?", CONNECTION_ASYNC)
-    PREPARE_STATEMENT(CHAR_SEL_GROUP_MEMBER, "SELECT guid FROM group_member WHERE memberGuid = ?", CONNECTION_ASYNC)
+    PREPARE_STATEMENT(CHAR_SEL_GROUP_MEMBER, "SELECT guid FROM group_member WHERE memberGuid = ?", CONNECTION_BOTH)
     PREPARE_STATEMENT(CHAR_SEL_CHARACTER_INSTANCE, "SELECT id, permanent, map, difficulty, resettime FROM character_instance LEFT JOIN instance ON instance = id WHERE guid = ?", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_SEL_CHARACTER_AURAS, "SELECT caster_guid, spell, effect_mask, recalculate_mask, stackcount, amount0, amount1, amount2, "
     "base_amount0, base_amount1, base_amount2, maxduration, remaintime, remaincharges FROM character_aura WHERE guid = ?", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_SEL_CHARACTER_SPELL, "SELECT spell, active, disabled FROM character_spell WHERE guid = ?", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_SEL_CHARACTER_QUESTSTATUS, "SELECT quest, status, explored, timer, mobcount1, mobcount2, mobcount3, mobcount4, "
-    "itemcount1, itemcount2, itemcount3, itemcount4, playercount FROM character_queststatus WHERE guid = ?", CONNECTION_ASYNC)
+    "itemcount1, itemcount2, itemcount3, itemcount4, playercount FROM character_queststatus WHERE guid = ? AND status <> 0", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_SEL_CHARACTER_DAILYQUESTSTATUS, "SELECT quest, time FROM character_queststatus_daily WHERE guid = ?", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_SEL_CHARACTER_WEEKLYQUESTSTATUS, "SELECT quest FROM character_queststatus_weekly WHERE guid = ?", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_SEL_CHARACTER_SEASONALQUESTSTATUS, "SELECT quest, event FROM character_queststatus_seasonal WHERE guid = ?", CONNECTION_ASYNC)
@@ -78,11 +85,12 @@
     PREPARE_STATEMENT(CHAR_SEL_CHARACTER_ACTIONS, "SELECT a.button, a.action, a.type FROM character_action as a, characters as c WHERE a.guid = c.guid AND a.spec = c.activespec AND a.guid = ? ORDER BY button", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_SEL_CHARACTER_MAILCOUNT, "SELECT COUNT(id) FROM mail WHERE receiver = ? AND (checked & 1) = 0 AND deliver_time <= ?", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_SEL_CHARACTER_MAILDATE, "SELECT MIN(deliver_time) FROM mail WHERE receiver = ? AND (checked & 1) = 0", CONNECTION_ASYNC)
+    PREPARE_STATEMENT(CHAR_SEL_MAIL_COUNT, "SELECT COUNT(*) FROM mail WHERE receiver = ?", CONNECTION_SYNCH);
     PREPARE_STATEMENT(CHAR_SEL_CHARACTER_SOCIALLIST, "SELECT friend, flags, note FROM character_social JOIN characters ON characters.guid = character_social.friend WHERE character_social.guid = ? AND deleteinfos_name IS NULL LIMIT 255", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_SEL_CHARACTER_HOMEBIND, "SELECT mapId, zoneId, posX, posY, posZ FROM character_homebind WHERE guid = ?", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_SEL_CHARACTER_SPELLCOOLDOWNS, "SELECT spell, item, time FROM character_spell_cooldown WHERE guid = ?", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_SEL_CHARACTER_DECLINEDNAMES, "SELECT genitive, dative, accusative, instrumental, prepositional FROM character_declinedname WHERE guid = ?", CONNECTION_ASYNC)
-    PREPARE_STATEMENT(CHAR_SEL_GUILD_MEMBER, "SELECT guildid, rank FROM guild_member WHERE guid = ?", CONNECTION_ASYNC)
+    PREPARE_STATEMENT(CHAR_SEL_GUILD_MEMBER, "SELECT guildid, rank FROM guild_member WHERE guid = ?", CONNECTION_BOTH)
     PREPARE_STATEMENT(CHAR_SEL_CHARACTER_ACHIEVEMENTS, "SELECT achievement, date FROM character_achievement WHERE guid = ?", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_SEL_CHARACTER_CRITERIAPROGRESS, "SELECT criteria, counter, date FROM character_achievement_progress WHERE guid = ?", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_SEL_CHARACTER_EQUIPMENTSETS, "SELECT setguid, setindex, name, iconname, item0, item1, item2, item3, item4, item5, item6, item7, item8, "
@@ -103,8 +111,10 @@
     PREPARE_STATEMENT(CHAR_SEL_AUCTIONS, "SELECT id, auctioneerguid, itemguid, itemEntry, itemowner, buyoutprice, time, buyguid, lastbid, startbid, deposit FROM auctionhouse ah INNER JOIN item_instance ii ON ii.guid = ah.itemguid", CONNECTION_SYNCH)
     PREPARE_STATEMENT(CHAR_INS_AUCTION, "INSERT INTO auctionhouse (id, auctioneerguid, itemguid, itemowner, buyoutprice, time, buyguid, lastbid, startbid, deposit) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_DEL_AUCTION, "DELETE FROM auctionhouse WHERE id = ?", CONNECTION_ASYNC)
+    PREPARE_STATEMENT(CHAR_SEL_AUCTION_BY_TIME, "SELECT id FROM auctionhouse WHERE time <= ? ORDER BY TIME ASC", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_UPD_AUCTION_BID, "UPDATE auctionhouse SET buyguid = ?, lastbid = ? WHERE id = ?", CONNECTION_ASYNC);
     PREPARE_STATEMENT(CHAR_INS_MAIL, "INSERT INTO mail(id, messageType, stationery, mailTemplateId, sender, receiver, subject, body, has_items, expire_time, deliver_time, money, cod, checked) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC)
-    PREPARE_STATEMENT(CHAR_DEL_MAIL, "DELETE FROM mail WHERE id = ?", CONNECTION_ASYNC)
+    PREPARE_STATEMENT(CHAR_DEL_MAIL_BY_ID, "DELETE FROM mail WHERE id = ?", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_INS_MAIL_ITEM, "INSERT INTO mail_items(mail_id, item_guid, receiver) VALUES (?, ?, ?)", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_DEL_MAIL_ITEM, "DELETE FROM mail_items WHERE item_guid = ?", CONNECTION_ASYNC);
     PREPARE_STATEMENT(CHAR_DEL_INVALID_MAIL_ITEM, "DELETE FROM mail_items WHERE item_guid = ?", CONNECTION_ASYNC);
@@ -122,17 +132,20 @@
     PREPARE_STATEMENT(CHAR_DEL_ITEM_BOP_TRADE, "DELETE FROM item_soulbound_trade_data WHERE itemGuid = ? LIMIT 1", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_INS_ITEM_BOP_TRADE, "INSERT INTO item_soulbound_trade_data VALUES (?, ?)", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_REP_INVENTORY_ITEM, "REPLACE INTO character_inventory (guid, bag, slot, item) VALUES (?, ?, ?, ?)", CONNECTION_ASYNC)
-    PREPARE_STATEMENT(CHAR_DEL_INVENTORY_ITEM, "DELETE FROM character_inventory WHERE item = ?", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_REP_ITEM_INSTANCE, "REPLACE INTO item_instance (itemEntry, owner_guid, creatorGuid, giftCreatorGuid, count, duration, charges, flags, enchantments, randomPropertyId, durability, playedTime, text, guid) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_UPD_ITEM_INSTANCE, "UPDATE item_instance SET itemEntry = ?, owner_guid = ?, creatorGuid = ?, giftCreatorGuid = ?, count = ?, duration = ?, charges = ?, flags = ?, enchantments = ?, randomPropertyId = ?, durability = ?, playedTime = ?, text = ? WHERE guid = ?", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_UPD_ITEM_INSTANCE_ON_LOAD, "UPDATE item_instance SET duration = ?, flags = ?, durability = ? WHERE guid = ?", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_DEL_ITEM_INSTANCE, "DELETE FROM item_instance WHERE guid = ?", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_UPD_GIFT_OWNER, "UPDATE character_gifts SET guid = ? WHERE item_guid = ?", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_DEL_GIFT, "DELETE FROM character_gifts WHERE item_guid = ?", CONNECTION_ASYNC)
+    PREPARE_STATEMENT(CHAR_SEL_CHARACTER_GIFT_BY_ITEM, "SELECT entry, flags FROM character_gifts WHERE item_guid = ?", CONNECTION_SYNCH);
     PREPARE_STATEMENT(CHAR_SEL_ACCOUNT_BY_NAME, "SELECT account FROM characters WHERE name = ?", CONNECTION_SYNCH)
+    PREPARE_STATEMENT(CHAR_SEL_ACCOUNT_BY_GUID, "SELECT account FROM characters WHERE guid = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_ACCOUNT_NAME_BY_GUID, "SELECT account, name FROM characters WHERE guid = ?", CONNECTION_SYNCH);
     PREPARE_STATEMENT(CHAR_DEL_ACCOUNT_INSTANCE_LOCK_TIMES, "DELETE FROM account_instance_times WHERE accountId = ?", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_INS_ACCOUNT_INSTANCE_LOCK_TIMES, "INSERT INTO account_instance_times (accountId, instanceId, releaseTime) VALUES (?, ?, ?)", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_SEL_CHARACTER_NAME_CLASS, "SELECT name, class FROM characters WHERE guid = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_CHARACTER_NAME, "SELECT name FROM characters WHERE guid = ?", CONNECTION_SYNCH);
     PREPARE_STATEMENT(CHAR_SEL_MATCH_MAKER_RATING, "SELECT matchMakerRating FROM character_arena_stats WHERE guid = ? AND slot = ?", CONNECTION_SYNCH);
     PREPARE_STATEMENT(CHAR_SEL_CHARACTER_COUNT, "SELECT account, COUNT(guid) FROM characters WHERE account = ? GROUP BY account", CONNECTION_ASYNC);
     PREPARE_STATEMENT(CHAR_UPD_NAME, "UPDATE characters set name = ?, at_login = at_login & ~ ? WHERE guid = ?", CONNECTION_ASYNC);
@@ -228,13 +241,12 @@
     PREPARE_STATEMENT(CHAR_DEL_EQUIP_SET, "DELETE FROM character_equipmentsets WHERE setguid=?", CONNECTION_ASYNC)
 
     // Auras
-    PREPARE_STATEMENT(CHAR_DEL_AURA, "DELETE FROM character_aura WHERE guid = ?", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_INS_AURA, "INSERT INTO character_aura (guid, caster_guid, item_guid, spell, effect_mask, recalculate_mask, stackcount, amount0, amount1, amount2, base_amount0, base_amount1, base_amount2, maxduration, remaintime, remaincharges) "
     "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC)
 
     // Account data
     PREPARE_STATEMENT(CHAR_SEL_ACCOUNT_DATA, "SELECT type, time, data FROM account_data WHERE accountId = ?", CONNECTION_SYNCH)
-    PREPARE_STATEMENT(CHAR_REP_ACCOUNT_DATA, "REPLACE INTO account_data(accountId, type, time, data) VALUES (?, ?, ?, ?)", CONNECTION_ASYNC)
+    PREPARE_STATEMENT(CHAR_REP_ACCOUNT_DATA, "REPLACE INTO account_data (accountId, type, time, data) VALUES (?, ?, ?, ?)", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_DEL_ACCOUNT_DATA, "DELETE FROM account_data WHERE accountId = ?", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_SEL_PLAYER_ACCOUNT_DATA, "SELECT type, time, data FROM character_account_data WHERE guid = ?", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_REP_PLAYER_ACCOUNT_DATA, "REPLACE INTO character_account_data(guid, type, time, data) VALUES (?, ?, ?, ?)", CONNECTION_ASYNC)
@@ -265,6 +277,13 @@
     PREPARE_STATEMENT(CHAR_SEL_PETITION_SIGNATURE, "SELECT playerguid FROM petition_sign WHERE petitionguid = ?", CONNECTION_SYNCH);
     PREPARE_STATEMENT(CHAR_DEL_ALL_PETITION_SIGNATURES, "DELETE FROM petition_sign WHERE playerguid = ?", CONNECTION_ASYNC);
     PREPARE_STATEMENT(CHAR_DEL_PETITION_SIGNATURE, "DELETE FROM petition_sign WHERE playerguid = ? AND type = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_SEL_PETITION_BY_OWNER, "SELECT petitionguid FROM petition WHERE ownerguid = ? AND type = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_PETITION_TYPE, "SELECT type FROM petition WHERE petitionguid = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_PETITION_SIGNATURES, "SELECT ownerguid, (SELECT COUNT(playerguid) FROM petition_sign WHERE petition_sign.petitionguid = ?) AS signs, type FROM petition WHERE petitionguid = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_PETITION_SIG_BY_ACCOUNT, "SELECT playerguid FROM petition_sign WHERE player_account = ? AND petitionguid = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_PETITION_OWNER_BY_GUID, "SELECT ownerguid FROM petition WHERE petitionguid = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_PETITION_SIG_BY_GUID, "SELECT ownerguid, petitionguid FROM petition_sign WHERE playerguid = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_PETITION_SIG_BY_GUID_TYPE, "SELECT ownerguid, petitionguid FROM petition_sign WHERE playerguid = ? AND type = ?", CONNECTION_SYNCH);
 
     // Arena teams
     PREPARE_STATEMENT(CHAR_SEL_CHARACTER_ARENAINFO, "SELECT arenaTeamId, weekGames, seasonGames, seasonWins, personalRating FROM arena_team_member WHERE guid = ?", CONNECTION_ASYNC)
@@ -318,7 +337,7 @@
     // GM Survey/subsurvey/lag report
     PREPARE_STATEMENT(CHAR_INS_GM_SURVEY, "INSERT INTO gm_surveys (guid, surveyId, mainSurvey, overallComment, createTime) VALUES (?, ?, ?, ?, UNIX_TIMESTAMP(NOW()))", CONNECTION_ASYNC)
     PREPARE_STATEMENT(CHAR_INS_GM_SUBSURVEY, "INSERT INTO gm_subsurveys (surveyId, subsurveyId, rank, comment) VALUES (?, ?, ?, ?)", CONNECTION_ASYNC)
-    PREPARE_STATEMENT(CHAR_INS_LAG_REPORT, "INSERT INTO lag_reports (guid, lagType, mapId, posX, posY, posZ) VALUES (?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC)
+    PREPARE_STATEMENT(CHAR_INS_LAG_REPORT, "INSERT INTO lag_reports (guid, lagType, mapId, posX, posY, posZ, latency, createTime) VALUES (?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC)
 
     //  For loading and deleting expired auctions at startup
     PREPARE_STATEMENT(CHAR_SEL_EXPIRED_AUCTIONS, "SELECT id, auctioneerguid, itemguid, itemEntry, itemowner, buyoutprice, time, buyguid, lastbid, startbid, deposit FROM auctionhouse ah INNER JOIN item_instance ii ON ii.guid = ah.itemguid WHERE ah.time <= ?", CONNECTION_SYNCH)
@@ -380,7 +399,7 @@
     PREPARE_STATEMENT(CHAR_UPD_CHAR_NAME_AT_LOGIN, "UPDATE characters set name = ?, at_login = at_login & ~ ? WHERE guid = ?", CONNECTION_ASYNC);
     PREPARE_STATEMENT(CHAR_UPD_WORLDSTATE, "UPDATE worldstates SET value = ? WHERE entry = ?", CONNECTION_ASYNC);
     PREPARE_STATEMENT(CHAR_INS_WORLDSTATE, "INSERT INTO worldstates (entry, value) VALUES (?, ?)", CONNECTION_ASYNC);
-    PREPARE_STATEMENT(CHAR_DEL_CHAR_INSTANCE, "DELETE FROM character_instance WHERE guid = ? AND instance = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_INSTANCE_BY_INSTANCE_GUID, "DELETE FROM character_instance WHERE guid = ? AND instance = ?", CONNECTION_ASYNC);
     PREPARE_STATEMENT(CHAR_UPD_CHAR_INSTANCE, "UPDATE character_instance SET instance = ?, permanent = ? WHERE guid = ? AND instance = ?", CONNECTION_ASYNC);
     PREPARE_STATEMENT(CHAR_INS_CHAR_INSTANCE, "INSERT INTO character_instance (guid, instance, permanent) VALUES (?, ?, ?)", CONNECTION_ASYNC);
     PREPARE_STATEMENT(CHAR_UPD_GENDER_PLAYERBYTES, "UPDATE characters SET gender = ?, playerBytes = ?, playerBytes2 = ? WHERE guid = ?", CONNECTION_ASYNC);
@@ -391,5 +410,145 @@
     PREPARE_STATEMENT(CHAR_DEL_CHARACTER_SOCIAL, "DELETE FROM character_social WHERE guid = ? AND friend = ?", CONNECTION_ASYNC);
     PREPARE_STATEMENT(CHAR_UPD_CHARACTER_SOCIAL_NOTE, "UPDATE character_social SET note = ? WHERE guid = ? AND friend = ?", CONNECTION_ASYNC);
     PREPARE_STATEMENT(CHAR_UPD_CHARACTER_POSITION, "UPDATE characters SET position_x = ?, position_y = ?, position_z = ?, orientation = ?, map = ?, zone = ?, trans_x = 0, trans_y = 0, trans_z = 0, transguid = 0, taxi_path = '' WHERE guid = ?", CONNECTION_ASYNC);
-
+    PREPARE_STATEMENT(CHAR_SEL_CHARACTER_AURA_FROZEN, "SELECT characters.name FROM characters LEFT JOIN character_aura ON (characters.guid = character_aura.guid) WHERE character_aura.spell = 9454", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_CHARACTER_ONLINE, "SELECT name, account, map, zone FROM characters WHERE online > 0", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_CHAR_DEL_INFO_BY_GUID, "SELECT guid, deleteInfos_Name, deleteInfos_Account, deleteDate FROM characters WHERE deleteDate IS NOT NULL AND guid = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_CHAR_DEL_INFO_BY_NAME, "SELECT guid, deleteInfos_Name, deleteInfos_Account, deleteDate FROM characters WHERE deleteDate IS NOT NULL AND deleteInfos_Name LIKE CONCAT('%%', ?, '%%')", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_CHAR_DEL_INFO, "SELECT guid, deleteInfos_Name, deleteInfos_Account, deleteDate FROM characters WHERE deleteDate IS NOT NULL", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_CHARS_BY_ACCOUNT_ID, "SELECT guid FROM characters WHERE account = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_CHAR_PINFO, "SELECT totaltime, level, money, account, race, class, map, zone FROM characters WHERE guid = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_PINFO_BANS, "SELECT unbandate, bandate = unbandate, bannedby, banreason FROM character_banned WHERE guid = ? AND active ORDER BY bandate ASC LIMIT 1", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_CHAR_HOMEBIND, "SELECT mapId, zoneId, posX, posY, posZ FROM character_homebind WHERE guid = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_CHAR_GUID_NAME_BY_ACC, "SELECT guid, name FROM characters WHERE account = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_POOL_QUEST_SAVE, "SELECT quest_id FROM pool_quest_save WHERE pool_id = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_CHARACTER_AT_LOGIN, "SELECT at_login FROM characters WHERE guid = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_CHAR_CLASS_LVL_AT_LOGIN, "SELECT class, level, at_login FROM characters WHERE guid = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_INSTANCE, "SELECT data, completedEncounters FROM instance WHERE map = ? AND id = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_PET_SPELL_LIST, "SELECT DISTINCT pet_spell.spell FROM pet_spell, character_pet WHERE character_pet.owner = ? AND character_pet.id = pet_spell.guid AND character_pet.id <> ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_CHAR_PET, "SELECT id FROM character_pet WHERE owner = ? AND id <> ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_CHAR_PETS, "SELECT id FROM character_pet WHERE owner = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_CHAR_COD_ITEM_MAIL, "SELECT id, messageType, mailTemplateId, sender, subject, body, money, has_items FROM mail WHERE receiver = ? AND has_items <> 0 AND cod <> 0", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_CHAR_SOCIAL, "SELECT DISTINCT guid FROM character_social WHERE friend = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_PET_AURA, "SELECT caster_guid, spell, effect_mask, recalculate_mask, stackcount, amount0, amount1, amount2, base_amount0, base_amount1, base_amount2, maxduration, remaintime, remaincharges FROM pet_aura WHERE guid = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_CHAR_OLD_CHARS, "SELECT guid, deleteInfos_Account FROM characters WHERE deleteDate IS NOT NULL AND deleteDate < ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_ARENA_TEAM_ID_BY_PLAYER_GUID, "SELECT arena_team_member.arenateamid FROM arena_team_member JOIN arena_team ON arena_team_member.arenateamid = arena_team.arenateamid WHERE guid = ? AND type = ? LIMIT 1", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_MAIL, "SELECT id, messageType, sender, receiver, subject, body, has_items, expire_time, deliver_time, money, cod, checked, stationery, mailTemplateId FROM mail WHERE receiver = ? ORDER BY id DESC", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_CHAR_PLAYERBYTES2, "SELECT playerBytes2 FROM characters WHERE guid = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_PET_SPELL, "SELECT spell, active FROM pet_spell WHERE guid = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_PET_SPELL_COOLDOWN, "SELECT spell, time FROM pet_spell_cooldown WHERE guid = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_PET_DECLINED_NAME, "SELECT genitive, dative, accusative, instrumental, prepositional FROM character_pet_declinedname WHERE owner = ? AND id = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_CHAR_GUID_BY_NAME, "SELECT characters.guid FROM characters WHERE characters.name = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_AURA_FROZEN, "DELETE FROM character_aura WHERE character_aura.spell = 9454 AND character_aura.guid = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_CHAR_INVENTORY_COUNT_ITEM, "SELECT COUNT(itemEntry) FROM character_inventory ci INNER JOIN item_instance ii ON ii.guid = ci.item WHERE itemEntry = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_MAIL_COUNT_ITEM, "SELECT COUNT(itemEntry) FROM mail_items mi INNER JOIN item_instance ii ON ii.guid = mi.item_guid WHERE itemEntry = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_AUCTIONHOUSE_COUNT_ITEM,"SELECT COUNT(itemEntry) FROM auctionhouse ah INNER JOIN item_instance ii ON ii.guid = ah.itemguid WHERE itemEntry = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_GUILD_BANK_COUNT_ITEM, "SELECT COUNT(itemEntry) FROM guild_bank_item gbi INNER JOIN item_instance ii ON ii.guid = gbi.item_guid WHERE itemEntry = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_CHAR_INVENTORY_ITEM_BY_ENTRY, "SELECT ci.item, cb.slot AS bag, ci.slot, ci.guid, c.account, c.name FROM characters c INNER JOIN character_inventory ci ON ci.guid = c.guid INNER JOIN item_instance ii ON ii.guid = ci.item LEFT JOIN character_inventory cb ON cb.item = ci.bag WHERE ii.itemEntry = ? LIMIT ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_MAIL_ITEMS_BY_ENTRY, "SELECT mi.item_guid, m.sender, m.receiver, cs.account, cs.name, cr.account, cr.name FROM mail m INNER JOIN mail_items mi ON mi.mail_id = m.id INNER JOIN item_instance ii ON ii.guid = mi.item_guid INNER JOIN characters cs ON cs.guid = m.sender INNER JOIN characters cr ON cr.guid = m.receiver WHERE ii.itemEntry = ? LIMIT ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_AUCTIONHOUSE_ITEM_BY_ENTRY, "SELECT  ah.itemguid, ah.itemowner, c.account, c.name FROM auctionhouse ah INNER JOIN characters c ON c.guid = ah.itemowner INNER JOIN item_instance ii ON ii.guid = ah.itemguid WHERE ii.itemEntry = ? LIMIT ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_GUILD_BANK_ITEM_BY_ENTRY, "SELECT gi.item_guid, gi.guildid, g.name FROM guild_bank_item gi INNER JOIN guild g ON g.guildid = gi.guildid INNER JOIN item_instance ii ON ii.guid = gi.item_guid WHERE ii.itemEntry = ? LIMIT ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_CHAR_PET_BY_ENTRY, "SELECT id, entry, owner, modelid, level, exp, Reactstate, slot, name, renamed, curhealth, curmana, curhappiness, abdata, savetime, CreatedBySpell, PetType FROM character_pet WHERE owner = ? AND id = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_CHAR_PET_BY_ENTRY_AND_SLOT_2, "SELECT id, entry, owner, modelid, level, exp, Reactstate, slot, name, renamed, curhealth, curmana, curhappiness, abdata, savetime, CreatedBySpell, PetType FROM character_pet WHERE owner = ? AND entry = ? AND (slot = ? OR slot > ?)", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_SEL_CHAR_PET_BY_SLOT, "SELECT id, entry, owner, modelid, level, exp, Reactstate, slot, name, renamed, curhealth, curmana, curhappiness, abdata, savetime, CreatedBySpell, PetType FROM character_pet WHERE owner = ? AND (slot = ? OR slot > ?) ", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_ACHIEVEMENT, "DELETE FROM character_achievement WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_ACHIEVEMENT_PROGRESS, "DELETE FROM character_achievement_progress WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_REPUTATION_BY_FACTION, "DELETE FROM character_reputation WHERE guid = ? AND faction = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_INS_CHAR_REPUTATION_BY_FACTION, "INSERT INTO character_reputation (guid, faction, standing, flags) VALUES (?, ?, ? , ?)", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_UPD_CHAR_ARENA_POINTS, "UPDATE characters SET arenaPoints = (arenaPoints + ?) WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_ITEM_REFUND_INSTANCE, "DELETE FROM item_refund_instance WHERE item_guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_INS_ITEM_REFUND_INSTANCE, "INSERT INTO item_refund_instance (item_guid, player_guid, paidMoney, paidExtendedCost) VALUES (?, ?, ?, ?)", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_GROUP, "DELETE FROM groups WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_GROUP_MEMBER_ALL, "DELETE FROM group_member WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_INS_CHAR_GIFT, "INSERT INTO character_gifts (guid, item_guid, entry, flags) VALUES (?, ?, ?, ?)", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_INSTANCE_BY_INSTANCE, "DELETE FROM instance WHERE id = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_INSTANCE_BY_INSTANCE, "DELETE FROM character_instance WHERE instance = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_INSTANCE_BY_MAP_DIFF, "DELETE FROM character_instance USING character_instance LEFT JOIN instance ON character_instance.instance = id WHERE map = ? and difficulty = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_GROUP_INSTANCE_BY_MAP_DIFF, "DELETE FROM group_instance USING group_instance LEFT JOIN instance ON group_instance.instance = id WHERE map = ? and difficulty = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_INSTANCE_BY_MAP_DIFF, "DELETE FROM instance WHERE map = ? and difficulty = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_MAIL_ITEM_BY_ID, "DELETE FROM mail_items WHERE mail_id = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_PET_DECLINEDNAME, "DELETE FROM character_pet_declinedname WHERE id = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_ADD_CHAR_PET_DECLINEDNAME, "INSERT INTO character_pet_declinedname (id, owner, genitive, dative, accusative, instrumental, prepositional) VALUES (?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_UPD_CHAR_PET_NAME, "UPDATE character_pet SET name = ?, renamed = 1 WHERE owner = ? AND id = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_INS_PETITION, "INSERT INTO petition (ownerguid, petitionguid, name, type) VALUES (?, ?, ?, ?)", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_PETITION_BY_GUID, "DELETE FROM petition WHERE petitionguid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_PETITION_SIGNATURE_BY_GUID, "DELETE FROM petition_sign WHERE petitionguid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_UDP_CHAR_PET_SLOT_BY_SLOT_EXCLUDE_ID, "UPDATE character_pet SET slot = ? WHERE owner = ? AND slot = ? AND id <> ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_UDP_CHAR_PET_SLOT_BY_SLOT, "UPDATE character_pet SET slot = ? WHERE owner = ? AND slot = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_UPD_CHAR_PET_SLOT_BY_ID, "UPDATE character_pet SET slot = ? WHERE owner = ? AND id = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_PET_BY_ID, "DELETE FROM character_pet WHERE id = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_PET_BY_SLOT, "DELETE FROM character_pet WHERE owner = ? AND (slot = ? OR slot > ?)", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_PET_AURAS, "DELETE FROM pet_aura WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_PET_SPELLS, "DELETE FROM pet_spell WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_PET_SPELL_COOLDOWNS, "DELETE FROM pet_spell_cooldown WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_INS_PET_SPELL_COOLDOWN, "INSERT INTO pet_spell_cooldown (guid, spell, time) VALUES (?, ?, ?)", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_PET_SPELL_BY_SPELL, "DELETE FROM pet_spell WHERE guid = ? and spell = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_INS_PET_SPELL, "INSERT INTO pet_spell (guid, spell, active) VALUES (?, ?, ?)", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_INS_PET_AURA, "INSERT INTO pet_aura (guid, caster_guid, spell, effect_mask, recalculate_mask, stackcount, amount0, amount1, amount2, base_amount0, base_amount1, base_amount2, maxduration, remaintime, remaincharges) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_DECLINED_NAME, "DELETE FROM character_declinedname WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_INS_CHAR_DECLINED_NAME, "INSERT INTO character_declinedname (guid, genitive, dative, accusative, instrumental, prepositional) VALUES (?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_UPD_FACTION_OR_RACE, "UPDATE characters SET name = ?, race = ?, at_login = at_login & ~ ? WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_SKILL_LANGUAGES, "DELETE FROM character_skills WHERE skill IN (98, 113, 759, 111, 313, 109, 115, 315, 673, 137) AND guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_INS_CHAR_SKILL_LANGUAGE, "INSERT INTO `character_skills` (guid, skill, value, max) VALUES (?, ?, 300, 300)", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_UPD_CHAR_TAXI_PATH, "UPDATE characters SET taxi_path = '' WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_UPD_CHAR_TAXIMASK, "UPDATE characters SET taximask = ? WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_QUESTSTATUS, "DELETE FROM character_queststatus WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_SOCIAL_BY_GUID, "DELETE FROM character_social WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_SOCIAL_BY_FRIEND, "DELETE FROM character_social WHERE friend = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_ACHIEVEMENT_BY_ACHIEVEMENT, "DELETE FROM character_achievement WHERE achievement = ? AND guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_UPD_CHAR_ACHIEVEMENT, "UPDATE character_achievement SET achievement = ? where achievement = ? AND guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_UPD_CHAR_INVENTORY_FACTION_CHANGE, "UPDATE item_instance ii, character_inventory ci SET ii.itemEntry = ? WHERE ii.itemEntry = ? AND ci.guid = ? AND ci.item = ii.guid", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_SPELL_BY_SPELL, "DELETE FROM character_spell WHERE spell = ? AND guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_UPD_CHAR_SPELL_FACTION_CHANGE, "UPDATE character_spell SET spell = ? where spell = ? AND guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_REP_BY_FACTION, "DELETE FROM character_reputation WHERE faction = ? AND guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_UPD_CHAR_REP_FACTION_CHANGE, "UPDATE character_reputation SET faction = ? where faction = ? AND guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_SPELL_COOLDOWN, "DELETE FROM character_spell_cooldown WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHARACTER, "DELETE FROM characters WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_ACTION, "DELETE FROM character_action WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_AURA, "DELETE FROM character_aura WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_GIFT, "DELETE FROM character_gifts WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_INSTANCE, "DELETE FROM character_instance WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_INVENTORY, "DELETE FROM character_inventory WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_QUESTSTATUS_REWARDED, "DELETE FROM character_queststatus_rewarded WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_REPUTATION, "DELETE FROM character_reputation WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_SPELL, "DELETE FROM character_spell WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_MAIL, "DELETE FROM mail WHERE receiver = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_MAIL_ITEMS, "DELETE FROM mail_items WHERE receiver = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_PET_BY_OWNER, "DELETE FROM character_pet WHERE owner = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_PET_DECLINEDNAME_BY_OWNER, "DELETE FROM character_pet_declinedname WHERE owner = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_ACHIEVEMENTS, "DELETE FROM character_achievement WHERE guid = ? AND achievement NOT BETWEEN '456' AND '467' AND achievement NOT BETWEEN '1400' AND '1427' AND achievement NOT IN(1463, 3117, 3259)", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_EQUIPMENTSETS, "DELETE FROM character_equipmentsets WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_GUILD_EVENTLOG_BY_PLAYER, "DELETE FROM guild_eventlog WHERE PlayerGuid1 = ? OR PlayerGuid2 = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_GUILD_BANK_EVENTLOG_BY_PLAYER, "DELETE FROM guild_bank_eventlog WHERE PlayerGuid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_GLYPHS, "DELETE FROM character_glyphs WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_QUESTSTATUS_DAILY, "DELETE FROM character_queststatus_daily WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_TALENT, "DELETE FROM character_talent WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_SKILLS, "DELETE FROM character_skills WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_UDP_CHAR_HONOR_POINTS, "UPDATE characters SET totalHonorPoints = ? WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_UDP_CHAR_ARENA_POINTS, "UPDATE characters SET arenaPoints = ? WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_UDP_CHAR_MONEY, "UPDATE characters SET money = ? WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_INS_CHAR_ACTION, "INSERT INTO character_action (guid, spec, button, action, type) VALUES (?, ?, ?, ?, ?)", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_UPD_CHAR_ACTION, "UPDATE character_action SET action = ?, type = ? WHERE guid = ? AND button = ? AND spec = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_ACTION_BY_BUTTON_SPEC, "DELETE FROM character_action WHERE guid = ? and button = ? and spec = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_INVENTORY_BY_ITEM, "DELETE FROM character_inventory WHERE item = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_INVENTORY_BY_BAG_SLOT, "DELETE FROM character_inventory WHERE bag = ? AND slot = ? AND guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_UPD_MAIL, "UPDATE mail SET has_items = ?, expire_time = ?, deliver_time = ?, money = ?, cod = ?, checked = ? WHERE id = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_REP_CHAR_QUESTSTATUS, "REPLACE INTO character_queststatus (guid, quest, status, explored, timer, mobcount1, mobcount2, mobcount3, mobcount4, itemcount1, itemcount2, itemcount3, itemcount4, playercount) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_QUESTSTATUS_BY_QUEST, "DELETE FROM character_queststatus WHERE guid = ? AND quest = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_INS_CHAR_QUESTSTATUS, "INSERT IGNORE INTO character_queststatus_rewarded (guid, quest) VALUES (?, ?)", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_QUESTSTATUS_REWARDED_BY_QUEST, "DELETE FROM character_queststatus_rewarded WHERE guid = ? AND quest = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_SKILL_BY_SKILL, "DELETE FROM character_skills WHERE guid = ? AND skill = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_INS_CHAR_SKILLS, "INSERT INTO character_skills (guid, skill, value, max) VALUES (?, ?, ?, ?)", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_UDP_CHAR_SKILLS, "UPDATE character_skills SET value = ?, max = ? WHERE guid = ? AND skill = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_INS_CHAR_SPELL, "INSERT INTO character_spell (guid, spell, active, disabled) VALUES (?, ?, ?, ?)", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_STATS, "DELETE FROM character_stats WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_INS_CHAR_STATS, "INSERT INTO character_stats (guid, maxhealth, maxpower1, maxpower2, maxpower3, maxpower4, maxpower5, maxpower6, maxpower7, strength, agility, stamina, intellect, spirit, armor, resHoly, resFire, resNature, resFrost, resShadow, resArcane, blockPct, dodgePct, parryPct, critPct, rangedCritPct, spellCritPct, attackPower, rangedAttackPower, spellPower, resilience) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_PETITION_BY_OWNER, "DELETE FROM petition WHERE ownerguid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_PETITION_SIGNATURE_BY_OWNER, "DELETE FROM petition_sign WHERE ownerguid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_PETITION_BY_OWNER_AND_TYPE, "DELETE FROM petition WHERE ownerguid = ? AND type = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_PETITION_SIGNATURE_BY_OWNER_AND_TYPE, "DELETE FROM petition_sign WHERE ownerguid = ? AND type = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_INS_CHAR_GLYPHS, "INSERT INTO character_glyphs VALUES(?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_TALENT_BY_SPELL_SPEC, "DELETE FROM character_talent WHERE guid = ? and spell = ? and spec = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_INS_CHAR_TALENT, "INSERT INTO character_talent (guid, spell, spec) VALUES (?, ?, ?)", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_DEL_CHAR_ACTION_EXCEPT_SPEC, "DELETE FROM character_action WHERE spec<>? AND guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(CHAR_SEL_CHAR_PET_BY_ENTRY_AND_SLOT, "SELECT id, entry, owner, modelid, level, exp, Reactstate, slot, name, renamed, curhealth, curmana, curhappiness, abdata, savetime, CreatedBySpell, PetType FROM character_pet WHERE owner = ? AND slot = ?", CONNECTION_SYNCH);
 }
diff -r b4c056460923 -r da13f4f7a26c src/server/shared/Database/Implementation/CharacterDatabase.h
--- a/src/server/shared/Database/Implementation/CharacterDatabase.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/shared/Database/Implementation/CharacterDatabase.h	Mon Apr 16 14:29:17 2012 +0300
@@ -48,6 +48,7 @@
     CHAR_DEL_EXPIRED_BANS,
     CHAR_SEL_GUID_BY_NAME,
     CHAR_SEL_CHECK_NAME,
+    CHAR_SEL_CHECK_GUID,
     CHAR_SEL_SUM_CHARS,
     CHAR_SEL_CHAR_CREATE_INFO,
     CHAR_INS_CHARACTER_BAN,
@@ -64,6 +65,12 @@
     CHAR_SEL_PET_SLOT_BY_ID,
     CHAR_SEL_FREE_NAME,
     CHAR_SEL_GUID_RACE_ACC_BY_NAME,
+    CHAR_SEL_CHAR_RACE,
+    CHAR_SEL_CHAR_LEVEL,
+    CHAR_SEL_CHAR_ZONE,
+    CHAR_SEL_CHARACTER_NAME_DATA,
+    CHAR_SEL_CHAR_POSITION_XYZ,
+    CHAR_SEL_CHAR_POSITION,
     CHAR_DEL_QUEST_STATUS_DAILY,
     CHAR_DEL_QUEST_STATUS_WEEKLY,
     CHAR_DEL_QUEST_STATUS_SEASONAL,
@@ -91,6 +98,7 @@
     CHAR_SEL_CHARACTER_ACTIONS_SPEC,
     CHAR_SEL_CHARACTER_MAILCOUNT,
     CHAR_SEL_CHARACTER_MAILDATE,
+    CHAR_SEL_MAIL_COUNT,
     CHAR_SEL_CHARACTER_SOCIALLIST,
     CHAR_SEL_CHARACTER_HOMEBIND,
     CHAR_SEL_CHARACTER_SPELLCOOLDOWNS,
@@ -112,9 +120,11 @@
     CHAR_SEL_AUCTION_ITEMS,
     CHAR_INS_AUCTION,
     CHAR_DEL_AUCTION,
+    CHAR_SEL_AUCTION_BY_TIME,
+    CHAR_UPD_AUCTION_BID,
     CHAR_SEL_AUCTIONS,
     CHAR_INS_MAIL,
-    CHAR_DEL_MAIL,
+    CHAR_DEL_MAIL_BY_ID,
     CHAR_INS_MAIL_ITEM,
     CHAR_DEL_MAIL_ITEM,
     CHAR_DEL_INVALID_MAIL_ITEM,
@@ -131,21 +141,24 @@
     CHAR_DEL_ITEM_BOP_TRADE,
     CHAR_INS_ITEM_BOP_TRADE,
     CHAR_REP_INVENTORY_ITEM,
-    CHAR_DEL_INVENTORY_ITEM,
     CHAR_REP_ITEM_INSTANCE,
     CHAR_UPD_ITEM_INSTANCE,
     CHAR_UPD_ITEM_INSTANCE_ON_LOAD,
     CHAR_DEL_ITEM_INSTANCE,
     CHAR_UPD_GIFT_OWNER,
     CHAR_DEL_GIFT,
+    CHAR_SEL_CHARACTER_GIFT_BY_ITEM,
     CHAR_SEL_ACCOUNT_BY_NAME,
+    CHAR_SEL_ACCOUNT_BY_GUID,
     CHAR_DEL_ACCOUNT_INSTANCE_LOCK_TIMES,
     CHAR_INS_ACCOUNT_INSTANCE_LOCK_TIMES,
     CHAR_SEL_CHARACTER_NAME_CLASS,
+    CHAR_SEL_CHARACTER_NAME,
     CHAR_SEL_MATCH_MAKER_RATING,
     CHAR_SEL_CHARACTER_COUNT,
     CHAR_UPD_NAME,
     CHAR_DEL_DECLINED_NAME,
+    CHAR_SEL_ACCOUNT_NAME_BY_GUID,
 
     CHAR_INS_GUILD,
     CHAR_DEL_GUILD,
@@ -220,7 +233,6 @@
     CHAR_INS_EQUIP_SET,
     CHAR_DEL_EQUIP_SET,
 
-    CHAR_DEL_AURA,
     CHAR_INS_AURA,
 
     CHAR_SEL_ACCOUNT_DATA,
@@ -261,6 +273,13 @@
     CHAR_SEL_PETITION_SIGNATURE,
     CHAR_DEL_ALL_PETITION_SIGNATURES,
     CHAR_DEL_PETITION_SIGNATURE,
+    CHAR_SEL_PETITION_BY_OWNER,
+    CHAR_SEL_PETITION_TYPE,
+    CHAR_SEL_PETITION_SIGNATURES,
+    CHAR_SEL_PETITION_SIG_BY_ACCOUNT,
+    CHAR_SEL_PETITION_OWNER_BY_GUID,
+    CHAR_SEL_PETITION_SIG_BY_GUID,
+    CHAR_SEL_PETITION_SIG_BY_GUID_TYPE,
 
     CHAR_INS_PLAYER_BGDATA,
     CHAR_DEL_PLAYER_BGDATA,
@@ -337,7 +356,7 @@
     CHAR_UPD_CHAR_NAME_AT_LOGIN,
     CHAR_UPD_WORLDSTATE,
     CHAR_INS_WORLDSTATE,
-    CHAR_DEL_CHAR_INSTANCE,
+    CHAR_DEL_CHAR_INSTANCE_BY_INSTANCE_GUID,
     CHAR_UPD_CHAR_INSTANCE,
     CHAR_INS_CHAR_INSTANCE,
     CHAR_UPD_GENDER_PLAYERBYTES,
@@ -352,6 +371,150 @@
     CHAR_INS_LFG_DATA,
     CHAR_DEL_LFG_DATA,
 
+    CHAR_SEL_CHARACTER_AURA_FROZEN,
+    CHAR_SEL_CHARACTER_ONLINE,
+
+    CHAR_SEL_CHAR_DEL_INFO_BY_GUID,
+    CHAR_SEL_CHAR_DEL_INFO_BY_NAME,
+    CHAR_SEL_CHAR_DEL_INFO,
+
+    CHAR_SEL_CHARS_BY_ACCOUNT_ID,
+    CHAR_SEL_CHAR_PINFO,
+    CHAR_SEL_PINFO_BANS,
+    CHAR_SEL_CHAR_HOMEBIND,
+    CHAR_SEL_CHAR_GUID_NAME_BY_ACC,
+    CHAR_SEL_POOL_QUEST_SAVE,
+    CHAR_SEL_CHARACTER_AT_LOGIN,
+    CHAR_SEL_CHAR_CLASS_LVL_AT_LOGIN,
+    CHAR_SEL_INSTANCE,
+    CHAR_SEL_PET_SPELL_LIST,
+    CHAR_SEL_CHAR_PET,
+    CHAR_SEL_CHAR_PETS,
+    CHAR_SEL_CHAR_COD_ITEM_MAIL,
+    CHAR_SEL_CHAR_SOCIAL,
+    CHAR_SEL_PET_AURA,
+    CHAR_SEL_CHAR_OLD_CHARS,
+    CHAR_SEL_ARENA_TEAM_ID_BY_PLAYER_GUID,
+    CHAR_SEL_MAIL,
+    CHAR_SEL_CHAR_PLAYERBYTES2,
+    CHAR_SEL_PET_SPELL,
+    CHAR_SEL_PET_SPELL_COOLDOWN,
+    CHAR_SEL_PET_DECLINED_NAME,
+    CHAR_SEL_CHAR_GUID_BY_NAME,
+    CHAR_DEL_CHAR_AURA_FROZEN,
+    CHAR_SEL_CHAR_INVENTORY_COUNT_ITEM,
+    CHAR_SEL_MAIL_COUNT_ITEM,
+    CHAR_SEL_AUCTIONHOUSE_COUNT_ITEM,
+    CHAR_SEL_GUILD_BANK_COUNT_ITEM,
+    CHAR_SEL_CHAR_INVENTORY_ITEM_BY_ENTRY,
+    CHAR_SEL_MAIL_ITEMS_BY_ENTRY,
+    CHAR_SEL_AUCTIONHOUSE_ITEM_BY_ENTRY,
+    CHAR_SEL_GUILD_BANK_ITEM_BY_ENTRY,
+    CHAR_SEL_CHAR_PET_BY_ENTRY,
+    CHAR_SEL_CHAR_PET_BY_ENTRY_AND_SLOT_2,
+    CHAR_SEL_CHAR_PET_BY_SLOT,
+    CHAR_DEL_CHAR_ACHIEVEMENT,
+    CHAR_DEL_CHAR_ACHIEVEMENT_PROGRESS,
+    CHAR_DEL_CHAR_REPUTATION_BY_FACTION,
+    CHAR_INS_CHAR_REPUTATION_BY_FACTION,
+    CHAR_UPD_CHAR_ARENA_POINTS,
+    CHAR_DEL_ITEM_REFUND_INSTANCE,
+    CHAR_INS_ITEM_REFUND_INSTANCE,
+    CHAR_DEL_GROUP,
+    CHAR_DEL_GROUP_MEMBER_ALL,
+    CHAR_INS_CHAR_GIFT,
+    CHAR_DEL_INSTANCE_BY_INSTANCE,
+    CHAR_DEL_CHAR_INSTANCE_BY_INSTANCE,
+    CHAR_DEL_CHAR_INSTANCE_BY_MAP_DIFF,
+    CHAR_DEL_GROUP_INSTANCE_BY_MAP_DIFF,
+    CHAR_DEL_INSTANCE_BY_MAP_DIFF,
+    CHAR_DEL_MAIL_ITEM_BY_ID,
+    CHAR_DEL_CHAR_PET_DECLINEDNAME,
+    CHAR_ADD_CHAR_PET_DECLINEDNAME,
+    CHAR_UPD_CHAR_PET_NAME,
+    CHAR_INS_PETITION,
+    CHAR_DEL_PETITION_BY_GUID,
+    CHAR_DEL_PETITION_SIGNATURE_BY_GUID,
+    CHAR_UDP_CHAR_PET_SLOT_BY_SLOT_EXCLUDE_ID,
+    CHAR_UDP_CHAR_PET_SLOT_BY_SLOT,
+    CHAR_UPD_CHAR_PET_SLOT_BY_ID,
+    CHAR_DEL_CHAR_PET_BY_ID,
+    CHAR_DEL_CHAR_PET_BY_SLOT,
+    CHAR_DEL_PET_AURAS,
+    CHAR_DEL_PET_SPELLS,
+    CHAR_DEL_PET_SPELL_COOLDOWNS,
+    CHAR_INS_PET_SPELL_COOLDOWN,
+    CHAR_DEL_PET_SPELL_BY_SPELL,
+    CHAR_INS_PET_SPELL,
+    CHAR_INS_PET_AURA,
+    CHAR_DEL_CHAR_DECLINED_NAME,
+    CHAR_INS_CHAR_DECLINED_NAME,
+    CHAR_UPD_FACTION_OR_RACE,
+    CHAR_DEL_CHAR_SKILL_LANGUAGES,
+    CHAR_INS_CHAR_SKILL_LANGUAGE,
+    CHAR_UPD_CHAR_TAXI_PATH,
+    CHAR_UPD_CHAR_TAXIMASK,
+    CHAR_DEL_CHAR_QUESTSTATUS,
+    CHAR_DEL_CHAR_SOCIAL_BY_GUID,
+    CHAR_DEL_CHAR_SOCIAL_BY_FRIEND,
+    CHAR_DEL_CHAR_ACHIEVEMENT_BY_ACHIEVEMENT,
+    CHAR_UPD_CHAR_ACHIEVEMENT,
+    CHAR_UPD_CHAR_INVENTORY_FACTION_CHANGE,
+    CHAR_DEL_CHAR_SPELL_BY_SPELL,
+    CHAR_UPD_CHAR_SPELL_FACTION_CHANGE,
+    CHAR_DEL_CHAR_REP_BY_FACTION,
+    CHAR_UPD_CHAR_REP_FACTION_CHANGE,
+    CHAR_DEL_CHAR_SPELL_COOLDOWN,
+    CHAR_DEL_CHARACTER,
+    CHAR_DEL_CHAR_ACTION,
+    CHAR_DEL_CHAR_AURA,
+    CHAR_DEL_CHAR_GIFT,
+    CHAR_DEL_CHAR_INSTANCE,
+    CHAR_DEL_CHAR_INVENTORY,
+    CHAR_DEL_CHAR_QUESTSTATUS_REWARDED,
+    CHAR_DEL_CHAR_REPUTATION,
+    CHAR_DEL_CHAR_SPELL,
+    CHAR_DEL_MAIL,
+    CHAR_DEL_MAIL_ITEMS,
+    CHAR_DEL_CHAR_PET_BY_OWNER,
+    CHAR_DEL_CHAR_PET_DECLINEDNAME_BY_OWNER,
+    CHAR_DEL_CHAR_ACHIEVEMENTS,
+    CHAR_DEL_CHAR_EQUIPMENTSETS,
+    CHAR_DEL_GUILD_EVENTLOG_BY_PLAYER,
+    CHAR_DEL_GUILD_BANK_EVENTLOG_BY_PLAYER,
+    CHAR_DEL_CHAR_GLYPHS,
+    CHAR_DEL_CHAR_QUESTSTATUS_DAILY,
+    CHAR_DEL_CHAR_TALENT,
+    CHAR_DEL_CHAR_SKILLS,
+    CHAR_UDP_CHAR_HONOR_POINTS,
+    CHAR_UDP_CHAR_ARENA_POINTS,
+    CHAR_UDP_CHAR_MONEY,
+    CHAR_INS_CHAR_ACTION,
+    CHAR_UPD_CHAR_ACTION,
+    CHAR_DEL_CHAR_ACTION_BY_BUTTON_SPEC,
+    CHAR_DEL_CHAR_INVENTORY_BY_ITEM,
+    CHAR_DEL_CHAR_INVENTORY_BY_BAG_SLOT,
+    CHAR_UPD_MAIL,
+    CHAR_REP_CHAR_QUESTSTATUS,
+    CHAR_DEL_CHAR_QUESTSTATUS_BY_QUEST,
+    CHAR_INS_CHAR_QUESTSTATUS,
+    CHAR_DEL_CHAR_QUESTSTATUS_REWARDED_BY_QUEST,
+    CHAR_DEL_CHAR_SKILL_BY_SKILL,
+    CHAR_INS_CHAR_SKILLS,
+    CHAR_UDP_CHAR_SKILLS,
+    CHAR_INS_CHAR_SPELL,
+    CHAR_DEL_CHAR_STATS,
+    CHAR_INS_CHAR_STATS,
+    CHAR_DEL_PETITION_BY_OWNER,
+    CHAR_DEL_PETITION_SIGNATURE_BY_OWNER,
+    CHAR_DEL_PETITION_BY_OWNER_AND_TYPE,
+    CHAR_DEL_PETITION_SIGNATURE_BY_OWNER_AND_TYPE,
+    CHAR_INS_CHAR_GLYPHS,
+    CHAR_DEL_CHAR_TALENT_BY_SPELL_SPEC,
+    CHAR_INS_CHAR_TALENT,
+    CHAR_DEL_CHAR_ACTION_EXCEPT_SPEC,
+    CHAR_SEL_CHAR_PET_BY_ENTRY_AND_SLOT,
+
     MAX_CHARACTERDATABASE_STATEMENTS,
 };
 
diff -r b4c056460923 -r da13f4f7a26c src/server/shared/Database/Implementation/LoginDatabase.cpp
--- a/src/server/shared/Database/Implementation/LoginDatabase.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/shared/Database/Implementation/LoginDatabase.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -22,12 +22,16 @@
     if (!m_reconnecting)
         m_stmts.resize(MAX_LOGINDATABASE_STATEMENTS);
 
-    PREPARE_STATEMENT(LOGIN_SEL_REALMLIST, "SELECT id, name, address, port, icon, color, timezone, allowedSecurityLevel, population, gamebuild FROM realmlist WHERE color <> 3 ORDER BY name", CONNECTION_SYNCH)
+    PREPARE_STATEMENT(LOGIN_SEL_REALMLIST, "SELECT id, name, address, port, icon, flag, timezone, allowedSecurityLevel, population, gamebuild FROM realmlist WHERE flag <> 3 ORDER BY name", CONNECTION_SYNCH)
     PREPARE_STATEMENT(LOGIN_DEL_EXPIRED_IP_BANS, "DELETE FROM ip_banned WHERE unbandate<>bandate AND unbandate<=UNIX_TIMESTAMP()", CONNECTION_ASYNC)
     PREPARE_STATEMENT(LOGIN_UPD_EXPIRED_ACCOUNT_BANS, "UPDATE account_banned SET active = 0 WHERE active = 1 AND unbandate<>bandate AND unbandate<=UNIX_TIMESTAMP()", CONNECTION_ASYNC)
     PREPARE_STATEMENT(LOGIN_SEL_IP_BANNED, "SELECT * FROM ip_banned WHERE ip = ?", CONNECTION_SYNCH)
     PREPARE_STATEMENT(LOGIN_INS_IP_AUTO_BANNED, "INSERT INTO ip_banned VALUES (?, UNIX_TIMESTAMP(), UNIX_TIMESTAMP()+?, 'Trinity realmd', 'Failed login autoban')", CONNECTION_ASYNC)
+    PREPARE_STATEMENT(LOGIN_SEL_IP_BANNED_ALL, "SELECT ip, bandate, unbandate, bannedby, banreason FROM ip_banned WHERE (bandate = unbandate OR unbandate > UNIX_TIMESTAMP()) ORDER BY unbandate", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(LOGIN_SEL_IP_BANNED_BY_IP, "SELECT ip, bandate, unbandate, bannedby, banreason FROM ip_banned WHERE (bandate = unbandate OR unbandate > UNIX_TIMESTAMP()) AND ip LIKE CONCAT('%%', ?, '%%') ORDER BY unbandate", CONNECTION_SYNCH);
     PREPARE_STATEMENT(LOGIN_SEL_ACCOUNT_BANNED, "SELECT bandate, unbandate FROM account_banned WHERE id = ? AND active = 1", CONNECTION_SYNCH)
+    PREPARE_STATEMENT(LOGIN_SEL_ACCOUNT_BANNED_ALL, "SELECT account.id, username FROM account, account_banned WHERE account.id = account_banned.id AND active = 1 GROUP BY account.id", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(LOGIN_SEL_ACCOUNT_BANNED_BY_USERNAME, "SELECT account.id, username FROM account, account_banned WHERE account.id = account_banned.id AND active = 1 AND username LIKE CONCAT('%%', ?, '%%') GROUP BY account.id", CONNECTION_SYNCH);
     PREPARE_STATEMENT(LOGIN_INS_ACCOUNT_AUTO_BANNED, "INSERT INTO account_banned VALUES (?, UNIX_TIMESTAMP(), UNIX_TIMESTAMP()+?, 'Trinity realmd', 'Failed login autoban', 1)", CONNECTION_ASYNC)
     PREPARE_STATEMENT(LOGIN_SEL_SESSIONKEY, "SELECT a.sessionkey, a.id, aa.gmlevel  FROM account a LEFT JOIN account_access aa ON (a.id = aa.id) WHERE username = ?", CONNECTION_SYNCH)
     PREPARE_STATEMENT(LOGIN_UPD_VS, "UPDATE account SET v = ?, s = ? WHERE username = ?", CONNECTION_ASYNC)
@@ -36,19 +40,22 @@
     PREPARE_STATEMENT(LOGIN_UPD_FAILEDLOGINS, "UPDATE account SET failed_logins = failed_logins + 1 WHERE username = ?", CONNECTION_ASYNC)
     PREPARE_STATEMENT(LOGIN_SEL_FAILEDLOGINS, "SELECT id, failed_logins FROM account WHERE username = ?", CONNECTION_SYNCH)
     PREPARE_STATEMENT(LOGIN_SEL_ACCOUNT_ID_BY_NAME, "SELECT id FROM account WHERE username = ?", CONNECTION_SYNCH)
+    PREPARE_STATEMENT(LOGIN_SEL_ACCOUNT_LIST_BY_NAME, "SELECT id, username FROM account WHERE username = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(LOGIN_SEL_ACCOUNT_INFO_BY_NAME, "SELECT id, sessionkey, last_ip, locked, v, s, expansion, mutetime, locale, recruiter, os FROM account WHERE username = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(LOGIN_SEL_ACCOUNT_LIST_BY_EMAIL, "SELECT id, username FROM account WHERE email = ?", CONNECTION_SYNCH);
     PREPARE_STATEMENT(LOGIN_SEL_NUM_CHARS_ON_REALM, "SELECT numchars FROM realmcharacters WHERE realmid = ? AND acctid= ?", CONNECTION_SYNCH)
-    PREPARE_STATEMENT(LOGIN_SEL_ACCOUNT_BY_IP, "SELECT id FROM account WHERE last_ip = ?", CONNECTION_SYNCH)
+    PREPARE_STATEMENT(LOGIN_SEL_ACCOUNT_BY_IP, "SELECT id, username FROM account WHERE last_ip = ?", CONNECTION_SYNCH)
+    PREPARE_STATEMENT(LOGIN_SEL_ACCOUNT_BY_ID, "SELECT 1 FROM account WHERE id = ?", CONNECTION_SYNCH);
     PREPARE_STATEMENT(LOGIN_INS_IP_BANNED, "INSERT INTO ip_banned VALUES (?, UNIX_TIMESTAMP(), UNIX_TIMESTAMP()+?, ?, ?)", CONNECTION_ASYNC)
     PREPARE_STATEMENT(LOGIN_DEL_IP_NOT_BANNED, "DELETE FROM ip_banned WHERE ip = ?", CONNECTION_ASYNC)
     PREPARE_STATEMENT(LOGIN_INS_ACCOUNT_BANNED, "INSERT INTO account_banned VALUES (?, UNIX_TIMESTAMP(), UNIX_TIMESTAMP()+?, ?, ?, 1)", CONNECTION_ASYNC)
     PREPARE_STATEMENT(LOGIN_UPD_ACCOUNT_NOT_BANNED, "UPDATE account_banned SET active = 0 WHERE id = ? AND active != 0", CONNECTION_ASYNC)
-    PREPARE_STATEMENT(LOGIN_DEL_REALM_CHARACTERS, "DELETE FROM realmcharacters WHERE acctid = ? AND realmid = ?", CONNECTION_ASYNC)
+    PREPARE_STATEMENT(LOGIN_DEL_REALM_CHARACTERS_BY_REALM, "DELETE FROM realmcharacters WHERE acctid = ? AND realmid = ?", CONNECTION_ASYNC)
+    PREPARE_STATEMENT(LOGIN_DEL_REALM_CHARACTERS, "DELETE FROM realmcharacters WHERE acctid = ?", CONNECTION_ASYNC);
     PREPARE_STATEMENT(LOGIN_INS_REALM_CHARACTERS, "INSERT INTO realmcharacters (numchars, acctid, realmid) VALUES (?, ?, ?)", CONNECTION_ASYNC)
     PREPARE_STATEMENT(LOGIN_SEL_SUM_REALM_CHARACTERS, "SELECT SUM(numchars) FROM realmcharacters WHERE acctid = ?", CONNECTION_ASYNC);
     PREPARE_STATEMENT(LOGIN_INS_ACCOUNT, "INSERT INTO account(username, sha_pass_hash, joindate) VALUES(?, ?, NOW())", CONNECTION_ASYNC);
     PREPARE_STATEMENT(LOGIN_INS_REALM_CHARACTERS_INIT, "INSERT INTO realmcharacters (realmid, acctid, numchars) SELECT realmlist.id, account.id, 0 FROM realmlist, account LEFT JOIN realmcharacters ON acctid=account.id WHERE acctid IS NULL", CONNECTION_ASYNC);
-    PREPARE_STATEMENT(LOGIN_DEL_OLD_BANS, "DELETE FROM ip_banned WHERE unbandate <= UNIX_TIMESTAMP() AND unbandate<>bandate", CONNECTION_ASYNC);
-    PREPARE_STATEMENT(LOGIN_DEL_OLD_IP_BANS, "DELETE FROM ip_banned WHERE unbandate <= UNIX_TIMESTAMP() AND unbandate<>bandate", CONNECTION_ASYNC);
     PREPARE_STATEMENT(LOGIN_SET_ACCOUNT_PREMIUM, "UPDATE account_premium SET active = 0 WHERE unsetdate<=UNIX_TIMESTAMP() AND unsetdate<>setdate", CONNECTION_ASYNC);
     PREPARE_STATEMENT(LOGIN_UPD_EXPANSION, "UPDATE account SET expansion = ? WHERE id = ?", CONNECTION_ASYNC);
     PREPARE_STATEMENT(LOGIN_UPD_ACCOUNT_LOCK, "UPDATE account SET locked = ? WHERE id = ?", CONNECTION_ASYNC);
@@ -63,4 +70,22 @@
     PREPARE_STATEMENT(LOGIN_DEL_ACCOUNT_ACCESS, "DELETE FROM account_access WHERE id = ?", CONNECTION_ASYNC);
     PREPARE_STATEMENT(LOGIN_DEL_ACCOUNT_ACCESS_BY_REALM, "DELETE FROM account_access WHERE id = ? AND (RealmID = ? OR RealmID = -1)", CONNECTION_ASYNC);
     PREPARE_STATEMENT(LOGIN_INS_ACCOUNT_ACCESS, "INSERT INTO account_access (id,gmlevel,RealmID) VALUES (?, ?, ?)", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(LOGIN_GET_ACCOUNT_ID_BY_USERNAME, "SELECT id FROM account WHERE username = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(LOGIN_GET_ACCOUNT_ACCESS_GMLEVEL, "SELECT gmlevel FROM account_access WHERE id = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(LOGIN_GET_GMLEVEL_BY_REALMID, "SELECT gmlevel FROM account_access WHERE id = ? AND (RealmID = ? OR RealmID = -1)", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(LOGIN_GET_USERNAME_BY_ID, "SELECT username FROM account WHERE id = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(LOGIN_SEL_CHECK_PASSWORD, "SELECT 1 FROM account WHERE id = ? AND sha_pass_hash = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(LOGIN_SEL_CHECK_PASSWORD_BY_NAME, "SELECT 1 FROM account WHERE username = ? AND sha_pass_hash = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(LOGIN_SEL_PINFO, "SELECT a.username, aa.gmlevel, a.email, a.last_ip, DATE_FORMAT(a.last_login, '%Y-%m-%d %T'), a.mutetime FROM account a LEFT JOIN account_access aa ON (a.id = aa.id AND (aa.RealmID = ? OR aa.RealmID = -1)) WHERE a.id = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(LOGIN_SEL_PINFO_BANS, "SELECT unbandate, bandate = unbandate, bannedby, banreason FROM account_banned WHERE id = ? AND active ORDER BY bandate ASC LIMIT 1", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(LOGIN_SEL_GM_ACCOUNTS, "SELECT a.username, aa.gmlevel FROM account a, account_access aa WHERE a.id=aa.id AND aa.gmlevel >= ? AND (aa.realmid = -1 OR aa.realmid = ?)", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(LOGIN_SEL_ACCOUNT_INFO, "SELECT a.username, a.last_ip, aa.gmlevel, a.expansion FROM account a LEFT JOIN account_access aa ON (a.id = aa.id) WHERE a.id = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(LOGIN_SEL_ACCOUNT_ACCESS_GMLEVEL_TEST, "SELECT 1 FROM account_access WHERE id = ? AND gmlevel > ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(LOGIN_SEL_ACCOUNT_ACCESS, "SELECT a.id, aa.gmlevel, aa.RealmID FROM account a LEFT JOIN account_access aa ON (a.id = aa.id) WHERE a.username = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(LOGIN_SEL_ACCOUNT_RECRUITER, "SELECT 1 FROM account WHERE recruiter = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(LOGIN_SEL_BANS, "SELECT 1 FROM account_banned WHERE id = ? AND active = 1 UNION SELECT 1 FROM ip_banned WHERE ip = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(LOGIN_SEL_ACCOUNT_WHOIS, "SELECT username, email, last_ip FROM account WHERE id = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(LOGIN_SEL_REALMLIST_SECURITY_LEVEL, "SELECT allowedSecurityLevel from realmlist WHERE id = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(LOGIN_DEL_ACCOUNT, "DELETE FROM account WHERE id = ?", CONNECTION_ASYNC);
+
 }
diff -r b4c056460923 -r da13f4f7a26c src/server/shared/Database/Implementation/LoginDatabase.h
--- a/src/server/shared/Database/Implementation/LoginDatabase.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/shared/Database/Implementation/LoginDatabase.h	Mon Apr 16 14:29:17 2012 +0300
@@ -48,6 +48,8 @@
     LOGIN_SEL_IP_BANNED,
     LOGIN_INS_IP_AUTO_BANNED,
     LOGIN_SEL_ACCOUNT_BANNED,
+    LOGIN_SEL_ACCOUNT_BANNED_ALL,
+    LOGIN_SEL_ACCOUNT_BANNED_BY_USERNAME,
     LOGIN_INS_ACCOUNT_AUTO_BANNED,
     LOGIN_SEL_SESSIONKEY,
     LOGIN_UPD_VS,
@@ -56,19 +58,24 @@
     LOGIN_UPD_FAILEDLOGINS,
     LOGIN_SEL_FAILEDLOGINS,
     LOGIN_SEL_ACCOUNT_ID_BY_NAME,
+    LOGIN_SEL_ACCOUNT_LIST_BY_NAME,
+    LOGIN_SEL_ACCOUNT_INFO_BY_NAME,
+    LOGIN_SEL_ACCOUNT_LIST_BY_EMAIL,
     LOGIN_SEL_NUM_CHARS_ON_REALM,
     LOGIN_SEL_ACCOUNT_BY_IP,
     LOGIN_INS_IP_BANNED,
     LOGIN_DEL_IP_NOT_BANNED,
+    LOGIN_SEL_IP_BANNED_ALL,
+    LOGIN_SEL_IP_BANNED_BY_IP,
+    LOGIN_SEL_ACCOUNT_BY_ID,
     LOGIN_INS_ACCOUNT_BANNED,
     LOGIN_UPD_ACCOUNT_NOT_BANNED,
+    LOGIN_DEL_REALM_CHARACTERS_BY_REALM,
     LOGIN_DEL_REALM_CHARACTERS,
     LOGIN_INS_REALM_CHARACTERS,
     LOGIN_SEL_SUM_REALM_CHARACTERS,
     LOGIN_INS_ACCOUNT,
     LOGIN_INS_REALM_CHARACTERS_INIT,
-    LOGIN_DEL_OLD_BANS,
-    LOGIN_DEL_OLD_IP_BANS,
     LOGIN_UPD_EXPANSION,
     LOGIN_UPD_ACCOUNT_LOCK,
     LOGIN_INS_LOG,
@@ -82,6 +89,23 @@
     LOGIN_DEL_ACCOUNT_ACCESS,
     LOGIN_DEL_ACCOUNT_ACCESS_BY_REALM,
     LOGIN_INS_ACCOUNT_ACCESS,
+    LOGIN_GET_ACCOUNT_ID_BY_USERNAME,
+    LOGIN_GET_ACCOUNT_ACCESS_GMLEVEL,
+    LOGIN_GET_GMLEVEL_BY_REALMID,
+    LOGIN_GET_USERNAME_BY_ID,
+    LOGIN_SEL_CHECK_PASSWORD,
+    LOGIN_SEL_CHECK_PASSWORD_BY_NAME,
+    LOGIN_SEL_PINFO,
+    LOGIN_SEL_PINFO_BANS,
+    LOGIN_SEL_GM_ACCOUNTS,
+    LOGIN_SEL_ACCOUNT_INFO,
+    LOGIN_SEL_ACCOUNT_ACCESS_GMLEVEL_TEST,
+    LOGIN_SEL_ACCOUNT_ACCESS,
+    LOGIN_SEL_ACCOUNT_RECRUITER,
+    LOGIN_SEL_BANS,
+    LOGIN_SEL_ACCOUNT_WHOIS,
+    LOGIN_SEL_REALMLIST_SECURITY_LEVEL,
+    LOGIN_DEL_ACCOUNT,
     LOGIN_SET_ACCOUNT_PREMIUM,
 
     MAX_LOGINDATABASE_STATEMENTS,
diff -r b4c056460923 -r da13f4f7a26c src/server/shared/Database/Implementation/WorldDatabase.cpp
--- a/src/server/shared/Database/Implementation/WorldDatabase.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/shared/Database/Implementation/WorldDatabase.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -36,6 +36,7 @@
     PREPARE_STATEMENT(WORLD_DEL_GAME_TELE, "DELETE FROM game_tele WHERE name = ?", CONNECTION_ASYNC);
     PREPARE_STATEMENT(WORLD_INS_NPC_VENODR, "INSERT INTO npc_vendor (entry, item, maxcount, incrtime, extendedcost) VALUES(?, ?, ?, ?, ?)", CONNECTION_ASYNC);
     PREPARE_STATEMENT(WORLD_DEL_NPC_VENDOR, "DELETE FROM npc_vendor WHERE entry = ? AND item = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(WORLD_SEL_NPC_VENDOR_REF, "SELECT item, maxcount, incrtime, ExtendedCost FROM npc_vendor WHERE entry = ? ORDER BY slot ASC", CONNECTION_SYNCH);
     PREPARE_STATEMENT(WORLD_UPD_CREATURE_MOVEMENT_TYPE, "UPDATE creature SET MovementType = ? WHERE guid = ?", CONNECTION_ASYNC);
     PREPARE_STATEMENT(WORLD_UPD_CREATURE_FACTION, "UPDATE creature_template SET faction_A = ?, faction_H = ? WHERE entry = ?", CONNECTION_ASYNC);
     PREPARE_STATEMENT(WORLD_UPD_CREATURE_NPCFLAG, "UPDATE creature_template SET npcflag = ? WHERE entry = ?", CONNECTION_ASYNC);
@@ -48,10 +49,23 @@
     PREPARE_STATEMENT(WORLD_UPD_WAYPOINT_DATA_POINT, "UPDATE waypoint_data SET point = point - 1 WHERE id = ? AND point > ?", CONNECTION_ASYNC);
     PREPARE_STATEMENT(WORLD_UPD_WAYPOINT_DATA_POSITION, "UPDATE waypoint_data SET position_x = ?, position_y = ?, position_z = ? where id = ? AND point = ?", CONNECTION_ASYNC);
     PREPARE_STATEMENT(WORLD_UPD_WAYPOINT_DATA_WPGUID, "UPDATE waypoint_data SET wpguid = ? WHERE id = ? and point = ?", CONNECTION_ASYNC);
-    PREPARE_STATEMENT(WORLD_UPD_ALL_WAYPOINT_DATA_WPGUID, "UPDATE waypoint_data SET wpguid = 0", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(WORLD_SEL_WAYPOINT_DATA_MAX_ID, "SELECT MAX(id) FROM waypoint_data", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(WORLD_SEL_WAYPOINT_DATA_MAX_POINT, "SELECT MAX(point) FROM waypoint_data WHERE id = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(WORLD_SEL_WAYPOINT_DATA_BY_ID, "SELECT point, position_x, position_y, position_z, orientation, move_flag, delay, action, action_chance FROM waypoint_data WHERE id = ? ORDER BY point", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(WORLD_SEL_WAYPOINT_DATA_POS_BY_ID, "SELECT point, position_x, position_y, position_z FROM waypoint_data WHERE id = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(WORLD_SEL_WAYPOINT_DATA_POS_FIRST_BY_ID, "SELECT position_x, position_y, position_z FROM waypoint_data WHERE point = 1 AND id = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(WORLD_SEL_WAYPOINT_DATA_POS_LAST_BY_ID, "SELECT position_x, position_y, position_z, orientation FROM waypoint_data WHERE id = ? ORDER BY point DESC LIMIT 1", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(WORLD_SEL_WAYPOINT_DATA_BY_WPGUID, "SELECT id, point FROM waypoint_data WHERE wpguid = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(WORLD_SEL_WAYPOINT_DATA_ALL_BY_WPGUID, "SELECT id, point, delay, move_flag, action, action_chance FROM waypoint_data WHERE wpguid = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(WORLD_UPD_WAYPOINT_DATA_ALL_WPGUID, "UPDATE waypoint_data SET wpguid = 0", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(WORLD_SEL_WAYPOINT_DATA_BY_POS, "SELECT id, point FROM waypoint_data WHERE (abs(position_x - ?) <= ?) and (abs(position_y - ?) <= ?) and (abs(position_z - ?) <= ?)", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(WORLD_SEL_WAYPOINT_DATA_WPGUID_BY_ID, "SELECT wpguid FROM waypoint_data WHERE id = ? and wpguid <> 0", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(WOLRD_SEL_WAYPOINT_DATA_ACTION, "SELECT DISTINCT action FROM waypoint_data", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(WORLD_SEL_WAYPOINT_SCRIPTS_MAX_ID, "SELECT MAX(guid) FROM waypoint_scripts", CONNECTION_SYNCH);
     PREPARE_STATEMENT(WORLD_INS_CREATURE_ADDON, "INSERT INTO creature_addon(guid, path_id) VALUES (?, ?)", CONNECTION_ASYNC);
     PREPARE_STATEMENT(WORLD_UPD_CREATURE_ADDON_PATH, "UPDATE creature_addon SET path_id = ? WHERE guid = ?", CONNECTION_ASYNC);
     PREPARE_STATEMENT(WORLD_DEL_CREATURE_ADDON, "DELETE FROM creature_addon WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(WORLD_SEL_CREATURE_ADDON_BY_GUID, "SELECT guid FROM creature_addon WHERE guid = ?", CONNECTION_SYNCH);
     PREPARE_STATEMENT(WORLD_INS_WAYPOINT_SCRIPT, "INSERT INTO waypoint_scripts (guid) VALUES (?)", CONNECTION_ASYNC);
     PREPARE_STATEMENT(WORLD_DEL_WAYPOINT_SCRIPT, "DELETE FROM waypoint_scripts WHERE guid = ?", CONNECTION_ASYNC);
     PREPARE_STATEMENT(WORLD_UPD_WAYPOINT_SCRIPT_ID, "UPDATE waypoint_scripts SET id = ? WHERE guid = ?", CONNECTION_ASYNC);
@@ -59,7 +73,19 @@
     PREPARE_STATEMENT(WORLD_UPD_WAYPOINT_SCRIPT_Y, "UPDATE waypoint_scripts SET y = ? WHERE guid = ?", CONNECTION_ASYNC);
     PREPARE_STATEMENT(WORLD_UPD_WAYPOINT_SCRIPT_Z, "UPDATE waypoint_scripts SET z = ? WHERE guid = ?", CONNECTION_ASYNC);
     PREPARE_STATEMENT(WORLD_UPD_WAYPOINT_SCRIPT_O, "UPDATE waypoint_scripts SET o = ? WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(WORLD_SEL_WAYPOINT_SCRIPT_ID_BY_GUID, "SELECT id FROM waypoint_scripts WHERE guid = ?", CONNECTION_SYNCH);
     PREPARE_STATEMENT(WORLD_DEL_CREATURE, "DELETE FROM creature WHERE guid = ?", CONNECTION_ASYNC);
     PREPARE_STATEMENT(WORLD_INS_CREATURE_TRANSPORT, "INSERT INTO creature_transport (guid, npc_entry, transport_entry,  TransOffsetX, TransOffsetY, TransOffsetZ, TransOffsetO) values (?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC);
     PREPARE_STATEMENT(WORLD_UPD_CREATURE_TRANSPORT_EMOTE, "UPDATE creature_transport SET emote = ? WHERE transport_entry = ? AND guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(WORLD_SEL_COMMANDS, "SELECT name, security, help FROM command", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(WORLD_SEL_CREATURE_TEMPLATE, "SELECT difficulty_entry_1, difficulty_entry_2, difficulty_entry_3, KillCredit1, KillCredit2, modelid1, modelid2, modelid3, modelid4, name, subname, IconName, gossip_menu_id, minlevel, maxlevel, exp, faction_A, faction_H, npcflag, speed_walk, speed_run, scale, rank, mindmg, maxdmg, dmgschool, attackpower, dmg_multiplier, baseattacktime, rangeattacktime, unit_class, unit_flags, dynamicflags, family, trainer_type, trainer_spell, trainer_class, trainer_race, minrangedmg, maxrangedmg, rangedattackpower, type, type_flags, lootid, pickpocketloot, skinloot, resistance1, resistance2, resistance3, resistance4, resistance5, resistance6, spell1, spell2, spell3, spell4, spell5, spell6, spell7, spell8, PetSpellDataId, VehicleId, mingold, maxgold, AIName, MovementType, InhabitType, HoverHeight, Health_mod, Mana_mod, Armor_mod, RacialLeader, questItem1, questItem2, questItem3, questItem4, questItem5, questItem6, movementId, RegenHealth, equipment_id, mechanic_immune_mask, flags_extra, ScriptName FROM creature_template WHERE entry = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(WORLD_SEL_WAYPOINT_SCRIPT_BY_ID, "SELECT guid, delay, command, datalong, datalong2, dataint, x, y, z, o FROM waypoint_scripts WHERE id = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(WORLD_SEL_IP2NATION_COUNTRY, "SELECT c.country FROM ip2nationCountries c, ip2nation i WHERE i.ip < ? AND c.code = i.country ORDER BY i.ip DESC LIMIT 0,1", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(WORLD_SEL_ITEM_TEMPLATE_BY_NAME, "SELECT entry FROM item_template WHERE name = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(WORLD_SEL_CREATURE_BY_ID, "SELECT guid FROM creature WHERE id = ?", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(WORLD_SEL_GAMEOBJECT_NEAREST, "SELECT guid, id, position_x, position_y, position_z, map, (POW(position_x - ?, 2) + POW(position_y - ?, 2) + POW(position_z - ?, 2)) AS order_ FROM gameobject WHERE map = ? AND (POW(position_x - ?, 2) + POW(position_y - ?, 2) + POW(position_z - ?, 2)) <= ? ORDER BY order_", CONNECTION_SYNCH);
+    PREPARE_STATEMENT(WORLD_INS_CREATURE, "INSERT INTO creature (guid, id , map, spawnMask, phaseMask, modelid, equipment_id, position_x, position_y, position_z, orientation, spawntimesecs, spawndist, currentwaypoint, curhealth, curmana, MovementType, npcflag, unit_flags, dynamicflags) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(WORLD_DEL_GAME_EVENT_CREATURE, "DELETE FROM game_event_creature WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(WORLD_DEL_GAME_EVENT_MODEL_EQUIP, "DELETE FROM game_event_model_equip WHERE guid = ?", CONNECTION_ASYNC);
+    PREPARE_STATEMENT(WORLD_INS_GAMEOBJECT, "INSERT INTO gameobject (guid, id, map, spawnMask, phaseMask, position_x, position_y, position_z, orientation, rotation0, rotation1, rotation2, rotation3, spawntimesecs, animprogress, state) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC);
 }
diff -r b4c056460923 -r da13f4f7a26c src/server/shared/Database/Implementation/WorldDatabase.h
--- a/src/server/shared/Database/Implementation/WorldDatabase.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/shared/Database/Implementation/WorldDatabase.h	Mon Apr 16 14:29:17 2012 +0300
@@ -56,6 +56,7 @@
     WORLD_DEL_GAME_TELE,
     WORLD_INS_NPC_VENODR,
     WORLD_DEL_NPC_VENDOR,
+    WORLD_SEL_NPC_VENDOR_REF,
     WORLD_UPD_CREATURE_MOVEMENT_TYPE,
     WORLD_UPD_CREATURE_FACTION,
     WORLD_UPD_CREATURE_NPCFLAG,
@@ -68,10 +69,23 @@
     WORLD_UPD_WAYPOINT_DATA_POINT,
     WORLD_UPD_WAYPOINT_DATA_POSITION,
     WORLD_UPD_WAYPOINT_DATA_WPGUID,
-    WORLD_UPD_ALL_WAYPOINT_DATA_WPGUID,
+    WORLD_UPD_WAYPOINT_DATA_ALL_WPGUID,
+    WORLD_SEL_WAYPOINT_DATA_MAX_ID,
+    WORLD_SEL_WAYPOINT_DATA_BY_ID,
+    WORLD_SEL_WAYPOINT_DATA_POS_BY_ID,
+    WORLD_SEL_WAYPOINT_DATA_POS_FIRST_BY_ID,
+    WORLD_SEL_WAYPOINT_DATA_POS_LAST_BY_ID,
+    WORLD_SEL_WAYPOINT_DATA_BY_WPGUID,
+    WORLD_SEL_WAYPOINT_DATA_ALL_BY_WPGUID,
+    WORLD_SEL_WAYPOINT_DATA_MAX_POINT,
+    WORLD_SEL_WAYPOINT_DATA_BY_POS,
+    WORLD_SEL_WAYPOINT_DATA_WPGUID_BY_ID,
+    WOLRD_SEL_WAYPOINT_DATA_ACTION,
+    WORLD_SEL_WAYPOINT_SCRIPTS_MAX_ID,
     WORLD_UPD_CREATURE_ADDON_PATH,
     WORLD_INS_CREATURE_ADDON,
     WORLD_DEL_CREATURE_ADDON,
+    WORLD_SEL_CREATURE_ADDON_BY_GUID,
     WORLD_INS_WAYPOINT_SCRIPT,
     WORLD_DEL_WAYPOINT_SCRIPT,
     WORLD_UPD_WAYPOINT_SCRIPT_ID,
@@ -79,9 +93,22 @@
     WORLD_UPD_WAYPOINT_SCRIPT_Y,
     WORLD_UPD_WAYPOINT_SCRIPT_Z,
     WORLD_UPD_WAYPOINT_SCRIPT_O,
+    WORLD_SEL_WAYPOINT_SCRIPT_ID_BY_GUID,
     WORLD_DEL_CREATURE,
     WORLD_INS_CREATURE_TRANSPORT,
     WORLD_UPD_CREATURE_TRANSPORT_EMOTE,
+    WORLD_SEL_COMMANDS,
+    WORLD_SEL_CREATURE_TEMPLATE,
+    WORLD_SEL_WAYPOINT_SCRIPT_BY_ID,
+    WORLD_SEL_IP2NATION_COUNTRY,
+    WORLD_SEL_ITEM_TEMPLATE_BY_NAME,
+    WORLD_SEL_CREATURE_BY_ID,
+    WORLD_SEL_GAMEOBJECT_NEAREST,
+    WORLD_SEL_GAMEOBJECT_TARGET,
+    WORLD_INS_CREATURE,
+    WORLD_DEL_GAME_EVENT_CREATURE,
+    WORLD_DEL_GAME_EVENT_MODEL_EQUIP,
+    WORLD_INS_GAMEOBJECT,
 
     MAX_WORLDDATABASE_STATEMENTS,
 };
diff -r b4c056460923 -r da13f4f7a26c src/server/shared/Database/MySQLConnection.cpp
--- a/src/server/shared/Database/MySQLConnection.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/shared/Database/MySQLConnection.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -58,17 +58,13 @@
 {
     ASSERT (m_Mysql); /// MySQL context must be present at this point
 
-    sLog->outSQLDriver("MySQLConnection::~MySQLConnection()");
     for (size_t i = 0; i < m_stmts.size(); ++i)
         delete m_stmts[i];
 
     for (PreparedStatementMap::const_iterator itr = m_queries.begin(); itr != m_queries.end(); ++itr)
-    {
         free((void *)m_queries[itr->first].first);
-    }
 
     mysql_close(m_Mysql);
-    Unlock();   /// Unlock while we die, how ironic
 }
 
 void MySQLConnection::Close()
diff -r b4c056460923 -r da13f4f7a26c src/server/shared/Database/PreparedStatement.cpp
--- a/src/server/shared/Database/PreparedStatement.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/shared/Database/PreparedStatement.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -1,418 +1,451 @@
-/*
- * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "PreparedStatement.h"
-#include "MySQLConnection.h"
-#include "Log.h"
-
-PreparedStatement::PreparedStatement(uint32 index) :
-m_stmt(NULL),
-m_index(index)
-{
-}
-
-PreparedStatement::~PreparedStatement()
-{
-}
-
-void PreparedStatement::BindParameters()
-{
-    ASSERT (m_stmt);
-
-    uint32 i = 0;
-    for (; i < statement_data.size(); i++)
-    {
-        switch (statement_data[i].type)
-        {
-            case TYPE_BOOL:
-                m_stmt->setBool(i, statement_data[i].data.boolean);
-                break;
-            case TYPE_UI8:
-            case TYPE_UI16:
-            case TYPE_UI32:
-                m_stmt->setUInt32(i, statement_data[i].data.ui32);
-                break;
-            case TYPE_I8:
-            case TYPE_I16:
-            case TYPE_I32:
-                m_stmt->setInt32(i, statement_data[i].data.i32);
-                break;
-            case TYPE_UI64:
-                m_stmt->setUInt64(i, statement_data[i].data.ui64);
-                break;
-            case TYPE_I64:
-                m_stmt->setInt64(i, statement_data[i].data.i64);
-                break;
-            case TYPE_FLOAT:
-                m_stmt->setFloat(i, statement_data[i].data.f);
-                break;
-            case TYPE_DOUBLE:
-                m_stmt->setDouble(i, statement_data[i].data.d);
-                break;
-            case TYPE_STRING:
-                m_stmt->setString(i, statement_data[i].str.c_str());
-                break;
-        }
-    }
-    #ifdef _DEBUG
-    if (i < m_stmt->m_paramCount)
-        sLog->outSQLDriver("[WARNING]: BindParameters() for statement %u did not bind all allocated parameters", m_index);
-    #endif
-}
-
-//- Bind to buffer
-void PreparedStatement::setBool(const uint8 index, const bool value)
-{
-    if (index >= statement_data.size())
-        statement_data.resize(index+1);
-
-    statement_data[index].data.boolean = value;
-    statement_data[index].type = TYPE_BOOL;
-}
-
-void PreparedStatement::setUInt8(const uint8 index, const uint8 value)
-{
-    if (index >= statement_data.size())
-        statement_data.resize(index+1);
-
-    statement_data[index].data.ui32 = value;
-    statement_data[index].type = TYPE_UI8;
-}
-
-void PreparedStatement::setUInt16(const uint8 index, const uint16 value)
-{
-    if (index >= statement_data.size())
-        statement_data.resize(index+1);
-
-    statement_data[index].data.ui32 = value;
-    statement_data[index].type = TYPE_UI16;
-}
-
-void PreparedStatement::setUInt32(const uint8 index, const uint32 value)
-{
-    if (index >= statement_data.size())
-        statement_data.resize(index+1);
-
-    statement_data[index].data.ui32 = value;
-    statement_data[index].type = TYPE_UI32;
-}
-
-void PreparedStatement::setUInt64(const uint8 index, const uint64 value)
-{
-    if (index >= statement_data.size())
-        statement_data.resize(index+1);
-
-    statement_data[index].data.ui64 = value;
-    statement_data[index].type = TYPE_UI64;
-}
-
-void PreparedStatement::setInt8(const uint8 index, const int8 value)
-{
-    if (index >= statement_data.size())
-        statement_data.resize(index+1);
-
-    statement_data[index].data.i32 = value;
-    statement_data[index].type = TYPE_I8;
-}
-
-void PreparedStatement::setInt16(const uint8 index, const int16 value)
-{
-    if (index >= statement_data.size())
-        statement_data.resize(index+1);
-
-    statement_data[index].data.i32 = value;
-    statement_data[index].type = TYPE_I16;
-}
-
-void PreparedStatement::setInt32(const uint8 index, const int32 value)
-{
-    if (index >= statement_data.size())
-        statement_data.resize(index+1);
-
-    statement_data[index].data.i32 = value;
-    statement_data[index].type = TYPE_I32;
-}
-
-void PreparedStatement::setInt64(const uint8 index, const int64 value)
-{
-    if (index >= statement_data.size())
-        statement_data.resize(index+1);
-
-    statement_data[index].data.i64 = value;
-    statement_data[index].type = TYPE_I64;
-}
-
-void PreparedStatement::setFloat(const uint8 index, const float value)
-{
-    if (index >= statement_data.size())
-        statement_data.resize(index+1);
-
-    statement_data[index].data.f = value;
-    statement_data[index].type = TYPE_FLOAT;
-}
-
-void PreparedStatement::setDouble(const uint8 index, const double value)
-{
-    if (index >= statement_data.size())
-        statement_data.resize(index+1);
-
-    statement_data[index].data.d = value;
-    statement_data[index].type = TYPE_DOUBLE;
-}
-
-void PreparedStatement::setString(const uint8 index, const std::string& value)
-{
-    if (index >= statement_data.size())
-        statement_data.resize(index+1);
-
-    statement_data[index].str = value;
-    statement_data[index].type = TYPE_STRING;
-}
-
-MySQLPreparedStatement::MySQLPreparedStatement(MYSQL_STMT* stmt) :
-m_Mstmt(stmt),
-m_bind(NULL)
-{
-    /// Initialize variable parameters
-    m_paramCount = mysql_stmt_param_count(stmt);
-    m_paramsSet.assign(m_paramCount, false);
-    m_bind = new MYSQL_BIND[m_paramCount];
-    memset(m_bind, 0, sizeof(MYSQL_BIND)*m_paramCount);
-
-    /// "If set to 1, causes mysql_stmt_store_result() to update the metadata MYSQL_FIELD->max_length value."
-    my_bool bool_tmp = 1;
-    mysql_stmt_attr_set(stmt, STMT_ATTR_UPDATE_MAX_LENGTH, &bool_tmp);
-}
-
-MySQLPreparedStatement::~MySQLPreparedStatement()
-{
-    ClearParameters();
-    mysql_stmt_close(m_Mstmt);
-    delete[] m_bind;
-}
-
-void MySQLPreparedStatement::ClearParameters()
-{
-    for (uint32 i=0; i < m_paramCount; ++i)
-    {
-        delete m_bind[i].length;
-        m_bind[i].length = NULL;
-        delete[] (char*) m_bind[i].buffer;
-        m_bind[i].buffer = NULL;
-        m_paramsSet[i] = false;
-    }
-}
-
-//- Bind on mysql level
-bool MySQLPreparedStatement::CheckValidIndex(uint8 index)
-{
-    if (index >= m_paramCount)
-        return false;
-
-    if (m_paramsSet[index])
-        sLog->outSQLDriver("[WARNING] Prepared Statement (id: %u) trying to bind value on already bound index (%u).", m_stmt->m_index, index);
-    return true;
-}
-
-void MySQLPreparedStatement::setBool(const uint8 index, const bool value)
-{
-    setUInt32(index, value);
-}
-
-void MySQLPreparedStatement::setUInt8(const uint8 index, const uint8 value)
-{
-    setUInt32(index, value);
-}
-
-void MySQLPreparedStatement::setUInt16(const uint8 index, const uint16 value)
-{
-    setUInt32(index, value);
-}
-
-void MySQLPreparedStatement::setUInt32(const uint8 index, const uint32 value)
-{
-    CheckValidIndex(index);
-    m_paramsSet[index] = true;
-    MYSQL_BIND* param = &m_bind[index];
-    setValue(param, MYSQL_TYPE_LONG, &value, sizeof(uint32), true);
-}
-
-void MySQLPreparedStatement::setUInt64(const uint8 index, const uint64 value)
-{
-    CheckValidIndex(index);
-    m_paramsSet[index] = true;
-    MYSQL_BIND* param = &m_bind[index];
-    setValue(param, MYSQL_TYPE_LONGLONG, &value, sizeof(uint64), true);
-}
-
-void MySQLPreparedStatement::setInt8(const uint8 index, const int8 value)
-{
-    setInt32(index, value);
-}
-
-void MySQLPreparedStatement::setInt16(const uint8 index, const int16 value)
-{
-    setInt32(index, value);
-}
-
-void MySQLPreparedStatement::setInt32(const uint8 index, const int32 value)
-{
-    CheckValidIndex(index);
-    m_paramsSet[index] = true;
-    MYSQL_BIND* param = &m_bind[index];
-    setValue(param, MYSQL_TYPE_LONG, &value, sizeof(int32), false);
-}
-
-void MySQLPreparedStatement::setInt64(const uint8 index, const int64 value)
-{
-    CheckValidIndex(index);
-    m_paramsSet[index] = true;
-    MYSQL_BIND* param = &m_bind[index];
-    setValue(param, MYSQL_TYPE_LONGLONG, &value, sizeof(int64), false);
-}
-
-void MySQLPreparedStatement::setFloat(const uint8 index, const float value)
-{
-    CheckValidIndex(index);
-    m_paramsSet[index] = true;
-    MYSQL_BIND* param = &m_bind[index];
-    setValue(param, MYSQL_TYPE_FLOAT, &value, sizeof(float), (value > 0.0f));
-}
-
-void MySQLPreparedStatement::setDouble(const uint8 index, const double value)
-{
-    CheckValidIndex(index);
-    m_paramsSet[index] = true;
-    MYSQL_BIND* param = &m_bind[index];
-    setValue(param, MYSQL_TYPE_DOUBLE, &value, sizeof(double), (value > 0.0f));
-}
-
-void MySQLPreparedStatement::setString(const uint8 index, const char* value)
-{
-    CheckValidIndex(index);
-    m_paramsSet[index] = true;
-    MYSQL_BIND* param = &m_bind[index];
-    size_t len = strlen(value) + 1;
-    param->buffer_type = MYSQL_TYPE_VAR_STRING;
-    delete [] static_cast<char *>(param->buffer);
-    param->buffer = new char[len];
-    param->buffer_length = len;
-    param->is_null_value = 0;
-    param->length = new unsigned long(len-1);
-
-    memcpy(param->buffer, value, len);
-}
-
-void MySQLPreparedStatement::setValue(MYSQL_BIND* param, enum_field_types type, const void* value, uint32 len, bool isUnsigned)
-{
-    param->buffer_type = type;
-    delete [] static_cast<char *>(param->buffer);
-    param->buffer = new char[len];
-    param->buffer_length = 0;
-    param->is_null_value = 0;
-    param->length = NULL;               // Only != NULL for strings
-    param->is_unsigned = isUnsigned;
-
-    memcpy(param->buffer, value, len);
-}
-
-std::string MySQLPreparedStatement::getQueryString(const char *query)
-{
-    std::string queryString = query;
-
-    uint32 pos = 0;
-    for (uint32 i = 0; i < m_stmt->statement_data.size(); i++)
-    {
-        pos = queryString.find("?", pos);
-        std::stringstream replace;
-
-        replace << '\'';
-
-        switch (m_stmt->statement_data[i].type)
-        {
-            case TYPE_BOOL:
-                replace << (m_stmt->statement_data[i].data.boolean ? '1' : '0');
-                break;
-            case TYPE_UI8:
-            case TYPE_UI16:
-            case TYPE_UI32:
-                replace << m_stmt->statement_data[i].data.ui32;
-                break;
-            case TYPE_I8:
-            case TYPE_I16:
-            case TYPE_I32:
-                replace << m_stmt->statement_data[i].data.i32;
-                break;
-            case TYPE_UI64:
-                replace << m_stmt->statement_data[i].data.ui64;
-                break;
-            case TYPE_I64:
-                replace << m_stmt->statement_data[i].data.i64;
-                break;
-            case TYPE_FLOAT:
-                replace << m_stmt->statement_data[i].data.f;
-                break;
-            case TYPE_DOUBLE:
-                replace << m_stmt->statement_data[i].data.d;
-                break;
-            case TYPE_STRING:
-                replace << m_stmt->statement_data[i].str;
-                break;
-        }
-        replace << '\'';
-        queryString.replace(pos, 1, replace.str());
-    }
-
-    return queryString;
-}
-
-//- Execution
-PreparedStatementTask::PreparedStatementTask(PreparedStatement* stmt) :
-m_stmt(stmt),
-m_has_result(false)
-{
-}
-
-PreparedStatementTask::PreparedStatementTask(PreparedStatement* stmt, PreparedQueryResultFuture result) :
-m_stmt(stmt),
-m_has_result(true),
-m_result(result)
-{
-}
-
-
-PreparedStatementTask::~PreparedStatementTask()
-{
-    delete m_stmt;
-}
-
-bool PreparedStatementTask::Execute()
-{
-    if (m_has_result)
-    {
-        PreparedResultSet* result = m_conn->Query(m_stmt);
-        if (!result || !result->GetRowCount())
-        {
-            m_result.set(PreparedQueryResult(NULL));
-            return false;
-        }
-        m_result.set(PreparedQueryResult(result));
-        return true;
-    }
-
-    return m_conn->Execute(m_stmt);
-}
+/*
+ * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "PreparedStatement.h"
+#include "MySQLConnection.h"
+#include "Log.h"
+
+PreparedStatement::PreparedStatement(uint32 index) :
+m_stmt(NULL),
+m_index(index)
+{
+}
+
+PreparedStatement::~PreparedStatement()
+{
+}
+
+void PreparedStatement::BindParameters()
+{
+    ASSERT (m_stmt);
+
+    uint32 i = 0;
+    for (; i < statement_data.size(); i++)
+    {
+        switch (statement_data[i].type)
+        {
+            case TYPE_BOOL:
+                m_stmt->setBool(i, statement_data[i].data.boolean);
+                break;
+            case TYPE_UI8:
+                m_stmt->setUInt8(i, statement_data[i].data.ui8);
+                break;
+            case TYPE_UI16:
+                m_stmt->setUInt16(i, statement_data[i].data.ui16);
+                break;
+            case TYPE_UI32:
+                m_stmt->setUInt32(i, statement_data[i].data.ui32);
+                break;
+            case TYPE_I8:
+                m_stmt->setInt8(i, statement_data[i].data.i8);
+                break;
+            case TYPE_I16:
+                m_stmt->setInt16(i, statement_data[i].data.i16);
+                break;
+            case TYPE_I32:
+                m_stmt->setInt32(i, statement_data[i].data.i32);
+                break;
+            case TYPE_UI64:
+                m_stmt->setUInt64(i, statement_data[i].data.ui64);
+                break;
+            case TYPE_I64:
+                m_stmt->setInt64(i, statement_data[i].data.i64);
+                break;
+            case TYPE_FLOAT:
+                m_stmt->setFloat(i, statement_data[i].data.f);
+                break;
+            case TYPE_DOUBLE:
+                m_stmt->setDouble(i, statement_data[i].data.d);
+                break;
+            case TYPE_STRING:
+                m_stmt->setString(i, statement_data[i].str.c_str());
+                break;
+        }
+    }
+    #ifdef _DEBUG
+    if (i < m_stmt->m_paramCount)
+        sLog->outSQLDriver("[WARNING]: BindParameters() for statement %u did not bind all allocated parameters", m_index);
+    #endif
+}
+
+//- Bind to buffer
+void PreparedStatement::setBool(const uint8 index, const bool value)
+{
+    if (index >= statement_data.size())
+        statement_data.resize(index+1);
+
+    statement_data[index].data.boolean = value;
+    statement_data[index].type = TYPE_BOOL;
+}
+
+void PreparedStatement::setUInt8(const uint8 index, const uint8 value)
+{
+    if (index >= statement_data.size())
+        statement_data.resize(index+1);
+
+    statement_data[index].data.ui8 = value;
+    statement_data[index].type = TYPE_UI8;
+}
+
+void PreparedStatement::setUInt16(const uint8 index, const uint16 value)
+{
+    if (index >= statement_data.size())
+        statement_data.resize(index+1);
+
+    statement_data[index].data.ui16 = value;
+    statement_data[index].type = TYPE_UI16;
+}
+
+void PreparedStatement::setUInt32(const uint8 index, const uint32 value)
+{
+    if (index >= statement_data.size())
+        statement_data.resize(index+1);
+
+    statement_data[index].data.ui32 = value;
+    statement_data[index].type = TYPE_UI32;
+}
+
+void PreparedStatement::setUInt64(const uint8 index, const uint64 value)
+{
+    if (index >= statement_data.size())
+        statement_data.resize(index+1);
+
+    statement_data[index].data.ui64 = value;
+    statement_data[index].type = TYPE_UI64;
+}
+
+void PreparedStatement::setInt8(const uint8 index, const int8 value)
+{
+    if (index >= statement_data.size())
+        statement_data.resize(index+1);
+
+    statement_data[index].data.i8 = value;
+    statement_data[index].type = TYPE_I8;
+}
+
+void PreparedStatement::setInt16(const uint8 index, const int16 value)
+{
+    if (index >= statement_data.size())
+        statement_data.resize(index+1);
+
+    statement_data[index].data.i16 = value;
+    statement_data[index].type = TYPE_I16;
+}
+
+void PreparedStatement::setInt32(const uint8 index, const int32 value)
+{
+    if (index >= statement_data.size())
+        statement_data.resize(index+1);
+
+    statement_data[index].data.i32 = value;
+    statement_data[index].type = TYPE_I32;
+}
+
+void PreparedStatement::setInt64(const uint8 index, const int64 value)
+{
+    if (index >= statement_data.size())
+        statement_data.resize(index+1);
+
+    statement_data[index].data.i64 = value;
+    statement_data[index].type = TYPE_I64;
+}
+
+void PreparedStatement::setFloat(const uint8 index, const float value)
+{
+    if (index >= statement_data.size())
+        statement_data.resize(index+1);
+
+    statement_data[index].data.f = value;
+    statement_data[index].type = TYPE_FLOAT;
+}
+
+void PreparedStatement::setDouble(const uint8 index, const double value)
+{
+    if (index >= statement_data.size())
+        statement_data.resize(index+1);
+
+    statement_data[index].data.d = value;
+    statement_data[index].type = TYPE_DOUBLE;
+}
+
+void PreparedStatement::setString(const uint8 index, const std::string& value)
+{
+    if (index >= statement_data.size())
+        statement_data.resize(index+1);
+
+    statement_data[index].str = value;
+    statement_data[index].type = TYPE_STRING;
+}
+
+MySQLPreparedStatement::MySQLPreparedStatement(MYSQL_STMT* stmt) :
+m_Mstmt(stmt),
+m_bind(NULL)
+{
+    /// Initialize variable parameters
+    m_paramCount = mysql_stmt_param_count(stmt);
+    m_paramsSet.assign(m_paramCount, false);
+    m_bind = new MYSQL_BIND[m_paramCount];
+    memset(m_bind, 0, sizeof(MYSQL_BIND)*m_paramCount);
+
+    /// "If set to 1, causes mysql_stmt_store_result() to update the metadata MYSQL_FIELD->max_length value."
+    my_bool bool_tmp = 1;
+    mysql_stmt_attr_set(stmt, STMT_ATTR_UPDATE_MAX_LENGTH, &bool_tmp);
+}
+
+MySQLPreparedStatement::~MySQLPreparedStatement()
+{
+    ClearParameters();
+    if(m_Mstmt->bind_result_done)
+    {
+        delete[] m_Mstmt->bind->length;
+        delete[] m_Mstmt->bind->is_null;
+    }
+    mysql_stmt_close(m_Mstmt);
+    delete[] m_bind;
+}
+
+void MySQLPreparedStatement::ClearParameters()
+{
+    for (uint32 i=0; i < m_paramCount; ++i)
+    {
+        delete m_bind[i].length;
+        m_bind[i].length = NULL;
+        delete[] (char*) m_bind[i].buffer;
+        m_bind[i].buffer = NULL;
+        m_paramsSet[i] = false;
+    }
+}
+
+//- Bind on mysql level
+bool MySQLPreparedStatement::CheckValidIndex(uint8 index)
+{
+    if (index >= m_paramCount)
+        return false;
+
+    if (m_paramsSet[index])
+        sLog->outSQLDriver("[WARNING] Prepared Statement (id: %u) trying to bind value on already bound index (%u).", m_stmt->m_index, index);
+    return true;
+}
+
+void MySQLPreparedStatement::setBool(const uint8 index, const bool value)
+{
+    setUInt8(index, value ? 1 : 0);
+}
+
+void MySQLPreparedStatement::setUInt8(const uint8 index, const uint8 value)
+{
+    CheckValidIndex(index);
+    m_paramsSet[index] = true;
+    MYSQL_BIND* param = &m_bind[index];
+    setValue(param, MYSQL_TYPE_TINY, &value, sizeof(uint8), true);
+}
+
+void MySQLPreparedStatement::setUInt16(const uint8 index, const uint16 value)
+{
+    CheckValidIndex(index);
+    m_paramsSet[index] = true;
+    MYSQL_BIND* param = &m_bind[index];
+    setValue(param, MYSQL_TYPE_SHORT, &value, sizeof(uint16), true);
+}
+
+void MySQLPreparedStatement::setUInt32(const uint8 index, const uint32 value)
+{
+    CheckValidIndex(index);
+    m_paramsSet[index] = true;
+    MYSQL_BIND* param = &m_bind[index];
+    setValue(param, MYSQL_TYPE_LONG, &value, sizeof(uint32), true);
+}
+
+void MySQLPreparedStatement::setUInt64(const uint8 index, const uint64 value)
+{
+    CheckValidIndex(index);
+    m_paramsSet[index] = true;
+    MYSQL_BIND* param = &m_bind[index];
+    setValue(param, MYSQL_TYPE_LONGLONG, &value, sizeof(uint64), true);
+}
+
+void MySQLPreparedStatement::setInt8(const uint8 index, const int8 value)
+{
+    CheckValidIndex(index);
+    m_paramsSet[index] = true;
+    MYSQL_BIND* param = &m_bind[index];
+    setValue(param, MYSQL_TYPE_TINY, &value, sizeof(int8), false);
+}
+
+void MySQLPreparedStatement::setInt16(const uint8 index, const int16 value)
+{
+    CheckValidIndex(index);
+    m_paramsSet[index] = true;
+    MYSQL_BIND* param = &m_bind[index];
+    setValue(param, MYSQL_TYPE_SHORT, &value, sizeof(int16), false);
+}
+
+void MySQLPreparedStatement::setInt32(const uint8 index, const int32 value)
+{
+    CheckValidIndex(index);
+    m_paramsSet[index] = true;
+    MYSQL_BIND* param = &m_bind[index];
+    setValue(param, MYSQL_TYPE_LONG, &value, sizeof(int32), false);
+}
+
+void MySQLPreparedStatement::setInt64(const uint8 index, const int64 value)
+{
+    CheckValidIndex(index);
+    m_paramsSet[index] = true;
+    MYSQL_BIND* param = &m_bind[index];
+    setValue(param, MYSQL_TYPE_LONGLONG, &value, sizeof(int64), false);
+}
+
+void MySQLPreparedStatement::setFloat(const uint8 index, const float value)
+{
+    CheckValidIndex(index);
+    m_paramsSet[index] = true;
+    MYSQL_BIND* param = &m_bind[index];
+    setValue(param, MYSQL_TYPE_FLOAT, &value, sizeof(float), (value > 0.0f));
+}
+
+void MySQLPreparedStatement::setDouble(const uint8 index, const double value)
+{
+    CheckValidIndex(index);
+    m_paramsSet[index] = true;
+    MYSQL_BIND* param = &m_bind[index];
+    setValue(param, MYSQL_TYPE_DOUBLE, &value, sizeof(double), (value > 0.0f));
+}
+
+void MySQLPreparedStatement::setString(const uint8 index, const char* value)
+{
+    CheckValidIndex(index);
+    m_paramsSet[index] = true;
+    MYSQL_BIND* param = &m_bind[index];
+    size_t len = strlen(value) + 1;
+    param->buffer_type = MYSQL_TYPE_VAR_STRING;
+    delete [] static_cast<char *>(param->buffer);
+    param->buffer = new char[len];
+    param->buffer_length = len;
+    param->is_null_value = 0;
+    param->length = new unsigned long(len-1);
+
+    memcpy(param->buffer, value, len);
+}
+
+void MySQLPreparedStatement::setValue(MYSQL_BIND* param, enum_field_types type, const void* value, uint32 len, bool isUnsigned)
+{
+    param->buffer_type = type;
+    delete [] static_cast<char *>(param->buffer);
+    param->buffer = new char[len];
+    param->buffer_length = 0;
+    param->is_null_value = 0;
+    param->length = NULL;               // Only != NULL for strings
+    param->is_unsigned = isUnsigned;
+
+    memcpy(param->buffer, value, len);
+}
+
+std::string MySQLPreparedStatement::getQueryString(const char *query)
+{
+    std::string queryString = query;
+
+    uint32 pos = 0;
+    for (uint32 i = 0; i < m_stmt->statement_data.size(); i++)
+    {
+        pos = queryString.find("?", pos);
+        std::stringstream replace;
+
+        replace << '\'';
+
+        switch (m_stmt->statement_data[i].type)
+        {
+            case TYPE_BOOL:
+                replace << (m_stmt->statement_data[i].data.boolean ? '1' : '0');
+                break;
+            case TYPE_UI8:
+                replace << uint16(m_stmt->statement_data[i].data.ui8);  // stringstream will append a character with that code instead of numeric representation
+                break;
+            case TYPE_UI16:
+                replace << m_stmt->statement_data[i].data.ui16;
+                break;
+            case TYPE_UI32:
+                replace << m_stmt->statement_data[i].data.ui32;
+                break;
+            case TYPE_I8:
+                replace << int16(m_stmt->statement_data[i].data.i8);  // stringstream will append a character with that code instead of numeric representation
+                break;
+            case TYPE_I16:
+                replace << m_stmt->statement_data[i].data.i16;
+                break;
+            case TYPE_I32:
+                replace << m_stmt->statement_data[i].data.i32;
+                break;
+            case TYPE_UI64:
+                replace << m_stmt->statement_data[i].data.ui64;
+                break;
+            case TYPE_I64:
+                replace << m_stmt->statement_data[i].data.i64;
+                break;
+            case TYPE_FLOAT:
+                replace << m_stmt->statement_data[i].data.f;
+                break;
+            case TYPE_DOUBLE:
+                replace << m_stmt->statement_data[i].data.d;
+                break;
+            case TYPE_STRING:
+                replace << m_stmt->statement_data[i].str;
+                break;
+        }
+        replace << '\'';
+        queryString.replace(pos, 1, replace.str());
+    }
+
+    return queryString;
+}
+
+//- Execution
+PreparedStatementTask::PreparedStatementTask(PreparedStatement* stmt) :
+m_stmt(stmt),
+m_has_result(false)
+{
+}
+
+PreparedStatementTask::PreparedStatementTask(PreparedStatement* stmt, PreparedQueryResultFuture result) :
+m_stmt(stmt),
+m_has_result(true),
+m_result(result)
+{
+}
+
+
+PreparedStatementTask::~PreparedStatementTask()
+{
+    delete m_stmt;
+}
+
+bool PreparedStatementTask::Execute()
+{
+    if (m_has_result)
+    {
+        PreparedResultSet* result = m_conn->Query(m_stmt);
+        if (!result || !result->GetRowCount())
+        {
+            m_result.set(PreparedQueryResult(NULL));
+            return false;
+        }
+        m_result.set(PreparedQueryResult(result));
+        return true;
+    }
+
+    return m_conn->Execute(m_stmt);
+}
diff -r b4c056460923 -r da13f4f7a26c src/server/shared/Database/QueryResult.h
--- a/src/server/shared/Database/QueryResult.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/shared/Database/QueryResult.h	Mon Apr 16 14:29:17 2012 +0300
@@ -19,7 +19,7 @@
 #ifndef QUERYRESULT_H
 #define QUERYRESULT_H
 
-#include <ace/Refcounted_Auto_Ptr.h>
+#include "AutoPtr.h"
 #include <ace/Thread_Mutex.h>
 
 #include "Field.h"
@@ -58,7 +58,7 @@
         MYSQL_FIELD* _fields;
 };
 
-typedef ACE_Refcounted_Auto_Ptr<ResultSet, ACE_Null_Mutex> QueryResult;
+typedef Trinity::AutoPtr<ResultSet, ACE_Thread_Mutex> QueryResult;
 
 class PreparedResultSet
 {
@@ -103,7 +103,7 @@
 
 };
 
-typedef ACE_Refcounted_Auto_Ptr<PreparedResultSet, ACE_Null_Mutex> PreparedQueryResult;
+typedef Trinity::AutoPtr<PreparedResultSet, ACE_Thread_Mutex> PreparedQueryResult;
 
 #endif
 
diff -r b4c056460923 -r da13f4f7a26c src/server/shared/Database/Transaction.h
--- a/src/server/shared/Database/Transaction.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/shared/Database/Transaction.h	Mon Apr 16 14:29:17 2012 +0300
@@ -47,7 +47,7 @@
         bool _cleanedUp;
 
 };
-typedef ACE_Refcounted_Auto_Ptr<Transaction, ACE_Null_Mutex> SQLTransaction;
+typedef Trinity::AutoPtr<Transaction, ACE_Thread_Mutex> SQLTransaction;
 
 /*! Low level class*/
 class TransactionTask : public SQLOperation
diff -r b4c056460923 -r da13f4f7a26c src/server/shared/Dynamic/TypeContainerFunctionsPtr.h
--- a/src/server/shared/Dynamic/TypeContainerFunctionsPtr.h	Thu Apr 05 13:10:49 2012 +0300
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,168 +0,0 @@
-/*
- * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
- * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef TYPECONTAINER_FUNCTIONS_PTR_H
-#define TYPECONTAINER_FUNCTIONS_PTR_H
-
-/*
- * Here you'll find a list of helper functions to make
- * the TypeContainer usefull.  Without it, its hard
- * to access or mutate the container.
- */
-
-#include "Platform/Define.h"
-#include "Utilities/TypeList.h"
-#include <map>
-
-namespace Trinity
-{
-    /* ContainerMapList Helpers */
-    // count functions
-    //    template<class SPECIFIC_TYPE> size_t Count(const ContainerMapList<SPECIFIC_TYPE> &elements, CountedPtr<SPECIFIC_TYPE>* /*fake*/)
-    //    {
-    //        return elements._element.size();
-    //    };
-    //
-    //    template<class SPECIFIC_TYPE> size_t Count(const ContainerMapList<TypeNull> &elements, CountedPtr<SPECIFIC_TYPE>* /*fake*/)
-    //    {
-    //        return 0;
-    //    }
-    //
-    //    template<class SPECIFIC_TYPE, class T> size_t Count(const ContainerMapList<T> &elements, CountedPtr<SPECIFIC_TYPE>* /*fake*/)
-    //    {
-    //        return 0;
-    //    }
-    //
-    //    template<class SPECIFIC_TYPE, class T> size_t Count(const ContainerMapList<TypeList<SPECIFIC_TYPE, T> >&elements, SPECIFIC_TYPE* fake)
-    //    {
-    //        return Count(elements._elements, fake);
-    //    }
-    //
-    //    template<class SPECIFIC_TYPE, class H, class T> size_t Count(const ContainerMapList<TypeList<H, T> >&elements, SPECIFIC_TYPE* fake)
-    //    {
-    //        return Count(elements._TailElements, fake);
-    //    }
-
-    // non-const find functions
-    template<class SPECIFIC_TYPE> CountedPtr<SPECIFIC_TYPE>& Find(ContainerMapList<SPECIFIC_TYPE> &elements, OBJECT_HANDLE hdl, CountedPtr<SPECIFIC_TYPE>* /*fake*/)
-    {
-        typename std::map<OBJECT_HANDLE, CountedPtr<SPECIFIC_TYPE> >::iterator iter = elements._element.find(hdl);
-        return (iter == elements._element.end() ? NullPtr<SPECIFIC_TYPE>((SPECIFIC_TYPE*)NULL) : iter->second);
-    };
-
-    template<class SPECIFIC_TYPE> CountedPtr<SPECIFIC_TYPE>& Find(ContainerMapList<TypeNull> &elements, OBJECT_HANDLE hdl, CountedPtr<SPECIFIC_TYPE>* /*fake*/)
-    {
-        return NullPtr<SPECIFIC_TYPE>((SPECIFIC_TYPE*)NULL);// terminate recursion
-    }
-
-    template<class SPECIFIC_TYPE, class T> CountedPtr<SPECIFIC_TYPE>& Find(ContainerMapList<T> &elements, OBJECT_HANDLE hdl, CountedPtr<SPECIFIC_TYPE>* /*fake*/)
-    {
-        return NullPtr<SPECIFIC_TYPE>((SPECIFIC_TYPE*)NULL);// this is a missed
-    }
-
-    template<class SPECIFIC_TYPE, class H, class T> CountedPtr<SPECIFIC_TYPE>& Find(ContainerMapList<TypeList<H, T> >&elements, OBJECT_HANDLE hdl, CountedPtr<SPECIFIC_TYPE>* fake)
-    {
-        CountedPtr<SPECIFIC_TYPE> &t = Find(elements._elements, hdl, fake);
-        return (!t ? Find(elements._TailElements, hdl, fake) : t);
-    }
-
-    // const find functions
-    template<class SPECIFIC_TYPE> const CountedPtr<SPECIFIC_TYPE>& Find(const ContainerMapList<SPECIFIC_TYPE> &elements, OBJECT_HANDLE hdl, CountedPtr<SPECIFIC_TYPE>* /*fake*/)
-    {
-        typename CountedPtr<SPECIFIC_TYPE>::iterator iter = elements._element.find(hdl);
-        return (iter == elements._element.end() ? NullPtr<SPECIFIC_TYPE>((SPECIFIC_TYPE*)NULL) : iter->second);
-    };
-
-    template<class SPECIFIC_TYPE> const CountedPtr<SPECIFIC_TYPE>& Find(const ContainerMapList<TypeNull> &elements, OBJECT_HANDLE hdl, CountedPtr<SPECIFIC_TYPE>* /*fake*/)
-    {
-        return NullPtr<SPECIFIC_TYPE>((SPECIFIC_TYPE*)NULL);
-    }
-
-    template<class SPECIFIC_TYPE, class T> const CountedPtr<SPECIFIC_TYPE>& Find(const ContainerMapList<T> &elements, OBJECT_HANDLE hdl, CountedPtr<SPECIFIC_TYPE>* /*fake*/)
-    {
-        return NullPtr<SPECIFIC_TYPE>((SPECIFIC_TYPE*)NULL);
-    }
-
-    template<class SPECIFIC_TYPE, class H, class T> CountedPtr<SPECIFIC_TYPE>& Find(const ContainerMapList<TypeList<H, T> >&elements, OBJECT_HANDLE hdl, CountedPtr<SPECIFIC_TYPE>* fake)
-    {
-        CountedPtr<SPECIFIC_TYPE> &t = Find(elements._elements, hdl, fake);
-        if (!t)
-            t = Find(elements._TailElement, hdl, fake);
-
-        return t;
-    }
-
-    // non-const insert functions
-    template<class SPECIFIC_TYPE> CountedPtr<SPECIFIC_TYPE>& Insert(ContainerMapList<SPECIFIC_TYPE> &elements, CountedPtr<SPECIFIC_TYPE> &obj, OBJECT_HANDLE hdl)
-    {
-        elements._element[hdl] = obj;
-        return obj;
-    };
-
-    template<class SPECIFIC_TYPE> CountedPtr<SPECIFIC_TYPE>& Insert(ContainerMapList<TypeNull> &elements, CountedPtr<SPECIFIC_TYPE> &obj, OBJECT_HANDLE hdl)
-    {
-        return NullPtr<SPECIFIC_TYPE>((SPECIFIC_TYPE*)NULL);
-    }
-
-    // this is a missed
-    template<class SPECIFIC_TYPE, class T> CountedPtr<SPECIFIC_TYPE>& Insert(ContainerMapList<T> &elements, CountedPtr<SPECIFIC_TYPE> &obj, OBJECT_HANDLE hdl)
-    {
-        return NullPtr<SPECIFIC_TYPE>((SPECIFIC_TYPE*)NULL);// a missed
-    }
-
-    // Recursion
-    template<class SPECIFIC_TYPE, class H, class T> CountedPtr<SPECIFIC_TYPE>& Insert(ContainerMapList<TypeList<H, T> >&elements, CountedPtr<SPECIFIC_TYPE> &obj, OBJECT_HANDLE hdl)
-    {
-        CountedPtr<SPECIFIC_TYPE> &t= Insert(elements._elements, obj, hdl);
-        return (!t ? Insert(elements._TailElements, obj, hdl) : t);
-    }
-
-    // non-const remove method
-    template<class SPECIFIC_TYPE> bool Remove(ContainerMapList<SPECIFIC_TYPE> &elements, CountedPtr<SPECIFIC_TYPE> &obj, OBJECT_HANDLE hdl)
-    {
-        typename std::map<OBJECT_HANDLE, CountedPtr<SPECIFIC_TYPE> >::iterator iter = elements._element.find(hdl);
-        if ( iter != elements._element.end() )
-        {
-            elements._element.erase(iter);
-            return true;
-        }
-
-        return false;                                       // found... terminate the search
-    }
-
-    template<class SPECIFIC_TYPE> bool Remove(ContainerMapList<TypeNull> &elements, CountedPtr<SPECIFIC_TYPE> &obj, OBJECT_HANDLE hdl)
-    {
-        return false;
-    }
-
-    // this is a missed
-    template<class SPECIFIC_TYPE, class T> bool Remove(ContainerMapList<T> &elements, CountedPtr<SPECIFIC_TYPE> &obj, OBJECT_HANDLE hdl)
-    {
-        return false;
-    }
-
-    template<class SPECIFIC_TYPE, class T, class H> bool Remove(ContainerMapList<TypeList<H, T> > &elements, CountedPtr<SPECIFIC_TYPE> &obj, OBJECT_HANDLE hdl)
-    {
-        // The head element is bad
-        bool t = Remove(elements._elements, obj, hdl);
-        return ( !t ? Remove(elements._TailElements, obj, hdl) : t );
-    }
-
-}
-#endif
-
diff -r b4c056460923 -r da13f4f7a26c src/server/shared/Logging/Log.cpp
--- a/src/server/shared/Logging/Log.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/shared/Logging/Log.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -1,1078 +1,1079 @@
-/*
- * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
- * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "Common.h"
-#include "Log.h"
-#include "Configuration/Config.h"
-#include "Util.h"
-
-#include "Implementation/LoginDatabase.h" // For logging
-extern LoginDatabaseWorkerPool LoginDatabase;
-
-#include <stdarg.h>
-#include <stdio.h>
-
-Log::Log() :
-    raLogfile(NULL), logfile(NULL), gmLogfile(NULL), charLogfile(NULL),
-    dberLogfile(NULL), chatLogfile(NULL), arenaLogFile(NULL), sqlLogFile(NULL), sqlDevLogFile(NULL), wardenLogFile(NULL),
-    m_gmlog_per_account(false), m_enableLogDBLater(false),
-    m_enableLogDB(false), m_colored(false)
-{
-    Initialize();
-}
-
-Log::~Log()
-{
-    if ( logfile != NULL )
-        fclose(logfile);
-    logfile = NULL;
-
-    if ( gmLogfile != NULL )
-        fclose(gmLogfile);
-    gmLogfile = NULL;
-
-    if (charLogfile != NULL)
-        fclose(charLogfile);
-    charLogfile = NULL;
-
-    if( dberLogfile != NULL )
-        fclose(dberLogfile);
-    dberLogfile = NULL;
-
-    if (raLogfile != NULL)
-        fclose(raLogfile);
-    raLogfile = NULL;
-
-    if (chatLogfile != NULL)
-        fclose(chatLogfile);
-    chatLogfile = NULL;
-
-    if (arenaLogFile != NULL)
-        fclose(arenaLogFile);
-    arenaLogFile = NULL;
-
-    if (sqlLogFile != NULL)
-        fclose(sqlLogFile);
-    sqlLogFile = NULL;
-
-    if (sqlDevLogFile != NULL)
-        fclose(sqlDevLogFile);
-    sqlDevLogFile = NULL;
-	
-    if (wardenLogFile != NULL)
-        fclose(wardenLogFile);
-    wardenLogFile = NULL;
-}
-
-void Log::SetLogLevel(char *Level)
-{
-    int32 NewLevel =atoi((char*)Level);
-    if ( NewLevel <0 )
-        NewLevel = 0;
-    m_logLevel = NewLevel;
-
-    outString( "LogLevel is %u", m_logLevel );
-}
-
-void Log::SetLogFileLevel(char *Level)
-{
-    int32 NewLevel =atoi((char*)Level);
-    if ( NewLevel <0 )
-        NewLevel = 0;
-    m_logFileLevel = NewLevel;
-
-    outString( "LogFileLevel is %u", m_logFileLevel );
-}
-
-void Log::SetDBLogLevel(char *Level)
-{
-    int32 NewLevel = atoi((char*)Level);
-    if ( NewLevel < 0 )
-        NewLevel = 0;
-    m_dbLogLevel = NewLevel;
-
-    outString( "DBLogLevel is %u", m_dbLogLevel );
-}
-
-void Log::Initialize()
-{
-    /// Check whether we'll log GM commands/RA events/character outputs/chat stuffs
-    m_dbChar = ConfigMgr::GetBoolDefault("LogDB.Char", false);
-    m_dbRA = ConfigMgr::GetBoolDefault("LogDB.RA", false);
-    m_dbGM = ConfigMgr::GetBoolDefault("LogDB.GM", false);
-    m_dbChat = ConfigMgr::GetBoolDefault("LogDB.Chat", false);
-
-    /// Realm must be 0 by default
-    SetRealmID(0);
-
-    /// Common log files data
-    m_logsDir = ConfigMgr::GetStringDefault("LogsDir", "");
-    if (!m_logsDir.empty())
-        if ((m_logsDir.at(m_logsDir.length() - 1) != '/') && (m_logsDir.at(m_logsDir.length() - 1) != '\\'))
-            m_logsDir.push_back('/');
-
-    m_logsTimestamp = "_" + GetTimestampStr();
-
-    /// Open specific log files
-    logfile = openLogFile("LogFile", "LogTimestamp", "w");
-    InitColors(ConfigMgr::GetStringDefault("LogColors", ""));
-
-    m_gmlog_per_account = ConfigMgr::GetBoolDefault("GmLogPerAccount", false);
-    if (!m_gmlog_per_account)
-        gmLogfile = openLogFile("GMLogFile", "GmLogTimestamp", "a");
-    else
-    {
-        // GM log settings for per account case
-        m_gmlog_filename_format = ConfigMgr::GetStringDefault("GMLogFile", "");
-        if (!m_gmlog_filename_format.empty())
-        {
-            bool m_gmlog_timestamp = ConfigMgr::GetBoolDefault("GmLogTimestamp", false);
-
-            size_t dot_pos = m_gmlog_filename_format.find_last_of('.');
-            if (dot_pos!=m_gmlog_filename_format.npos)
-            {
-                if (m_gmlog_timestamp)
-                    m_gmlog_filename_format.insert(dot_pos, m_logsTimestamp);
-
-                m_gmlog_filename_format.insert(dot_pos, "_#%u");
-            }
-            else
-            {
-                m_gmlog_filename_format += "_#%u";
-
-                if (m_gmlog_timestamp)
-                    m_gmlog_filename_format += m_logsTimestamp;
-            }
-
-            m_gmlog_filename_format = m_logsDir + m_gmlog_filename_format;
-        }
-    }
-
-    charLogfile = openLogFile("CharLogFile", "CharLogTimestamp", "a");
-    dberLogfile = openLogFile("DBErrorLogFile", NULL, "a");
-    raLogfile = openLogFile("RaLogFile", NULL, "a");
-    chatLogfile = openLogFile("ChatLogFile", "ChatLogTimestamp", "a");
-    arenaLogFile = openLogFile("ArenaLogFile", NULL, "a");
-    sqlLogFile = openLogFile("SQLDriverLogFile", NULL, "a");
-    sqlDevLogFile = openLogFile("SQLDeveloperLogFile", NULL, "a");
-	wardenLogFile = openLogFile("Warden.LogFile",NULL,"a");
-
-    // Main log file settings
-    m_logLevel     = ConfigMgr::GetIntDefault("LogLevel", LOGL_NORMAL);
-    m_logFileLevel = ConfigMgr::GetIntDefault("LogFileLevel", LOGL_NORMAL);
-    m_dbLogLevel   = ConfigMgr::GetIntDefault("DBLogLevel", LOGL_NORMAL);
-    m_sqlDriverQueryLogging  = ConfigMgr::GetBoolDefault("SQLDriverQueryLogging", false);
-
-    m_DebugLogMask = DebugLogFilters(ConfigMgr::GetIntDefault("DebugLogMask", LOG_FILTER_NONE));
-
-    // Char log settings
-    m_charLog_Dump = ConfigMgr::GetBoolDefault("CharLogDump", false);
-    m_charLog_Dump_Separate = ConfigMgr::GetBoolDefault("CharLogDump.Separate", false);
-    if (m_charLog_Dump_Separate)
-    {
-        m_dumpsDir = ConfigMgr::GetStringDefault("CharLogDump.SeparateDir", "");
-        if (!m_dumpsDir.empty())
-            if ((m_dumpsDir.at(m_dumpsDir.length() - 1) != '/') && (m_dumpsDir.at(m_dumpsDir.length() - 1) != '\\'))
-                m_dumpsDir.push_back('/');
-    }
-}
-
-void Log::ReloadConfig()
-{
-    m_logLevel     = ConfigMgr::GetIntDefault("LogLevel", LOGL_NORMAL);
-    m_logFileLevel = ConfigMgr::GetIntDefault("LogFileLevel", LOGL_NORMAL);
-    m_dbLogLevel   = ConfigMgr::GetIntDefault("DBLogLevel", LOGL_NORMAL);
-
-    m_DebugLogMask = DebugLogFilters(ConfigMgr::GetIntDefault("DebugLogMask", LOG_FILTER_NONE));
-}
-
-FILE* Log::openLogFile(char const* configFileName, char const* configTimeStampFlag, char const* mode)
-{
-    std::string logfn=ConfigMgr::GetStringDefault(configFileName, "");
-    if (logfn.empty())
-        return NULL;
-
-    if (configTimeStampFlag && ConfigMgr::GetBoolDefault(configTimeStampFlag, false))
-    {
-        size_t dot_pos = logfn.find_last_of(".");
-        if (dot_pos!=logfn.npos)
-            logfn.insert(dot_pos, m_logsTimestamp);
-        else
-            logfn += m_logsTimestamp;
-    }
-
-    return fopen((m_logsDir+logfn).c_str(), mode);
-}
-
-FILE* Log::openGmlogPerAccount(uint32 account)
-{
-    if (m_gmlog_filename_format.empty())
-        return NULL;
-
-    char namebuf[TRINITY_PATH_MAX];
-    snprintf(namebuf, TRINITY_PATH_MAX, m_gmlog_filename_format.c_str(), account);
-    return fopen(namebuf, "a");
-}
-
-void Log::outTimestamp(FILE* file)
-{
-    time_t t = time(NULL);
-    tm* aTm = localtime(&t);
-    //       YYYY   year
-    //       MM     month (2 digits 01-12)
-    //       DD     day (2 digits 01-31)
-    //       HH     hour (2 digits 00-23)
-    //       MM     minutes (2 digits 00-59)
-    //       SS     seconds (2 digits 00-59)
-    fprintf(file, "%-4d-%02d-%02d %02d:%02d:%02d ", aTm->tm_year+1900, aTm->tm_mon+1, aTm->tm_mday, aTm->tm_hour, aTm->tm_min, aTm->tm_sec);
-}
-
-void Log::InitColors(const std::string& str)
-{
-    if (str.empty())
-    {
-        m_colored = false;
-        return;
-    }
-
-    int color[4];
-
-    std::istringstream ss(str);
-
-    for (uint8 i = 0; i < LogLevels; ++i)
-    {
-        ss >> color[i];
-
-        if (!ss)
-            return;
-
-        if (color[i] < 0 || color[i] >= Colors)
-            return;
-    }
-
-    for (uint8 i = 0; i < LogLevels; ++i)
-        m_colors[i] = ColorTypes(color[i]);
-
-    m_colored = true;
-}
-
-void Log::SetColor(bool stdout_stream, ColorTypes color)
-{
-    #if PLATFORM == PLATFORM_WINDOWS
-    static WORD WinColorFG[Colors] =
-    {
-        0,                                                  // BLACK
-        FOREGROUND_RED,                                     // RED
-        FOREGROUND_GREEN,                                   // GREEN
-        FOREGROUND_RED | FOREGROUND_GREEN,                  // BROWN
-        FOREGROUND_BLUE,                                    // BLUE
-        FOREGROUND_RED |                    FOREGROUND_BLUE, // MAGENTA
-        FOREGROUND_GREEN | FOREGROUND_BLUE,                 // CYAN
-        FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE, // WHITE
-                                                            // YELLOW
-        FOREGROUND_RED | FOREGROUND_GREEN |                   FOREGROUND_INTENSITY,
-                                                            // RED_BOLD
-        FOREGROUND_RED |                                      FOREGROUND_INTENSITY,
-                                                            // GREEN_BOLD
-        FOREGROUND_GREEN |                   FOREGROUND_INTENSITY,
-        FOREGROUND_BLUE | FOREGROUND_INTENSITY,             // BLUE_BOLD
-                                                            // MAGENTA_BOLD
-        FOREGROUND_RED |                    FOREGROUND_BLUE | FOREGROUND_INTENSITY,
-                                                            // CYAN_BOLD
-        FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY,
-                                                            // WHITE_BOLD
-        FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY
-    };
-
-    HANDLE hConsole = GetStdHandle(stdout_stream ? STD_OUTPUT_HANDLE : STD_ERROR_HANDLE );
-    SetConsoleTextAttribute(hConsole, WinColorFG[color]);
-    #else
-    enum ANSITextAttr
-    {
-        TA_NORMAL=0,
-        TA_BOLD=1,
-        TA_BLINK=5,
-        TA_REVERSE=7
-    };
-
-    enum ANSIFgTextAttr
-    {
-        FG_BLACK=30, FG_RED,  FG_GREEN, FG_BROWN, FG_BLUE,
-        FG_MAGENTA,  FG_CYAN, FG_WHITE, FG_YELLOW
-    };
-
-    enum ANSIBgTextAttr
-    {
-        BG_BLACK=40, BG_RED,  BG_GREEN, BG_BROWN, BG_BLUE,
-        BG_MAGENTA,  BG_CYAN, BG_WHITE
-    };
-
-    static uint8 UnixColorFG[Colors] =
-    {
-        FG_BLACK,                                           // BLACK
-        FG_RED,                                             // RED
-        FG_GREEN,                                           // GREEN
-        FG_BROWN,                                           // BROWN
-        FG_BLUE,                                            // BLUE
-        FG_MAGENTA,                                         // MAGENTA
-        FG_CYAN,                                            // CYAN
-        FG_WHITE,                                           // WHITE
-        FG_YELLOW,                                          // YELLOW
-        FG_RED,                                             // LRED
-        FG_GREEN,                                           // LGREEN
-        FG_BLUE,                                            // LBLUE
-        FG_MAGENTA,                                         // LMAGENTA
-        FG_CYAN,                                            // LCYAN
-        FG_WHITE                                            // LWHITE
-    };
-
-    fprintf((stdout_stream? stdout : stderr), "\x1b[%d%sm", UnixColorFG[color], (color >= YELLOW && color < Colors ? ";1" : ""));
-    #endif
-}
-
-void Log::ResetColor(bool stdout_stream)
-{
-    #if PLATFORM == PLATFORM_WINDOWS
-    HANDLE hConsole = GetStdHandle(stdout_stream ? STD_OUTPUT_HANDLE : STD_ERROR_HANDLE );
-    SetConsoleTextAttribute(hConsole, FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED );
-    #else
-    fprintf(( stdout_stream ? stdout : stderr ), "\x1b[0m");
-    #endif
-}
-
-std::string Log::GetTimestampStr()
-{
-    time_t t = time(NULL);
-    tm* aTm = localtime(&t);
-    //       YYYY   year
-    //       MM     month (2 digits 01-12)
-    //       DD     day (2 digits 01-31)
-    //       HH     hour (2 digits 00-23)
-    //       MM     minutes (2 digits 00-59)
-    //       SS     seconds (2 digits 00-59)
-    char buf[20];
-    snprintf(buf, 20, "%04d-%02d-%02d_%02d-%02d-%02d", aTm->tm_year+1900, aTm->tm_mon+1, aTm->tm_mday, aTm->tm_hour, aTm->tm_min, aTm->tm_sec);
-    return std::string(buf);
-}
-
-void Log::outDB(LogTypes type, const char * str)
-{
-    if (!str || type >= MAX_LOG_TYPES)
-         return;
-
-    std::string logStr(str);
-    if (logStr.empty())
-        return;
-    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_INS_LOG);
-
-    stmt->setInt32(0, realm);
-    stmt->setInt32(1, type);
-    stmt->setString(2, logStr);
-
-    LoginDatabase.Execute(stmt);
-}
-
-void Log::outString(const char * str, ...)
-{
-    if (!str)
-        return;
-
-    if (m_enableLogDB)
-    {
-        // we don't want empty strings in the DB
-        std::string s(str);
-        if (s.empty() || s == " ")
-            return;
-
-        va_list ap2;
-        va_start(ap2, str);
-        char nnew_str[MAX_QUERY_LEN];
-        vsnprintf(nnew_str, MAX_QUERY_LEN, str, ap2);
-        outDB(LOG_TYPE_STRING, nnew_str);
-        va_end(ap2);
-    }
-
-    if (m_colored)
-        SetColor(true, m_colors[LOGL_NORMAL]);
-
-    va_list ap;
-
-    va_start(ap, str);
-    vutf8printf(stdout, str, &ap);
-    va_end(ap);
-
-    if (m_colored)
-        ResetColor(true);
-
-    printf("\n");
-    if (logfile)
-    {
-        outTimestamp(logfile);
-        va_start(ap, str);
-        vfprintf(logfile, str, ap);
-        fprintf(logfile, "\n");
-        va_end(ap);
-
-        fflush(logfile);
-    }
-    fflush(stdout);
-}
-
-void Log::outString()
-{
-    printf("\n");
-    if (logfile)
-    {
-        outTimestamp(logfile);
-        fprintf(logfile, "\n");
-        fflush(logfile);
-    }
-    fflush(stdout);
-}
-
-void Log::outCrash(const char * err, ...)
-{
-    if (!err)
-        return;
-
-    if (m_enableLogDB)
-    {
-        va_list ap2;
-        va_start(ap2, err);
-        char nnew_str[MAX_QUERY_LEN];
-        vsnprintf(nnew_str, MAX_QUERY_LEN, err, ap2);
-        outDB(LOG_TYPE_CRASH, nnew_str);
-        va_end(ap2);
-    }
-
-    if (m_colored)
-        SetColor(false, LRED);
-
-    va_list ap;
-
-    va_start(ap, err);
-    vutf8printf(stderr, err, &ap);
-    va_end(ap);
-
-    if (m_colored)
-        ResetColor(false);
-
-    fprintf(stderr, "\n");
-    if (logfile)
-    {
-        outTimestamp(logfile);
-        fprintf(logfile, "CRASH ALERT: ");
-
-        va_start(ap, err);
-        vfprintf(logfile, err, ap);
-        va_end(ap);
-
-        fprintf(logfile, "\n");
-        fflush(logfile);
-    }
-    fflush(stderr);
-}
-
-void Log::outError(const char * err, ...)
-{
-    if (!err)
-        return;
-
-    if (m_enableLogDB)
-    {
-        va_list ap2;
-        va_start(ap2, err);
-        char nnew_str[MAX_QUERY_LEN];
-        vsnprintf(nnew_str, MAX_QUERY_LEN, err, ap2);
-        outDB(LOG_TYPE_ERROR, nnew_str);
-        va_end(ap2);
-    }
-
-    if (m_colored)
-        SetColor(false, LRED);
-
-    va_list ap;
-
-    va_start(ap, err);
-    vutf8printf(stderr, err, &ap);
-    va_end(ap);
-
-    if (m_colored)
-        ResetColor(false);
-
-    fprintf( stderr, "\n");
-    if (logfile)
-    {
-        outTimestamp(logfile);
-        fprintf(logfile, "ERROR: ");
-
-        va_start(ap, err);
-        vfprintf(logfile, err, ap);
-        va_end(ap);
-
-        fprintf(logfile, "\n");
-        fflush(logfile);
-    }
-    fflush(stderr);
-}
-
-void Log::outArena(const char * str, ...)
-{
-    if (!str)
-        return;
-
-    if (arenaLogFile)
-    {
-        va_list ap;
-        outTimestamp(arenaLogFile);
-        va_start(ap, str);
-        vfprintf(arenaLogFile, str, ap);
-        fprintf(arenaLogFile, "\n");
-        va_end(ap);
-        fflush(arenaLogFile);
-    }
-}
-
-void Log::outSQLDriver(const char* str, ...)
-{
-    if (!str)
-        return;
-
-    va_list ap;
-    va_start(ap, str);
-    vutf8printf(stdout, str, &ap);
-    va_end(ap);
-
-    printf("\n");
-
-    if (sqlLogFile)
-    {
-        outTimestamp(sqlLogFile);
-
-        va_list apSQL;
-        va_start(apSQL, str);
-        vfprintf(sqlLogFile, str, apSQL);
-        va_end(apSQL);
-
-        fprintf(sqlLogFile, "\n");
-        fflush(sqlLogFile);
-    }
-
-    fflush(stdout);
-}
-
-void Log::outErrorDb(const char * err, ...)
-{
-    if (!err)
-        return;
-
-    if (m_colored)
-        SetColor(false, LRED);
-
-    va_list ap;
-
-    va_start(ap, err);
-    vutf8printf(stderr, err, &ap);
-    va_end(ap);
-
-    if (m_colored)
-        ResetColor(false);
-
-    fprintf( stderr, "\n" );
-
-    if (logfile)
-    {
-        outTimestamp(logfile);
-        fprintf(logfile, "ERROR: " );
-
-        va_start(ap, err);
-        vfprintf(logfile, err, ap);
-        va_end(ap);
-
-        fprintf(logfile, "\n" );
-        fflush(logfile);
-    }
-
-    if (dberLogfile)
-    {
-        outTimestamp(dberLogfile);
-        va_start(ap, err);
-        vfprintf(dberLogfile, err, ap);
-        va_end(ap);
-
-        fprintf(dberLogfile, "\n" );
-        fflush(dberLogfile);
-    }
-    fflush(stderr);
-}
-
-void Log::outBasic(const char * str, ...)
-{
-    if (!str)
-        return;
-
-    if (m_enableLogDB && m_dbLogLevel > LOGL_NORMAL)
-    {
-        va_list ap2;
-        va_start(ap2, str);
-        char nnew_str[MAX_QUERY_LEN];
-        vsnprintf(nnew_str, MAX_QUERY_LEN, str, ap2);
-        outDB(LOG_TYPE_BASIC, nnew_str);
-        va_end(ap2);
-    }
-
-    if (m_logLevel > LOGL_NORMAL)
-    {
-        if (m_colored)
-            SetColor(true, m_colors[LOGL_BASIC]);
-
-        va_list ap;
-        va_start(ap, str);
-        vutf8printf(stdout, str, &ap);
-        va_end(ap);
-
-        if (m_colored)
-            ResetColor(true);
-
-        printf("\n");
-
-        if (logfile)
-        {
-            outTimestamp(logfile);
-            va_list ap2;
-            va_start(ap2, str);
-            vfprintf(logfile, str, ap2);
-            fprintf(logfile, "\n" );
-            va_end(ap2);
-            fflush(logfile);
-        }
-    }
-    fflush(stdout);
-}
-
-void Log::outDetail(const char * str, ...)
-{
-    if (!str)
-        return;
-
-    if (m_enableLogDB && m_dbLogLevel > LOGL_BASIC)
-    {
-        va_list ap2;
-        va_start(ap2, str);
-        char nnew_str[MAX_QUERY_LEN];
-        vsnprintf(nnew_str, MAX_QUERY_LEN, str, ap2);
-        outDB(LOG_TYPE_DETAIL, nnew_str);
-        va_end(ap2);
-    }
-
-    if (m_logLevel > LOGL_BASIC)
-    {
-        if (m_colored)
-            SetColor(true, m_colors[LOGL_DETAIL]);
-
-        va_list ap;
-        va_start(ap, str);
-        vutf8printf(stdout, str, &ap);
-        va_end(ap);
-
-        if (m_colored)
-            ResetColor(true);
-
-        printf("\n");
-
-        if (logfile)
-        {
-            outTimestamp(logfile);
-            va_list ap2;
-            va_start(ap2, str);
-            vfprintf(logfile, str, ap2);
-            va_end(ap2);
-
-            fprintf(logfile, "\n");
-            fflush(logfile);
-        }
-    }
-
-    fflush(stdout);
-}
-
-void Log::outDebugInLine(const char * str, ...)
-{
-    if (!str)
-        return;
-
-    if (m_logLevel > LOGL_DETAIL)
-    {
-        va_list ap;
-        va_start(ap, str);
-        vutf8printf(stdout, str, &ap);
-        va_end(ap);
-
-        //if (m_colored)
-        //    ResetColor(true);
-
-        if (logfile)
-        {
-            va_list ap2;
-            va_start(ap2, str);
-            vfprintf(logfile, str, ap2);
-            va_end(ap2);
-        }
-    }
-}
-
-void Log::outSQLDev(const char* str, ...)
-{
-    if (!str)
-        return;
-
-    va_list ap;
-    va_start(ap, str);
-    vutf8printf(stdout, str, &ap);
-    va_end(ap);
-
-    printf("\n");
-
-    if (sqlDevLogFile)
-    {
-        va_list ap2;
-        va_start(ap2, str);
-        vfprintf(sqlDevLogFile, str, ap2);
-        va_end(ap2);
-
-        fprintf(sqlDevLogFile, "\n");
-        fflush(sqlDevLogFile);
-    }
-
-    fflush(stdout);
-}
-
-void Log::outDebug(DebugLogFilters f, const char * str, ...)
-{
-    if (!(m_DebugLogMask & f))
-        return;
-
-    if (!str)
-        return;
-
-    if (m_enableLogDB && m_dbLogLevel > LOGL_DETAIL)
-    {
-        va_list ap2;
-        va_start(ap2, str);
-        char nnew_str[MAX_QUERY_LEN];
-        vsnprintf(nnew_str, MAX_QUERY_LEN, str, ap2);
-        outDB(LOG_TYPE_DEBUG, nnew_str);
-        va_end(ap2);
-    }
-
-    if ( m_logLevel > LOGL_DETAIL )
-    {
-        if (m_colored)
-            SetColor(true, m_colors[LOGL_DEBUG]);
-
-        va_list ap;
-        va_start(ap, str);
-        vutf8printf(stdout, str, &ap);
-        va_end(ap);
-
-        if (m_colored)
-            ResetColor(true);
-
-        printf( "\n" );
-
-        if (logfile)
-        {
-            outTimestamp(logfile);
-            va_list ap2;
-            va_start(ap2, str);
-            vfprintf(logfile, str, ap2);
-            va_end(ap2);
-
-            fprintf(logfile, "\n" );
-            fflush(logfile);
-        }
-    }
-    fflush(stdout);
-}
-
-void Log::outStaticDebug(const char * str, ...)
-{
-    if (!str)
-        return;
-
-    if (m_enableLogDB && m_dbLogLevel > LOGL_DETAIL)
-    {
-        va_list ap2;
-        va_start(ap2, str);
-        char nnew_str[MAX_QUERY_LEN];
-        vsnprintf(nnew_str, MAX_QUERY_LEN, str, ap2);
-        outDB(LOG_TYPE_DEBUG, nnew_str);
-        va_end(ap2);
-    }
-
-    if ( m_logLevel > LOGL_DETAIL )
-    {
-        if (m_colored)
-            SetColor(true, m_colors[LOGL_DEBUG]);
-
-        va_list ap;
-        va_start(ap, str);
-        vutf8printf(stdout, str, &ap);
-        va_end(ap);
-
-        if (m_colored)
-            ResetColor(true);
-
-        printf( "\n" );
-
-        if (logfile)
-        {
-            outTimestamp(logfile);
-            va_list ap2;
-            va_start(ap2, str);
-            vfprintf(logfile, str, ap2);
-            va_end(ap2);
-
-            fprintf(logfile, "\n" );
-            fflush(logfile);
-        }
-    }
-    fflush(stdout);
-}
-
-void Log::outStringInLine(const char * str, ...)
-{
-    if (!str)
-        return;
-
-    va_list ap;
-
-    va_start(ap, str);
-    vutf8printf(stdout, str, &ap);
-    va_end(ap);
-
-    if (logfile)
-    {
-        va_start(ap, str);
-        vfprintf(logfile, str, ap);
-        va_end(ap);
-    }
-}
-
-void Log::outCommand(uint32 account, const char * str, ...)
-{
-    if (!str)
-        return;
-
-    // TODO: support accountid
-    if (m_enableLogDB && m_dbGM)
-    {
-        va_list ap2;
-        va_start(ap2, str);
-        char nnew_str[MAX_QUERY_LEN];
-        vsnprintf(nnew_str, MAX_QUERY_LEN, str, ap2);
-        outDB(LOG_TYPE_GM, nnew_str);
-        va_end(ap2);
-    }
-
-    if (m_logLevel > LOGL_NORMAL)
-    {
-        if (m_colored)
-            SetColor(true, m_colors[LOGL_BASIC]);
-
-        va_list ap;
-        va_start(ap, str);
-        vutf8printf(stdout, str, &ap);
-        va_end(ap);
-
-        if (m_colored)
-            ResetColor(true);
-
-        printf("\n");
-
-        if (logfile)
-        {
-            outTimestamp(logfile);
-            va_list ap2;
-            va_start(ap2, str);
-            vfprintf(logfile, str, ap2);
-            fprintf(logfile, "\n" );
-            va_end(ap2);
-            fflush(logfile);
-        }
-    }
-
-    if (m_gmlog_per_account)
-    {
-        if (FILE* per_file = openGmlogPerAccount (account))
-        {
-            outTimestamp(per_file);
-            va_list ap;
-            va_start(ap, str);
-            vfprintf(per_file, str, ap);
-            fprintf(per_file, "\n" );
-            va_end(ap);
-            fclose(per_file);
-        }
-    }
-    else if (gmLogfile)
-    {
-        outTimestamp(gmLogfile);
-        va_list ap;
-        va_start(ap, str);
-        vfprintf(gmLogfile, str, ap);
-        fprintf(gmLogfile, "\n" );
-        va_end(ap);
-        fflush(gmLogfile);
-    }
-
-    fflush(stdout);
-}
-
-void Log::outChar(const char * str, ...)
-{
-    if (!str)
-        return;
-
-    if (m_enableLogDB && m_dbChar)
-    {
-        va_list ap2;
-        va_start(ap2, str);
-        char nnew_str[MAX_QUERY_LEN];
-        vsnprintf(nnew_str, MAX_QUERY_LEN, str, ap2);
-        outDB(LOG_TYPE_CHAR, nnew_str);
-        va_end(ap2);
-    }
-
-    if (charLogfile)
-    {
-        outTimestamp(charLogfile);
-        va_list ap;
-        va_start(ap, str);
-        vfprintf(charLogfile, str, ap);
-        fprintf(charLogfile, "\n" );
-        va_end(ap);
-        fflush(charLogfile);
-    }
-}
-
-void Log::outCharDump(const char * str, uint32 account_id, uint32 guid, const char * name)
-{
-    FILE* file = NULL;
-    if (m_charLog_Dump_Separate)
-    {
-        char fileName[29]; // Max length: name(12) + guid(11) + _.log (5) + \0
-        snprintf(fileName, 29, "%d_%s.log", guid, name);
-        std::string sFileName(m_dumpsDir);
-        sFileName.append(fileName);
-        file = fopen((m_logsDir + sFileName).c_str(), "w");
-    }
-    else
-        file = charLogfile;
-    if (file)
-    {
-        fprintf(file, "== START DUMP == (account: %u guid: %u name: %s )\n%s\n== END DUMP ==\n",
-            account_id, guid, name, str);
-        fflush(file);
-        if (m_charLog_Dump_Separate)
-            fclose(file);
-    }
-}
-
-void Log::outRemote(const char * str, ...)
-{
-    if (!str)
-        return;
-
-    if (m_enableLogDB && m_dbRA)
-    {
-        va_list ap2;
-        va_start(ap2, str);
-        char nnew_str[MAX_QUERY_LEN];
-        vsnprintf(nnew_str, MAX_QUERY_LEN, str, ap2);
-        outDB(LOG_TYPE_RA, nnew_str);
-        va_end(ap2);
-    }
-
-    if (raLogfile)
-    {
-        outTimestamp(raLogfile);
-        va_list ap;
-        va_start(ap, str);
-        vfprintf(raLogfile, str, ap);
-        fprintf(raLogfile, "\n" );
-        va_end(ap);
-        fflush(raLogfile);
-    }
-}
-
-void Log::outChat(const char * str, ...)
-{
-    if (!str)
-        return;
-
-    if (m_enableLogDB && m_dbChat)
-    {
-        va_list ap2;
-        va_start(ap2, str);
-        char nnew_str[MAX_QUERY_LEN];
-        vsnprintf(nnew_str, MAX_QUERY_LEN, str, ap2);
-        outDB(LOG_TYPE_CHAT, nnew_str);
-        va_end(ap2);
-    }
-
-    if (chatLogfile)
-    {
-        outTimestamp(chatLogfile);
-        va_list ap;
-        va_start(ap, str);
-        vfprintf(chatLogfile, str, ap);
-        fprintf(chatLogfile, "\n" );
-        fflush(chatLogfile);
-        va_end(ap);
-    }
-}
-
-void Log::outErrorST(const char * str, ...)
-{
-    va_list ap;
-    va_start(ap, str);
-    char nnew_str[MAX_QUERY_LEN];
-    vsnprintf(nnew_str, MAX_QUERY_LEN, str, ap);
-    va_end(ap);
-
-    ACE_Stack_Trace st;
-    outError("%s [Stacktrace: %s]", nnew_str, st.c_str());
-}
-
-void Log::outWarden(const char * str, ...)
-{
-    if (!str)
-        return;
-
-    if (wardenLogFile)
-    {
-        outTimestamp(wardenLogFile);
-        va_list ap;
-        va_start(ap, str);
-        vfprintf(wardenLogFile, str, ap);
-        fprintf(wardenLogFile, "\n" );
-        fflush(wardenLogFile);
-        va_end(ap);
-    }
-}
+/*
+ * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "Common.h"
+#include "Log.h"
+#include "Configuration/Config.h"
+#include "Util.h"
+
+#include "Implementation/LoginDatabase.h" // For logging
+extern LoginDatabaseWorkerPool LoginDatabase;
+
+#include <stdarg.h>
+#include <stdio.h>
+
+Log::Log() :
+    raLogfile(NULL), logfile(NULL), gmLogfile(NULL), charLogfile(NULL),
+    dberLogfile(NULL), chatLogfile(NULL), arenaLogFile(NULL), sqlLogFile(NULL), sqlDevLogFile(NULL), wardenLogFile(NULL),
+    m_gmlog_per_account(false), m_enableLogDBLater(false),
+    m_enableLogDB(false), m_colored(false)
+{
+    Initialize();
+}
+
+Log::~Log()
+{
+    if (logfile != NULL)
+        fclose(logfile);
+    logfile = NULL;
+
+    if (gmLogfile != NULL)
+        fclose(gmLogfile);
+    gmLogfile = NULL;
+
+    if (charLogfile != NULL)
+        fclose(charLogfile);
+    charLogfile = NULL;
+
+    if (dberLogfile != NULL)
+        fclose(dberLogfile);
+    dberLogfile = NULL;
+
+    if (raLogfile != NULL)
+        fclose(raLogfile);
+    raLogfile = NULL;
+
+    if (chatLogfile != NULL)
+        fclose(chatLogfile);
+    chatLogfile = NULL;
+
+    if (arenaLogFile != NULL)
+        fclose(arenaLogFile);
+    arenaLogFile = NULL;
+
+    if (sqlLogFile != NULL)
+        fclose(sqlLogFile);
+    sqlLogFile = NULL;
+
+    if (sqlDevLogFile != NULL)
+        fclose(sqlDevLogFile);
+    sqlDevLogFile = NULL;
+
+    if (wardenLogFile != NULL)
+        fclose(wardenLogFile);
+    wardenLogFile = NULL;
+}
+
+void Log::SetLogLevel(char *Level)
+{
+    int32 NewLevel = atoi((char*)Level);
+    if (NewLevel < 0)
+        NewLevel = 0;
+    m_logLevel = NewLevel;
+
+    outString("LogLevel is %u", m_logLevel);
+}
+
+void Log::SetLogFileLevel(char *Level)
+{
+    int32 NewLevel = atoi((char*)Level);
+    if (NewLevel < 0)
+        NewLevel = 0;
+    m_logFileLevel = NewLevel;
+
+    outString("LogFileLevel is %u", m_logFileLevel);
+}
+
+void Log::SetDBLogLevel(char *Level)
+{
+    int32 NewLevel = atoi((char*)Level);
+    if (NewLevel < 0)
+        NewLevel = 0;
+    m_dbLogLevel = NewLevel;
+
+    outString("DBLogLevel is %u", m_dbLogLevel);
+}
+
+void Log::Initialize()
+{
+    /// Check whether we'll log GM commands/RA events/character outputs/chat stuffs
+    m_dbChar = ConfigMgr::GetBoolDefault("LogDB.Char", false);
+    m_dbRA = ConfigMgr::GetBoolDefault("LogDB.RA", false);
+    m_dbGM = ConfigMgr::GetBoolDefault("LogDB.GM", false);
+    m_dbChat = ConfigMgr::GetBoolDefault("LogDB.Chat", false);
+
+    /// Realm must be 0 by default
+    SetRealmID(0);
+
+    /// Common log files data
+    m_logsDir = ConfigMgr::GetStringDefault("LogsDir", "");
+    if (!m_logsDir.empty())
+        if ((m_logsDir.at(m_logsDir.length() - 1) != '/') && (m_logsDir.at(m_logsDir.length() - 1) != '\\'))
+            m_logsDir.push_back('/');
+
+    m_logsTimestamp = "_" + GetTimestampStr();
+
+    /// Open specific log files
+    logfile = openLogFile("LogFile", "LogTimestamp", "w");
+    InitColors(ConfigMgr::GetStringDefault("LogColors", ""));
+
+    m_gmlog_per_account = ConfigMgr::GetBoolDefault("GmLogPerAccount", false);
+    if (!m_gmlog_per_account)
+        gmLogfile = openLogFile("GMLogFile", "GmLogTimestamp", "a");
+    else
+    {
+        // GM log settings for per account case
+        m_gmlog_filename_format = ConfigMgr::GetStringDefault("GMLogFile", "");
+        if (!m_gmlog_filename_format.empty())
+        {
+            bool m_gmlog_timestamp = ConfigMgr::GetBoolDefault("GmLogTimestamp", false);
+
+            size_t dot_pos = m_gmlog_filename_format.find_last_of('.');
+            if (dot_pos!=m_gmlog_filename_format.npos)
+            {
+                if (m_gmlog_timestamp)
+                    m_gmlog_filename_format.insert(dot_pos, m_logsTimestamp);
+
+                m_gmlog_filename_format.insert(dot_pos, "_#%u");
+            }
+            else
+            {
+                m_gmlog_filename_format += "_#%u";
+
+                if (m_gmlog_timestamp)
+                    m_gmlog_filename_format += m_logsTimestamp;
+            }
+
+            m_gmlog_filename_format = m_logsDir + m_gmlog_filename_format;
+        }
+    }
+
+    charLogfile = openLogFile("CharLogFile", "CharLogTimestamp", "a");
+    dberLogfile = openLogFile("DBErrorLogFile", NULL, "a");
+    raLogfile = openLogFile("RaLogFile", NULL, "a");
+    chatLogfile = openLogFile("ChatLogFile", "ChatLogTimestamp", "a");
+    arenaLogFile = openLogFile("ArenaLogFile", NULL, "a");
+    sqlLogFile = openLogFile("SQLDriverLogFile", NULL, "a");
+    sqlDevLogFile = openLogFile("SQLDeveloperLogFile", NULL, "a");
+    wardenLogFile = openLogFile("Warden.LogFile",NULL,"a");
+
+    // Main log file settings
+    m_logLevel     = ConfigMgr::GetIntDefault("LogLevel", LOGL_NORMAL);
+    m_logFileLevel = ConfigMgr::GetIntDefault("LogFileLevel", LOGL_NORMAL);
+    m_dbLogLevel   = ConfigMgr::GetIntDefault("DBLogLevel", LOGL_NORMAL);
+    m_sqlDriverQueryLogging  = ConfigMgr::GetBoolDefault("SQLDriverQueryLogging", false);
+
+    m_DebugLogMask = DebugLogFilters(ConfigMgr::GetIntDefault("DebugLogMask", LOG_FILTER_NONE));
+
+    // Char log settings
+    m_charLog_Dump = ConfigMgr::GetBoolDefault("CharLogDump", false);
+    m_charLog_Dump_Separate = ConfigMgr::GetBoolDefault("CharLogDump.Separate", false);
+    if (m_charLog_Dump_Separate)
+    {
+        m_dumpsDir = ConfigMgr::GetStringDefault("CharLogDump.SeparateDir", "");
+        if (!m_dumpsDir.empty())
+            if ((m_dumpsDir.at(m_dumpsDir.length() - 1) != '/') && (m_dumpsDir.at(m_dumpsDir.length() - 1) != '\\'))
+                m_dumpsDir.push_back('/');
+    }
+}
+
+void Log::ReloadConfig()
+{
+    m_logLevel     = ConfigMgr::GetIntDefault("LogLevel", LOGL_NORMAL);
+    m_logFileLevel = ConfigMgr::GetIntDefault("LogFileLevel", LOGL_NORMAL);
+    m_dbLogLevel   = ConfigMgr::GetIntDefault("DBLogLevel", LOGL_NORMAL);
+
+    m_DebugLogMask = DebugLogFilters(ConfigMgr::GetIntDefault("DebugLogMask", LOG_FILTER_NONE));
+}
+
+FILE* Log::openLogFile(char const* configFileName, char const* configTimeStampFlag, char const* mode)
+{
+    std::string logfn=ConfigMgr::GetStringDefault(configFileName, "");
+    if (logfn.empty())
+        return NULL;
+
+    if (configTimeStampFlag && ConfigMgr::GetBoolDefault(configTimeStampFlag, false))
+    {
+        size_t dot_pos = logfn.find_last_of(".");
+        if (dot_pos!=logfn.npos)
+            logfn.insert(dot_pos, m_logsTimestamp);
+        else
+            logfn += m_logsTimestamp;
+    }
+
+    return fopen((m_logsDir+logfn).c_str(), mode);
+}
+
+FILE* Log::openGmlogPerAccount(uint32 account)
+{
+    if (m_gmlog_filename_format.empty())
+        return NULL;
+
+    char namebuf[TRINITY_PATH_MAX];
+    snprintf(namebuf, TRINITY_PATH_MAX, m_gmlog_filename_format.c_str(), account);
+    return fopen(namebuf, "a");
+}
+
+void Log::outTimestamp(FILE* file)
+{
+    time_t t = time(NULL);
+    tm* aTm = localtime(&t);
+    //       YYYY   year
+    //       MM     month (2 digits 01-12)
+    //       DD     day (2 digits 01-31)
+    //       HH     hour (2 digits 00-23)
+    //       MM     minutes (2 digits 00-59)
+    //       SS     seconds (2 digits 00-59)
+    fprintf(file, "%-4d-%02d-%02d %02d:%02d:%02d ", aTm->tm_year+1900, aTm->tm_mon+1, aTm->tm_mday, aTm->tm_hour, aTm->tm_min, aTm->tm_sec);
+}
+
+void Log::InitColors(const std::string& str)
+{
+    if (str.empty())
+    {
+        m_colored = false;
+        return;
+    }
+
+    int color[4];
+
+    std::istringstream ss(str);
+
+    for (uint8 i = 0; i < LogLevels; ++i)
+    {
+        ss >> color[i];
+
+        if (!ss)
+            return;
+
+        if (color[i] < 0 || color[i] >= Colors)
+            return;
+    }
+
+    for (uint8 i = 0; i < LogLevels; ++i)
+        m_colors[i] = ColorTypes(color[i]);
+
+    m_colored = true;
+}
+
+void Log::SetColor(bool stdout_stream, ColorTypes color)
+{
+    #if PLATFORM == PLATFORM_WINDOWS
+    static WORD WinColorFG[Colors] =
+    {
+        0,                                                  // BLACK
+        FOREGROUND_RED,                                     // RED
+        FOREGROUND_GREEN,                                   // GREEN
+        FOREGROUND_RED | FOREGROUND_GREEN,                  // BROWN
+        FOREGROUND_BLUE,                                    // BLUE
+        FOREGROUND_RED |                    FOREGROUND_BLUE, // MAGENTA
+        FOREGROUND_GREEN | FOREGROUND_BLUE,                 // CYAN
+        FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE, // WHITE
+                                                            // YELLOW
+        FOREGROUND_RED | FOREGROUND_GREEN |                   FOREGROUND_INTENSITY,
+                                                            // RED_BOLD
+        FOREGROUND_RED |                                      FOREGROUND_INTENSITY,
+                                                            // GREEN_BOLD
+        FOREGROUND_GREEN |                   FOREGROUND_INTENSITY,
+        FOREGROUND_BLUE | FOREGROUND_INTENSITY,             // BLUE_BOLD
+                                                            // MAGENTA_BOLD
+        FOREGROUND_RED |                    FOREGROUND_BLUE | FOREGROUND_INTENSITY,
+                                                            // CYAN_BOLD
+        FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY,
+                                                            // WHITE_BOLD
+        FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY
+    };
+
+    HANDLE hConsole = GetStdHandle(stdout_stream ? STD_OUTPUT_HANDLE : STD_ERROR_HANDLE );
+    SetConsoleTextAttribute(hConsole, WinColorFG[color]);
+    #else
+    enum ANSITextAttr
+    {
+        TA_NORMAL=0,
+        TA_BOLD=1,
+        TA_BLINK=5,
+        TA_REVERSE=7
+    };
+
+    enum ANSIFgTextAttr
+    {
+        FG_BLACK=30, FG_RED,  FG_GREEN, FG_BROWN, FG_BLUE,
+        FG_MAGENTA,  FG_CYAN, FG_WHITE, FG_YELLOW
+    };
+
+    enum ANSIBgTextAttr
+    {
+        BG_BLACK=40, BG_RED,  BG_GREEN, BG_BROWN, BG_BLUE,
+        BG_MAGENTA,  BG_CYAN, BG_WHITE
+    };
+
+    static uint8 UnixColorFG[Colors] =
+    {
+        FG_BLACK,                                           // BLACK
+        FG_RED,                                             // RED
+        FG_GREEN,                                           // GREEN
+        FG_BROWN,                                           // BROWN
+        FG_BLUE,                                            // BLUE
+        FG_MAGENTA,                                         // MAGENTA
+        FG_CYAN,                                            // CYAN
+        FG_WHITE,                                           // WHITE
+        FG_YELLOW,                                          // YELLOW
+        FG_RED,                                             // LRED
+        FG_GREEN,                                           // LGREEN
+        FG_BLUE,                                            // LBLUE
+        FG_MAGENTA,                                         // LMAGENTA
+        FG_CYAN,                                            // LCYAN
+        FG_WHITE                                            // LWHITE
+    };
+
+    fprintf((stdout_stream? stdout : stderr), "\x1b[%d%sm", UnixColorFG[color], (color >= YELLOW && color < Colors ? ";1" : ""));
+    #endif
+}
+
+void Log::ResetColor(bool stdout_stream)
+{
+    #if PLATFORM == PLATFORM_WINDOWS
+    HANDLE hConsole = GetStdHandle(stdout_stream ? STD_OUTPUT_HANDLE : STD_ERROR_HANDLE );
+    SetConsoleTextAttribute(hConsole, FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED );
+    #else
+    fprintf(( stdout_stream ? stdout : stderr ), "\x1b[0m");
+    #endif
+}
+
+std::string Log::GetTimestampStr()
+{
+    time_t t = time(NULL);
+    tm* aTm = localtime(&t);
+    //       YYYY   year
+    //       MM     month (2 digits 01-12)
+    //       DD     day (2 digits 01-31)
+    //       HH     hour (2 digits 00-23)
+    //       MM     minutes (2 digits 00-59)
+    //       SS     seconds (2 digits 00-59)
+    char buf[20];
+    snprintf(buf, 20, "%04d-%02d-%02d_%02d-%02d-%02d", aTm->tm_year+1900, aTm->tm_mon+1, aTm->tm_mday, aTm->tm_hour, aTm->tm_min, aTm->tm_sec);
+    return std::string(buf);
+}
+
+void Log::outDB(LogTypes type, const char * str)
+{
+    if (!str || type >= MAX_LOG_TYPES)
+         return;
+
+    std::string logStr(str);
+    if (logStr.empty())
+        return;
+
+    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_INS_LOG);
+
+    stmt->setInt32(0, realm);
+    stmt->setUInt8(1, uint8(type));
+    stmt->setString(2, logStr);
+
+    LoginDatabase.Execute(stmt);
+}
+
+void Log::outString(const char * str, ...)
+{
+    if (!str)
+        return;
+
+    if (m_enableLogDB)
+    {
+        // we don't want empty strings in the DB
+        std::string s(str);
+        if (s.empty() || s == " ")
+            return;
+
+        va_list ap2;
+        va_start(ap2, str);
+        char nnew_str[MAX_QUERY_LEN];
+        vsnprintf(nnew_str, MAX_QUERY_LEN, str, ap2);
+        outDB(LOG_TYPE_STRING, nnew_str);
+        va_end(ap2);
+    }
+
+    if (m_colored)
+        SetColor(true, m_colors[LOGL_NORMAL]);
+
+    va_list ap;
+
+    va_start(ap, str);
+    vutf8printf(stdout, str, &ap);
+    va_end(ap);
+
+    if (m_colored)
+        ResetColor(true);
+
+    printf("\n");
+    if (logfile)
+    {
+        outTimestamp(logfile);
+        va_start(ap, str);
+        vfprintf(logfile, str, ap);
+        fprintf(logfile, "\n");
+        va_end(ap);
+
+        fflush(logfile);
+    }
+    fflush(stdout);
+}
+
+void Log::outString()
+{
+    printf("\n");
+    if (logfile)
+    {
+        outTimestamp(logfile);
+        fprintf(logfile, "\n");
+        fflush(logfile);
+    }
+    fflush(stdout);
+}
+
+void Log::outCrash(const char * err, ...)
+{
+    if (!err)
+        return;
+
+    if (m_enableLogDB)
+    {
+        va_list ap2;
+        va_start(ap2, err);
+        char nnew_str[MAX_QUERY_LEN];
+        vsnprintf(nnew_str, MAX_QUERY_LEN, err, ap2);
+        outDB(LOG_TYPE_CRASH, nnew_str);
+        va_end(ap2);
+    }
+
+    if (m_colored)
+        SetColor(false, LRED);
+
+    va_list ap;
+
+    va_start(ap, err);
+    vutf8printf(stderr, err, &ap);
+    va_end(ap);
+
+    if (m_colored)
+        ResetColor(false);
+
+    fprintf(stderr, "\n");
+    if (logfile)
+    {
+        outTimestamp(logfile);
+        fprintf(logfile, "CRASH ALERT: ");
+
+        va_start(ap, err);
+        vfprintf(logfile, err, ap);
+        va_end(ap);
+
+        fprintf(logfile, "\n");
+        fflush(logfile);
+    }
+    fflush(stderr);
+}
+
+void Log::outError(const char * err, ...)
+{
+    if (!err)
+        return;
+
+    if (m_enableLogDB)
+    {
+        va_list ap2;
+        va_start(ap2, err);
+        char nnew_str[MAX_QUERY_LEN];
+        vsnprintf(nnew_str, MAX_QUERY_LEN, err, ap2);
+        outDB(LOG_TYPE_ERROR, nnew_str);
+        va_end(ap2);
+    }
+
+    if (m_colored)
+        SetColor(false, LRED);
+
+    va_list ap;
+
+    va_start(ap, err);
+    vutf8printf(stderr, err, &ap);
+    va_end(ap);
+
+    if (m_colored)
+        ResetColor(false);
+
+    fprintf( stderr, "\n");
+    if (logfile)
+    {
+        outTimestamp(logfile);
+        fprintf(logfile, "ERROR: ");
+
+        va_start(ap, err);
+        vfprintf(logfile, err, ap);
+        va_end(ap);
+
+        fprintf(logfile, "\n");
+        fflush(logfile);
+    }
+    fflush(stderr);
+}
+
+void Log::outArena(const char * str, ...)
+{
+    if (!str)
+        return;
+
+    if (arenaLogFile)
+    {
+        va_list ap;
+        outTimestamp(arenaLogFile);
+        va_start(ap, str);
+        vfprintf(arenaLogFile, str, ap);
+        fprintf(arenaLogFile, "\n");
+        va_end(ap);
+        fflush(arenaLogFile);
+    }
+}
+
+void Log::outSQLDriver(const char* str, ...)
+{
+    if (!str)
+        return;
+
+    va_list ap;
+    va_start(ap, str);
+    vutf8printf(stdout, str, &ap);
+    va_end(ap);
+
+    printf("\n");
+
+    if (sqlLogFile)
+    {
+        outTimestamp(sqlLogFile);
+
+        va_list apSQL;
+        va_start(apSQL, str);
+        vfprintf(sqlLogFile, str, apSQL);
+        va_end(apSQL);
+
+        fprintf(sqlLogFile, "\n");
+        fflush(sqlLogFile);
+    }
+
+    fflush(stdout);
+}
+
+void Log::outErrorDb(const char * err, ...)
+{
+    if (!err)
+        return;
+
+    if (m_colored)
+        SetColor(false, LRED);
+
+    va_list ap;
+
+    va_start(ap, err);
+    vutf8printf(stderr, err, &ap);
+    va_end(ap);
+
+    if (m_colored)
+        ResetColor(false);
+
+    fprintf( stderr, "\n" );
+
+    if (logfile)
+    {
+        outTimestamp(logfile);
+        fprintf(logfile, "ERROR: " );
+
+        va_start(ap, err);
+        vfprintf(logfile, err, ap);
+        va_end(ap);
+
+        fprintf(logfile, "\n" );
+        fflush(logfile);
+    }
+
+    if (dberLogfile)
+    {
+        outTimestamp(dberLogfile);
+        va_start(ap, err);
+        vfprintf(dberLogfile, err, ap);
+        va_end(ap);
+
+        fprintf(dberLogfile, "\n" );
+        fflush(dberLogfile);
+    }
+    fflush(stderr);
+}
+
+void Log::outBasic(const char * str, ...)
+{
+    if (!str)
+        return;
+
+    if (m_enableLogDB && m_dbLogLevel > LOGL_NORMAL)
+    {
+        va_list ap2;
+        va_start(ap2, str);
+        char nnew_str[MAX_QUERY_LEN];
+        vsnprintf(nnew_str, MAX_QUERY_LEN, str, ap2);
+        outDB(LOG_TYPE_BASIC, nnew_str);
+        va_end(ap2);
+    }
+
+    if (m_logLevel > LOGL_NORMAL)
+    {
+        if (m_colored)
+            SetColor(true, m_colors[LOGL_BASIC]);
+
+        va_list ap;
+        va_start(ap, str);
+        vutf8printf(stdout, str, &ap);
+        va_end(ap);
+
+        if (m_colored)
+            ResetColor(true);
+
+        printf("\n");
+
+        if (logfile)
+        {
+            outTimestamp(logfile);
+            va_list ap2;
+            va_start(ap2, str);
+            vfprintf(logfile, str, ap2);
+            fprintf(logfile, "\n" );
+            va_end(ap2);
+            fflush(logfile);
+        }
+    }
+    fflush(stdout);
+}
+
+void Log::outDetail(const char * str, ...)
+{
+    if (!str)
+        return;
+
+    if (m_enableLogDB && m_dbLogLevel > LOGL_BASIC)
+    {
+        va_list ap2;
+        va_start(ap2, str);
+        char nnew_str[MAX_QUERY_LEN];
+        vsnprintf(nnew_str, MAX_QUERY_LEN, str, ap2);
+        outDB(LOG_TYPE_DETAIL, nnew_str);
+        va_end(ap2);
+    }
+
+    if (m_logLevel > LOGL_BASIC)
+    {
+        if (m_colored)
+            SetColor(true, m_colors[LOGL_DETAIL]);
+
+        va_list ap;
+        va_start(ap, str);
+        vutf8printf(stdout, str, &ap);
+        va_end(ap);
+
+        if (m_colored)
+            ResetColor(true);
+
+        printf("\n");
+
+        if (logfile)
+        {
+            outTimestamp(logfile);
+            va_list ap2;
+            va_start(ap2, str);
+            vfprintf(logfile, str, ap2);
+            va_end(ap2);
+
+            fprintf(logfile, "\n");
+            fflush(logfile);
+        }
+    }
+
+    fflush(stdout);
+}
+
+void Log::outDebugInLine(const char * str, ...)
+{
+    if (!str)
+        return;
+
+    if (m_logLevel > LOGL_DETAIL)
+    {
+        va_list ap;
+        va_start(ap, str);
+        vutf8printf(stdout, str, &ap);
+        va_end(ap);
+
+        //if (m_colored)
+        //    ResetColor(true);
+
+        if (logfile)
+        {
+            va_list ap2;
+            va_start(ap2, str);
+            vfprintf(logfile, str, ap2);
+            va_end(ap2);
+        }
+    }
+}
+
+void Log::outSQLDev(const char* str, ...)
+{
+    if (!str)
+        return;
+
+    va_list ap;
+    va_start(ap, str);
+    vutf8printf(stdout, str, &ap);
+    va_end(ap);
+
+    printf("\n");
+
+    if (sqlDevLogFile)
+    {
+        va_list ap2;
+        va_start(ap2, str);
+        vfprintf(sqlDevLogFile, str, ap2);
+        va_end(ap2);
+
+        fprintf(sqlDevLogFile, "\n");
+        fflush(sqlDevLogFile);
+    }
+
+    fflush(stdout);
+}
+
+void Log::outDebug(DebugLogFilters f, const char * str, ...)
+{
+    if (!(m_DebugLogMask & f))
+        return;
+
+    if (!str)
+        return;
+
+    if (m_enableLogDB && m_dbLogLevel > LOGL_DETAIL)
+    {
+        va_list ap2;
+        va_start(ap2, str);
+        char nnew_str[MAX_QUERY_LEN];
+        vsnprintf(nnew_str, MAX_QUERY_LEN, str, ap2);
+        outDB(LOG_TYPE_DEBUG, nnew_str);
+        va_end(ap2);
+    }
+
+    if ( m_logLevel > LOGL_DETAIL )
+    {
+        if (m_colored)
+            SetColor(true, m_colors[LOGL_DEBUG]);
+
+        va_list ap;
+        va_start(ap, str);
+        vutf8printf(stdout, str, &ap);
+        va_end(ap);
+
+        if (m_colored)
+            ResetColor(true);
+
+        printf( "\n" );
+
+        if (logfile)
+        {
+            outTimestamp(logfile);
+            va_list ap2;
+            va_start(ap2, str);
+            vfprintf(logfile, str, ap2);
+            va_end(ap2);
+
+            fprintf(logfile, "\n" );
+            fflush(logfile);
+        }
+    }
+    fflush(stdout);
+}
+
+void Log::outStaticDebug(const char * str, ...)
+{
+    if (!str)
+        return;
+
+    if (m_enableLogDB && m_dbLogLevel > LOGL_DETAIL)
+    {
+        va_list ap2;
+        va_start(ap2, str);
+        char nnew_str[MAX_QUERY_LEN];
+        vsnprintf(nnew_str, MAX_QUERY_LEN, str, ap2);
+        outDB(LOG_TYPE_DEBUG, nnew_str);
+        va_end(ap2);
+    }
+
+    if ( m_logLevel > LOGL_DETAIL )
+    {
+        if (m_colored)
+            SetColor(true, m_colors[LOGL_DEBUG]);
+
+        va_list ap;
+        va_start(ap, str);
+        vutf8printf(stdout, str, &ap);
+        va_end(ap);
+
+        if (m_colored)
+            ResetColor(true);
+
+        printf( "\n" );
+
+        if (logfile)
+        {
+            outTimestamp(logfile);
+            va_list ap2;
+            va_start(ap2, str);
+            vfprintf(logfile, str, ap2);
+            va_end(ap2);
+
+            fprintf(logfile, "\n" );
+            fflush(logfile);
+        }
+    }
+    fflush(stdout);
+}
+
+void Log::outStringInLine(const char * str, ...)
+{
+    if (!str)
+        return;
+
+    va_list ap;
+
+    va_start(ap, str);
+    vutf8printf(stdout, str, &ap);
+    va_end(ap);
+
+    if (logfile)
+    {
+        va_start(ap, str);
+        vfprintf(logfile, str, ap);
+        va_end(ap);
+    }
+}
+
+void Log::outCommand(uint32 account, const char * str, ...)
+{
+    if (!str)
+        return;
+
+    // TODO: support accountid
+    if (m_enableLogDB && m_dbGM)
+    {
+        va_list ap2;
+        va_start(ap2, str);
+        char nnew_str[MAX_QUERY_LEN];
+        vsnprintf(nnew_str, MAX_QUERY_LEN, str, ap2);
+        outDB(LOG_TYPE_GM, nnew_str);
+        va_end(ap2);
+    }
+
+    if (m_logLevel > LOGL_NORMAL)
+    {
+        if (m_colored)
+            SetColor(true, m_colors[LOGL_BASIC]);
+
+        va_list ap;
+        va_start(ap, str);
+        vutf8printf(stdout, str, &ap);
+        va_end(ap);
+
+        if (m_colored)
+            ResetColor(true);
+
+        printf("\n");
+
+        if (logfile)
+        {
+            outTimestamp(logfile);
+            va_list ap2;
+            va_start(ap2, str);
+            vfprintf(logfile, str, ap2);
+            fprintf(logfile, "\n" );
+            va_end(ap2);
+            fflush(logfile);
+        }
+    }
+
+    if (m_gmlog_per_account)
+    {
+        if (FILE* per_file = openGmlogPerAccount (account))
+        {
+            outTimestamp(per_file);
+            va_list ap;
+            va_start(ap, str);
+            vfprintf(per_file, str, ap);
+            fprintf(per_file, "\n" );
+            va_end(ap);
+            fclose(per_file);
+        }
+    }
+    else if (gmLogfile)
+    {
+        outTimestamp(gmLogfile);
+        va_list ap;
+        va_start(ap, str);
+        vfprintf(gmLogfile, str, ap);
+        fprintf(gmLogfile, "\n" );
+        va_end(ap);
+        fflush(gmLogfile);
+    }
+
+    fflush(stdout);
+}
+
+void Log::outChar(const char * str, ...)
+{
+    if (!str)
+        return;
+
+    if (m_enableLogDB && m_dbChar)
+    {
+        va_list ap2;
+        va_start(ap2, str);
+        char nnew_str[MAX_QUERY_LEN];
+        vsnprintf(nnew_str, MAX_QUERY_LEN, str, ap2);
+        outDB(LOG_TYPE_CHAR, nnew_str);
+        va_end(ap2);
+    }
+
+    if (charLogfile)
+    {
+        outTimestamp(charLogfile);
+        va_list ap;
+        va_start(ap, str);
+        vfprintf(charLogfile, str, ap);
+        fprintf(charLogfile, "\n" );
+        va_end(ap);
+        fflush(charLogfile);
+    }
+}
+
+void Log::outCharDump(const char * str, uint32 account_id, uint32 guid, const char * name)
+{
+    FILE* file = NULL;
+    if (m_charLog_Dump_Separate)
+    {
+        char fileName[29]; // Max length: name(12) + guid(11) + _.log (5) + \0
+        snprintf(fileName, 29, "%d_%s.log", guid, name);
+        std::string sFileName(m_dumpsDir);
+        sFileName.append(fileName);
+        file = fopen((m_logsDir + sFileName).c_str(), "w");
+    }
+    else
+        file = charLogfile;
+    if (file)
+    {
+        fprintf(file, "== START DUMP == (account: %u guid: %u name: %s )\n%s\n== END DUMP ==\n",
+            account_id, guid, name, str);
+        fflush(file);
+        if (m_charLog_Dump_Separate)
+            fclose(file);
+    }
+}
+
+void Log::outRemote(const char * str, ...)
+{
+    if (!str)
+        return;
+
+    if (m_enableLogDB && m_dbRA)
+    {
+        va_list ap2;
+        va_start(ap2, str);
+        char nnew_str[MAX_QUERY_LEN];
+        vsnprintf(nnew_str, MAX_QUERY_LEN, str, ap2);
+        outDB(LOG_TYPE_RA, nnew_str);
+        va_end(ap2);
+    }
+
+    if (raLogfile)
+    {
+        outTimestamp(raLogfile);
+        va_list ap;
+        va_start(ap, str);
+        vfprintf(raLogfile, str, ap);
+        fprintf(raLogfile, "\n" );
+        va_end(ap);
+        fflush(raLogfile);
+    }
+}
+
+void Log::outChat(const char * str, ...)
+{
+    if (!str)
+        return;
+
+    if (m_enableLogDB && m_dbChat)
+    {
+        va_list ap2;
+        va_start(ap2, str);
+        char nnew_str[MAX_QUERY_LEN];
+        vsnprintf(nnew_str, MAX_QUERY_LEN, str, ap2);
+        outDB(LOG_TYPE_CHAT, nnew_str);
+        va_end(ap2);
+    }
+
+    if (chatLogfile)
+    {
+        outTimestamp(chatLogfile);
+        va_list ap;
+        va_start(ap, str);
+        vfprintf(chatLogfile, str, ap);
+        fprintf(chatLogfile, "\n" );
+        fflush(chatLogfile);
+        va_end(ap);
+    }
+}
+
+void Log::outErrorST(const char * str, ...)
+{
+    va_list ap;
+    va_start(ap, str);
+    char nnew_str[MAX_QUERY_LEN];
+    vsnprintf(nnew_str, MAX_QUERY_LEN, str, ap);
+    va_end(ap);
+
+    ACE_Stack_Trace st;
+    outError("%s [Stacktrace: %s]", nnew_str, st.c_str());
+}
+
+void Log::outWarden(const char * str, ...)
+{
+    if (!str)
+        return;
+
+    if (wardenLogFile)
+    {
+        outTimestamp(wardenLogFile);
+        va_list ap;
+        va_start(ap, str);
+        vfprintf(wardenLogFile, str, ap);
+        fprintf(wardenLogFile, "\n" );
+        fflush(wardenLogFile);
+        va_end(ap);
+    }
+}
diff -r b4c056460923 -r da13f4f7a26c src/server/shared/Logging/Log.h
--- a/src/server/shared/Logging/Log.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/shared/Logging/Log.h	Mon Apr 16 14:29:17 2012 +0300
@@ -1,214 +1,214 @@
-/*
- * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
- * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef TRINITYCORE_LOG_H
-#define TRINITYCORE_LOG_H
-
-#include "Common.h"
-#include <ace/Singleton.h>
-
-class Config;
-
-enum DebugLogFilters
-{
-    LOG_FILTER_NONE                     = 0x00000000,
-    LOG_FILTER_UNITS                    = 0x00000001,   // Anything related to units that doesn't fit in other categories. ie. creature formations
-    LOG_FILTER_PETS                     = 0x00000002,
-    LOG_FILTER_VEHICLES                 = 0x00000004,
-    LOG_FILTER_TSCR                     = 0x00000008,   // C++ AI, instance scripts, etc.
-    LOG_FILTER_DATABASE_AI              = 0x08000010,   // SmartAI, EventAI, CreatureAI
-    LOG_FILTER_MAPSCRIPTS               = 0x00000020,
-    LOG_FILTER_NETWORKIO                = 0x00000040,   // Anything packet/netcode related
-    LOG_FILTER_SPELLS_AURAS             = 0x00000080,
-    LOG_FILTER_ACHIEVEMENTSYS           = 0x00000100,
-    LOG_FILTER_CONDITIONSYS             = 0x00000200,
-    LOG_FILTER_POOLSYS                  = 0x00000400,
-    LOG_FILTER_AUCTIONHOUSE             = 0x00000800,
-    LOG_FILTER_BATTLEGROUND             = 0x00001000,   // Anything related to arena's and battlegrounds
-    LOG_FILTER_OUTDOORPVP               = 0x00002000,
-    LOG_FILTER_CHATSYS                  = 0x00004000,
-    LOG_FILTER_LFG                      = 0x00008000,
-    LOG_FILTER_MAPS                     = 0x00010000,   // Maps, instances, grids, cells, visibility
-    LOG_FILTER_PLAYER_LOADING           = 0x00020000,   // Debug output from Player::_Load functions
-    LOG_FILTER_PLAYER_ITEMS             = 0x00040000,   // Anything item related
-    LOG_FILTER_PLAYER_SKILLS            = 0x00080000,   // Skills related
-    LOG_FILTER_LOOT                     = 0x00100000,   // Loot related
-    LOG_FILTER_GUILD                    = 0x00200000,   // Guild related
-    LOG_FILTER_TRANSPORTS               = 0x00400000,   // Transport related
-	LOG_FILTER_WARDEN                   = 0x00800000,   // Warden related
-};
-
-enum LogTypes
-{
-    LOG_TYPE_STRING = 0,
-    LOG_TYPE_ERROR  = 1,
-    LOG_TYPE_BASIC  = 2,
-    LOG_TYPE_DETAIL = 3,
-    LOG_TYPE_DEBUG  = 4,
-    LOG_TYPE_CHAR   = 5,
-    LOG_TYPE_WORLD  = 6,
-    LOG_TYPE_RA     = 7,
-    LOG_TYPE_GM     = 8,
-    LOG_TYPE_CRASH  = 9,
-    LOG_TYPE_CHAT   = 10,
-    MAX_LOG_TYPES
-};
-
-enum LogLevel
-{
-    LOGL_NORMAL = 0,
-    LOGL_BASIC,
-    LOGL_DETAIL,
-    LOGL_DEBUG
-};
-
-const int LogLevels = int(LOGL_DEBUG)+1;
-
-enum ColorTypes
-{
-    BLACK,
-    RED,
-    GREEN,
-    BROWN,
-    BLUE,
-    MAGENTA,
-    CYAN,
-    GREY,
-    YELLOW,
-    LRED,
-    LGREEN,
-    LBLUE,
-    LMAGENTA,
-    LCYAN,
-    WHITE
-};
-
-const int Colors = int(WHITE)+1;
-
-class Log
-{
-    friend class ACE_Singleton<Log, ACE_Thread_Mutex>;
-
-    private:
-        Log();
-        ~Log();
-
-    public:
-        void Initialize();
-        
-        void ReloadConfig();
-
-        void InitColors(const std::string& init_str);
-        void SetColor(bool stdout_stream, ColorTypes color);
-        void ResetColor(bool stdout_stream);
-
-        void outErrorST( const char * err, ... )                ATTR_PRINTF(2, 3);
-        void outDB( LogTypes type, const char * str );
-        void outString( const char * str, ... )                 ATTR_PRINTF(2, 3);
-        void outString( );
-        void outStringInLine( const char * str, ... )           ATTR_PRINTF(2, 3);
-        void outError( const char * err, ... )                  ATTR_PRINTF(2, 3);
-        void outCrash( const char * err, ... )                  ATTR_PRINTF(2, 3);
-        void outBasic( const char * str, ... )                  ATTR_PRINTF(2, 3);
-        void outDetail( const char * str, ... )                 ATTR_PRINTF(2, 3);
-        void outSQLDev( const char * str, ... )                 ATTR_PRINTF(2, 3);
-        void outDebug(DebugLogFilters f, const char* str, ...)  ATTR_PRINTF(3, 4);
-        void outStaticDebug( const char * str, ... )            ATTR_PRINTF(2, 3);
-        void outDebugInLine( const char * str, ... )            ATTR_PRINTF(2, 3);
-        void outErrorDb( const char * str, ... )                ATTR_PRINTF(2, 3);
-        void outChar( const char * str, ... )                   ATTR_PRINTF(2, 3);
-        void outCommand( uint32 account, const char * str, ...) ATTR_PRINTF(3, 4);
-        void outRemote( const char * str, ... )                 ATTR_PRINTF(2, 3);
-        void outChat( const char * str, ... )                   ATTR_PRINTF(2, 3);
-        void outArena( const char * str, ... )                  ATTR_PRINTF(2, 3);
-        void outSQLDriver( const char* str, ... )               ATTR_PRINTF(2, 3);
-		void outWarden( const char * str, ... )                 ATTR_PRINTF(2, 3);
-        void outCharDump( const char * str, uint32 account_id, uint32 guid, const char * name );
-
-        static void outTimestamp(FILE* file);
-        static std::string GetTimestampStr();
-
-        void SetLogLevel(char * Level);
-        void SetLogFileLevel(char * Level);
-        void SetDBLogLevel(char * Level);
-        void SetSQLDriverQueryLogging(bool newStatus) { m_sqlDriverQueryLogging = newStatus; }
-        void SetRealmID(uint32 id) { realm = id; }
-
-        bool IsOutDebug() const { return m_logLevel > 2 || (m_logFileLevel > 2 && logfile); }
-        bool IsOutCharDump() const { return m_charLog_Dump; }
-
-        bool GetLogDB() const { return m_enableLogDB; }
-        bool GetLogDBLater() const { return m_enableLogDBLater; }
-        void SetLogDB(bool enable) { m_enableLogDB = enable; }
-        void SetLogDBLater(bool value) { m_enableLogDBLater = value; }
-        bool GetSQLDriverQueryLogging() const { return m_sqlDriverQueryLogging; }
-    private:
-        FILE* openLogFile(char const* configFileName, char const* configTimeStampFlag, char const* mode);
-        FILE* openGmlogPerAccount(uint32 account);
-
-        FILE* raLogfile;
-        FILE* logfile;
-        FILE* gmLogfile;
-        FILE* charLogfile;
-        FILE* dberLogfile;
-        FILE* chatLogfile;
-        FILE* arenaLogFile;
-        FILE* sqlLogFile;
-        FILE* sqlDevLogFile;
-        FILE* wardenLogFile;
-
-        // cache values for after initilization use (like gm log per account case)
-        std::string m_logsDir;
-        std::string m_logsTimestamp;
-
-        // gm log control
-        bool m_gmlog_per_account;
-        std::string m_gmlog_filename_format;
-
-        bool m_enableLogDBLater;
-        bool m_enableLogDB;
-        uint32 realm;
-
-        // log coloring
-        bool m_colored;
-        ColorTypes m_colors[4];
-
-        // log levels:
-        // false: errors only, true: full query logging
-        bool m_sqlDriverQueryLogging;
-
-        // log levels:
-        // 0 minimum/string, 1 basic/error, 2 detail, 3 full/debug
-        uint8 m_dbLogLevel;
-        uint8 m_logLevel;
-        uint8 m_logFileLevel;
-        bool m_dbChar;
-        bool m_dbRA;
-        bool m_dbGM;
-        bool m_dbChat;
-        bool m_charLog_Dump;
-        bool m_charLog_Dump_Separate;
-        std::string m_dumpsDir;
-
-        DebugLogFilters m_DebugLogMask;
-};
-
-#define sLog ACE_Singleton<Log, ACE_Thread_Mutex>::instance()
-
-#endif
-
+/*
+ * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef TRINITYCORE_LOG_H
+#define TRINITYCORE_LOG_H
+
+#include "Common.h"
+#include <ace/Singleton.h>
+
+class Config;
+
+enum DebugLogFilters
+{
+    LOG_FILTER_NONE                     = 0x00000000,
+    LOG_FILTER_UNITS                    = 0x00000001,   // Anything related to units that doesn't fit in other categories. ie. creature formations
+    LOG_FILTER_PETS                     = 0x00000002,
+    LOG_FILTER_VEHICLES                 = 0x00000004,
+    LOG_FILTER_TSCR                     = 0x00000008,   // C++ AI, instance scripts, etc.
+    LOG_FILTER_DATABASE_AI              = 0x00000010,   // SmartAI, EventAI, CreatureAI
+    LOG_FILTER_MAPSCRIPTS               = 0x00000020,
+    LOG_FILTER_NETWORKIO                = 0x00000040,   // Anything packet/netcode related
+    LOG_FILTER_SPELLS_AURAS             = 0x00000080,
+    LOG_FILTER_ACHIEVEMENTSYS           = 0x00000100,
+    LOG_FILTER_CONDITIONSYS             = 0x00000200,
+    LOG_FILTER_POOLSYS                  = 0x00000400,
+    LOG_FILTER_AUCTIONHOUSE             = 0x00000800,
+    LOG_FILTER_BATTLEGROUND             = 0x00001000,   // Anything related to arena's and battlegrounds
+    LOG_FILTER_OUTDOORPVP               = 0x00002000,
+    LOG_FILTER_CHATSYS                  = 0x00004000,
+    LOG_FILTER_LFG                      = 0x00008000,
+    LOG_FILTER_MAPS                     = 0x00010000,   // Maps, instances, grids, cells, visibility
+    LOG_FILTER_PLAYER_LOADING           = 0x00020000,   // Debug output from Player::_Load functions
+    LOG_FILTER_PLAYER_ITEMS             = 0x00040000,   // Anything item related
+    LOG_FILTER_PLAYER_SKILLS            = 0x00080000,   // Skills related
+    LOG_FILTER_LOOT                     = 0x00100000,   // Loot related
+    LOG_FILTER_GUILD                    = 0x00200000,   // Guild related
+    LOG_FILTER_TRANSPORTS               = 0x00400000,   // Transport related
+    LOG_FILTER_WARDEN                   = 0x00800000,   // Warden related
+};
+
+enum LogTypes
+{
+    LOG_TYPE_STRING = 0,
+    LOG_TYPE_ERROR  = 1,
+    LOG_TYPE_BASIC  = 2,
+    LOG_TYPE_DETAIL = 3,
+    LOG_TYPE_DEBUG  = 4,
+    LOG_TYPE_CHAR   = 5,
+    LOG_TYPE_WORLD  = 6,
+    LOG_TYPE_RA     = 7,
+    LOG_TYPE_GM     = 8,
+    LOG_TYPE_CRASH  = 9,
+    LOG_TYPE_CHAT   = 10,
+    MAX_LOG_TYPES
+};
+
+enum LogLevel
+{
+    LOGL_NORMAL = 0,
+    LOGL_BASIC,
+    LOGL_DETAIL,
+    LOGL_DEBUG
+};
+
+const int LogLevels = int(LOGL_DEBUG)+1;
+
+enum ColorTypes
+{
+    BLACK,
+    RED,
+    GREEN,
+    BROWN,
+    BLUE,
+    MAGENTA,
+    CYAN,
+    GREY,
+    YELLOW,
+    LRED,
+    LGREEN,
+    LBLUE,
+    LMAGENTA,
+    LCYAN,
+    WHITE
+};
+
+const int Colors = int(WHITE)+1;
+
+class Log
+{
+    friend class ACE_Singleton<Log, ACE_Thread_Mutex>;
+
+    private:
+        Log();
+        ~Log();
+
+    public:
+        void Initialize();
+
+        void ReloadConfig();
+
+        void InitColors(const std::string& init_str);
+        void SetColor(bool stdout_stream, ColorTypes color);
+        void ResetColor(bool stdout_stream);
+
+        void outErrorST(const char * err, ...)                  ATTR_PRINTF(2, 3);
+        void outDB(LogTypes type, const char * str);
+        void outString(const char * str, ...)                   ATTR_PRINTF(2, 3);
+        void outString();
+        void outStringInLine(const char * str, ...)             ATTR_PRINTF(2, 3);
+        void outError(const char * err, ...)                    ATTR_PRINTF(2, 3);
+        void outCrash(const char * err, ...)                    ATTR_PRINTF(2, 3);
+        void outBasic(const char * str, ...)                    ATTR_PRINTF(2, 3);
+        void outDetail(const char * str, ...)                   ATTR_PRINTF(2, 3);
+        void outSQLDev(const char * str, ...)                   ATTR_PRINTF(2, 3);
+        void outDebug(DebugLogFilters f, const char* str, ...)  ATTR_PRINTF(3, 4);
+        void outStaticDebug(const char * str, ...)              ATTR_PRINTF(2, 3);
+        void outDebugInLine(const char * str, ...)              ATTR_PRINTF(2, 3);
+        void outErrorDb(const char * str, ...)                  ATTR_PRINTF(2, 3);
+        void outChar(const char * str, ...)                     ATTR_PRINTF(2, 3);
+        void outCommand(uint32 account, const char * str, ...)  ATTR_PRINTF(3, 4);
+        void outRemote(const char * str, ...)                   ATTR_PRINTF(2, 3);
+        void outChat(const char * str, ...)                     ATTR_PRINTF(2, 3);
+        void outArena(const char * str, ...)                    ATTR_PRINTF(2, 3);
+        void outSQLDriver(const char* str, ...)                 ATTR_PRINTF(2, 3);
+        void outWarden(const char * str, ...)                   ATTR_PRINTF(2, 3);
+        void outCharDump(const char * str, uint32 account_id, uint32 guid, const char * name);
+
+        static void outTimestamp(FILE* file);
+        static std::string GetTimestampStr();
+
+        void SetLogLevel(char * Level);
+        void SetLogFileLevel(char * Level);
+        void SetDBLogLevel(char * Level);
+        void SetSQLDriverQueryLogging(bool newStatus) { m_sqlDriverQueryLogging = newStatus; }
+        void SetRealmID(uint32 id) { realm = id; }
+
+        bool IsOutDebug() const { return m_logLevel > 2 || (m_logFileLevel > 2 && logfile); }
+        bool IsOutCharDump() const { return m_charLog_Dump; }
+
+        bool GetLogDB() const { return m_enableLogDB; }
+        bool GetLogDBLater() const { return m_enableLogDBLater; }
+        void SetLogDB(bool enable) { m_enableLogDB = enable; }
+        void SetLogDBLater(bool value) { m_enableLogDBLater = value; }
+        bool GetSQLDriverQueryLogging() const { return m_sqlDriverQueryLogging; }
+    private:
+        FILE* openLogFile(char const* configFileName, char const* configTimeStampFlag, char const* mode);
+        FILE* openGmlogPerAccount(uint32 account);
+
+        FILE* raLogfile;
+        FILE* logfile;
+        FILE* gmLogfile;
+        FILE* charLogfile;
+        FILE* dberLogfile;
+        FILE* chatLogfile;
+        FILE* arenaLogFile;
+        FILE* sqlLogFile;
+        FILE* sqlDevLogFile;
+        FILE* wardenLogFile;
+
+        // cache values for after initilization use (like gm log per account case)
+        std::string m_logsDir;
+        std::string m_logsTimestamp;
+
+        // gm log control
+        bool m_gmlog_per_account;
+        std::string m_gmlog_filename_format;
+
+        bool m_enableLogDBLater;
+        bool m_enableLogDB;
+        uint32 realm;
+
+        // log coloring
+        bool m_colored;
+        ColorTypes m_colors[4];
+
+        // log levels:
+        // false: errors only, true: full query logging
+        bool m_sqlDriverQueryLogging;
+
+        // log levels:
+        // 0 minimum/string, 1 basic/error, 2 detail, 3 full/debug
+        uint8 m_dbLogLevel;
+        uint8 m_logLevel;
+        uint8 m_logFileLevel;
+        bool m_dbChar;
+        bool m_dbRA;
+        bool m_dbGM;
+        bool m_dbChat;
+        bool m_charLog_Dump;
+        bool m_charLog_Dump_Separate;
+        std::string m_dumpsDir;
+
+        DebugLogFilters m_DebugLogMask;
+};
+
+#define sLog ACE_Singleton<Log, ACE_Thread_Mutex>::instance()
+
+#endif
+
diff -r b4c056460923 -r da13f4f7a26c src/server/shared/Packets/ByteBuffer.h
--- a/src/server/shared/Packets/ByteBuffer.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/shared/Packets/ByteBuffer.h	Mon Apr 16 14:29:17 2012 +0300
@@ -363,7 +363,7 @@
 
         void resize(size_t newsize)
         {
-            _storage.resize(newsize);
+            _storage.resize(newsize, 0);
             _rpos = 0;
             _wpos = size();
         }
diff -r b4c056460923 -r da13f4f7a26c src/server/shared/Utilities/Util.cpp
--- a/src/server/shared/Utilities/Util.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/shared/Utilities/Util.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -19,15 +19,10 @@
 #include <iostream>
 #include "Util.h"
 #include "utf8.h"
-#ifdef USE_SFMT_FOR_RNG
 #include "SFMT.h"
-#else
-#include "MersenneTwister.h"
-#endif
 #include <ace/TSS_T.h>
 #include <ace/INET_Addr.h>
 
-#ifdef USE_SFMT_FOR_RNG
 typedef ACE_TSS<SFMTRand> SFMTRandTSS;
 static SFMTRandTSS sfmtRand;
 
@@ -61,41 +56,6 @@
     return sfmtRand->Random() * 100.0;
 }
 
-#else
-typedef ACE_TSS<MTRand> MTRandTSS;
-static MTRandTSS mtRand;
-
-int32 irand(int32 min, int32 max)
-{
-    return int32(mtRand->randInt(max - min)) + min;
-}
-
-uint32 urand(uint32 min, uint32 max)
-{
-    return mtRand->randInt(max - min) + min;
-}
-
-float frand(float min, float max)
-{
-    return float(mtRand->randExc(max - min) + min);
-}
-
-int32 rand32()
-{
-    return mtRand->randInt();
-}
-
-double rand_norm(void)
-{
-    return mtRand->randExc();
-}
-
-double rand_chance(void)
-{
-    return mtRand->randExc(100.0);
-}
-#endif
-
 Tokens::Tokens(const std::string &src, const char sep, uint32 vectorReserve)
 {
     m_str = new char[src.length() + 1];
diff -r b4c056460923 -r da13f4f7a26c src/server/shared/Utilities/Util.h
--- a/src/server/shared/Utilities/Util.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/shared/Utilities/Util.h	Mon Apr 16 14:29:17 2012 +0300
@@ -20,7 +20,7 @@
 #define _UTIL_H
 
 #include "Common.h"
-
+#include "Containers.h"
 #include <string>
 #include <vector>
 
@@ -73,7 +73,7 @@
  double rand_norm(void);
 
 /* Return a random double from 0.0 to 99.9999999999999. Floats support only 7 valid decimal digits.
- * A double supports up to 15 valid decimal digits and is used internaly (RAND32_MAX has 10 digits).
+ * A double supports up to 15 valid decimal digits and is used internally (RAND32_MAX has 10 digits).
  * With an FPU, there is usually no difference in performance between float and double. */
  double rand_chance(void);
 
@@ -653,12 +653,4 @@
     };
 };
 
-/* Select a random element from a container. Note: make sure you explicitly empty check the container */
-template <class C> typename C::value_type const& SelectRandomContainerElement(C const& container)
-{
-    typename C::const_iterator it = container.begin();
-    std::advance(it, urand(0, container.size() - 1));
-    return *it;
-}
-
 #endif
diff -r b4c056460923 -r da13f4f7a26c src/server/worldserver/CMakeLists.txt
--- a/src/server/worldserver/CMakeLists.txt	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/worldserver/CMakeLists.txt	Mon Apr 16 14:29:17 2012 +0300
@@ -48,7 +48,6 @@
   ${CMAKE_SOURCE_DIR}/dep/gsoap
   ${CMAKE_SOURCE_DIR}/dep/sockets/include
   ${CMAKE_SOURCE_DIR}/dep/SFMT
-  ${CMAKE_SOURCE_DIR}/dep/mersennetwister
   ${CMAKE_SOURCE_DIR}/src/server/collision
   ${CMAKE_SOURCE_DIR}/src/server/collision/Management
   ${CMAKE_SOURCE_DIR}/src/server/collision/Models
@@ -134,6 +133,7 @@
   ${CMAKE_SOURCE_DIR}/src/server/game/Weather
   ${CMAKE_SOURCE_DIR}/src/server/game/World
   ${CMAKE_SOURCE_DIR}/src/server/authserver/Server
+  ${CMAKE_SOURCE_DIR}/src/server/authserver/Realms
   ${CMAKE_CURRENT_SOURCE_DIR}
   ${CMAKE_CURRENT_SOURCE_DIR}/CommandLine
   ${CMAKE_CURRENT_SOURCE_DIR}/RemoteAccess
@@ -201,4 +201,3 @@
     add_native_precompiled_header(worldserver ${CMAKE_CURRENT_SOURCE_DIR}/PrecompiledHeaders/worldPCH)
   endif()
 endif()
-
diff -r b4c056460923 -r da13f4f7a26c src/server/worldserver/CommandLine/CliRunnable.cpp
--- a/src/server/worldserver/CommandLine/CliRunnable.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/worldserver/CommandLine/CliRunnable.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -125,29 +125,44 @@
  */
 bool ChatHandler::GetDeletedCharacterInfoList(DeletedInfoList& foundList, std::string searchString)
 {
-    QueryResult resultChar;
+    PreparedQueryResult result;
+    PreparedStatement* stmt;
     if (!searchString.empty())
     {
         // search by GUID
         if (isNumeric(searchString.c_str()))
-            resultChar = CharacterDatabase.PQuery("SELECT guid, deleteInfos_Name, deleteInfos_Account, deleteDate FROM characters WHERE deleteDate IS NOT NULL AND guid = %u", uint64(atoi(searchString.c_str())));
+        {
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_DEL_INFO_BY_GUID);
+
+            stmt->setUInt32(0, uint32(atoi(searchString.c_str())));
+
+            result = CharacterDatabase.Query(stmt);
+        }
         // search by name
         else
         {
             if (!normalizePlayerName(searchString))
                 return false;
 
-            resultChar = CharacterDatabase.PQuery("SELECT guid, deleteInfos_Name, deleteInfos_Account, deleteDate FROM characters WHERE deleteDate IS NOT NULL AND deleteInfos_Name " _LIKE_ " " _CONCAT3_("'%%'", "'%s'", "'%%'"), searchString.c_str());
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_DEL_INFO_BY_NAME);
+
+            stmt->setString(0, searchString);
+
+            result = CharacterDatabase.Query(stmt);
         }
     }
     else
-        resultChar = CharacterDatabase.Query("SELECT guid, deleteInfos_Name, deleteInfos_Account, deleteDate FROM characters WHERE deleteDate IS NOT NULL");
+    {
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_DEL_INFO);
 
-    if (resultChar)
+        result = CharacterDatabase.Query(stmt);
+    }
+
+    if (result)
     {
         do
         {
-            Field* fields = resultChar->Fetch();
+            Field* fields = result->Fetch();
 
             DeletedInfo info;
 
@@ -161,7 +176,7 @@
             info.deleteDate = time_t(fields[3].GetUInt32());
 
             foundList.push_back(info);
-        } while (resultChar->NextRow());
+        } while (result->NextRow());
     }
 
     return true;
@@ -299,6 +314,11 @@
     stmt->setUInt32(2, delInfo.lowguid);
 
     CharacterDatabase.Execute(stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_NAME_DATA);
+    stmt->setUInt32(0, delInfo.lowguid);
+    if (PreparedQueryResult result = CharacterDatabase.Query(stmt))
+        sWorld->AddCharacterNameData(delInfo.lowguid, delInfo.name, (*result)[2].GetUInt8(), (*result)[0].GetUInt8(), (*result)[1].GetUInt8());
 }
 
 /**
diff -r b4c056460923 -r da13f4f7a26c src/server/worldserver/Main.cpp
--- a/src/server/worldserver/Main.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/worldserver/Main.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -146,8 +146,8 @@
 
     //sLog->outString("Using configuration file %s.", cfg_file);
 
-    sLog->outDetail("%s (Library: %s)", OPENSSL_VERSION_TEXT, SSLeay_version(SSLEAY_VERSION));
-    sLog->outDetail("Using ACE: %s", ACE_VERSION);
+    sLog->outString("Using SSL version: %s (library: %s)", OPENSSL_VERSION_TEXT, SSLeay_version(SSLEAY_VERSION));
+    sLog->outString("Using ACE version: %s", ACE_VERSION);
 
     ///- and run the 'Master'
     /// \todo Why do we need this 'Master'? Can't all of this be in the Main as for Realmd?
diff -r b4c056460923 -r da13f4f7a26c src/server/worldserver/Master.cpp
--- a/src/server/worldserver/Master.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/worldserver/Master.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -41,6 +41,7 @@
 #include "Timer.h"
 #include "Util.h"
 #include "AuthSocket.h"
+#include "RealmList.h"
 
 #include "BigNumber.h"
 
@@ -126,13 +127,6 @@
     sLog->outString("%s", _FULLVERSION);
     sLog->outString("<Ctrl-C> to stop.\n");
 
-#ifdef USE_SFMT_FOR_RNG
-    sLog->outString("\n");
-    sLog->outString("SFMT has been enabled as the random number generator, if worldserver");
-    sLog->outString("freezes or crashes randomly, first, try disabling SFMT in CMAKE configuration");
-    sLog->outString("\n");
-#endif //USE_SFMT_FOR_RNG
-
     /// worldserver PID file creation
     std::string pidfile = ConfigMgr::GetStringDefault("PidFile", "");
     if (!pidfile.empty())
@@ -152,7 +146,7 @@
         return 1;
 
     // set server offline (not connectable)
-    LoginDatabase.DirectPExecute("UPDATE realmlist SET color = (color & ~%u) | %u WHERE id = '%d'", REALM_FLAG_OFFLINE, REALM_FLAG_INVALID, realmID);
+    LoginDatabase.DirectPExecute("UPDATE realmlist SET flag = (flag & ~%u) | %u WHERE id = '%d'", REALM_FLAG_OFFLINE, REALM_FLAG_INVALID, realmID);
 
     ///- Initialize the World
     sWorld->SetInitialWorldSettings();
@@ -263,9 +257,12 @@
     }
 
     // set server online (allow connecting now)
-    LoginDatabase.DirectPExecute("UPDATE realmlist SET color = color & ~%u, population = 0 WHERE id = '%u'", REALM_FLAG_INVALID, realmID);
+    LoginDatabase.DirectPExecute("UPDATE realmlist SET flag = flag & ~%u, population = 0 WHERE id = '%u'", REALM_FLAG_INVALID, realmID);
 
-    sWorldSocketMgr->Wait();
+    // when the main thread closes the singletons get unloaded
+    // since worldrunnable uses them, it will crash if unloaded after master
+    world_thread.wait();
+    rar_thread.wait();
 
     if (soap_thread)
     {
@@ -275,12 +272,7 @@
     }
 
     // set server offline
-    LoginDatabase.DirectPExecute("UPDATE realmlist SET color = color | %u WHERE id = '%d'", REALM_FLAG_OFFLINE, realmID);
-
-    // when the main thread closes the singletons get unloaded
-    // since worldrunnable uses them, it will crash if unloaded after master
-    world_thread.wait();
-    rar_thread.wait();
+    LoginDatabase.DirectPExecute("UPDATE realmlist SET flag = flag | %u WHERE id = '%d'", REALM_FLAG_OFFLINE, realmID);
 
     ///- Clean database before leaving
     ClearOnlineAccounts();
diff -r b4c056460923 -r da13f4f7a26c src/server/worldserver/RemoteAccess/RASocket.cpp
--- a/src/server/worldserver/RemoteAccess/RASocket.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/worldserver/RemoteAccess/RASocket.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -32,7 +32,7 @@
 
 RASocket::RASocket()
 {
-    iMinLevel = ConfigMgr::GetIntDefault("RA.MinLevel", 3);
+    _minLevel = ConfigMgr::GetIntDefault("RA.MinLevel", 3);
 }
 
 RASocket::~RASocket()
@@ -174,12 +174,15 @@
 
 int RASocket::check_access_level(const std::string& user)
 {
-    std::string safe_user = user;
+    std::string safeUser = user;
 
-    AccountMgr::normalizeString(safe_user);
-    LoginDatabase.EscapeString(safe_user);
+    AccountMgr::normalizeString(safeUser);
 
-    QueryResult result = LoginDatabase.PQuery("SELECT a.id, aa.gmlevel, aa.RealmID FROM account a LEFT JOIN account_access aa ON (a.id = aa.id) WHERE a.username = '%s'", safe_user.c_str());
+
+
+    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_ACCOUNT_ACCESS);
+    stmt->setString(0, safeUser);
+    PreparedQueryResult result = LoginDatabase.Query(stmt);
 
     if (!result)
     {
@@ -189,7 +192,7 @@
 
     Field* fields = result->Fetch();
 
-    if (fields[1].GetUInt32() < iMinLevel)
+    if (fields[1].GetUInt8() < _minLevel)
     {
         sLog->outRemote("User %s has no privilege to login", user.c_str());
         return -1;
@@ -207,19 +210,20 @@
 {
     std::string safe_user = user;
     AccountMgr::normalizeString(safe_user);
-    LoginDatabase.EscapeString(safe_user);
 
     std::string safe_pass = pass;
     AccountMgr::normalizeString(safe_pass);
-    LoginDatabase.EscapeString(safe_pass);
 
     std::string hash = AccountMgr::CalculateShaPassHash(safe_user, safe_pass);
 
-    QueryResult check = LoginDatabase.PQuery(
-            "SELECT 1 FROM account WHERE username = '%s' AND sha_pass_hash = '%s'",
-            safe_user.c_str(), hash.c_str());
+    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_CHECK_PASSWORD_BY_NAME);
 
-    if (!check)
+    stmt->setString(0, safe_user);
+    stmt->setString(1, hash);
+
+    PreparedQueryResult result = LoginDatabase.Query(stmt);
+
+    if (!result)
     {
         sLog->outRemote("Wrong password for user: %s", user.c_str());
         return -1;
diff -r b4c056460923 -r da13f4f7a26c src/server/worldserver/RemoteAccess/RASocket.h
--- a/src/server/worldserver/RemoteAccess/RASocket.h	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/worldserver/RemoteAccess/RASocket.h	Mon Apr 16 14:29:17 2012 +0300
@@ -56,7 +56,7 @@
 
     private:
         /// Minimum security level required to connect
-        uint8 iMinLevel;
+        uint8 _minLevel;
 };
 #endif
 /// @}
diff -r b4c056460923 -r da13f4f7a26c src/server/worldserver/WorldThread/WorldRunnable.cpp
--- a/src/server/worldserver/WorldThread/WorldRunnable.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/server/worldserver/WorldThread/WorldRunnable.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -30,6 +30,7 @@
 #include "MapManager.h"
 #include "Timer.h"
 #include "WorldRunnable.h"
+#include "OutdoorPvPMgr.h"
 
 #define WORLD_SLEEP_CONST 50
 
@@ -93,4 +94,5 @@
     sMapMgr->UnloadAll();                     // unload all grids (including locked in memory)
     sObjectAccessor->UnloadAll();             // unload 'i_player2corpse' storage and remove from world
     sScriptMgr->Unload();
+    sOutdoorPvPMgr->Die();
 }
diff -r b4c056460923 -r da13f4f7a26c src/tools/map_extractor/System.cpp
--- a/src/tools/map_extractor/System.cpp	Thu Apr 05 13:10:49 2012 +0300
+++ b/src/tools/map_extractor/System.cpp	Mon Apr 16 14:29:17 2012 +0300
@@ -71,7 +71,7 @@
 float CONF_flat_liquid_delta_limit = 0.001f; // If max - min less this value - liquid surface is flat
 
 // List MPQ for extract from
-char *CONF_mpq_list[]={
+const char *CONF_mpq_list[]={
     "common.MPQ",
     "common-2.MPQ",
     "lichking.MPQ",
@@ -83,7 +83,7 @@
     "patch-5.MPQ",
 };
 
-static char* const langs[] = {"enGB", "enUS", "deDE", "esES", "frFR", "koKR", "zhCN", "zhTW", "enCN", "enTW", "esMX", "ruRU" };
+static const char* const langs[] = {"enGB", "enUS", "deDE", "esES", "frFR", "koKR", "zhCN", "zhTW", "enCN", "enTW", "esMX", "ruRU" };
 #define LANG_COUNT 12
 
 void CreateDir( const std::string& Path )
